"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_troika-three-text_dist_troika-three-text_esm_js"],{

/***/ "./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlyphsGeometry: function() { return /* binding */ GlyphsGeometry; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   configureTextBuilder: function() { return /* binding */ configureTextBuilder; },\n/* harmony export */   createTextDerivedMaterial: function() { return /* binding */ createTextDerivedMaterial; },\n/* harmony export */   dumpSDFTextures: function() { return /* binding */ dumpSDFTextures; },\n/* harmony export */   fontResolverWorkerModule: function() { return /* binding */ fontResolverWorkerModule; },\n/* harmony export */   getCaretAtPoint: function() { return /* binding */ getCaretAtPoint; },\n/* harmony export */   getSelectionRects: function() { return /* binding */ getSelectionRects; },\n/* harmony export */   getTextRenderInfo: function() { return /* binding */ getTextRenderInfo; },\n/* harmony export */   preloadFont: function() { return /* binding */ preloadFont; },\n/* harmony export */   typesetterWorkerModule: function() { return /* binding */ typesetterWorkerModule; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/\nfunction typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/\nfunction woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */\n\n/**\n * @typedef ParsedFont\n * @property {number} ascender\n * @property {number} descender\n * @property {number} xHeight\n * @property {(number) => boolean} supportsCodePoint\n * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n * @property {number} lineGap\n * @property {number} capHeight\n * @property {number} unitsPerEm\n */\n\n/**\n * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n */\n\n/**\n * @returns {FontParser}\n */\nfunction parserFactory(Typr, woff2otf) {\n  const cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  // {joinType: \"skip+step,...\"}\n  const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n  let joiningTypeMap;\n  function getCharJoiningType(ch) {\n    if (!joiningTypeMap) {\n      const m = {\n        R: JT_RIGHT,\n        L: JT_LEFT,\n        D: JT_DUAL,\n        C: JT_JOIN_CAUSING,\n        U: JT_NON_JOINING,\n        T: JT_TRANSPARENT\n      };\n      joiningTypeMap = new Map();\n      for (let type in joiningTypeRawData) {\n        let lastCode = 0;\n        joiningTypeRawData[type].split(',').forEach(range => {\n          let [skip, step] = range.split('+');\n          skip = parseInt(skip,36);\n          step = step ? parseInt(step, 36) : 0;\n          joiningTypeMap.set(lastCode += skip, m[type]);\n          for (let i = step; i--;) {\n            joiningTypeMap.set(++lastCode, m[type]);\n          }\n        });\n      }\n    }\n    return joiningTypeMap.get(ch) || JT_NON_JOINING\n  }\n\n  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n  function detectJoiningForms(str) {\n    // This implements the algorithm described here:\n    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n    const joiningForms = new Uint8Array(str.length);\n    let prevJoiningType = JT_NON_JOINING;\n    let prevForm = ISOL;\n    let prevIndex = -1;\n    for (let i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n      let joiningType = getCharJoiningType(code) | 0;\n      let form = ISOL;\n      if (joiningType & JT_TRANSPARENT) {\n        continue\n      }\n      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n          form = FINA;\n          // isol->init, fina->medi\n          if (prevForm === ISOL || prevForm === FINA) {\n            joiningForms[prevIndex]++;\n          }\n        }\n        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n      }\n      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n        // medi->fina, init->isol\n        if (prevForm === INIT || prevForm === MEDI) {\n          joiningForms[prevIndex]--;\n        }\n      }\n      prevForm = joiningForms[i] = form;\n      prevJoiningType = joiningType;\n      prevIndex = i;\n      if (code > 0xffff) i++;\n    }\n    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n    return joiningForms\n  }\n\n  function stringToGlyphs (font, str) {\n    const glyphIds = [];\n    for (let i = 0; i < str.length; i++) {\n      const cc = str.codePointAt(i);\n      if (cc > 0xffff) i++;\n      glyphIds.push(Typr.U.codeToGlyph(font, cc));\n    }\n\n    const gsub = font['GSUB'];\n    if (gsub) {\n      const {lookupList, featureList} = gsub;\n      let joiningForms;\n      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n      const usedLookups = [];\n      featureList.forEach(feature => {\n        if (supportedFeatures.test(feature.tag)) {\n          for (let ti = 0; ti < feature.tab.length; ti++) {\n            if (usedLookups[feature.tab[ti]]) continue\n            usedLookups[feature.tab[ti]] = true;\n            const tab = lookupList[feature.tab[ti]];\n            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n            if (isJoiningFeature && !joiningForms) { //lazy\n              joiningForms = detectJoiningForms(str);\n            }\n            for (let ci = 0; ci < glyphIds.length; ci++) {\n              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n              }\n            }\n          }\n        }\n      });\n    }\n\n    return glyphIds\n  }\n\n  // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n  // attachments. This is a more complete version of Typr.U.getPairAdjustment\n  // and should become an upstream replacement eventually.\n  function calcGlyphPositions(font, glyphIds) {\n    const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n    let glyphIndex = 0;\n    for (; glyphIndex < glyphIds.length; glyphIndex++) {\n      const glyphId = glyphIds[glyphIndex];\n      if (glyphId === -1) continue;\n\n      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n\n      const gpos = font.GPOS;\n      if (gpos) {\n        const llist = gpos.lookupList;\n        for (let i = 0; i < llist.length; i++) {\n          const lookup = llist[i];\n          for (let j = 0; j < lookup.tabs.length; j++) {\n            const tab = lookup.tabs[j];\n            // Single char placement\n            if (lookup.ltype === 1) {\n              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n              if (ind !== -1 && tab.pos) {\n                applyValueRecord(tab.pos, glyphIndex);\n                break\n              }\n            }\n            // Pairs (kerning)\n            else if (lookup.ltype === 2) {\n              let adj = null;\n              let prevGlyphIndex = getPrevGlyphIndex();\n              if (prevGlyphIndex !== -1) {\n                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                if (coverageIndex !== -1) {\n                  if (tab.fmt === 1) {\n                    const right = tab.pairsets[coverageIndex];\n                    for (let k = 0; k < right.length; k++) {\n                      if (right[k].gid2 === glyphId) adj = right[k];\n                    }\n                  } else if (tab.fmt === 2) {\n                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                  }\n                  if (adj) {\n                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                    break\n                  }\n                }\n              }\n            }\n            // Mark to base\n            else if (lookup.ltype === 4) {\n              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n              if (markArrIndex !== -1) {\n                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                if (baseArrIndex !== -1) {\n                  const markRecord = tab.markArray[markArrIndex];\n                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                  break;\n                }\n              }\n            }\n            // Mark to mark\n            else if (lookup.ltype === 6) {\n              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n              if (mark1ArrIndex !== -1) {\n                const prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                  const prevGlyphId = glyphIds[prevGlyphIndex];\n                  if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs\n                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                    if (mark2ArrIndex !== -1) {\n                      const mark1Record = tab.mark1Array[mark1ArrIndex];\n                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      // Check kern table if no GPOS\n      else if (font.kern && !font.cff) {\n        const prevGlyphIndex = getPrevGlyphIndex();\n        if (prevGlyphIndex !== -1) {\n          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n          if (ind1 !== -1) {\n            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n            if (ind2 !== -1) {\n              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n            }\n          }\n        }\n      }\n    }\n\n    return positions;\n\n    function getPrevGlyphIndex(filter) {\n      for (let i = glyphIndex - 1; i >=0; i--) {\n        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n          return i\n        }\n      }\n      return -1;\n    }\n\n    function isBaseGlyph(glyphId) {\n      return getGlyphClass(font, glyphId) === 1;\n    }\n\n    function applyValueRecord(source, gi) {\n      for (let i = 0; i < 3; i++) {\n        positions[gi * 3 + i] += source[i] || 0;\n      }\n    }\n  }\n\n  function getGlyphClass(font, glyphId) {\n    const classDef = font.GDEF && font.GDEF.glyphClassDef;\n    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n  }\n\n  function firstNum(...args) {\n    for (let i = 0; i < args.length; i++) {\n      if (typeof args[i] === 'number') {\n        return args[i]\n      }\n    }\n  }\n\n  /**\n   * @returns ParsedFont\n   */\n  function wrapFontObj(typrFont) {\n    const glyphMap = Object.create(null);\n\n    const os2 = typrFont['OS/2'];\n    const hhea = typrFont.hhea;\n    const unitsPerEm = typrFont.head.unitsPerEm;\n    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n    /** @type ParsedFont */\n    const fontObj = {\n      unitsPerEm,\n      ascender,\n      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n      capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n      xHeight: firstNum(os2 && os2.sxHeight, ascender),\n      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n      supportsCodePoint(code) {\n        return Typr.U.codeToGlyph(typrFont, code) > 0\n      },\n      forEachGlyph(text, fontSize, letterSpacing, callback) {\n        let penX = 0;\n        const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        const glyphIds = stringToGlyphs(typrFont, text);\n        let charIndex = 0;\n        const positions = calcGlyphPositions(typrFont, glyphIds);\n\n        glyphIds.forEach((glyphId, i) => {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphId !== -1) {\n            let glyphObj = glyphMap[glyphId];\n            if (!glyphObj) {\n              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);\n\n              // Build path string\n              let path = '';\n              let crdsIdx = 0;\n              for (let i = 0, len = cmds.length; i < len; i++) {\n                const numArgs = cmdArgLengths[cmds[i]];\n                path += cmds[i];\n                for (let j = 1; j <= numArgs; j++) {\n                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                }\n              }\n\n              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n              // normalize the two, so it's simplest just to iterate ourselves.\n              let xMin, yMin, xMax, yMax;\n              if (crds.length) {\n                xMin = yMin = Infinity;\n                xMax = yMax = -Infinity;\n                for (let i = 0, len = crds.length; i < len; i += 2) {\n                  let x = crds[i];\n                  let y = crds[i + 1];\n                  if (x < xMin) xMin = x;\n                  if (y < yMin) yMin = y;\n                  if (x > xMax) xMax = x;\n                  if (y > yMax) yMax = y;\n                }\n              } else {\n                xMin = xMax = yMin = yMax = 0;\n              }\n\n              glyphObj = glyphMap[glyphId] = {\n                index: glyphId,\n                advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                xMin,\n                yMin,\n                xMax,\n                yMax,\n                path,\n              };\n            }\n\n            callback.call(\n              null,\n              glyphObj,\n              penX + positions[i * 3] * fontScale,\n              positions[i * 3 + 1] * fontScale,\n              charIndex\n            );\n\n            penX += positions[i * 3 + 2] * fontScale;\n            if (letterSpacing) {\n              penX += letterSpacing * fontSize;\n            }\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n\n        return penX\n      }\n    };\n\n    return fontObj\n  }\n\n  /**\n   * @type FontParser\n   */\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    const peek = new Uint8Array(buffer, 0, 4);\n    const tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer)[0])\n  }\n}\n\n\nconst workerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typr Font Parser',\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init(typrFactory, woff2otfFactory, parserFactory) {\n    const Typr = typrFactory();\n    const woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\n/*!\nCustom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\nfor use in Troika text rendering. \nOriginal MIT license applies\n*/\nfunction unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}\n\n/**\n * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n */\n\n/**\n * @typedef {ClientOptions} FontResolverOptions\n * @property {Array<UserFont>|UserFont} [fonts]\n * @property {'normal'|'italic'} [style]\n * @property {'normal'|'bold'|number} [style]\n * @property {string} [unicodeFontsURL]\n */\n\n/**\n * @typedef {Object} FontResolverResult\n * @property {Uint8Array} chars\n * @property {Array<ParsedFont & {src:string}>} fonts\n */\n\n/**\n * @typedef {function} FontResolver\n * @param {string} text\n * @param {(FontResolverResult) => void} callback\n * @param {FontResolverOptions} [options]\n */\n\n/**\n * Factory for the FontResolver function.\n * @param {FontParser} fontParser\n * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n * @return {FontResolver}\n */\nfunction createFontResolver(fontParser, unicodeFontResolverClient) {\n  /**\n   * @type {Record<string, ParsedFont>}\n   */\n  const parsedFonts = Object.create(null);\n\n  /**\n   * @type {Record<string, Array<(ParsedFont) => void>>}\n   */\n  const loadingFonts = Object.create(null);\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    const onError = err => {\n      console.error(`Failure loading font ${url}`, err);\n    };\n    try {\n      const request = new XMLHttpRequest();\n      request.open('get', url, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function () {\n        if (request.status >= 400) {\n          onError(new Error(request.statusText));\n        }\n        else if (request.status > 0) {\n          try {\n            const fontObj = fontParser(request.response);\n            fontObj.src = url;\n            callback(fontObj);\n          } catch (e) {\n            onError(e);\n          }\n        }\n      };\n      request.onerror = onError;\n      request.send();\n    } catch(err) {\n      onError(err);\n    }\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   * @param {string} fontUrl\n   * @param {(font: ParsedFont) => void} callback\n   */\n  function loadFont(fontUrl, callback) {\n    let font = parsedFonts[fontUrl];\n    if (font) {\n      callback(font);\n    } else if (loadingFonts[fontUrl]) {\n      loadingFonts[fontUrl].push(callback);\n    } else {\n      loadingFonts[fontUrl] = [callback];\n      doLoadFont(fontUrl, fontObj => {\n        fontObj.src = fontUrl;\n        parsedFonts[fontUrl] = fontObj;\n        loadingFonts[fontUrl].forEach(cb => cb(fontObj));\n        delete loadingFonts[fontUrl];\n      });\n    }\n  }\n\n  /**\n   * For a given string of text, determine which fonts are required to fully render it and\n   * ensure those fonts are loaded.\n   */\n  return function (text, callback, {\n    lang,\n    fonts: userFonts = [],\n    style = 'normal',\n    weight = 'normal',\n    unicodeFontsURL\n  } = {}) {\n    const charResolutions = new Uint8Array(text.length);\n    const fontResolutions = [];\n    if (!text.length) {\n      allDone();\n    }\n\n    const fontIndices = new Map();\n    const fallbackRanges = []; // [[start, end], ...]\n\n    if (style !== 'italic') style = 'normal';\n    if (typeof weight !== 'number') {\n      weight = weight === 'bold' ? 700 : 400;\n    }\n\n    if (userFonts && !Array.isArray(userFonts)) {\n      userFonts = [userFonts];\n    }\n    userFonts = userFonts.slice()\n      // filter by language\n      .filter(def => !def.lang || def.lang.test(lang))\n      // switch order for easier iteration\n      .reverse();\n    if (userFonts.length) {\n      const UNKNOWN = 0;\n      const RESOLVED = 1;\n      const NEEDS_FALLBACK = 2;\n      let prevCharResult = UNKNOWN\n\n      ;(function resolveUserFonts (startIndex = 0) {\n        for (let i = startIndex, iLen = text.length; i < iLen; i++) {\n          const codePoint = text.codePointAt(i);\n          // Carry previous character's result forward if:\n          // - it resolved to a font that also covers this character\n          // - this character is whitespace\n          if (\n            (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||\n            /\\s/.test(text[i])\n          ) {\n            charResolutions[i] = charResolutions[i - 1];\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          }  else {\n            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {\n              if (j === jLen) {\n                // none of the user fonts matched; needs fallback\n                const range = prevCharResult === NEEDS_FALLBACK ?\n                  fallbackRanges[fallbackRanges.length - 1] :\n                  (fallbackRanges[fallbackRanges.length] = [i, i]);\n                range[1] = i;\n                prevCharResult = NEEDS_FALLBACK;\n              } else {\n                charResolutions[i] = j;\n                const { src, unicodeRange } = userFonts[j];\n                // filter by optional explicit unicode ranges\n                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                  const fontObj = parsedFonts[src];\n                  // font not yet loaded, load it and resume\n                  if (!fontObj) {\n                    loadFont(src, () => {\n                      resolveUserFonts(i);\n                    });\n                    return;\n                  }\n                  // if the font actually contains a glyph for this char, lock it in\n                  if (fontObj.supportsCodePoint(codePoint)) {\n                    let fontIndex = fontIndices.get(fontObj);\n                    if (typeof fontIndex !== 'number') {\n                      fontIndex = fontResolutions.length;\n                      fontResolutions.push(fontObj);\n                      fontIndices.set(fontObj, fontIndex);\n                    }\n                    charResolutions[i] = fontIndex;\n                    prevCharResult = RESOLVED;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (codePoint > 0xffff && i + 1 < iLen) {\n            charResolutions[i + 1] = charResolutions[i];\n            i++;\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          }\n        }\n        resolveFallbacks();\n      })();\n    } else {\n      fallbackRanges.push([0, text.length - 1]);\n      resolveFallbacks();\n    }\n\n    function resolveFallbacks() {\n      if (fallbackRanges.length) {\n        // Combine all fallback substrings into a single string for querying\n        const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');\n        unicodeFontResolverClient.getFontsForString(fallbackString, {\n          lang: lang || undefined,\n          style,\n          weight,\n          dataUrl: unicodeFontsURL\n        }).then(({fontUrls, chars}) => {\n          // Extract results and put them back in the main array\n          const fontIndexOffset = fontResolutions.length;\n          let charIdx = 0;\n          fallbackRanges.forEach(range => {\n            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {\n              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n            }\n            charIdx++; //skip segment separator\n          });\n\n          // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n          let loadedCount = 0;\n          fontUrls.forEach((url, i) => {\n            loadFont(url, fontObj => {\n              fontResolutions[i + fontIndexOffset] = fontObj;\n              if (++loadedCount === fontUrls.length) {\n                allDone();\n              }\n            });\n          });\n        });\n      } else {\n        allDone();\n      }\n    }\n\n    function allDone() {\n      callback({\n        chars: charResolutions,\n        fonts: fontResolutions\n      });\n    }\n\n    function isCodeInRanges(code, ranges) {\n      // todo optimize search - CodePointSet from unicode-font-resolver?\n      for (let k = 0; k < ranges.length; k++) {\n        const [start, end = start] = ranges[k];\n        if (start <= code && code <= end) {\n          return true\n        }\n      }\n      return false\n    }\n  }\n}\n\nconst fontResolverWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'FontResolver',\n  dependencies: [\n    createFontResolver,\n    workerModule,\n    unicodeFontResolverClientFactory,\n  ],\n  init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n    return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n  }\n});\n\n/**\n * @typedef {number|'left'|'center'|'right'} AnchorXValue\n */\n/**\n * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n */\n\n/**\n * @typedef {object} TypesetParams\n * @property {string} text\n * @property {UserFont|UserFont[]} [font]\n * @property {string} [lang]\n * @property {number} [sdfGlyphSize=64]\n * @property {number} [fontSize=1]\n * @property {number|'normal'|'bold'} [fontWeight='normal']\n * @property {'normal'|'italic'} [fontStyle='normal']\n * @property {number} [letterSpacing=0]\n * @property {'normal'|number} [lineHeight='normal']\n * @property {number} [maxWidth]\n * @property {'ltr'|'rtl'} [direction='ltr']\n * @property {string} [textAlign='left']\n * @property {number} [textIndent=0]\n * @property {'normal'|'nowrap'} [whiteSpace='normal']\n * @property {'normal'|'break-word'} [overflowWrap='normal']\n * @property {AnchorXValue} [anchorX=0]\n * @property {AnchorYValue} [anchorY=0]\n * @property {boolean} [metricsOnly=false]\n * @property {string} [unicodeFontsURL]\n * @property {FontResolverResult} [preResolvedFonts]\n * @property {boolean} [includeCaretPositions=false]\n * @property {number} [chunkedBoundsSize=8192]\n * @property {{[rangeStartIndex]: number}} [colorRanges]\n */\n\n/**\n * @typedef {object} TypesetResult\n * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n * @property {TypesetFontData[]} fontData data about each font used in the text\n * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n *         fontSize, //calculated em height\n *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n *           anchorXOffset,\n *           anchorYOffset - totalHeight,\n *           anchorXOffset + maxLineWidth,\n *           anchorYOffset\n *         ],\n *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n *         timings\n */\n\n/**\n * @typedef {object} TypesetFontData\n * @property src\n * @property unitsPerEm\n * @property ascender\n * @property descender\n * @property lineHeight\n * @property capHeight\n * @property xHeight\n */\n\n/**\n * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n * @param {TypesetParams} params\n * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n/**\n * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n * @param {TypesetParams} params\n * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n * @param {object} bidi - the bidi.js implementation object\n * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n */\nfunction createTypesetter(resolveFonts, bidi) {\n  const INF = Infinity;\n\n  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n  // eslint-disable-next-line no-misleading-character-class\n  const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n  // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n  const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n  // Incomplete set of characters that allow line breaking after them\n  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n  /**\n   * Load and parse all the necessary fonts to render a given string of text, then group\n   * them into consecutive runs of characters sharing a font.\n   */\n  function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {\n    const onResolved = ({chars, fonts: parsedFonts}) => {\n      let curRun, prevVal;\n      const runs = [];\n      for (let i = 0; i < chars.length; i++) {\n        if (chars[i] !== prevVal) {\n          prevVal = chars[i];\n          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});\n        } else {\n          curRun.end = i;\n        }\n      }\n      onDone(runs);\n    };\n    if (preResolvedFonts) {\n      onResolved(preResolvedFonts);\n    } else {\n      resolveFonts(\n        text,\n        onResolved,\n        { lang, fonts, style, weight, unicodeFontsURL }\n      );\n    }\n  }\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   * @type TypesetterTypesetFunction\n   */\n  function typeset(\n    {\n      text='',\n      font,\n      lang,\n      sdfGlyphSize=64,\n      fontSize=400,\n      fontWeight=1,\n      fontStyle='normal',\n      letterSpacing=0,\n      lineHeight='normal',\n      maxWidth=INF,\n      direction,\n      textAlign='left',\n      textIndent=0,\n      whiteSpace='normal',\n      overflowWrap='normal',\n      anchorX = 0,\n      anchorY = 0,\n      metricsOnly=false,\n      unicodeFontsURL,\n      preResolvedFonts=null,\n      includeCaretPositions=false,\n      chunkedBoundsSize=8192,\n      colorRanges=null\n    },\n    callback\n  ) {\n    const mainStart = now();\n    const timings = {fontLoad: 0, typesetting: 0};\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    // Ensure we've got numbers not strings\n    fontSize = +fontSize;\n    letterSpacing = +letterSpacing;\n    maxWidth = +maxWidth;\n    lineHeight = lineHeight || 'normal';\n    textIndent = +textIndent;\n\n    calculateFontRuns({\n      text,\n      lang,\n      style: fontStyle,\n      weight: fontWeight,\n      fonts: typeof font === 'string' ? [{src: font}] : font,\n      unicodeFontsURL,\n      preResolvedFonts\n    }, runs => {\n      timings.fontLoad = now() - mainStart;\n      const hasMaxWidth = isFinite(maxWidth);\n      let glyphIds = null;\n      let glyphFontIndices = null;\n      let glyphPositions = null;\n      let glyphData = null;\n      let glyphColors = null;\n      let caretPositions = null;\n      let visibleBounds = null;\n      let chunkedBounds = null;\n      let maxLineWidth = 0;\n      let renderableGlyphCount = 0;\n      let canWrap = whiteSpace !== 'nowrap';\n      const metricsByFont = new Map(); // fontObj -> metrics\n      const typesetStart = now();\n\n      // Distribute glyphs into lines based on wrapping\n      let lineXOffset = textIndent;\n      let prevRunEndX = 0;\n      let currentLine = new TextLine();\n      const lines = [currentLine];\n      runs.forEach(run => {\n        const { fontObj } = run;\n        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n\n        // Calculate metrics for each font used\n        let fontData = metricsByFont.get(fontObj);\n        if (!fontData) {\n          // Find conversion between native font units and fontSize units\n          const fontSizeMult = fontSize / unitsPerEm;\n\n          // Determine appropriate value for 'normal' line height based on the font's actual metrics\n          // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n          const calcLineHeight = lineHeight === 'normal' ?\n            (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n\n          // Determine line height and leading adjustments\n          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n          const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n          fontData = {\n            index: metricsByFont.size,\n            src: fontObj.src,\n            fontObj,\n            fontSizeMult,\n            unitsPerEm,\n            ascender: ascender * fontSizeMult,\n            descender: descender * fontSizeMult,\n            capHeight: capHeight * fontSizeMult,\n            xHeight: xHeight * fontSizeMult,\n            lineHeight: calcLineHeight,\n            baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height\n            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n            caretTop,\n            caretBottom: caretTop - caretHeight\n          };\n          metricsByFont.set(fontObj, fontData);\n        }\n        const { fontSizeMult } = fontData;\n\n        const runText = text.slice(run.start, run.end + 1);\n        let prevGlyphX, prevGlyphObj;\n        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {\n          glyphX += prevRunEndX;\n          charIndex += run.start;\n          prevGlyphX = glyphX;\n          prevGlyphObj = glyphObj;\n          const char = text.charAt(charIndex);\n          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n          const curLineCount = currentLine.count;\n          let nextLine;\n\n          // Calc isWhitespace and isEmpty once per glyphObj\n          if (!('isEmpty' in glyphObj)) {\n            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n          }\n          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n            renderableGlyphCount++;\n          }\n\n          // If a non-whitespace character overflows the max width, we need to soft-wrap\n          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n            // If it's the first char after a whitespace, start a new line\n            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n              nextLine = new TextLine();\n              lineXOffset = -glyphX;\n            } else {\n              // Back up looking for a whitespace character to wrap at\n              for (let i = curLineCount; i--;) {\n                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                if (i === 0 && overflowWrap === 'break-word') {\n                  nextLine = new TextLine();\n                  lineXOffset = -glyphX;\n                  break\n                }\n                // Found a soft break point; move all chars since it to a new line\n                else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                  nextLine = currentLine.splitAt(i + 1);\n                  const adjustX = nextLine.glyphAt(0).x;\n                  lineXOffset -= adjustX;\n                  for (let j = nextLine.count; j--;) {\n                    nextLine.glyphAt(j).x -= adjustX;\n                  }\n                  break\n                }\n              }\n            }\n            if (nextLine) {\n              currentLine.isSoftWrapped = true;\n              currentLine = nextLine;\n              lines.push(currentLine);\n              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n            }\n          }\n\n          let fly = currentLine.glyphAt(currentLine.count);\n          fly.glyphObj = glyphObj;\n          fly.x = glyphX + lineXOffset;\n          fly.y = glyphY;\n          fly.width = glyphWidth;\n          fly.charIndex = charIndex;\n          fly.fontData = fontData;\n\n          // Handle hard line breaks\n          if (char === '\\n') {\n            currentLine = new TextLine();\n            lines.push(currentLine);\n            lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n          }\n        });\n        // At the end of a run we must capture the x position as the starting point for the next run\n        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n      });\n\n      // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n      let totalHeight = 0;\n      lines.forEach(line => {\n        let isTrailingWhitespace = true;\n        for (let i = line.count; i--;) {\n          const glyphInfo = line.glyphAt(i);\n          // omit trailing whitespace from width calculation\n          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n            line.width = glyphInfo.x + glyphInfo.width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            isTrailingWhitespace = false;\n          }\n          // use the tallest line height, lowest baseline, and highest cap/ex\n          let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;\n          if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n          const baselineDiff = baseline - line.baseline;\n          if (baselineDiff < 0) { //shift all metrics down\n            line.baseline += baselineDiff;\n            line.cap += baselineDiff;\n            line.ex += baselineDiff;\n          }\n          // compare cap/ex based on new lowest baseline\n          line.cap = Math.max(line.cap, line.baseline + capHeight);\n          line.ex = Math.max(line.ex, line.baseline + xHeight);\n        }\n        line.baseline -= totalHeight;\n        line.cap -= totalHeight;\n        line.ex -= totalHeight;\n        totalHeight += line.lineHeight;\n      });\n\n      // Find overall position adjustments for anchoring\n      let anchorXOffset = 0;\n      let anchorYOffset = 0;\n      if (anchorX) {\n        if (typeof anchorX === 'number') {\n          anchorXOffset = -anchorX;\n        }\n        else if (typeof anchorX === 'string') {\n          anchorXOffset = -maxLineWidth * (\n            anchorX === 'left' ? 0 :\n            anchorX === 'center' ? 0.5 :\n            anchorX === 'right' ? 1 :\n            parsePercent(anchorX)\n          );\n        }\n      }\n      if (anchorY) {\n        if (typeof anchorY === 'number') {\n          anchorYOffset = -anchorY;\n        }\n        else if (typeof anchorY === 'string') {\n          anchorYOffset = anchorY === 'top' ? 0 :\n            anchorY === 'top-baseline' ? -lines[0].baseline :\n            anchorY === 'top-cap' ? -lines[0].cap :\n            anchorY === 'top-ex' ? -lines[0].ex :\n            anchorY === 'middle' ? totalHeight / 2 :\n            anchorY === 'bottom' ? totalHeight :\n            anchorY === 'bottom-baseline' ? -lines[lines.length - 1].baseline :\n            parsePercent(anchorY) * totalHeight;\n        }\n      }\n\n      if (!metricsOnly) {\n        // Resolve bidi levels\n        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        glyphIds = new Uint16Array(renderableGlyphCount);\n        glyphFontIndices = new Uint8Array(renderableGlyphCount);\n        glyphPositions = new Float32Array(renderableGlyphCount * 2);\n        glyphData = {};\n        visibleBounds = [INF, INF, -INF, -INF];\n        chunkedBounds = [];\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 4);\n        }\n        if (colorRanges) {\n          glyphColors = new Uint8Array(renderableGlyphCount * 3);\n        }\n        let renderableGlyphIndex = 0;\n        let prevCharIndex = -1;\n        let colorCharIndex = -1;\n        let chunk;\n        let currentColor;\n        lines.forEach((line, lineIndex) => {\n          let {count:lineGlyphCount, width:lineWidth} = line;\n\n          // Ignore empty lines\n          if (lineGlyphCount > 0) {\n            // Count trailing whitespaces, we want to ignore these for certain things\n            let trailingWhitespaceCount = 0;\n            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n              trailingWhitespaceCount++;\n            }\n\n            // Apply horizontal alignment adjustments\n            let lineXOffset = 0;\n            let justifyAdjust = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify' && line.isSoftWrapped) {\n              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n              let whitespaceCount = 0;\n              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                  whitespaceCount++;\n                }\n              }\n              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n            }\n            if (justifyAdjust || lineXOffset) {\n              let justifyOffset = 0;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                const glyphObj = glyphInfo.glyphObj;\n                glyphInfo.x += lineXOffset + justifyOffset;\n                // Expand non-trailing whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                  justifyOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n              }\n            }\n\n            // Perform bidi range flipping\n            const flips = bidi.getReorderSegments(\n              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n            );\n            for (let fi = 0; fi < flips.length; fi++) {\n              const [start, end] = flips[fi];\n              // Map start/end string indices to indices in the line\n              let left = Infinity, right = -Infinity;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                  let startInLine = i, endInLine = i;\n                  for (; endInLine < lineGlyphCount; endInLine++) {\n                    let info = line.glyphAt(endInLine);\n                    if (info.charIndex > end) {\n                      break\n                    }\n                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                      left = Math.min(left, info.x);\n                      right = Math.max(right, info.x + info.width);\n                    }\n                  }\n                  for (let j = startInLine; j < endInLine; j++) {\n                    const glyphInfo = line.glyphAt(j);\n                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                  }\n                  break\n                }\n              }\n            }\n\n            // Assemble final data arrays\n            let glyphObj;\n            const setGlyphObj = g => glyphObj = g;\n            for (let i = 0; i < lineGlyphCount; i++) {\n              const glyphInfo = line.glyphAt(i);\n              glyphObj = glyphInfo.glyphObj;\n              const glyphId = glyphObj.index;\n\n              // Replace mirrored characters in rtl\n              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n              if (rtl) {\n                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                if (mirrored) {\n                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                }\n              }\n\n              // Add caret positions\n              if (includeCaretPositions) {\n                const {charIndex, fontData} = glyphInfo;\n                const caretLeft = glyphInfo.x + anchorXOffset;\n                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                // positions for those missing char indices; currently this uses a best-guess by dividing\n                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                // table to get better interior caret positions.\n                const ligCount = charIndex - prevCharIndex;\n                if (ligCount > 1) {\n                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Track current color range\n              if (colorRanges) {\n                const {charIndex} = glyphInfo;\n                while(charIndex > colorCharIndex) {\n                  colorCharIndex++;\n                  if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                    currentColor = colorRanges[colorCharIndex];\n                  }\n                }\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                const idx = renderableGlyphIndex++;\n                const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;\n\n                // Add this glyph's path data\n                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                if (!fontGlyphData[glyphId]) {\n                  fontGlyphData[glyphId] = {\n                    path: glyphObj.path,\n                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                  };\n                }\n\n                // Determine final glyph position and add to glyphPositions array\n                const glyphX = glyphInfo.x + anchorXOffset;\n                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                glyphPositions[idx * 2] = glyphX;\n                glyphPositions[idx * 2 + 1] = glyphY;\n\n                // Track total visible bounds\n                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                // Track bounding rects for each chunk of N glyphs\n                if (idx % chunkedBoundsSize === 0) {\n                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                  chunkedBounds.push(chunk);\n                }\n                chunk.end++;\n                const chunkRect = chunk.rect;\n                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                // Add to glyph ids and font indices arrays\n                glyphIds[idx] = glyphId;\n                glyphFontIndices[idx] = fontIndex;\n\n                // Add colors\n                if (colorRanges) {\n                  const start = idx * 3;\n                  glyphColors[start] = currentColor >> 16 & 255;\n                  glyphColors[start + 1] = currentColor >> 8 & 255;\n                  glyphColors[start + 2] = currentColor & 255;\n                }\n              }\n            }\n          }\n        });\n\n        // Fill in remaining caret positions in case the final character was a ligature\n        if (caretPositions) {\n          const ligCount = text.length - prevCharIndex;\n          if (ligCount > 1) {\n            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n          }\n        }\n      }\n\n      // Assemble final data about each font used\n      const fontData = [];\n      metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {\n        fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};\n      });\n\n      // Timing stats\n      timings.typesetting = now() - typesetStart;\n\n      callback({\n        glyphIds, //id for each glyph, specific to that glyph's font\n        glyphFontIndices, //index into fontData for each glyph\n        glyphPositions, //x,y of each glyph's origin in layout\n        glyphData, //dict holding data about each glyph appearing in the text\n        fontData, //data about each font used in the text\n        caretPositions, //startX,endX,bottomY caret positions for each char\n        // caretHeight, //height of cursor from bottom to top - todo per glyph?\n        glyphColors, //color for each glyph, if color ranges supplied\n        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n        fontSize, //calculated em height\n        topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n          anchorXOffset,\n          anchorYOffset - totalHeight,\n          anchorXOffset + maxLineWidth,\n          anchorYOffset\n        ],\n        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n        timings\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    typeset({...args, metricsOnly: true}, (result) => {\n      const [x0, y0, x1, y1] = result.blockBounds;\n      callback({\n        width: x1 - x0,\n        height: y1 - y0\n      });\n    });\n  }\n\n  function parsePercent(str) {\n    let match = str.match(/^([\\d.]+)%$/);\n    let pct = match ? parseFloat(match[1]) : NaN;\n    return isNaN(pct) ? 0 : pct / 100\n  }\n\n  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n    const ligStartX = caretPositions[ligStartIndex * 4];\n    const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n    const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n    const ligTop = caretPositions[ligStartIndex * 4 + 3];\n    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n    for (let i = 0; i < ligCount; i++) {\n      const startIndex = (ligStartIndex + i) * 4;\n      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n      caretPositions[startIndex + 2] = ligBottom;\n      caretPositions[startIndex + 3] = ligTop;\n    }\n  }\n\n  function now() {\n    return (self.performance || Date).now()\n  }\n\n  // Array-backed structure for a single line's glyphs data\n  function TextLine() {\n    this.data = [];\n  }\n  const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];\n  TextLine.prototype = {\n    width: 0,\n    lineHeight: 0,\n    baseline: 0,\n    cap: 0,\n    ex: 0,\n    isSoftWrapped: false,\n    get count() {\n      return Math.ceil(this.data.length / textLineProps.length)\n    },\n    glyphAt(i) {\n      let fly = TextLine.flyweight;\n      fly.data = this.data;\n      fly.index = i;\n      return fly\n    },\n    splitAt(i) {\n      let newLine = new TextLine();\n      newLine.data = this.data.splice(i * textLineProps.length);\n      return newLine\n    }\n  };\n  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n    Object.defineProperty(obj, prop, {\n      get() {\n        return this.data[this.index * textLineProps.length + i]\n      },\n      set(val) {\n        this.data[this.index * textLineProps.length + i] = val;\n      }\n    });\n    return obj\n  }, {data: null, index: 0});\n\n\n  return {\n    typeset,\n    measure,\n  }\n}\n\nconst now = () => (self.performance || Date).now();\n\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\nlet warned;\n\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */\nfunction generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n  // Allow opt-out\n  if (!useWebGL) {\n    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n  }\n\n  // Attempt GPU-accelerated generation first\n  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n    null,\n    err => {\n      // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n      if (!warned) {\n        console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n        warned = true;\n      }\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n  )\n}\n\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\n\nfunction nextChunk() {\n  const start = now();\n  while (queue.length && now() - start < chunkTimeBudget) {\n    queue.shift()();\n  }\n  timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */\nconst generateSDF_GL = (...args) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => {\n      const start = now();\n      try {\n        mainThreadGenerator.webgl.generateIntoCanvas(...args);\n        resolve({ timing: now() - start });\n      } catch (err) {\n        reject(err);\n      }\n    });\n    if (!timer) {\n      timer = setTimeout(nextChunk, 0);\n    }\n  })\n};\n\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */\nfunction generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n  let thread = threads[workerId];\n  if (!thread) {\n    thread = threads[workerId] = {\n      workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n        name: workerId,\n        workerId,\n        dependencies: [\n          webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          now\n        ],\n        init(_createSDFGenerator, now) {\n          const generate = _createSDFGenerator().javascript.generate;\n          return function (...args) {\n            const start = now();\n            const textureData = generate(...args);\n            return {\n              textureData,\n              timing: now() - start\n            }\n          }\n        },\n        getTransferables(result) {\n          return [result.textureData.buffer]\n        }\n      }),\n      requests: 0,\n      idleTimer: null\n    };\n  }\n\n  thread.requests++;\n  clearTimeout(thread.idleTimer);\n  return thread.workerModule(width, height, path, viewBox, distance, exponent)\n    .then(({ textureData, timing }) => {\n      // copy result data into the canvas\n      const start = now();\n      // expand single-channel data into rgba\n      const imageData = new Uint8Array(textureData.length * 4);\n      for (let i = 0; i < textureData.length; i++) {\n        imageData[i * 4 + channel] = textureData[i];\n      }\n      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n      timing += now() - start;\n\n      // clean up workers after a while\n      if (--thread.requests === 0) {\n        thread.idleTimer = setTimeout(() => { (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId); }, idleTimeout);\n      }\n      return { timing }\n    })\n}\n\nfunction warmUpSDFCanvas(canvas) {\n  if (!canvas._warm) {\n    mainThreadGenerator.webgl.isSupported(canvas);\n    canvas._warm = true;\n  }\n}\n\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\nconst CONFIG = {\n  defaultFontURL: null,\n  unicodeFontsURL: null,\n  sdfGlyphSize: 64,\n  sdfMargin: 1 / 16,\n  sdfExponent: 9,\n  textureWidth: 2048,\n};\nconst tempColor = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\n\nfunction now$1() {\n  return (self.performance || Date).now()\n}\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n *                 data and font files, if you don't want to use the default CDN. See\n *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n *                 configured per text instance, but this lets you do it once globally.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n */\nfunction configureTextBuilder(config) {\n  if (hasRequested) {\n    console.warn('configureTextBuilder called after first font request; will be ignored.');\n  } else {\n    assign(CONFIG, config);\n  }\n}\n\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */\nconst atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {TypesetParams} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  hasRequested = true;\n  args = assign({}, args);\n  const totalStart = now$1();\n\n  // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n  // In the future we'll allow args.font to be a list with unicode ranges too.\n  const { defaultFontURL } = CONFIG;\n  const fonts = [];\n  if (defaultFontURL) {\n    fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});\n  }\n  if (args.font) {\n    fonts.push({label: 'user', src: toAbsoluteURL(args.font)});\n  }\n  args.font = fonts;\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n\n  // Normalize colors\n  if (args.colorRanges != null) {\n    let colors = {};\n    for (let key in args.colorRanges) {\n      if (args.colorRanges.hasOwnProperty(key)) {\n        let val = args.colorRanges[key];\n        if (typeof val !== 'number') {\n          val = tempColor.set(val).getHex();\n        }\n        colors[key] = val;\n      }\n    }\n    args.colorRanges = colors;\n  }\n\n  Object.freeze(args);\n\n  // Init the atlas if needed\n  const {textureWidth, sdfExponent} = CONFIG;\n  const {sdfGlyphSize} = args;\n  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n  let atlas = atlases[sdfGlyphSize];\n  if (!atlas) {\n    const canvas = document.createElement('canvas');\n    canvas.width = textureWidth;\n    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n    atlas = atlases[sdfGlyphSize] = {\n      glyphCount: 0,\n      sdfGlyphSize,\n      sdfCanvas: canvas,\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(\n        canvas,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter\n      ),\n      contextLost: false,\n      glyphsByFont: new Map()\n    };\n    atlas.sdfTexture.generateMipmaps = false;\n    initContextLossHandling(atlas);\n  }\n\n  const {sdfTexture, sdfCanvas} = atlas;\n\n  // Issue request to the typesetting engine in the worker\n  typesetInWorker(args).then(result => {\n    const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;\n    const neededSDFs = [];\n    const glyphBounds = new Float32Array(glyphIds.length * 4);\n    let boundsIdx = 0;\n    let positionsIdx = 0;\n    const quadsStart = now$1();\n\n    const fontGlyphMaps = fontData.map(font => {\n      let map = atlas.glyphsByFont.get(font.src);\n      if (!map) {\n        atlas.glyphsByFont.set(font.src, map = new Map());\n      }\n      return map\n    });\n\n    glyphIds.forEach((glyphId, i) => {\n      const fontIndex = glyphFontIndices[i];\n      const {src: fontSrc, unitsPerEm} = fontData[fontIndex];\n      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n\n      // If this is a glyphId not seen before, add it to the atlas\n      if (!glyphInfo) {\n        const {path, pathBounds} = result.glyphData[fontSrc][glyphId];\n\n        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n        // useful interpolated values and will be ignored anyway.\n        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n        const atlasIndex = atlas.glyphCount++;\n        const sdfViewBox = [\n          pathBounds[0] - fontUnitsMargin,\n          pathBounds[1] - fontUnitsMargin,\n          pathBounds[2] + fontUnitsMargin,\n          pathBounds[3] + fontUnitsMargin,\n        ];\n        fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n        // Collect those that need SDF generation\n        neededSDFs.push(glyphInfo);\n      }\n\n      // Calculate bounds for renderable quads\n      // TODO can we get this back off the main thread?\n      const {sdfViewBox} = glyphInfo;\n      const posX = glyphPositions[positionsIdx++];\n      const posY = glyphPositions[positionsIdx++];\n      const fontSizeMult = fontSize / unitsPerEm;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n      // Convert glyphId to SDF index for the shader\n      glyphIds[i] = glyphInfo.atlasIndex;\n    });\n    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n    const sdfStart = now$1();\n    timings.sdf = {};\n\n    // Grow the texture height by power of 2 if needed\n    const currentHeight = sdfCanvas.height;\n    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n    if (neededHeight > currentHeight) {\n      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n      sdfTexture.dispose();\n    }\n\n    Promise.all(neededSDFs.map(glyphInfo =>\n      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n        timings.sdf[glyphInfo.atlasIndex] = timing;\n      })\n    )).then(() => {\n      if (neededSDFs.length && !atlas.contextLost) {\n        safariPre15Workaround(atlas);\n        sdfTexture.needsUpdate = true;\n      }\n      timings.sdfTotal = now$1() - sdfStart;\n      timings.total = now$1() - totalStart;\n      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture,\n        sdfGlyphSize,\n        sdfExponent,\n        glyphBounds,\n        glyphAtlasIndices: glyphIds,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        capHeight: result.capHeight,\n        xHeight: result.xHeight,\n        topBaseline: result.topBaseline,\n        blockBounds: result.blockBounds,\n        visibleBounds: result.visibleBounds,\n        timings: result.timings,\n      }));\n    });\n  });\n\n  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n  // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n  // a head start on that process before SDFs actually start getting processed.\n  Promise.resolve().then(() => {\n    if (!atlas.contextLost) {\n      warmUpSDFCanvas(sdfCanvas);\n    }\n  });\n}\n\nfunction generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n  if (contextLost) {\n    // If the context is lost there's nothing we can do, just quit silently and let it\n    // get regenerated when the context is restored\n    return Promise.resolve({timing: -1})\n  }\n  const {textureWidth, sdfExponent} = CONFIG;\n  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n  const squareIndex = Math.floor(atlasIndex / 4);\n  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n  const channel = atlasIndex % 4;\n  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n}\n\nfunction initContextLossHandling(atlas) {\n  const canvas = atlas.sdfCanvas;\n\n  /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */\n\n  canvas.addEventListener('webglcontextlost', (event) => {\n    console.log('Context Lost', event);\n    event.preventDefault();\n    atlas.contextLost = true;\n  });\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    console.log('Context Restored', event);\n    atlas.contextLost = false;\n    // Regenerate all glyphs into the restored canvas:\n    const promises = [];\n    atlas.glyphsByFont.forEach(glyphMap => {\n      glyphMap.forEach(glyph => {\n        promises.push(generateGlyphSDF(glyph, atlas, true));\n      });\n    });\n    Promise.all(promises).then(() => {\n      safariPre15Workaround(atlas);\n      atlas.sdfTexture.needsUpdate = true;\n    });\n  });\n}\n\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */\nfunction preloadFont({font, characters, sdfGlyphSize}, callback) {\n  let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n}\n\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (let key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n  if (!linkEl) {\n    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n  }\n  linkEl.href = path;\n  return linkEl.href\n}\n\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */\nfunction safariPre15Workaround(atlas) {\n  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n  // have supported it for a long while so any false positives should be minimal.\n  if (typeof createImageBitmap !== 'function') {\n    console.info('Safari<15: applying SDF canvas workaround');\n    const {sdfCanvas, sdfTexture} = atlas;\n    const {width, height} = sdfCanvas;\n    const gl = atlas.sdfCanvas.getContext('webgl');\n    let pixels = sdfTexture.image.data;\n    if (!pixels || pixels.length !== width * height * 4) {\n      pixels = new Uint8Array(width * height * 4);\n      sdfTexture.image = {width, height, data: pixels};\n      sdfTexture.flipY = false;\n      sdfTexture.isDataTexture = true;\n    }\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n}\n\nconst typesetterWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    createTypesetter,\n    fontResolverWorkerModule,\n    bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  ],\n  init(createTypesetter, fontResolver, bidiFactory) {\n    return createTypesetter(fontResolver, bidiFactory())\n  }\n});\n\nconst typesetInWorker = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    typesetterWorkerModule,\n  ],\n  init(typesetter) {\n    return function(args) {\n      return new Promise(resolve => {\n        typesetter.typeset(args, resolve);\n      })\n    }\n  },\n  getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    const transferables = [];\n    for (let p in result) {\n      if (result[p] && result[p].buffer) {\n        transferables.push(result[p].buffer);\n      }\n    }\n    return transferables\n  }\n});\n\nfunction dumpSDFTextures() {\n  Object.keys(atlases).forEach(size => {\n    const canvas = atlases[size].sdfCanvas;\n    const {width, height} = canvas;\n    console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n  });\n}\n\nconst templateGeometries = {};\n\nfunction getTemplateGeometry(detail) {\n  let geom = templateGeometries[detail];\n  if (!geom) {\n    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n    const front = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail);\n    const back = front.clone();\n    const frontAttrs = front.attributes;\n    const backAttrs = back.attributes;\n    const combined = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n    const vertCount = frontAttrs.uv.count;\n    for (let i = 0; i < vertCount; i++) {\n      backAttrs.position.array[i * 3] *= -1; // flip position x\n      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n    }\n    ['position', 'normal', 'uv'].forEach(name => {\n      combined.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(\n        [...frontAttrs[name].array, ...backAttrs[name].array],\n        frontAttrs[name].itemSize)\n      );\n    });\n    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n    combined.translate(0.5, 0.5, 0);\n    geom = templateGeometries[detail] = combined;\n  }\n  return geom\n}\n\nconst glyphBoundsAttrName = 'aTroikaGlyphBounds';\nconst glyphIndexAttrName = 'aTroikaGlyphIndex';\nconst glyphColorAttrName = 'aTroikaGlyphColor';\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nclass GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    this.detail = 1;\n    this.curveRadius = 0;\n\n    // Define groups for rendering text outline as a separate pass; these will only\n    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n    this.groups = [\n      {start: 0, count: Infinity, materialIndex: 0},\n      {start: 0, count: Infinity, materialIndex: 1}\n    ];\n\n    // Preallocate empty bounding objects\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n  }\n\n  computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n  }\n\n  computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n  }\n\n  // Since our base geometry contains triangles for both front and back sides, we can emulate\n  // the \"side\" by restricting the draw range.\n  setSide(side) {\n    const verts = this.getIndex().count;\n    this.setDrawRange(side === three__WEBPACK_IMPORTED_MODULE_3__.BackSide ? verts / 2 : 0, side === three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide ? verts : verts / 2);\n  }\n\n  set detail(detail) {\n    if (detail !== this._detail) {\n      this._detail = detail;\n      if (typeof detail !== 'number' || detail < 1) {\n        detail = 1;\n      }\n      let tpl = getTemplateGeometry(detail)\n      ;['position', 'normal', 'uv'].forEach(attr => {\n        this.attributes[attr] = tpl.attributes[attr].clone();\n      });\n      this.setIndex(tpl.getIndex().clone());\n    }\n  }\n  get detail() {\n    return this._detail\n  }\n\n  set curveRadius(r) {\n    if (r !== this._curveRadius) {\n      this._curveRadius = r;\n      this._updateBounds();\n    }\n  }\n  get curveRadius() {\n    return this._curveRadius\n  }\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */\n  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n    // Update the instance attributes\n    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n    this._blockBounds = blockBounds;\n    this._chunkedBounds = chunkedBounds;\n    this.instanceCount = glyphAtlasIndices.length;\n    this._updateBounds();\n  }\n\n  _updateBounds() {\n    const bounds = this._blockBounds;\n    if (bounds) {\n      const { curveRadius, boundingBox: bbox } = this;\n      if (curveRadius) {\n        const { PI, floor, min, max, sin, cos } = Math;\n        const halfPi = PI / 2;\n        const twoPi = PI * 2;\n        const absR = Math.abs(curveRadius);\n        const leftAngle = bounds[0] / absR;\n        const rightAngle = bounds[2] / absR;\n        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n      } else {\n        bbox.min.set(bounds[0], bounds[1], 0);\n        bbox.max.set(bounds[2], bounds[3], 0);\n      }\n      bbox.getBoundingSphere(this.boundingSphere);\n    }\n  }\n\n  /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */\n  applyClipRect(clipRect) {\n    let count = this.getAttribute(glyphIndexAttrName).count;\n    let chunks = this._chunkedBounds;\n    if (chunks) {\n      for (let i = chunks.length; i--;) {\n        count = chunks[i].end;\n        let rect = chunks[i].rect;\n        // note: both rects are l-b-r-t\n        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n          break\n        }\n      }\n    }\n    this.instanceCount = count;\n  }\n}\n\n\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n  const attr = geom.getAttribute(attrName);\n  if (newArray) {\n    // If length isn't changing, just update the attribute's array data\n    if (attr && attr.array.length === newArray.length) {\n      attr.array.set(newArray);\n      attr.needsUpdate = true;\n    } else {\n      geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n      // If the new attribute has a different size, we also have to (as of r117) manually clear the\n      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n      // implies it should be supported. It's possible we need to\n      delete geom._maxInstanceCount; //for r117+, could be fragile\n      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n    }\n  } else if (attr) {\n    geom.deleteAttribute(attrName);\n  }\n}\n\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    extensions: {\n      derivatives: true\n    },\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFExponent: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaDistanceOffset: {value: 0},\n      uTroikaOutlineOpacity: {value: 0},\n      uTroikaFillOpacity: {value: 1},\n      uTroikaPositionOffset: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaCurveRadius: {value: 0},\n      uTroikaBlurRadius: {value: 0},\n      uTroikaStrokeWidth: {value: 0},\n      uTroikaStrokeColor: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()},\n      uTroikaStrokeOpacity: {value: 1},\n      uTroikaOrient: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()},\n      uTroikaUseGlyphColors: {value: true},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM,\n    customRewriter({vertexShader, fragmentShader}) {\n      let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n      if (uDiffuseRE.test(fragmentShader)) {\n        // Replace all instances of `diffuse` with our varying\n        fragmentShader = fragmentShader\n          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n          .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n        // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n        if (!uDiffuseRE.test(vertexShader)) {\n          vertexShader = vertexShader.replace(\n            troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp,\n            'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n          );\n        }\n      }\n      return { vertexShader, fragmentShader }\n    }\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  Object.defineProperties(textMaterial, {\n    isTroikaTextMaterial: {value: true},\n\n    // WebGLShadowMap reverses the side of the shadow material by default, which fails\n    // for planes, so here we force the `shadowSide` to always match the main side.\n    shadowSide: {\n      get() {\n        return this.side\n      },\n      set() {\n        //no-op\n      }\n    }\n  });\n\n  return textMaterial\n}\n\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n  transparent: true\n});\nconst defaultStrokeColor = 0x808080;\n\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = '+x+y';\n\nfunction first(o) {\n  return Array.isArray(o) ? o[0] : o\n}\n\nlet getFlatRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1),\n    defaultMaterial\n  );\n  getFlatRaycastMesh = () => mesh;\n  return mesh\n};\nlet getCurvedRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1),\n    defaultMaterial\n  );\n  getCurvedRaycastMesh = () => mesh;\n  return mesh\n};\n\nconst syncStartEvent = { type: 'syncstart' };\nconst syncCompleteEvent = { type: 'synccomplete' };\n\nconst SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'lang',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'direction',\n  'textAlign',\n  'textIndent',\n  'whiteSpace',\n  'anchorX',\n  'anchorY',\n  'colorRanges',\n  'sdfGlyphSize'\n];\n\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n  'material',\n  'color',\n  'depthOffset',\n  'clipRect',\n  'curveRadius',\n  'orientation',\n  'glyphGeometryDetail'\n);\n\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nclass Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n  constructor() {\n    const geometry = new GlyphsGeometry();\n    super(geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */\n    this.anchorX = 0;\n\n    /**\n     * @member {number|string} anchorY\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */\n    this.anchorY = 0;\n\n    /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */\n    this.curveRadius = 0;\n\n    /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */\n    this.direction = 'auto';\n\n    /**\n     * @member {string|null} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to Noto Sans.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    this.unicodeFontsURL = null; //defaults to CDN\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number|'normal'|'bold'}\n     * The weight of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontWeight = 'normal';\n\n    /**\n     * @member {'normal'|'italic'}\n     * The style of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontStyle = 'normal';\n\n    /**\n     * @member {string|null} lang\n     * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n     */\n    this.lang = null;\n\n      /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */\n    this.textIndent = 0;\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */\n    this.color = null;\n\n    /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */\n    this.colorRanges = null;\n\n    /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */\n    this.outlineWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */\n    this.outlineColor = 0x000000;\n\n    /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */\n    this.outlineOpacity = 1;\n\n    /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineBlur = 0;\n\n    /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetX = 0;\n\n    /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetY = 0;\n\n    /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.strokeWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */\n    this.strokeColor = defaultStrokeColor;\n\n    /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */\n    this.strokeOpacity = 1;\n\n    /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */\n    this.fillOpacity = 1;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */\n    this.orientation = defaultOrient;\n\n    /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */\n    this.glyphGeometryDetail = 1;\n\n    /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */\n    this.sdfGlyphSize = null;\n\n    /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */\n    this.gpuAccelerateSDF = true;\n\n    this.debugSDF = false;\n  }\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  sync(callback) {\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n        this.dispatchEvent(syncStartEvent);\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          lang: this.lang,\n          fontSize: this.fontSize || 0.1,\n          fontWeight: this.fontWeight || 'normal',\n          fontStyle: this.fontStyle || 'normal',\n          letterSpacing: this.letterSpacing || 0,\n          lineHeight: this.lineHeight || 'normal',\n          maxWidth: this.maxWidth,\n          direction: this.direction || 'auto',\n          textAlign: this.textAlign,\n          textIndent: this.textIndent,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          colorRanges: this.colorRanges,\n          includeCaretPositions: true, //TODO parameterize\n          sdfGlyphSize: this.sdfGlyphSize,\n          gpuAccelerateSDF: this.gpuAccelerateSDF,\n          unicodeFontsURL: this.unicodeFontsURL,\n        }, textRenderInfo => {\n          this._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this.geometry.updateGlyphs(\n            textRenderInfo.glyphBounds,\n            textRenderInfo.glyphAtlasIndices,\n            textRenderInfo.blockBounds,\n            textRenderInfo.chunkedBounds,\n            textRenderInfo.glyphColors\n          );\n\n          // If we had extra sync requests queued up, kick it off\n          const queued = this._queuedSyncs;\n          if (queued) {\n            this._queuedSyncs = null;\n            this._needsSync = true;\n            this.sync(() => {\n              queued.forEach(fn => fn && fn());\n            });\n          }\n\n          this.dispatchEvent(syncCompleteEvent);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  onBeforeRender(renderer, scene, camera, geometry, material, group) {\n    this.sync();\n\n    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n    if (material.isTroikaTextMaterial) {\n      this._prepareForRender(material);\n    }\n\n    // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n    // is instead applied via drawRange in the GlyphsGeometry.\n    material._hadOwnSide = material.hasOwnProperty('side');\n    this.geometry.setSide(material._actualSide = material.side);\n    material.side = three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;\n  }\n\n  onAfterRender(renderer, scene, camera, geometry, material, group) {\n    // Restore original material side\n    if (material._hadOwnSide) {\n      material.side = material._actualSide;\n    } else {\n      delete material.side; // back to inheriting from base material\n    }\n  }\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  dispose() {\n    this.geometry.dispose();\n  }\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  get textRenderInfo() {\n    return this._textRenderInfo || null\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    // If text outline is configured, render it as a preliminary draw using Three's multi-material\n    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n    // materials ensures the layers are always rendered consecutively in a consistent order.\n    // Each layer will trigger onBeforeRender with the appropriate material.\n    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n      let outlineMaterial = derivedMaterial._outlineMtl;\n      if (!outlineMaterial) {\n        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n          id: {value: derivedMaterial.id + 0.1}\n        });\n        outlineMaterial.isTextOutlineMaterial = true;\n        outlineMaterial.depthWrite = false;\n        outlineMaterial.map = null; //???\n        derivedMaterial.addEventListener('dispose', function onDispose() {\n          derivedMaterial.removeEventListener('dispose', onDispose);\n          outlineMaterial.dispose();\n        });\n      }\n      return [\n        outlineMaterial,\n        derivedMaterial\n      ]\n    } else {\n      return derivedMaterial\n    }\n  }\n  set material(baseMaterial) {\n    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n      this._derivedMaterial = baseMaterial;\n      this._baseMaterial = baseMaterial.baseMaterial;\n    } else {\n      this._baseMaterial = baseMaterial;\n    }\n  }\n\n  get glyphGeometryDetail() {\n    return this.geometry.detail\n  }\n  set glyphGeometryDetail(detail) {\n    this.geometry.detail = detail;\n  }\n\n  get curveRadius() {\n    return this.geometry.curveRadius\n  }\n  set curveRadius(r) {\n    this.geometry.curveRadius = r;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return first(this.material).getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return first(this.material).getDistanceMaterial()\n  }\n\n  _prepareForRender(material) {\n    const isOutline = material.isTextOutlineMaterial;\n    const uniforms = material.uniforms;\n    const textInfo = this.textRenderInfo;\n    if (textInfo) {\n      const {sdfTexture, blockBounds} = textInfo;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n      let distanceOffset = 0;\n      let blurRadius = 0;\n      let strokeWidth = 0;\n      let fillOpacity;\n      let strokeOpacity;\n      let strokeColor;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (isOutline) {\n        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n        distanceOffset = this._parsePercent(outlineWidth) || 0;\n        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n        fillOpacity = outlineOpacity;\n        offsetX = this._parsePercent(outlineOffsetX) || 0;\n        offsetY = this._parsePercent(outlineOffsetY) || 0;\n      } else {\n        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n        if (strokeWidth) {\n          strokeColor = this.strokeColor;\n          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n          strokeOpacity = this.strokeOpacity;\n          if (strokeOpacity == null) strokeOpacity = 1;\n        }\n        fillOpacity = this.fillOpacity;\n      }\n\n      uniforms.uTroikaDistanceOffset.value = distanceOffset;\n      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n      uniforms.uTroikaBlurRadius.value = blurRadius;\n      uniforms.uTroikaStrokeWidth.value = strokeWidth;\n      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n      let clipRect = this.clipRect;\n      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n        uniforms.uTroikaClipRect.value.fromArray(clipRect);\n      } else {\n        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n        const pad = (this.fontSize || 0.1) * 100;\n        uniforms.uTroikaClipRect.value.set(\n          blockBounds[0] - pad,\n          blockBounds[1] - pad,\n          blockBounds[2] + pad,\n          blockBounds[3] + pad\n        );\n      }\n      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n    }\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // Shortcut for setting material color via `color` prop on the mesh; this is\n    // applied only to the derived material to avoid mutating a shared base material.\n    const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n    if (color == null) {\n      delete material.color; //inherit from base\n    } else {\n      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color());\n      if (color !== colorObj._input || typeof color === 'object') {\n        colorObj.set(colorObj._input = color);\n      }\n    }\n\n    // base orientation\n    let orient = this.orientation || defaultOrient;\n    if (orient !== material._orientation) {\n      let rotMat = uniforms.uTroikaOrient.value;\n      orient = orient.replace(/[^-+xyz]/g, '');\n      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n      if (match) {\n        let [, hSign, hAxis, vSign, vAxis] = match;\n        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n        rotMat.setFromMatrix4(tempMat4);\n      } else {\n        rotMat.identity();\n      }\n      material._orientation = orient;\n    }\n  }\n\n  _parsePercent(value) {\n    if (typeof value === 'string') {\n      let match = value.match(/^(-?[\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n    }\n    return value\n  }\n\n  /**\n   * Translate a point in local space to an x/y in the text plane.\n   */\n  localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    target.copy(position); //simple non-curved case is 1:1\n    const r = this.curveRadius;\n    if (r) { //flatten the curve\n      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n    }\n    return target\n  }\n\n  /**\n   * Translate a point in world space to an x/y in the text plane.\n   */\n  worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    tempVec3a.copy(position);\n    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n  }\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  raycast(raycaster, intersects) {\n    const {textRenderInfo, curveRadius} = this;\n    if (textRenderInfo) {\n      const bounds = textRenderInfo.blockBounds;\n      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n      const geom = raycastMesh.geometry;\n      const {position, uv} = geom.attributes;\n      for (let i = 0; i < uv.count; i++) {\n        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n        let z = 0;\n        if (curveRadius) {\n          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n          x = Math.sin(x / curveRadius) * curveRadius;\n        }\n        position.setXYZ(i, x, y, z);\n      }\n      geom.boundingSphere = this.geometry.boundingSphere;\n      geom.boundingBox = this.geometry.boundingBox;\n      raycastMesh.matrixWorld = this.matrixWorld;\n      raycastMesh.material.side = this.material.side;\n      tempArray.length = 0;\n      raycastMesh.raycast(raycaster, tempArray);\n      for (let i = 0; i < tempArray.length; i++) {\n        tempArray[i].object = this;\n        intersects.push(tempArray[i]);\n      }\n    }\n  }\n\n  copy(source) {\n    // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n    const geom = this.geometry;\n    super.copy(source);\n    this.geometry = geom;\n\n    COPYABLE_PROPS.forEach(prop => {\n      this[prop] = source[prop];\n    });\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n}\n\n\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach(prop => {\n  const privateKey = '_private_' + prop;\n  Object.defineProperty(Text.prototype, prop, {\n    get() {\n      return this[privateKey]\n    },\n    set(value) {\n      if (value !== this[privateKey]) {\n        this[privateKey] = value;\n        this._needsSync = true;\n      }\n    }\n  });\n});\n\n//=== Utility functions for dealing with carets and selection ranges ===//\n\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */\n\n/**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */\nfunction getCaretAtPoint(textRenderInfo, x, y) {\n  let closestCaret = null;\n  const rows = groupCaretsByRow(textRenderInfo);\n\n  // Find nearest row by y first\n  let closestRow = null;\n  rows.forEach(row => {\n    if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n      closestRow = row;\n    }\n  });\n\n  // Then find closest caret by x within that row\n  closestRow.carets.forEach(caret => {\n    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n      closestCaret = caret;\n    }\n  });\n  return closestCaret\n}\n\n\nconst _rectsCache = new WeakMap();\n\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */\nfunction getSelectionRects(textRenderInfo, start, end) {\n  let rects;\n  if (textRenderInfo) {\n    // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n    let prevResult = _rectsCache.get(textRenderInfo);\n    if (prevResult && prevResult.start === start && prevResult.end === end) {\n      return prevResult.rects\n    }\n\n    const {caretPositions} = textRenderInfo;\n\n    // Normalize\n    if (end < start) {\n      const s = start;\n      start = end;\n      end = s;\n    }\n    start = Math.max(start, 0);\n    end = Math.min(end, caretPositions.length + 1);\n\n    // Build list of rects, expanding the current rect for all characters in a run and starting\n    // a new rect whenever reaching a new line or a new bidi direction\n    rects = [];\n    let currentRect = null;\n    for (let i = start; i < end; i++) {\n      const x1 = caretPositions[i * 4];\n      const x2 = caretPositions[i * 4 + 1];\n      const left = Math.min(x1, x2);\n      const right = Math.max(x1, x2);\n      const bottom = caretPositions[i * 4 + 2];\n      const top = caretPositions[i * 4 + 3];\n      if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n        currentRect = {\n          left: Infinity,\n          right: -Infinity,\n          bottom,\n          top,\n        };\n        rects.push(currentRect);\n      }\n      currentRect.left = Math.min(left, currentRect.left);\n      currentRect.right = Math.max(right, currentRect.right);\n    }\n\n    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n    for (let i = rects.length - 1; i-- > 0;) {\n      const rectA = rects[i];\n      const rectB = rects[i + 1];\n      if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n        rectB.left = Math.min(rectB.left, rectA.left);\n        rectB.right = Math.max(rectB.right, rectA.right);\n        rects.splice(i, 1);\n      }\n    }\n\n    _rectsCache.set(textRenderInfo, {start, end, rects});\n  }\n  return rects\n}\n\nconst _caretsByRowCache = new WeakMap();\n\n/**\n * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n */\nfunction groupCaretsByRow(textRenderInfo) {\n  // textRenderInfo is frozen so it's safe to cache based on it\n  let rows = _caretsByRowCache.get(textRenderInfo);\n  if (!rows) {\n    rows = [];\n    const {caretPositions} = textRenderInfo;\n    let curRow;\n\n    const visitCaret = (x, bottom, top, charIndex) => {\n      // new row if not overlapping by at least half\n      if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {\n        rows.push(curRow = {bottom, top, carets: []});\n      }\n      // expand vertical limits if necessary\n      if (top > curRow.top) curRow.top = top;\n      if (bottom < curRow.bottom) curRow.bottom = bottom;\n      curRow.carets.push({\n        x,\n        y: bottom,\n        height: top - bottom,\n        charIndex,\n      });\n    };\n\n    let i = 0;\n    for (; i < caretPositions.length; i += 4) {\n      visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n    }\n    // Add one more caret after the final char\n    visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n  }\n  _caretsByRowCache.set(textRenderInfo, rows);\n  return rows\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvUjtBQUMxTTtBQUNyQjtBQUNuQjtBQUN5Qzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWtFLE9BQU8sa0JBQWtCLGlDQUFpQywrQkFBK0IsUUFBUSw4Q0FBOEMsc0JBQXNCLEtBQUssaUJBQWlCLElBQUksS0FBSyxzQkFBc0IsK0JBQStCLFNBQVMsMEJBQTBCLHlCQUF5QixpQkFBaUIsc0JBQXNCLHdCQUF3QiwwRUFBMEUsK0hBQStILGtCQUFrQixLQUFLLEtBQUssSUFBSSxLQUFLLHlCQUF5QiwwQkFBMEIsc0JBQXNCLEtBQUssc0JBQXNCLFdBQVcsb0JBQW9CLFFBQVEsV0FBVyxLQUFLLFdBQVcsb0VBQW9FLFNBQVMsNEJBQTRCLGtEQUFrRCxJQUFJLEtBQUsseUJBQXlCLDBCQUEwQixzQkFBc0IsMkNBQTJDLFdBQVcsUUFBUSx3QkFBd0IsaURBQWlELDJCQUEyQixtQ0FBbUMsdUJBQXVCLG1DQUFtQyx3QkFBd0Isa0NBQWtDLHlCQUF5QixtQ0FBbUMsMEJBQTBCLG9DQUFvQyw2QkFBNkIsaUJBQWlCLElBQUksdUNBQXVDLFNBQVMsd0JBQXdCLG9DQUFvQywwQkFBMEIsOERBQThELDJCQUEyQixpQkFBaUIsSUFBSSxtQ0FBbUMsU0FBUyw2QkFBNkIsaUJBQWlCLElBQUksS0FBSyx1QkFBdUIsMkJBQTJCLFNBQVMsMkdBQTJHLG1CQUFtQixnRUFBZ0UsMkJBQTJCLGlCQUFpQixJQUFJLG1CQUFtQixTQUFTLGdDQUFnQyxpQkFBaUIsSUFBSSx3Q0FBd0MsU0FBUyxtQkFBbUIsb0lBQW9JLFdBQVcsbUNBQW1DLGlCQUFpQixLQUFLLHNCQUFzQix3QkFBd0IsS0FBSyx3QkFBd0IsS0FBSyx3QkFBd0IsbUpBQW1KLHdDQUF3QywwQ0FBMEMsS0FBSyxZQUFZLElBQUks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QixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUEsV0FBVyxnQkFBZ0I7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQuZXNtLmpzP2QwZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZSwgTGluZWFyRmlsdGVyLCBDb2xvciwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIFNwaGVyZSwgQm94MywgQmFja1NpZGUsIERvdWJsZVNpZGUsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgUGxhbmVHZW9tZXRyeSwgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIFZlY3RvcjIsIFZlY3RvcjQsIE1hdHJpeDMsIE1lc2gsIEZyb250U2lkZSwgTWVzaEJhc2ljTWF0ZXJpYWwsIE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBkZWZpbmVXb3JrZXJNb2R1bGUsIHRlcm1pbmF0ZVdvcmtlciB9IGZyb20gJ3Ryb2lrYS13b3JrZXItdXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVNERkdlbmVyYXRvciBmcm9tICd3ZWJnbC1zZGYtZ2VuZXJhdG9yJztcbmltcG9ydCBiaWRpRmFjdG9yeSBmcm9tICdiaWRpLWpzJztcbmltcG9ydCB7IGNyZWF0ZURlcml2ZWRNYXRlcmlhbCwgdm9pZE1haW5SZWdFeHAgfSBmcm9tICd0cm9pa2EtdGhyZWUtdXRpbHMnO1xuXG4vKiFcbkN1c3RvbSBidWlsZCBvZiBUeXByLnRzIChodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cykgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuXG5PcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuZnVuY3Rpb24gdHlwckZhY3RvcnkoKXtyZXR1cm4gXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmKHNlbGYud2luZG93PXNlbGYpLGZ1bmN0aW9uKHIpe3ZhciBlPXtwYXJzZTpmdW5jdGlvbihyKXt2YXIgdD1lLl9iaW4sYT1uZXcgVWludDhBcnJheShyKTtpZihcInR0Y2ZcIj09dC5yZWFkQVNDSUkoYSwwLDQpKXt2YXIgbj00O3QucmVhZFVzaG9ydChhLG4pLG4rPTIsdC5yZWFkVXNob3J0KGEsbiksbis9Mjt2YXIgbz10LnJlYWRVaW50KGEsbik7bis9NDtmb3IodmFyIHM9W10saT0wO2k8bztpKyspe3ZhciBoPXQucmVhZFVpbnQoYSxuKTtuKz00LHMucHVzaChlLl9yZWFkRm9udChhLGgpKTt9cmV0dXJuIHN9cmV0dXJuIFtlLl9yZWFkRm9udChhLDApXX0sX3JlYWRGb250OmZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dDthLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIHM9W1wiY21hcFwiLFwiaGVhZFwiLFwiaGhlYVwiLFwibWF4cFwiLFwiaG10eFwiLFwibmFtZVwiLFwiT1MvMlwiLFwicG9zdFwiLFwibG9jYVwiLFwiZ2x5ZlwiLFwia2VyblwiLFwiQ0ZGIFwiLFwiR0RFRlwiLFwiR1BPU1wiLFwiR1NVQlwiLFwiU1ZHIFwiXSxpPXtfZGF0YTpyLF9vZmZzZXQ6bn0saD17fSxkPTA7ZDxvO2QrKyl7dmFyIGY9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIHU9YS5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9YS5yZWFkVWludChyLHQpO3QrPTQsaFtmXT17b2Zmc2V0OnUsbGVuZ3RoOmx9O31mb3IoZD0wO2Q8cy5sZW5ndGg7ZCsrKXt2YXIgdj1zW2RdO2hbdl0mJihpW3YudHJpbSgpXT1lW3YudHJpbSgpXS5wYXJzZShyLGhbdl0ub2Zmc2V0LGhbdl0ubGVuZ3RoLGkpKTt9cmV0dXJuIGl9LF90YWJPZmZzZXQ6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocixhKzQpLHM9YSsxMixpPTA7aTxvO2krKyl7dmFyIGg9bi5yZWFkQVNDSUkocixzLDQpO3MrPTQsbi5yZWFkVWludChyLHMpLHMrPTQ7dmFyIGQ9bi5yZWFkVWludChyLHMpO2lmKHMrPTQsbi5yZWFkVWludChyLHMpLHMrPTQsaD09dClyZXR1cm4gZH1yZXR1cm4gMH19O2UuX2Jpbj17cmVhZEZpeGVkOmZ1bmN0aW9uKHIsZSl7cmV0dXJuIChyW2VdPDw4fHJbZSsxXSkrKHJbZSsyXTw8OHxyW2UrM10pLzY1NTQwfSxyZWFkRjJkb3QxNDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4ucmVhZFNob3J0KHIsdCkvMTYzODR9LHJlYWRJbnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDMyKHQpfSxyZWFkSW50ODpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50OCh0KX0scmVhZFNob3J0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQxNih0KX0scmVhZFVzaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDE2KHQpfSxyZWFkVXNob3J0czpmdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGE7bysrKW4ucHVzaChlLl9iaW4ucmVhZFVzaG9ydChyLHQrMipvKSk7cmV0dXJuIG59LHJlYWRVaW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRVaW50MzIodCl9LHJlYWRVaW50NjQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gNDI5NDk2NzI5NiplLl9iaW4ucmVhZFVpbnQocix0KStlLl9iaW4ucmVhZFVpbnQocix0KzQpfSxyZWFkQVNDSUk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKTtyZXR1cm4gYX0scmVhZFVuaWNvZGU6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKXt2YXIgbz1yW2UrK108PDh8cltlKytdO2ErPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7fXJldHVybiBhfSxfdGRlYzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuVGV4dERlY29kZXI/bmV3IHdpbmRvdy5UZXh0RGVjb2RlcjpudWxsLHJlYWRVVEY4OmZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4uX3RkZWM7cmV0dXJuIG4mJjA9PXQmJmE9PXIubGVuZ3RoP24uZGVjb2RlKHIpOmUuX2Jpbi5yZWFkQVNDSUkocix0LGEpfSxyZWFkQnl0ZXM6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2gocltlK25dKTtyZXR1cm4gYX0scmVhZEFTQ0lJQXJyYXk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyW2Urbl0pKTtyZXR1cm4gYX0sX3ZpZXc6ZnVuY3Rpb24ocil7cmV0dXJuIHIuX2RhdGFWaWV3fHwoci5fZGF0YVZpZXc9ci5idWZmZXI/bmV3IERhdGFWaWV3KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpOm5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheShyKS5idWZmZXIpKX19LGUuX2xjdGY9e30sZS5fbGN0Zi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuLG8pe3ZhciBzPWUuX2JpbixpPXt9LGg9dDtzLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIGQ9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1zLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PXMucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLGkuc2NyaXB0TGlzdD1lLl9sY3RmLnJlYWRTY3JpcHRMaXN0KHIsaCtkKSxpLmZlYXR1cmVMaXN0PWUuX2xjdGYucmVhZEZlYXR1cmVMaXN0KHIsaCtmKSxpLmxvb2t1cExpc3Q9ZS5fbGN0Zi5yZWFkTG9va3VwTGlzdChyLGgrdSxvKSxpfSxlLl9sY3RmLnJlYWRMb29rdXBMaXN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9W10saT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9ZS5fbGN0Zi5yZWFkTG9va3VwVGFibGUocixvK2QsYSk7cy5wdXNoKGYpO31yZXR1cm4gc30sZS5fbGN0Zi5yZWFkTG9va3VwVGFibGU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXQscz17dGFiczpbXX07cy5sdHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLHMuZmxhZz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXMubHR5cGUsZD0wO2Q8aTtkKyspe3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9YShyLGgsbytmLHMpO3MudGFicy5wdXNoKHUpO31yZXR1cm4gc30sZS5fbGN0Zi5udW1PZk9uZXM9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPTAsdD0wO3Q8MzI7dCsrKTAhPShyPj4+dCYxKSYmZSsrO3JldHVybiBlfSxlLl9sY3RmLnJlYWRDbGFzc0RlZj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89YS5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1vKXt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyluLnB1c2gocytoKSxuLnB1c2gocytoKSxuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7fWlmKDI9PW8pe3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGg9MDtoPGQ7aCsrKW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MixuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31yZXR1cm4gbn0sZS5fbGN0Zi5nZXRJbnRlcnZhbD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9Myl7dmFyIGE9clt0XSxuPXJbdCsxXTtpZihyW3QrMl0sYTw9ZSYmZTw9bilyZXR1cm4gdH1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZENvdmVyYWdlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MiwxPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LG8pKSwyPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LDMqbykpLG59LGUuX2xjdGYuY292ZXJhZ2VJbmRleD1mdW5jdGlvbihyLHQpe3ZhciBhPXIudGFiO2lmKDE9PXIuZm10KXJldHVybiBhLmluZGV4T2YodCk7aWYoMj09ci5mbXQpe3ZhciBuPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoYSx0KTtpZigtMSE9bilyZXR1cm4gYVtuKzJdKyh0LWFbbl0pfXJldHVybiAtMX0sZS5fbGN0Zi5yZWFkRmVhdHVyZUxpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9ZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlKHIsbitkKTtmLnRhZz1oLnRyaW0oKSxvLnB1c2goZik7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRGZWF0dXJlVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZmVhdHVyZVBhcmFtcz1uK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby50YWI9W107Zm9yKHZhciBoPTA7aDxpO2grKylvLnRhYi5wdXNoKGEucmVhZFVzaG9ydChyLHQrMipoKSk7cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdExpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1toLnRyaW0oKV09ZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGUocixuK2QpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZGVmYXVsdD1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK3MpKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBkPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1tkLnRyaW0oKV09ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitmKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZExhbmdTeXNUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O2EucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZXFGZWF0dXJlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5mZWF0dXJlcz1hLnJlYWRVc2hvcnRzKHIsdCxvKSxufSxlLkNGRj17fSxlLkNGRi5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluOyhyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSkpW3Q9MF0sclsrK3RdLHJbKyt0XSxyWysrdF0sdCsrO3ZhciBvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTtmb3IodmFyIHM9W10saT0wO2k8by5sZW5ndGgtMTtpKyspcy5wdXNoKG4ucmVhZEFTQ0lJKHIsdCtvW2ldLG9baSsxXS1vW2ldKSk7dCs9b1tvLmxlbmd0aC0xXTt2YXIgaD1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsaCk7dmFyIGQ9W107Zm9yKGk9MDtpPGgubGVuZ3RoLTE7aSsrKWQucHVzaChlLkNGRi5yZWFkRGljdChyLHQraFtpXSx0K2hbaSsxXSkpO3QrPWhbaC5sZW5ndGgtMV07dmFyIGY9ZFswXSx1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgbD1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspbC5wdXNoKG4ucmVhZEFTQ0lJKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7aWYodCs9dVt1Lmxlbmd0aC0xXSxlLkNGRi5yZWFkU3VicnMocix0LGYpLGYuQ2hhclN0cmluZ3Mpe3Q9Zi5DaGFyU3RyaW5nczt1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgdj1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspdi5wdXNoKG4ucmVhZEJ5dGVzKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7Zi5DaGFyU3RyaW5ncz12O31pZihmLlJPUyl7dD1mLkZEQXJyYXk7dmFyIGM9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGMpLGYuRkRBcnJheT1bXTtmb3IoaT0wO2k8Yy5sZW5ndGgtMTtpKyspe3ZhciBwPWUuQ0ZGLnJlYWREaWN0KHIsdCtjW2ldLHQrY1tpKzFdKTtlLkNGRi5fcmVhZEZEaWN0KHIscCxsKSxmLkZEQXJyYXkucHVzaChwKTt9dCs9Y1tjLmxlbmd0aC0xXSx0PWYuRkRTZWxlY3QsZi5GRFNlbGVjdD1bXTt2YXIgVT1yW3RdO2lmKHQrKywzIT1VKXRocm93IFU7dmFyIGc9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IoaT0wO2k8ZysxO2krKylmLkZEU2VsZWN0LnB1c2gobi5yZWFkVXNob3J0KHIsdCksclt0KzJdKSx0Kz0zO31yZXR1cm4gZi5FbmNvZGluZyYmKGYuRW5jb2Rpbmc9ZS5DRkYucmVhZEVuY29kaW5nKHIsZi5FbmNvZGluZyxmLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGYuY2hhcnNldCYmKGYuY2hhcnNldD1lLkNGRi5yZWFkQ2hhcnNldChyLGYuY2hhcnNldCxmLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGUuQ0ZGLl9yZWFkRkRpY3QocixmLGwpLGZ9LGUuQ0ZGLl9yZWFkRkRpY3Q9ZnVuY3Rpb24ocix0LGEpe3ZhciBuO2Zvcih2YXIgbyBpbiB0LlByaXZhdGUmJihuPXQuUHJpdmF0ZVsxXSx0LlByaXZhdGU9ZS5DRkYucmVhZERpY3QocixuLG4rdC5Qcml2YXRlWzBdKSx0LlByaXZhdGUuU3VicnMmJmUuQ0ZGLnJlYWRTdWJycyhyLG4rdC5Qcml2YXRlLlN1YnJzLHQuUHJpdmF0ZSkpLHQpLTEhPVtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihvKSYmKHRbb109YVt0W29dLTQyNiszNV0pO30sZS5DRkYucmVhZFN1YnJzPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7dmFyIHMsaT1vLmxlbmd0aDtzPWk8MTI0MD8xMDc6aTwzMzkwMD8xMTMxOjMyNzY4LGEuQmlhcz1zLGEuU3VicnM9W107Zm9yKHZhciBoPTA7aDxvLmxlbmd0aC0xO2grKylhLlN1YnJzLnB1c2gobi5yZWFkQnl0ZXMocix0K29baF0sb1toKzFdLW9baF0pKTt9LGUuQ0ZGLnRhYmxlU0U9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMCwxMTEsMTEyLDExMywxMTQsMCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDAsMTIzLDAsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwwLDEzMiwxMzMsMCwxMzQsMTM1LDEzNiwxMzcsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMzgsMCwxMzksMCwwLDAsMCwxNDAsMTQxLDE0MiwxNDMsMCwwLDAsMCwwLDE0NCwwLDAsMCwxNDUsMCwwLDE0NiwxNDcsMTQ4LDE0OSwwLDAsMCwwXSxlLkNGRi5nbHlwaEJ5VW5pY29kZT1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5jaGFyc2V0Lmxlbmd0aDt0KyspaWYoci5jaGFyc2V0W3RdPT1lKXJldHVybiB0O3JldHVybiAtMX0sZS5DRkYuZ2x5cGhCeVNFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQ8MHx8dD4yNTU/LTE6ZS5DRkYuZ2x5cGhCeVVuaWNvZGUocixlLkNGRi50YWJsZVNFW3RdKX0sZS5DRkYucmVhZEVuY29kaW5nPWZ1bmN0aW9uKHIsdCxhKXtlLl9iaW47dmFyIG49W1wiLm5vdGRlZlwiXSxvPXJbdF07aWYodCsrLDAhPW8pdGhyb3cgXCJlcnJvcjogdW5rbm93biBlbmNvZGluZyBmb3JtYXQ6IFwiK287dmFyIHM9clt0XTt0Kys7Zm9yKHZhciBpPTA7aTxzO2krKyluLnB1c2goclt0K2ldKTtyZXR1cm4gbn0sZS5DRkYucmVhZENoYXJzZXQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtcIi5ub3RkZWZcIl0scz1yW3RdO2lmKHQrKywwPT1zKWZvcih2YXIgaT0wO2k8YTtpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGgpO31lbHNlIHtpZigxIT1zJiYyIT1zKXRocm93IFwiZXJyb3I6IGZvcm1hdDogXCIrcztmb3IoO28ubGVuZ3RoPGE7KXtoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9MDsxPT1zPyhkPXJbdF0sdCsrKTooZD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKTtmb3IoaT0wO2k8PWQ7aSsrKW8ucHVzaChoKSxoKys7fX1yZXR1cm4gb30sZS5DRkYucmVhZEluZGV4PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocix0KSsxLHM9clt0Kz0yXTtpZih0KyssMT09cylmb3IodmFyIGk9MDtpPG87aSsrKWEucHVzaChyW3QraV0pO2Vsc2UgaWYoMj09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKG4ucmVhZFVzaG9ydChyLHQrMippKSk7ZWxzZSBpZigzPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2goMTY3NzcyMTUmbi5yZWFkVWludChyLHQrMyppLTEpKTtlbHNlIGlmKDEhPW8pdGhyb3cgXCJ1bnN1cHBvcnRlZCBvZmZzZXQgc2l6ZTogXCIrcytcIiwgY291bnQ6IFwiK287cmV0dXJuICh0Kz1vKnMpLTF9LGUuQ0ZGLmdldENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXJbdF0scz1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGk9MSxoPW51bGwsZD1udWxsO288PTIwJiYoaD1vLGk9MSksMTI9PW8mJihoPTEwMCpvK3MsaT0yKSwyMTw9byYmbzw9MjcmJihoPW8saT0xKSwyOD09byYmKGQ9bi5yZWFkU2hvcnQocix0KzEpLGk9MyksMjk8PW8mJm88PTMxJiYoaD1vLGk9MSksMzI8PW8mJm88PTI0NiYmKGQ9by0xMzksaT0xKSwyNDc8PW8mJm88PTI1MCYmKGQ9MjU2KihvLTI0NykrcysxMDgsaT0yKSwyNTE8PW8mJm88PTI1NCYmKGQ9MjU2Ki0oby0yNTEpLXMtMTA4LGk9MiksMjU1PT1vJiYoZD1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGk9NSksYS52YWw9bnVsbCE9ZD9kOlwib1wiK2gsYS5zaXplPWk7fSxlLkNGRi5yZWFkQ2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXQrYSxvPWUuX2JpbixzPVtdO3Q8bjspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGQ9MSxmPW51bGwsdT1udWxsO2k8PTIwJiYoZj1pLGQ9MSksMTI9PWkmJihmPTEwMCppK2gsZD0yKSwxOSE9aSYmMjAhPWl8fChmPWksZD0yKSwyMTw9aSYmaTw9MjcmJihmPWksZD0xKSwyOD09aSYmKHU9by5yZWFkU2hvcnQocix0KzEpLGQ9MyksMjk8PWkmJmk8PTMxJiYoZj1pLGQ9MSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZD0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZD0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGQ9MiksMjU1PT1pJiYodT1vLnJlYWRJbnQocix0KzEpLzY1NTM1LGQ9NSkscy5wdXNoKG51bGwhPXU/dTpcIm9cIitmKSx0Kz1kO31yZXR1cm4gc30sZS5DRkYucmVhZERpY3Q9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz17fSxzPVtdO3Q8YTspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGQ9MSxmPW51bGwsdT1udWxsO2lmKDI4PT1pJiYodT1uLnJlYWRTaG9ydChyLHQrMSksZD0zKSwyOT09aSYmKHU9bi5yZWFkSW50KHIsdCsxKSxkPTUpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGQ9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGQ9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxkPTIpLDI1NT09aSl0aHJvdyB1PW4ucmVhZEludChyLHQrMSkvNjU1MzUsZD01LFwidW5rbm93biBudW1iZXJcIjtpZigzMD09aSl7dmFyIGw9W107Zm9yKGQ9MTs7KXt2YXIgdj1yW3QrZF07ZCsrO3ZhciBjPXY+PjQscD0xNSZ2O2lmKDE1IT1jJiZsLnB1c2goYyksMTUhPXAmJmwucHVzaChwKSwxNT09cClicmVha31mb3IodmFyIFU9XCJcIixnPVswLDEsMiwzLDQsNSw2LDcsOCw5LFwiLlwiLFwiZVwiLFwiZS1cIixcInJlc2VydmVkXCIsXCItXCIsXCJlbmRPZk51bWJlclwiXSxTPTA7UzxsLmxlbmd0aDtTKyspVSs9Z1tsW1NdXTt1PXBhcnNlRmxvYXQoVSk7fWlmKGk8PTIxKWlmKGY9W1widmVyc2lvblwiLFwiTm90aWNlXCIsXCJGdWxsTmFtZVwiLFwiRmFtaWx5TmFtZVwiLFwiV2VpZ2h0XCIsXCJGb250QkJveFwiLFwiQmx1ZVZhbHVlc1wiLFwiT3RoZXJCbHVlc1wiLFwiRmFtaWx5Qmx1ZXNcIixcIkZhbWlseU90aGVyQmx1ZXNcIixcIlN0ZEhXXCIsXCJTdGRWV1wiLFwiZXNjYXBlXCIsXCJVbmlxdWVJRFwiLFwiWFVJRFwiLFwiY2hhcnNldFwiLFwiRW5jb2RpbmdcIixcIkNoYXJTdHJpbmdzXCIsXCJQcml2YXRlXCIsXCJTdWJyc1wiLFwiZGVmYXVsdFdpZHRoWFwiLFwibm9taW5hbFdpZHRoWFwiXVtpXSxkPTEsMTI9PWkpZj1bXCJDb3B5cmlnaHRcIixcImlzRml4ZWRQaXRjaFwiLFwiSXRhbGljQW5nbGVcIixcIlVuZGVybGluZVBvc2l0aW9uXCIsXCJVbmRlcmxpbmVUaGlja25lc3NcIixcIlBhaW50VHlwZVwiLFwiQ2hhcnN0cmluZ1R5cGVcIixcIkZvbnRNYXRyaXhcIixcIlN0cm9rZVdpZHRoXCIsXCJCbHVlU2NhbGVcIixcIkJsdWVTaGlmdFwiLFwiQmx1ZUZ1enpcIixcIlN0ZW1TbmFwSFwiLFwiU3RlbVNuYXBWXCIsXCJGb3JjZUJvbGRcIiwwLDAsXCJMYW5ndWFnZUdyb3VwXCIsXCJFeHBhbnNpb25GYWN0b3JcIixcImluaXRpYWxSYW5kb21TZWVkXCIsXCJTeW50aGV0aWNCYXNlXCIsXCJQb3N0U2NyaXB0XCIsXCJCYXNlRm9udE5hbWVcIixcIkJhc2VGb250QmxlbmRcIiwwLDAsMCwwLDAsMCxcIlJPU1wiLFwiQ0lERm9udFZlcnNpb25cIixcIkNJREZvbnRSZXZpc2lvblwiLFwiQ0lERm9udFR5cGVcIixcIkNJRENvdW50XCIsXCJVSURCYXNlXCIsXCJGREFycmF5XCIsXCJGRFNlbGVjdFwiLFwiRm9udE5hbWVcIl1baF0sZD0yO251bGwhPWY/KG9bZl09MT09cy5sZW5ndGg/c1swXTpzLHM9W10pOnMucHVzaCh1KSx0Kz1kO31yZXR1cm4gb30sZS5jbWFwPXt9LGUuY21hcC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7cj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpLHQ9MDt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGk9W107by50YWJsZXM9W107Zm9yKHZhciBoPTA7aDxzO2grKyl7dmFyIGQ9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PW4ucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPVwicFwiK2QrXCJlXCIrZix2PWkuaW5kZXhPZih1KTtpZigtMT09dil7dmFyIGM7dj1vLnRhYmxlcy5sZW5ndGgsaS5wdXNoKHUpO3ZhciBwPW4ucmVhZFVzaG9ydChyLHUpOzA9PXA/Yz1lLmNtYXAucGFyc2UwKHIsdSk6ND09cD9jPWUuY21hcC5wYXJzZTQocix1KTo2PT1wP2M9ZS5jbWFwLnBhcnNlNihyLHUpOjEyPT1wP2M9ZS5jbWFwLnBhcnNlMTIocix1KTpjb25zb2xlLmRlYnVnKFwidW5rbm93biBmb3JtYXQ6IFwiK3AsZCxmLHUpLG8udGFibGVzLnB1c2goYyk7fWlmKG51bGwhPW9bbF0pdGhyb3cgXCJtdWx0aXBsZSB0YWJsZXMgZm9yIG9uZSBwbGF0Zm9ybStlbmNvZGluZ1wiO29bbF09djt9cmV0dXJuIG99LGUuY21hcC5wYXJzZTA9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLm1hcD1bXTtmb3IodmFyIHM9MDtzPG8tNjtzKyspbi5tYXAucHVzaChyW3Qrc10pO3JldHVybiBufSxlLmNtYXAucGFyc2U0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9O28uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGg9aS8yO28uc2VhcmNoUmFuZ2U9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVudHJ5U2VsZWN0b3I9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLnJhbmdlU2hpZnQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVuZENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCx0Kz0yLG8uc3RhcnRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5pZERlbHRhPVtdO2Zvcih2YXIgZD0wO2Q8aDtkKyspby5pZERlbHRhLnB1c2goYS5yZWFkU2hvcnQocix0KSksdCs9Mjtmb3Ioby5pZFJhbmdlT2Zmc2V0PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmdseXBoSWRBcnJheT1bXTt0PG4rczspby5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gb30sZS5jbWFwLnBhcnNlNj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4uZmlyc3RDb2RlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixuLmdseXBoSWRBcnJheT1bXTtmb3IodmFyIHM9MDtzPG87cysrKW4uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuY21hcC5wYXJzZTEyPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mix0Kz0yLGEucmVhZFVpbnQocix0KSx0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVpbnQocix0KTt0Kz00LG4uZ3JvdXBzPVtdO2Zvcih2YXIgcz0wO3M8bztzKyspe3ZhciBpPXQrMTIqcyxoPWEucmVhZFVpbnQocixpKzApLGQ9YS5yZWFkVWludChyLGkrNCksZj1hLnJlYWRVaW50KHIsaSs4KTtuLmdyb3Vwcy5wdXNoKFtoLGQsZl0pO31yZXR1cm4gbn0sZS5nbHlmPXt9LGUuZ2x5Zi5wYXJzZT1mdW5jdGlvbihyLGUsdCxhKXtmb3IodmFyIG49W10sbz0wO288YS5tYXhwLm51bUdseXBocztvKyspbi5wdXNoKG51bGwpO3JldHVybiBufSxlLmdseWYuX3BhcnNlR2x5Zj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXIuX2RhdGEsbz1lLl90YWJPZmZzZXQobixcImdseWZcIixyLl9vZmZzZXQpK3IubG9jYVt0XTtpZihyLmxvY2FbdF09PXIubG9jYVt0KzFdKXJldHVybiBudWxsO3ZhciBzPXt9O2lmKHMubm9jPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj49cy54TWF4fHxzLnlNaW4+PXMueU1heClyZXR1cm4gbnVsbDtpZihzLm5vYz4wKXtzLmVuZFB0cz1bXTtmb3IodmFyIGk9MDtpPHMubm9jO2krKylzLmVuZFB0cy5wdXNoKGEucmVhZFVzaG9ydChuLG8pKSxvKz0yO3ZhciBoPWEucmVhZFVzaG9ydChuLG8pO2lmKG8rPTIsbi5sZW5ndGgtbzxoKXJldHVybiBudWxsO3MuaW5zdHJ1Y3Rpb25zPWEucmVhZEJ5dGVzKG4sbyxoKSxvKz1oO3ZhciBkPXMuZW5kUHRzW3Mubm9jLTFdKzE7cy5mbGFncz1bXTtmb3IoaT0wO2k8ZDtpKyspe3ZhciBmPW5bb107aWYobysrLHMuZmxhZ3MucHVzaChmKSwwIT0oOCZmKSl7dmFyIHU9bltvXTtvKys7Zm9yKHZhciBsPTA7bDx1O2wrKylzLmZsYWdzLnB1c2goZiksaSsrO319cy54cz1bXTtmb3IoaT0wO2k8ZDtpKyspe3ZhciB2PTAhPSgyJnMuZmxhZ3NbaV0pLGM9MCE9KDE2JnMuZmxhZ3NbaV0pO3Y/KHMueHMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnhzLnB1c2goMCk6KHMueHMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9cy55cz1bXTtmb3IoaT0wO2k8ZDtpKyspe3Y9MCE9KDQmcy5mbGFnc1tpXSksYz0wIT0oMzImcy5mbGFnc1tpXSk7dj8ocy55cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueXMucHVzaCgwKToocy55cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO312YXIgcD0wLFU9MDtmb3IoaT0wO2k8ZDtpKyspcCs9cy54c1tpXSxVKz1zLnlzW2ldLHMueHNbaV09cCxzLnlzW2ldPVU7fWVsc2Uge3ZhciBnO3MucGFydHM9W107ZG97Zz1hLnJlYWRVc2hvcnQobixvKSxvKz0yO3ZhciBTPXttOnthOjEsYjowLGM6MCxkOjEsdHg6MCx0eTowfSxwMTotMSxwMjotMX07aWYocy5wYXJ0cy5wdXNoKFMpLFMuZ2x5cGhJbmRleD1hLnJlYWRVc2hvcnQobixvKSxvKz0yLDEmZyl7dmFyIG09YS5yZWFkU2hvcnQobixvKTtvKz0yO3ZhciBiPWEucmVhZFNob3J0KG4sbyk7bys9Mjt9ZWxzZSB7bT1hLnJlYWRJbnQ4KG4sbyk7bysrO2I9YS5yZWFkSW50OChuLG8pO28rKzt9MiZnPyhTLm0udHg9bSxTLm0udHk9Yik6KFMucDE9bSxTLnAyPWIpLDgmZz8oUy5tLmE9Uy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjY0Jmc/KFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKToxMjgmZyYmKFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5iPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5jPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTt9d2hpbGUoMzImZyk7aWYoMjU2Jmcpe3ZhciB5PWEucmVhZFVzaG9ydChuLG8pO28rPTIscy5pbnN0cj1bXTtmb3IoaT0wO2k8eTtpKyspcy5pbnN0ci5wdXNoKG5bb10pLG8rKzt9fXJldHVybiBzfSxlLkdERUY9e30sZS5HREVGLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPXQ7dCs9NDt2YXIgcz1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3JldHVybiB7Z2x5cGhDbGFzc0RlZjowPT09cz9udWxsOmUuX2xjdGYucmVhZENsYXNzRGVmKHIsbytzKX19LGUuR1BPUz17fSxlLkdQT1MucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdQT1Muc3VidCl9LGUuR1BPUy5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDE9PXR8fDI9PXR8fDM9PXR8fDc9PXR8fDg9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixoK3MpO31pZigxPT10JiYxPT1pLmZtdCl7dmFyIGQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MiwwIT1kJiYoaS5wb3M9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZCkpO31lbHNlIGlmKDI9PXQmJmkuZm10Pj0xJiZpLmZtdDw9Mil7ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHU9ZS5fbGN0Zi5udW1PZk9uZXMoZCksbD1lLl9sY3RmLm51bU9mT25lcyhmKTtpZigxPT1pLmZtdCl7aS5wYWlyc2V0cz1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgYz0wO2M8djtjKyspe3ZhciBwPXMrby5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgVT1vLnJlYWRVc2hvcnQocixwKTtwKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxVO1MrKyl7dmFyIG09by5yZWFkVXNob3J0KHIscCk7cCs9MiwwIT1kJiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxkKSxwKz0yKnUpLDAhPWYmJih4PWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixwLGYpLHArPTIqbCksZy5wdXNoKHtnaWQyOm0sdmFsMTpQLHZhbDI6eH0pO31pLnBhaXJzZXRzLnB1c2goZyk7fX1pZigyPT1pLmZtdCl7dmFyIGI9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgeT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBGPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIEM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNsYXNzRGVmMT1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrYiksaS5jbGFzc0RlZjI9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK3kpLGkubWF0cml4PVtdO2ZvcihjPTA7YzxGO2MrKyl7dmFyIF89W107Zm9yKFM9MDtTPEM7UysrKXt2YXIgUD1udWxsLHg9bnVsbDswIT1kJiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxkKSxhKz0yKnUpLDAhPWYmJih4PWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGYpLGErPTIqbCksXy5wdXNoKHt2YWwxOlAsdmFsMjp4fSk7fWkubWF0cml4LnB1c2goXyk7fX19ZWxzZSBpZig0PT10JiYxPT1pLmZtdClpLm1hcmtDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGEpK3MpLGkuYmFzZUNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSsyKStzKSxpLm1hcmtDbGFzc0NvdW50PW8ucmVhZFVzaG9ydChyLGErNCksaS5tYXJrQXJyYXk9ZS5HUE9TLnJlYWRNYXJrQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzYpK3MpLGkuYmFzZUFycmF5PWUuR1BPUy5yZWFkQmFzZUFycmF5KHIsby5yZWFkVXNob3J0KHIsYSs4KStzLGkubWFya0NsYXNzQ291bnQpO2Vsc2UgaWYoNj09dCYmMT09aS5mbXQpaS5tYXJrMUNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSkrcyksaS5tYXJrMkNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSsyKStzKSxpLm1hcmtDbGFzc0NvdW50PW8ucmVhZFVzaG9ydChyLGErNCksaS5tYXJrMUFycmF5PWUuR1BPUy5yZWFkTWFya0FycmF5KHIsby5yZWFkVXNob3J0KHIsYSs2KStzKSxpLm1hcmsyQXJyYXk9ZS5HUE9TLnJlYWRCYXNlQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzgpK3MsaS5tYXJrQ2xhc3NDb3VudCk7ZWxzZSB7aWYoOT09dCYmMT09aS5mbXQpe3ZhciBJPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHc9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPUk7ZWxzZSBpZihuLmx0eXBlIT1JKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1BPUy5zdWJ0KHIsbi5sdHlwZSxzK3cpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHUE9TIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HUE9TLnJlYWRWYWx1ZVJlY29yZD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107cmV0dXJuIG8ucHVzaCgxJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0xJmE/MjowLG8ucHVzaCgyJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0yJmE/MjowLG8ucHVzaCg0JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz00JmE/MjowLG8ucHVzaCg4JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz04JmE/MjowLG99LGUuR1BPUy5yZWFkQmFzZUFycmF5PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXSxzPXQsaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe2Zvcih2YXIgZD1bXSxmPTA7ZjxhO2YrKylkLnB1c2goZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQocixzK24ucmVhZFVzaG9ydChyLHQpKSksdCs9MjtvLnB1c2goZCk7fXJldHVybiBvfSxlLkdQT1MucmVhZE1hcmtBcnJheT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89dCxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9ZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQocixhLnJlYWRVc2hvcnQocix0KzIpK28pO2gubWFya0NsYXNzPWEucmVhZFVzaG9ydChyLHQpLG4ucHVzaChoKSx0Kz00O31yZXR1cm4gbn0sZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtyZXR1cm4gbi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksbi54PWEucmVhZFNob3J0KHIsdCsyKSxuLnk9YS5yZWFkU2hvcnQocix0KzQpLG59LGUuR1NVQj17fSxlLkdTVUIucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdTVUIuc3VidCl9LGUuR1NVQi5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDEhPXQmJjIhPXQmJjQhPXQmJjUhPXQmJjYhPXQpcmV0dXJuIG51bGw7aWYoMT09dHx8Mj09dHx8ND09dHx8NT09dCYmaS5mbXQ8PTJ8fDY9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK2gpO31pZigxPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2lmKDE9PWkuZm10KWkuZGVsdGE9by5yZWFkU2hvcnQocixhKSxhKz0yO2Vsc2UgaWYoMj09aS5mbXQpe3ZhciBkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5uZXdnPW8ucmVhZFVzaG9ydHMocixhLGQpLGErPTIqaS5uZXdnLmxlbmd0aDt9fWVsc2UgaWYoMj09dCYmMT09aS5mbXQpe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnNlcXM9W107Zm9yKHZhciBmPTA7ZjxkO2YrKyl7dmFyIHU9by5yZWFkVXNob3J0KHIsYSkrczthKz0yO3ZhciBsPW8ucmVhZFVzaG9ydChyLHUpO2kuc2Vxcy5wdXNoKG8ucmVhZFVzaG9ydHMocix1KzIsbCkpO319ZWxzZSBpZig0PT10KXtpLnZhbHM9W107ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO2ZvcihmPTA7ZjxkO2YrKyl7dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnZhbHMucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlU2V0KHIscyt2KSk7fX1lbHNlIGlmKDU9PXQmJjI9PWkuZm10KXtpZigyPT1pLmZtdCl7dmFyIGM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNEZWY9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2MpLGkuc2NzZXQ9W107dmFyIHA9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZj0wO2Y8cDtmKyspe3ZhciBVPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zY3NldC5wdXNoKDA9PVU/bnVsbDplLkdTVUIucmVhZFN1YkNsYXNzU2V0KHIscytVKSk7fX19ZWxzZSBpZig2PT10JiYzPT1pLmZtdCl7aWYoMz09aS5mbXQpe2ZvcihmPTA7ZjwzO2YrKyl7ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxkO1MrKylnLnB1c2goZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK28ucmVhZFVzaG9ydChyLGErMipTKSkpO2ErPTIqZCwwPT1mJiYoaS5iYWNrQ3ZnPWcpLDE9PWYmJihpLmlucHRDdmc9ZyksMj09ZiYmKGkuYWhlZEN2Zz1nKTt9ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubG9va3VwUmVjPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsYSxkKTt9fWVsc2Uge2lmKDc9PXQmJjE9PWkuZm10KXt2YXIgbT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBiPW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1tO2Vsc2UgaWYobi5sdHlwZSE9bSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdTVUIuc3VidChyLG4ubHR5cGUscytiKX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXQsbz1bXSxzPWEocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZFN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXt9LG89YShyLHQpLHM9YShyLHQrPTIpO3QrPTIsbi5pbnB1dD1bXTtmb3IodmFyIGk9MDtpPG8tMTtpKyspbi5pbnB1dC5wdXNoKGEocix0KSksdCs9MjtyZXR1cm4gbi5zdWJzdExvb2t1cFJlY29yZHM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocix0LHMpLG59LGUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLnJlYWRVc2hvcnQsbz1bXSxzPTA7czxhO3MrKylvLnB1c2gobihyLHQpLG4ocix0KzIpKSx0Kz00O3JldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9ZS5fYmluLG49e30sbz1bXCJiYWNrdHJhY2tcIixcImlucHV0XCIsXCJsb29rYWhlYWRcIl0scz0wO3M8by5sZW5ndGg7cysrKXt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLDE9PXMmJmktLSxuW29bc11dPWEucmVhZFVzaG9ydHMocix0LGkpLHQrPTIqbltvW3NdXS5sZW5ndGg7fWk9YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5zdWJzdD1hLnJlYWRVc2hvcnRzKHIsdCwyKmkpLHQrPTIqbi5zdWJzdC5sZW5ndGgsbn0sZS5HU1VCLnJlYWRMaWdhdHVyZVNldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRMaWdhdHVyZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXtjaGFpbjpbXX07bi5uZ2x5cGg9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgcz0wO3M8by0xO3MrKyluLmNoYWluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuaGVhZD17fSxlLmhlYWQucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5mb250UmV2aXNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG8uZmxhZ3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLnVuaXRzUGVyRW09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmNyZWF0ZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLm1vZGlmaWVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby54TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1hY1N0eWxlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5sb3dlc3RSZWNQUEVNPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5mb250RGlyZWN0aW9uSGludD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5pbmRleFRvTG9jRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmdseXBoRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sZS5oaGVhPXt9LGUuaGhlYS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmFzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmRlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5saW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmFkdmFuY2VXaWR0aE1heD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWluTGVmdFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1pblJpZ2h0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heEV4dGVudD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUmlzZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUnVuPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0T2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9Mix0Kz04LG8ubWV0cmljRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5udW1iZXJPZkhNZXRyaWNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsb30sZS5obXR4PXt9LGUuaG10eC5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ZS5fYmluLHM9e2FXaWR0aDpbXSxsc0JlYXJpbmc6W119LGk9MCxoPTAsZD0wO2Q8bi5tYXhwLm51bUdseXBocztkKyspZDxuLmhoZWEubnVtYmVyT2ZITWV0cmljcyYmKGk9by5yZWFkVXNob3J0KHIsdCksdCs9MixoPW8ucmVhZFNob3J0KHIsdCksdCs9Mikscy5hV2lkdGgucHVzaChpKSxzLmxzQmVhcmluZy5wdXNoKGgpO3JldHVybiBzfSxlLmtlcm49e30sZS5rZXJuLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPW8ucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09cylyZXR1cm4gZS5rZXJuLnBhcnNlVjEocix0LTIsYSxuKTt2YXIgaT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD17Z2x5cGgxOltdLHJ2YWw6W119LGQ9MDtkPGk7ZCsrKXt0Kz0yO2E9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWY+Pj44O2lmKDAhPSh1Jj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIit1O3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxoKTt9cmV0dXJuIGh9LGUua2Vybi5wYXJzZVYxPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbjtvLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIHM9by5yZWFkVWludChyLHQpO3QrPTQ7Zm9yKHZhciBpPXtnbHlwaDE6W10scnZhbDpbXX0saD0wO2g8cztoKyspe28ucmVhZFVpbnQocix0KSx0Kz00O3ZhciBkPW8ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgZj1kPj4+ODtpZigwIT0oZiY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrZjt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaSk7fXJldHVybiBpfSxlLmtlcm4ucmVhZEZvcm1hdDA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPS0xLHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkU2hvcnQocix0KTt0Kz0yLGghPW8mJihhLmdseXBoMS5wdXNoKGgpLGEucnZhbC5wdXNoKHtnbHlwaDI6W10sdmFsczpbXX0pKTt2YXIgdT1hLnJ2YWxbYS5ydmFsLmxlbmd0aC0xXTt1LmdseXBoMi5wdXNoKGQpLHUudmFscy5wdXNoKGYpLG89aDt9cmV0dXJuIHR9LGUubG9jYT17fSxlLmxvY2EucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9W10saT1uLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdCxoPW4ubWF4cC5udW1HbHlwaHMrMTtpZigwPT1pKWZvcih2YXIgZD0wO2Q8aDtkKyspcy5wdXNoKG8ucmVhZFVzaG9ydChyLHQrKGQ8PDEpKTw8MSk7aWYoMT09aSlmb3IoZD0wO2Q8aDtkKyspcy5wdXNoKG8ucmVhZFVpbnQocix0KyhkPDwyKSkpO3JldHVybiBzfSxlLm1heHA9e30sZS5tYXhwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fSxzPW4ucmVhZFVpbnQocix0KTtyZXR1cm4gdCs9NCxvLm51bUdseXBocz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLDY1NTM2PT1zJiYoby5tYXhQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZUNvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhab25lcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4VHdpbGlnaHRQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0b3JhZ2U9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEZ1bmN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4SW5zdHJ1Y3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdGFja0VsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTaXplT2ZJbnN0cnVjdGlvbnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudEVsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnREZXB0aD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKSxvfSxlLm5hbWU9e30sZS5uYW1lLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCk7Zm9yKHZhciBpLGg9W1wiY29weXJpZ2h0XCIsXCJmb250RmFtaWx5XCIsXCJmb250U3ViZmFtaWx5XCIsXCJJRFwiLFwiZnVsbE5hbWVcIixcInZlcnNpb25cIixcInBvc3RTY3JpcHROYW1lXCIsXCJ0cmFkZW1hcmtcIixcIm1hbnVmYWN0dXJlclwiLFwiZGVzaWduZXJcIixcImRlc2NyaXB0aW9uXCIsXCJ1cmxWZW5kb3JcIixcInVybERlc2lnbmVyXCIsXCJsaWNlbmNlXCIsXCJsaWNlbmNlVVJMXCIsXCItLS1cIixcInR5cG9GYW1pbHlOYW1lXCIsXCJ0eXBvU3ViZmFtaWx5TmFtZVwiLFwiY29tcGF0aWJsZUZ1bGxcIixcInNhbXBsZVRleHRcIixcInBvc3RTY3JpcHRDSURcIixcInd3c0ZhbWlseU5hbWVcIixcInd3c1N1YmZhbWlseU5hbWVcIixcImxpZ2h0UGFsZXR0ZVwiLFwiZGFya1BhbGV0dGVcIl0sZD10Kz0yLGY9MDtmPHM7ZisrKXt2YXIgdT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBsPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgYz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBwPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIFU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZyxTPWhbY10sbT1kKzEyKnMrVTtpZigwPT11KWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PXUmJjA9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMD09bClnPW4ucmVhZEFTQ0lJKHIsbSxwKTtlbHNlIGlmKDE9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSB7aWYoMSE9dSl0aHJvdyBcInVua25vd24gZW5jb2RpbmcgXCIrbCtcIiwgcGxhdGZvcm1JRDogXCIrdTtnPW4ucmVhZEFTQ0lJKHIsbSxwKSxjb25zb2xlLmRlYnVnKFwicmVhZGluZyB1bmtub3duIE1BQyBlbmNvZGluZyBcIitsK1wiIGFzIEFTQ0lJXCIpO312YXIgYj1cInBcIit1K1wiLFwiK3YudG9TdHJpbmcoMTYpO251bGw9PW9bYl0mJihvW2JdPXt9KSxvW2JdW3ZvaWQgMCE9PVM/UzpjXT1nLG9bYl0uX2xhbmc9djt9Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMTAzMz09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYwPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjMwODQ9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSlyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbyl7aT15O2JyZWFrfXJldHVybiBjb25zb2xlLmRlYnVnKFwicmV0dXJuaW5nIG5hbWUgdGFibGUgd2l0aCBsYW5ndWFnZUlEIFwiK29baV0uX2xhbmcpLG9baV19LGVbXCJPUy8yXCJdPXt9LGVbXCJPUy8yXCJdLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIG89e307aWYoMD09billW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsbyk7ZWxzZSBpZigxPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxvKTtlbHNlIGlmKDI9PW58fDM9PW58fDQ9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LG8pO2Vsc2Uge2lmKDUhPW4pdGhyb3cgXCJ1bmtub3duIE9TLzIgdGFibGUgdmVyc2lvbjogXCIrbjtlW1wiT1MvMlwiXS52ZXJzaW9uNShyLHQsbyk7fXJldHVybiBvfSxlW1wiT1MvMlwiXS52ZXJzaW9uMD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiBhLnhBdmdDaGFyV2lkdGg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXZWlnaHRDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaWR0aENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5mc1R5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zRmFtaWx5Q2xhc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEucGFub3NlPW4ucmVhZEJ5dGVzKHIsdCwxMCksdCs9MTAsYS51bFVuaWNvZGVSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTM9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTQ9bi5yZWFkVWludChyLHQpLHQrPTQsYS5hY2hWZW5kSUQ9W24ucmVhZEludDgocix0KSxuLnJlYWRJbnQ4KHIsdCsxKSxuLnJlYWRJbnQ4KHIsdCsyKSxuLnJlYWRJbnQ4KHIsdCszKV0sdCs9NCxhLmZzU2VsZWN0aW9uPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0ZpcnN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0xhc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnNUeXBvQXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9EZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9MaW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2luQXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpbkRlc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjE9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsYSksYS51bENvZGVQYWdlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxDb2RlUGFnZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NH0sZVtcIk9TLzJcIl0udmVyc2lvbjI9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsYSksYS5zeEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zQ2FwSGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzRGVmYXVsdD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNCcmVhaz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNNYXhDb250ZXh0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb241PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LGEpLGEudXNMb3dlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzVXBwZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGUucG9zdD17fSxlLnBvc3QucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBvLnZlcnNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG8uaXRhbGljQW5nbGU9bi5yZWFkRml4ZWQocix0KSx0Kz00LG8udW5kZXJsaW5lUG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8udW5kZXJsaW5lVGhpY2tuZXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxudWxsPT1lJiYoZT17fSksbnVsbD09ZS5VJiYoZS5VPXt9KSxlLlUuY29kZVRvR2x5cGg9ZnVuY3Rpb24ocixlKXt2YXIgdD1yLmNtYXAsYT0tMTtpZihudWxsIT10LnAwZTQ/YT10LnAwZTQ6bnVsbCE9dC5wM2UxP2E9dC5wM2UxOm51bGwhPXQucDFlMD9hPXQucDFlMDpudWxsIT10LnAwZTMmJihhPXQucDBlMyksLTE9PWEpdGhyb3cgXCJubyBmYW1pbGlhciBwbGF0Zm9ybSBhbmQgZW5jb2RpbmchXCI7dmFyIG49dC50YWJsZXNbYV07aWYoMD09bi5mb3JtYXQpcmV0dXJuIGU+PW4ubWFwLmxlbmd0aD8wOm4ubWFwW2VdO2lmKDQ9PW4uZm9ybWF0KXtmb3IodmFyIG89LTEscz0wO3M8bi5lbmRDb3VudC5sZW5ndGg7cysrKWlmKGU8PW4uZW5kQ291bnRbc10pe289czticmVha31pZigtMT09bylyZXR1cm4gMDtpZihuLnN0YXJ0Q291bnRbb10+ZSlyZXR1cm4gMDtyZXR1cm4gNjU1MzUmKDAhPW4uaWRSYW5nZU9mZnNldFtvXT9uLmdseXBoSWRBcnJheVtlLW4uc3RhcnRDb3VudFtvXSsobi5pZFJhbmdlT2Zmc2V0W29dPj4xKS0obi5pZFJhbmdlT2Zmc2V0Lmxlbmd0aC1vKV06ZStuLmlkRGVsdGFbb10pfWlmKDEyPT1uLmZvcm1hdCl7aWYoZT5uLmdyb3Vwc1tuLmdyb3Vwcy5sZW5ndGgtMV1bMV0pcmV0dXJuIDA7Zm9yKHM9MDtzPG4uZ3JvdXBzLmxlbmd0aDtzKyspe3ZhciBpPW4uZ3JvdXBzW3NdO2lmKGlbMF08PWUmJmU8PWlbMV0pcmV0dXJuIGlbMl0rKGUtaVswXSl9cmV0dXJuIDB9dGhyb3cgXCJ1bmtub3duIGNtYXAgdGFibGUgZm9ybWF0IFwiK24uZm9ybWF0fSxlLlUuZ2x5cGhUb1BhdGg9ZnVuY3Rpb24ocix0KXt2YXIgYT17Y21kczpbXSxjcmRzOltdfTtpZihyLlNWRyYmci5TVkcuZW50cmllc1t0XSl7dmFyIG49ci5TVkcuZW50cmllc1t0XTtyZXR1cm4gbnVsbD09bj9hOihcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49ZS5TVkcudG9QYXRoKG4pLHIuU1ZHLmVudHJpZXNbdF09biksbil9aWYoci5DRkYpe3ZhciBvPXt4OjAseTowLHN0YWNrOltdLG5TdGVtczowLGhhdmVXaWR0aDohMSx3aWR0aDpyLkNGRi5Qcml2YXRlP3IuQ0ZGLlByaXZhdGUuZGVmYXVsdFdpZHRoWDowLG9wZW46ITF9LHM9ci5DRkYsaT1yLkNGRi5Qcml2YXRlO2lmKHMuUk9TKXtmb3IodmFyIGg9MDtzLkZEU2VsZWN0W2grMl08PXQ7KWgrPTI7aT1zLkZEQXJyYXlbcy5GRFNlbGVjdFtoKzFdXS5Qcml2YXRlO31lLlUuX2RyYXdDRkYoci5DRkYuQ2hhclN0cmluZ3NbdF0sbyxzLGksYSk7fWVsc2Ugci5nbHlmJiZlLlUuX2RyYXdHbHlmKHQscixhKTtyZXR1cm4gYX0sZS5VLl9kcmF3R2x5Zj1mdW5jdGlvbihyLHQsYSl7dmFyIG49dC5nbHlmW3JdO251bGw9PW4mJihuPXQuZ2x5ZltyXT1lLmdseWYuX3BhcnNlR2x5Zih0LHIpKSxudWxsIT1uJiYobi5ub2M+LTE/ZS5VLl9zaW1wbGVHbHlwaChuLGEpOmUuVS5fY29tcG9HbHlwaChuLHQsYSkpO30sZS5VLl9zaW1wbGVHbHlwaD1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT0wO2E8ci5ub2M7YSsrKXtmb3IodmFyIG49MD09YT8wOnIuZW5kUHRzW2EtMV0rMSxvPXIuZW5kUHRzW2FdLHM9bjtzPD1vO3MrKyl7dmFyIGk9cz09bj9vOnMtMSxoPXM9PW8/bjpzKzEsZD0xJnIuZmxhZ3Nbc10sZj0xJnIuZmxhZ3NbaV0sdT0xJnIuZmxhZ3NbaF0sbD1yLnhzW3NdLHY9ci55c1tzXTtpZihzPT1uKWlmKGQpe2lmKCFmKXtlLlUuUC5tb3ZlVG8odCxsLHYpO2NvbnRpbnVlfWUuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk7fWVsc2UgZj9lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pOmUuVS5QLm1vdmVUbyh0LChyLnhzW2ldK2wpLzIsKHIueXNbaV0rdikvMik7ZD9mJiZlLlUuUC5saW5lVG8odCxsLHYpOnU/ZS5VLlAucWN1cnZlVG8odCxsLHYsci54c1toXSxyLnlzW2hdKTplLlUuUC5xY3VydmVUbyh0LGwsdiwobCtyLnhzW2hdKS8yLCh2K3IueXNbaF0pLzIpO31lLlUuUC5jbG9zZVBhdGgodCk7fX0sZS5VLl9jb21wb0dseXBoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHIucGFydHMubGVuZ3RoO24rKyl7dmFyIG89e2NtZHM6W10sY3JkczpbXX0scz1yLnBhcnRzW25dO2UuVS5fZHJhd0dseWYocy5nbHlwaEluZGV4LHQsbyk7Zm9yKHZhciBpPXMubSxoPTA7aDxvLmNyZHMubGVuZ3RoO2grPTIpe3ZhciBkPW8uY3Jkc1toXSxmPW8uY3Jkc1toKzFdO2EuY3Jkcy5wdXNoKGQqaS5hK2YqaS5iK2kudHgpLGEuY3Jkcy5wdXNoKGQqaS5jK2YqaS5kK2kudHkpO31mb3IoaD0wO2g8by5jbWRzLmxlbmd0aDtoKyspYS5jbWRzLnB1c2goby5jbWRzW2hdKTt9fSxlLlUuX2dldEdseXBoQ2xhc3M9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9sY3RmLmdldEludGVydmFsKHQscik7cmV0dXJuIC0xPT1hPzA6dFthKzJdfSxlLlUuX2FwcGx5U3Vicz1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ci5sZW5ndGgtdC0xLHM9MDtzPGEudGFicy5sZW5ndGg7cysrKWlmKG51bGwhPWEudGFic1tzXSl7dmFyIGksaD1hLnRhYnNbc107aWYoIWguY292ZXJhZ2V8fC0xIT0oaT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgoaC5jb3ZlcmFnZSxyW3RdKSkpaWYoMT09YS5sdHlwZSlyW3RdLDE9PWguZm10P3JbdF09clt0XStoLmRlbHRhOnJbdF09aC5uZXdnW2ldO2Vsc2UgaWYoND09YS5sdHlwZSlmb3IodmFyIGQ9aC52YWxzW2ldLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIHU9ZFtmXSxsPXUuY2hhaW4ubGVuZ3RoO2lmKCEobD5vKSl7Zm9yKHZhciB2PSEwLGM9MCxwPTA7cDxsO3ArKyl7Zm9yKDstMT09clt0K2MrKDErcCldOyljKys7dS5jaGFpbltwXSE9clt0K2MrKDErcCldJiYodj0hMSk7fWlmKHYpe3JbdF09dS5uZ2x5cGg7Zm9yKHA9MDtwPGwrYztwKyspclt0K3ArMV09LTE7YnJlYWt9fX1lbHNlIGlmKDU9PWEubHR5cGUmJjI9PWguZm10KWZvcih2YXIgVT1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3RdKSxnPWguY0RlZltVKzJdLFM9aC5zY3NldFtnXSxtPTA7bTxTLmxlbmd0aDttKyspe3ZhciBiPVNbbV0seT1iLmlucHV0O2lmKCEoeS5sZW5ndGg+bykpe2Zvcih2PSEwLHA9MDtwPHkubGVuZ3RoO3ArKyl7dmFyIEY9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0KzErcF0pO2lmKC0xPT1VJiZoLmNEZWZbRisyXSE9eVtwXSl7dj0hMTticmVha319aWYodil7dmFyIEM9Yi5zdWJzdExvb2t1cFJlY29yZHM7Zm9yKGY9MDtmPEMubGVuZ3RoO2YrPTIpQ1tmXSxDW2YrMV07fX19ZWxzZSBpZig2PT1hLmx0eXBlJiYzPT1oLmZtdCl7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYmFja0N2Zyx0LWguYmFja0N2Zy5sZW5ndGgpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmlucHRDdmcsdCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYWhlZEN2Zyx0K2guaW5wdEN2Zy5sZW5ndGgpKWNvbnRpbnVlO3ZhciBfPWgubG9va3VwUmVjO2ZvcihtPTA7bTxfLmxlbmd0aDttKz0yKXtVPV9bbV07dmFyIFA9bltfW20rMV1dO2UuVS5fYXBwbHlTdWJzKHIsdCtVLFAsbik7fX19fSxlLlUuX2dsc0NvdmVyZWQ9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXtpZigtMT09ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRbbl0sclthK25dKSlyZXR1cm4gITF9cmV0dXJuICEwfSxlLlUuZ2x5cGhzVG9QYXRoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49e2NtZHM6W10sY3JkczpbXX0sbz0wLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGk9dFtzXTtpZigtMSE9aSl7Zm9yKHZhciBoPXM8dC5sZW5ndGgtMSYmLTEhPXRbcysxXT90W3MrMV06MCxkPWUuVS5nbHlwaFRvUGF0aChyLGkpLGY9MDtmPGQuY3Jkcy5sZW5ndGg7Zis9MiluLmNyZHMucHVzaChkLmNyZHNbZl0rbyksbi5jcmRzLnB1c2goZC5jcmRzW2YrMV0pO2EmJm4uY21kcy5wdXNoKGEpO2ZvcihmPTA7ZjxkLmNtZHMubGVuZ3RoO2YrKyluLmNtZHMucHVzaChkLmNtZHNbZl0pO2EmJm4uY21kcy5wdXNoKFwiWFwiKSxvKz1yLmhtdHguYVdpZHRoW2ldLHM8dC5sZW5ndGgtMSYmKG8rPWUuVS5nZXRQYWlyQWRqdXN0bWVudChyLGksaCkpO319cmV0dXJuIG59LGUuVS5QPXt9LGUuVS5QLm1vdmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJNXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5saW5lVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTFwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAuY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4sbyxzKXtyLmNtZHMucHVzaChcIkNcIiksci5jcmRzLnB1c2goZSx0LGEsbixvLHMpO30sZS5VLlAucWN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuKXtyLmNtZHMucHVzaChcIlFcIiksci5jcmRzLnB1c2goZSx0LGEsbik7fSxlLlUuUC5jbG9zZVBhdGg9ZnVuY3Rpb24ocil7ci5jbWRzLnB1c2goXCJaXCIpO30sZS5VLl9kcmF3Q0ZGPWZ1bmN0aW9uKHIsdCxhLG4sbyl7Zm9yKHZhciBzPXQuc3RhY2ssaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGQ9dC53aWR0aCxmPXQub3Blbix1PTAsbD10Lngsdj10LnksYz0wLHA9MCxVPTAsZz0wLFM9MCxtPTAsYj0wLHk9MCxGPTAsQz0wLF89e3ZhbDowLHNpemU6MH07dTxyLmxlbmd0aDspe2UuQ0ZGLmdldENoYXJTdHJpbmcocix1LF8pO3ZhciBQPV8udmFsO2lmKHUrPV8uc2l6ZSxcIm8xXCI9PVB8fFwibzE4XCI9PVApcy5sZW5ndGglMiE9MCYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDtlbHNlIGlmKFwibzNcIj09UHx8XCJvMjNcIj09UCl7cy5sZW5ndGglMiE9MCYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDt9ZWxzZSBpZihcIm80XCI9PVApcy5sZW5ndGg+MSYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksZiYmZS5VLlAuY2xvc2VQYXRoKG8pLHYrPXMucG9wKCksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvNVwiPT1QKWZvcig7cy5sZW5ndGg+MDspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2Vsc2UgaWYoXCJvNlwiPT1QfHxcIm83XCI9PVApZm9yKHZhciB4PXMubGVuZ3RoLEk9XCJvNlwiPT1QLHc9MDt3PHg7dysrKXt2YXIgaz1zLnNoaWZ0KCk7ST9sKz1rOnYrPWssST0hSSxlLlUuUC5saW5lVG8obyxsLHYpO31lbHNlIGlmKFwibzhcIj09UHx8XCJvMjRcIj09UCl7eD1zLmxlbmd0aDtmb3IodmFyIEc9MDtHKzY8PXg7KWM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksRys9NjtcIm8yNFwiPT1QJiYobCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpKTt9ZWxzZSB7aWYoXCJvMTFcIj09UClicmVhaztpZihcIm8xMjM0XCI9PVB8fFwibzEyMzVcIj09UHx8XCJvMTIzNlwiPT1QfHxcIm8xMjM3XCI9PVApXCJvMTIzNFwiPT1QJiYocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxDPWc9cCtzLnNoaWZ0KCksbT1nLHk9dixsPShiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNVwiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLEM9ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPUMrcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLHY9eStzLnNoaWZ0KCkscy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNlwiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksQz1nPXArcy5zaGlmdCgpLG09ZyxiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM3XCI9PVAmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksQz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09QytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLE1hdGguYWJzKGItbCk+TWF0aC5hYnMoeS12KT9sPWIrcy5zaGlmdCgpOnY9eStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKTtlbHNlIGlmKFwibzE0XCI9PVApe2lmKHMubGVuZ3RoPjAmJiFoJiYoZD1zLnNoaWZ0KCkrYS5ub21pbmFsV2lkdGhYLGg9ITApLDQ9PXMubGVuZ3RoKXt2YXIgTz1zLnNoaWZ0KCksVD1zLnNoaWZ0KCksRD1zLnNoaWZ0KCksQj1zLnNoaWZ0KCksQT1lLkNGRi5nbHlwaEJ5U0UoYSxEKSxSPWUuQ0ZGLmdseXBoQnlTRShhLEIpO2UuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW0FdLHQsYSxuLG8pLHQueD1PLHQueT1ULGUuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW1JdLHQsYSxuLG8pO31mJiYoZS5VLlAuY2xvc2VQYXRoKG8pLGY9ITEpO31lbHNlIGlmKFwibzE5XCI9PVB8fFwibzIwXCI9PVApe3MubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITAsdSs9aSs3Pj4zO31lbHNlIGlmKFwibzIxXCI9PVApcy5sZW5ndGg+MiYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksdis9cy5wb3AoKSxsKz1zLnBvcCgpLGYmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm8yMlwiPT1QKXMubGVuZ3RoPjEmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGwrPXMucG9wKCksZiYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzI1XCI9PVApe2Zvcig7cy5sZW5ndGg+NjspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2M9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7fWVsc2UgaWYoXCJvMjZcIj09UClmb3Iocy5sZW5ndGglMiYmKGwrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspYz1sLHA9ditzLnNoaWZ0KCksbD1VPWMrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMjdcIj09UClmb3Iocy5sZW5ndGglMiYmKHYrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspcD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8xMFwiPT1QfHxcIm8yOVwiPT1QKXt2YXIgTD1cIm8xMFwiPT1QP246YTtpZigwPT1zLmxlbmd0aCljb25zb2xlLmRlYnVnKFwiZXJyb3I6IGVtcHR5IHN0YWNrXCIpO2Vsc2Uge3ZhciBXPXMucG9wKCksTT1MLlN1YnJzW1crTC5CaWFzXTt0Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1kLHQub3Blbj1mLGUuVS5fZHJhd0NGRihNLHQsYSxuLG8pLGw9dC54LHY9dC55LGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxkPXQud2lkdGgsZj10Lm9wZW47fX1lbHNlIGlmKFwibzMwXCI9PVB8fFwibzMxXCI9PVApe3ZhciBWPXMubGVuZ3RoLEU9KEc9MCxcIm8zMVwiPT1QKTtmb3IoRys9Vi0oeD0tMyZWKTtHPHg7KUU/KHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHgtRz09NT8obD1VK3Muc2hpZnQoKSxHKyspOmw9VSxFPSExKTooYz1sLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCkseC1HPT01Pyh2PWcrcy5zaGlmdCgpLEcrKyk6dj1nLEU9ITApLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksRys9NDt9ZWxzZSB7aWYoXCJvXCI9PShQK1wiXCIpLmNoYXJBdCgwKSl0aHJvdyBjb25zb2xlLmRlYnVnKFwiVW5rbm93biBvcGVyYXRpb246IFwiK1AsciksUDtzLnB1c2goUCk7fX19dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9ZCx0Lm9wZW49Zjt9O3ZhciB0PWUsYT17VHlwcjp0fTtyZXR1cm4gci5UeXByPXQsci5kZWZhdWx0PWEsT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLlR5cHJ9XG5cbi8qIVxuQ3VzdG9tIGJ1bmRsZSBvZiB3b2ZmMm90ZiAoaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zikgd2l0aCBmZmxhdGVcbihodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZSkgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuT3JpZ2luYWwgbGljZW5zZXMgYXBwbHk6IFxuLSBmZmxhdGU6IGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlL2Jsb2IvbWFzdGVyL0xJQ0VOU0UgKE1JVClcbi0gd29mZjJvdGYuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYvYmxvYi9tYXN0ZXIvd29mZjJvdGYuanMgKEFwYWNoZTIpXG4qL1xuZnVuY3Rpb24gd29mZjJvdGZGYWN0b3J5KCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3ZhciBlPVVpbnQ4QXJyYXksbj1VaW50MTZBcnJheSx0PVVpbnQzMkFycmF5LGE9bmV3IGUoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0pLGk9bmV3IGUoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTMsMCwwXSksbz1uZXcgZShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLGY9ZnVuY3Rpb24ocixlKXtmb3IodmFyIGE9bmV3IG4oMzEpLGk9MDtpPDMxOysraSlhW2ldPWUrPTE8PHJbaS0xXTt2YXIgbz1uZXcgdChhWzMwXSk7Zm9yKGk9MTtpPDMwOysraSlmb3IodmFyIGY9YVtpXTtmPGFbaSsxXTsrK2Ypb1tmXT1mLWFbaV08PDV8aTtyZXR1cm4gW2Esb119LHU9ZihhLDIpLHY9dVswXSxzPXVbMV07dlsyOF09MjU4LHNbMjU4XT0yODtmb3IodmFyIGw9ZihpLDApWzBdLGM9bmV3IG4oMzI3NjgpLGc9MDtnPDMyNzY4OysrZyl7dmFyIGg9KDQzNjkwJmcpPj4+MXwoMjE4NDUmZyk8PDE7aD0oNjE2ODAmKGg9KDUyNDI4JmgpPj4+MnwoMTMxMDcmaCk8PDIpKT4+PjR8KDM4NTUmaCk8PDQsY1tnXT0oKDY1MjgwJmgpPj4+OHwoMjU1JmgpPDw4KT4+PjE7fXZhciB3PWZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9ci5sZW5ndGgsaT0wLG89bmV3IG4oZSk7aTxhOysraSkrK29bcltpXS0xXTt2YXIgZix1PW5ldyBuKGUpO2ZvcihpPTA7aTxlOysraSl1W2ldPXVbaS0xXStvW2ktMV08PDE7aWYodCl7Zj1uZXcgbigxPDxlKTt2YXIgdj0xNS1lO2ZvcihpPTA7aTxhOysraSlpZihyW2ldKWZvcih2YXIgcz1pPDw0fHJbaV0sbD1lLXJbaV0sZz11W3JbaV0tMV0rKzw8bCxoPWd8KDE8PGwpLTE7Zzw9aDsrK2cpZltjW2ddPj4+dl09czt9ZWxzZSBmb3IoZj1uZXcgbihhKSxpPTA7aTxhOysraSlyW2ldJiYoZltpXT1jW3VbcltpXS0xXSsrXT4+PjE1LXJbaV0pO3JldHVybiBmfSxkPW5ldyBlKDI4OCk7Zm9yKGc9MDtnPDE0NDsrK2cpZFtnXT04O2ZvcihnPTE0NDtnPDI1NjsrK2cpZFtnXT05O2ZvcihnPTI1NjtnPDI4MDsrK2cpZFtnXT03O2ZvcihnPTI4MDtnPDI4ODsrK2cpZFtnXT04O3ZhciBtPW5ldyBlKDMyKTtmb3IoZz0wO2c8MzI7KytnKW1bZ109NTt2YXIgYj13KGQsOSwxKSxwPXcobSw1LDEpLHk9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPXJbMF0sbj0xO248ci5sZW5ndGg7KytuKXJbbl0+ZSYmKGU9cltuXSk7cmV0dXJuIGV9LEw9ZnVuY3Rpb24ocixlLG4pe3ZhciB0PWUvOHwwO3JldHVybiAoclt0XXxyW3QrMV08PDgpPj4oNyZlKSZufSxVPWZ1bmN0aW9uKHIsZSl7dmFyIG49ZS84fDA7cmV0dXJuIChyW25dfHJbbisxXTw8OHxyW24rMl08PDE2KT4+KDcmZSl9LGs9W1widW5leHBlY3RlZCBFT0ZcIixcImludmFsaWQgYmxvY2sgdHlwZVwiLFwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbFwiLFwiaW52YWxpZCBkaXN0YW5jZVwiLFwic3RyZWFtIGZpbmlzaGVkXCIsXCJubyBzdHJlYW0gaGFuZGxlclwiLCxcIm5vIGNhbGxiYWNrXCIsXCJpbnZhbGlkIFVURi04IGRhdGFcIixcImV4dHJhIGZpZWxkIHRvbyBsb25nXCIsXCJkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTlcIixcImZpbGVuYW1lIHRvbyBsb25nXCIsXCJzdHJlYW0gZmluaXNoaW5nXCIsXCJpbnZhbGlkIHppcCBkYXRhXCJdLFQ9ZnVuY3Rpb24ocixlLG4pe3ZhciB0PW5ldyBFcnJvcihlfHxrW3JdKTtpZih0LmNvZGU9cixFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodCxUKSwhbil0aHJvdyB0O3JldHVybiB0fSxPPWZ1bmN0aW9uKHIsZix1KXt2YXIgcz1yLmxlbmd0aDtpZighc3x8dSYmIXUubCYmczw1KXJldHVybiBmfHxuZXcgZSgwKTt2YXIgYz0hZnx8dSxnPSF1fHx1Lmk7dXx8KHU9e30pLGZ8fChmPW5ldyBlKDMqcykpO3ZhciBoLGQ9ZnVuY3Rpb24ocil7dmFyIG49Zi5sZW5ndGg7aWYocj5uKXt2YXIgdD1uZXcgZShNYXRoLm1heCgyKm4scikpO3Quc2V0KGYpLGY9dDt9fSxtPXUuZnx8MCxrPXUucHx8MCxPPXUuYnx8MCxBPXUubCx4PXUuZCxFPXUubSxEPXUubixNPTgqcztkb3tpZighQSl7dS5mPW09TChyLGssMSk7dmFyIFM9TChyLGsrMSwzKTtpZihrKz0zLCFTKXt2YXIgVj1yWyhJPSgoaD1rKS84fDApKyg3JmgmJjEpKzQpLTRdfHJbSS0zXTw8OCxfPUkrVjtpZihfPnMpe2cmJlQoMCk7YnJlYWt9YyYmZChPK1YpLGYuc2V0KHIuc3ViYXJyYXkoSSxfKSxPKSx1LmI9Tys9Vix1LnA9az04Kl87Y29udGludWV9aWYoMT09UylBPWIseD1wLEU9OSxEPTU7ZWxzZSBpZigyPT1TKXt2YXIgaj1MKHIsaywzMSkrMjU3LHo9TChyLGsrMTAsMTUpKzQsQz1qK0wocixrKzUsMzEpKzE7ays9MTQ7Zm9yKHZhciBGPW5ldyBlKEMpLFA9bmV3IGUoMTkpLHE9MDtxPHo7KytxKVBbb1txXV09TChyLGsrMypxLDcpO2srPTMqejt2YXIgQj15KFApLEc9KDE8PEIpLTEsSD13KFAsQiwxKTtmb3IocT0wO3E8Qzspe3ZhciBJLEo9SFtMKHIsayxHKV07aWYoays9MTUmSiwoST1KPj4+NCk8MTYpRltxKytdPUk7ZWxzZSB7dmFyIEs9MCxOPTA7Zm9yKDE2PT1JPyhOPTMrTChyLGssMyksays9MixLPUZbcS0xXSk6MTc9PUk/KE49MytMKHIsayw3KSxrKz0zKToxOD09SSYmKE49MTErTChyLGssMTI3KSxrKz03KTtOLS07KUZbcSsrXT1LO319dmFyIFE9Ri5zdWJhcnJheSgwLGopLFI9Ri5zdWJhcnJheShqKTtFPXkoUSksRD15KFIpLEE9dyhRLEUsMSkseD13KFIsRCwxKTt9ZWxzZSBUKDEpO2lmKGs+TSl7ZyYmVCgwKTticmVha319YyYmZChPKzEzMTA3Mik7Zm9yKHZhciBXPSgxPDxFKS0xLFg9KDE8PEQpLTEsWT1rOztZPWspe3ZhciBaPShLPUFbVShyLGspJlddKT4+PjQ7aWYoKGsrPTE1JkspPk0pe2cmJlQoMCk7YnJlYWt9aWYoS3x8VCgyKSxaPDI1NilmW08rK109WjtlbHNlIHtpZigyNTY9PVope1k9ayxBPW51bGw7YnJlYWt9dmFyICQ9Wi0yNTQ7aWYoWj4yNjQpe3ZhciBycj1hW3E9Wi0yNTddOyQ9TChyLGssKDE8PHJyKS0xKSt2W3FdLGsrPXJyO312YXIgZXI9eFtVKHIsaykmWF0sbnI9ZXI+Pj40O2VyfHxUKDMpLGsrPTE1JmVyO1I9bFtucl07aWYobnI+Myl7cnI9aVtucl07Uis9VShyLGspJigxPDxyciktMSxrKz1ycjt9aWYoaz5NKXtnJiZUKDApO2JyZWFrfWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgdHI9TyskO088dHI7Tys9NClmW09dPWZbTy1SXSxmW08rMV09ZltPKzEtUl0sZltPKzJdPWZbTysyLVJdLGZbTyszXT1mW08rMy1SXTtPPXRyO319dS5sPUEsdS5wPVksdS5iPU8sQSYmKG09MSx1Lm09RSx1LmQ9eCx1Lm49RCk7fXdoaWxlKCFtKTtyZXR1cm4gTz09Zi5sZW5ndGg/ZjpmdW5jdGlvbihyLGEsaSl7KG51bGw9PWF8fGE8MCkmJihhPTApLChudWxsPT1pfHxpPnIubGVuZ3RoKSYmKGk9ci5sZW5ndGgpO3ZhciBvPW5ldyhyIGluc3RhbmNlb2Ygbj9uOnIgaW5zdGFuY2VvZiB0P3Q6ZSkoaS1hKTtyZXR1cm4gby5zZXQoci5zdWJhcnJheShhLGkpKSxvfShmLDAsTyl9LEE9bmV3IGUoMCk7dmFyIHg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXI7dHJ5e3guZGVjb2RlKEEse3N0cmVhbTohMH0pLDE7fWNhdGNoKHIpe31yZXR1cm4gci5jb252ZXJ0X3N0cmVhbXM9ZnVuY3Rpb24ocil7dmFyIGU9bmV3IERhdGFWaWV3KHIpLG49MDtmdW5jdGlvbiB0KCl7dmFyIHI9ZS5nZXRVaW50MTYobik7cmV0dXJuIG4rPTIscn1mdW5jdGlvbiBhKCl7dmFyIHI9ZS5nZXRVaW50MzIobik7cmV0dXJuIG4rPTQscn1mdW5jdGlvbiBpKHIpe20uc2V0VWludDE2KGIsciksYis9Mjt9ZnVuY3Rpb24gbyhyKXttLnNldFVpbnQzMihiLHIpLGIrPTQ7fWZvcih2YXIgZj17c2lnbmF0dXJlOmEoKSxmbGF2b3I6YSgpLGxlbmd0aDphKCksbnVtVGFibGVzOnQoKSxyZXNlcnZlZDp0KCksdG90YWxTZm50U2l6ZTphKCksbWFqb3JWZXJzaW9uOnQoKSxtaW5vclZlcnNpb246dCgpLG1ldGFPZmZzZXQ6YSgpLG1ldGFMZW5ndGg6YSgpLG1ldGFPcmlnTGVuZ3RoOmEoKSxwcml2T2Zmc2V0OmEoKSxwcml2TGVuZ3RoOmEoKX0sdT0wO01hdGgucG93KDIsdSk8PWYubnVtVGFibGVzOyl1Kys7dS0tO2Zvcih2YXIgdj0xNipNYXRoLnBvdygyLHUpLHM9MTYqZi5udW1UYWJsZXMtdixsPTEyLGM9W10sZz0wO2c8Zi5udW1UYWJsZXM7ZysrKWMucHVzaCh7dGFnOmEoKSxvZmZzZXQ6YSgpLGNvbXBMZW5ndGg6YSgpLG9yaWdMZW5ndGg6YSgpLG9yaWdDaGVja3N1bTphKCl9KSxsKz0xNjt2YXIgaCx3PW5ldyBVaW50OEFycmF5KDEyKzE2KmMubGVuZ3RoK2MucmVkdWNlKChmdW5jdGlvbihyLGUpe3JldHVybiByK2Uub3JpZ0xlbmd0aCs0fSksMCkpLGQ9dy5idWZmZXIsbT1uZXcgRGF0YVZpZXcoZCksYj0wO3JldHVybiBvKGYuZmxhdm9yKSxpKGYubnVtVGFibGVzKSxpKHYpLGkodSksaShzKSxjLmZvckVhY2goKGZ1bmN0aW9uKHIpe28oci50YWcpLG8oci5vcmlnQ2hlY2tzdW0pLG8obCksbyhyLm9yaWdMZW5ndGgpLHIub3V0T2Zmc2V0PWwsKGwrPXIub3JpZ0xlbmd0aCklNCE9MCYmKGwrPTQtbCU0KTt9KSksYy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbix0PXIuc2xpY2UoZS5vZmZzZXQsZS5vZmZzZXQrZS5jb21wTGVuZ3RoKTtpZihlLmNvbXBMZW5ndGghPWUub3JpZ0xlbmd0aCl7dmFyIGE9bmV3IFVpbnQ4QXJyYXkoZS5vcmlnTGVuZ3RoKTtuPW5ldyBVaW50OEFycmF5KHQsMiksTyhuLGEpO31lbHNlIGE9bmV3IFVpbnQ4QXJyYXkodCk7dy5zZXQoYSxlLm91dE9mZnNldCk7dmFyIGk9MDsobD1lLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpJTQhPTAmJihpPTQtbCU0KSx3LnNldChuZXcgVWludDhBcnJheShpKS5idWZmZXIsZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSxoPWwraTt9KSksZC5zbGljZSgwLGgpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyfSh7fSkuY29udmVydF9zdHJlYW1zfVxuXG4vKipcbiAqIEEgZmFjdG9yeSB3cmFwcGVyIHBhcnNpbmcgYSBmb250IGZpbGUgdXNpbmcgVHlwci5cbiAqIEFsc28gYWRkcyBzdXBwb3J0IGZvciBXT0ZGIGZpbGVzIChub3QgV09GRjIpLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgUGFyc2VkRm9udFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0geEhlaWdodFxuICogQHByb3BlcnR5IHsobnVtYmVyKSA9PiBib29sZWFufSBzdXBwb3J0c0NvZGVQb2ludFxuICogQHByb3BlcnR5IHsodGV4dDpzdHJpbmcsIGZvbnRTaXplOm51bWJlciwgbGV0dGVyU3BhY2luZzpudW1iZXIsIGNhbGxiYWNrKSA9PiBudW1iZXJ9IGZvckVhY2hHbHlwaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVHYXBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBIZWlnaHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1bml0c1BlckVtXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IFBhcnNlZEZvbnR9IEZvbnRQYXJzZXJcbiAqL1xuXG4vKipcbiAqIEByZXR1cm5zIHtGb250UGFyc2VyfVxuICovXG5mdW5jdGlvbiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKSB7XG4gIGNvbnN0IGNtZEFyZ0xlbmd0aHMgPSB7XG4gICAgTTogMixcbiAgICBMOiAyLFxuICAgIFE6IDQsXG4gICAgQzogNixcbiAgICBaOiAwXG4gIH07XG5cbiAgLy8ge2pvaW5UeXBlOiBcInNraXArc3RlcCwuLi5cIn1cbiAgY29uc3Qgam9pbmluZ1R5cGVSYXdEYXRhID0ge1wiQ1wiOlwiMThnLGNhLDM2OCwxa3pcIixcIkRcIjpcIjE3ayw2LDIsMis0LDUrYywyKzYsMisxLDEwKzEsOStmLGorMTEsMisxLGEsMiwyKzEsMTUrMiwzLGorMiw2KzMsMis4LDIsMiwyKzEsdythLDQrZSwzKzMsMiwzKzIsMys1LDIzK3csMmYrNCwzLDIrOSwyLGIsMiszLDMsMWsrOSw2KzEsMysxLDIrMiwyK2QsMzBnLHAreSwxLDErMWcsZit4LDIsc2QyKzFkLGpmMys0LGYrMywyKzQsMisyLGIrMyw0MiwyLDQrMiwyKzEsMiwzLHQrMSw5Zit3LDIsZWwrMiwyK2csZCsyLDJsLDIrMSw1LDMrMSwyKzEsMiwzLDYsMTZ3bSsxdlwiLFwiUlwiOlwiMTdtKzMsMiwyLDYrMyxtLDE1KzIsMisyLGgraCwxMywzKzgsMiwyLDMrMSwyLHArMSx4LDUrNCw1LGEsMiwyLDMsdSxjKzIsZysxLDUsMisxLDQrMSw1aiw2KzEsMixiLDIrMixmLDIrMSwxcysyLDIsMysxLDcsMWV6MCwyLDIrMSw0KzQsYiw0LDMsYiw0MiwyKzIsNCwzLDIrMSwyLG8rMyxhZSxlcCx4LDJvKzIsMysxLDMsNSsxLDZcIixcIkxcIjpcIng5dSxqZmYsYSxmZCxqdlwiLFwiVFwiOlwiNHQsZ2orMzMsN28rNCwxKzEsN2MrMTgsMiwyKzEsMisxLDIsMjErYSwyLDFiK2ssaCwydSs2LDMrNSwzKzEsMiszLHksMix2K3EsMmsrYSwxbis4LGEscCszLDIrOCwyKzIsMis0LDE4KzIsM2MrZSwyK3YsMWssMiw1KzcsNSw0KzYsYisxLHUsMW4sNSszLDksbCsxLHIsMysxLDFtLDUrMSw1KzEsMysyLDQsdisxLDQsYysxLDFtLDUrNCwyKzEsNSxsKzEsbis1LDIsMW4sMywyKzMsOSw4KzEsYysxLHYsMXEsZCwxZiw0LDFtKzIsNisyLDIrMyw4KzEsYysxLHUsMW4sMyw3LDYrMSxsKzEsdCsxLDFtKzEsNSszLDksbCsxLHUsMjEsOCsyLDIsMmosMys2LGQrNywyciwzKzgsYys1LDIzKzEscywyLDIsMWsrZCwyKzQsMisxLDYrYSwyK3osYSwydiszLDIrNSwyKzEsMysxLHErMSw1KzIsaCszLGUsMysxLDcsZyxqaysyLHFiKzIsdSsyLHUrMSx2KzEsMXQrMSwyKzYsOSwzK2EsYSwxYSsyLDNjKzEseiwzYisyLDUrMSxhLDcrMiw2NCsxLDMsMW4sMis2LDIsMiwzKzcsNys5LDMsMWQrZCwxLDErMSwxcyszLDFkLDIrNCwyLDYsMTUrOCxkKzEseCszLDMrMSwyKzIsMWwsMisxLDQsMisyLDFuKzcsMysxLDQ5KzIsMitjLDIrNiw1LDcsNCsxLDVqKzFsLDIrNCxlaywzKzEscis0LDFlKzQsNis1LDJwK2MsMSszLDEsMSsyLDErYiwyZGIrMiwzeSwycCt2LGZmKzMsMzArMSxuOXgsMSsyLDIrOSx4KzEsMjkrMSw3bCw0LDUscSsxLDYsNDgrMSxyK2gsZSwxMys3LHErYSwxYisyLDFkLDMrMywzKzEsMTQsMXcrNSwzKzEsMysxLGQsOSwxYywxZywyKzIsMysxLDYrMSwyLDE3KzEsOSw2biwzLDUsZm41LGtpK2YsaCtmLDVzLDZ5KzIsZWEsNmIsNDYrNCwxYWYrMiwyKzEsNiszLDE1KzIsNSw0bSsxLGZ5KzMsYXMrMSw0YSthLDR4LDFqK2UsMWwrMiwxZSszLDMrMSwxeSsyLDExKzQsMis3LDFyLGQrMSwxaCs4LGIrMywzLDJvKzIsMywyKzEsNyw0aCw0KzcsbSsxLDFtKzEsNCwxMis2LDQrNCw1Zys3LDMrMiwyLG8sMmQrNSwyLDUrMSwyKzEsNm4rMyw3KzEsMisxLHMrMSwyZSs3LDMsMisxLDJ6LDIsMys1LDIsMnUrMiwzKzMsMis0LDc4KzgsMisxLDc1KzEsMiw1LDQxKzMsMysxLDUseCs5LDE1KzUsMyszLDksYSs1LDMrMiwxYitjLDIrMSxiYis2LDIrNSwyLDJiK2wsMys2LDIrMSwyKzEsM2YrNSw0LDIrMSwyKzYsMiwyMSsxLDQsMiw5bysxLDQ3MCs4LGF0NCs0LDFvKzYsdDUsMXMrMywyYSxmNWwrMSwyKzMsNDNvKzIsYSs3LDErNywzKzYsdiszLDQ1KzIsMWowKzFpLDUrMWQsOSxmLG4rNCwyK2UsMTF0KzYsMitnLDMrNiwyKzEsMis0LDdhKzYsYzYrMywxNXQrNiwzMis2LDEsZ3phdSx2KzJuLDNsKzZuXCJ9O1xuXG4gIGNvbnN0IEpUX0xFRlQgPSAxLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLCBidXQgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyLlxuICAgIEpUX1JJR0hUID0gMiwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyLCBidXQgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci5cbiAgICBKVF9EVUFMID0gNCwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIGFuZCBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci5cbiAgICBKVF9UUkFOU1BBUkVOVCA9IDgsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggYWRqYWNlbnQgY2hhcmFjdGVycyBhbmQgdGhhdCB0aGUgY2hhcmFjdGVyIG11c3QgYmUgc2tpcHBlZCBvdmVyIHdoZW4gdGhlIHNoYXBpbmcgZW5naW5lIGlzIGV2YWx1YXRpbmcgdGhlIGpvaW5pbmcgcG9zaXRpb25zIGluIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy4gV2hlbiBhIEpUX1RSQU5TUEFSRU5UIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBhIHNlcXVlbmNlLCB0aGUgSk9JTklOR19UWVBFIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIHBhc3NlcyB0aHJvdWdoLiBEaWFjcml0aWNhbCBtYXJrcyBhcmUgZnJlcXVlbnRseSBhc3NpZ25lZCB0aGlzIHZhbHVlLlxuICAgIEpUX0pPSU5fQ0FVU0lORyA9IDE2LCAvL2luZGljYXRlcyB0aGF0IHRoZSBjaGFyYWN0ZXIgZm9yY2VzIHRoZSB1c2Ugb2Ygam9pbmluZyBmb3JtcyB3aXRoIHRoZSBwcmVjZWRpbmcgYW5kIHN1YnNlcXVlbnQgY2hhcmFjdGVycy4gS2FzaGlkYXMgYW5kIHRoZSBaZXJvIFdpZHRoIEpvaW5lciAoVSsyMDBEKSBhcmUgYm90aCBKT0lOX0NBVVNJTkcgY2hhcmFjdGVycy5cbiAgICBKVF9OT05fSk9JTklORyA9IDMyOyAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIG9yIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLixcblxuICBsZXQgam9pbmluZ1R5cGVNYXA7XG4gIGZ1bmN0aW9uIGdldENoYXJKb2luaW5nVHlwZShjaCkge1xuICAgIGlmICgham9pbmluZ1R5cGVNYXApIHtcbiAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgIFI6IEpUX1JJR0hULFxuICAgICAgICBMOiBKVF9MRUZULFxuICAgICAgICBEOiBKVF9EVUFMLFxuICAgICAgICBDOiBKVF9KT0lOX0NBVVNJTkcsXG4gICAgICAgIFU6IEpUX05PTl9KT0lOSU5HLFxuICAgICAgICBUOiBKVF9UUkFOU1BBUkVOVFxuICAgICAgfTtcbiAgICAgIGpvaW5pbmdUeXBlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgdHlwZSBpbiBqb2luaW5nVHlwZVJhd0RhdGEpIHtcbiAgICAgICAgbGV0IGxhc3RDb2RlID0gMDtcbiAgICAgICAgam9pbmluZ1R5cGVSYXdEYXRhW3R5cGVdLnNwbGl0KCcsJykuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgbGV0IFtza2lwLCBzdGVwXSA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgc2tpcCA9IHBhcnNlSW50KHNraXAsMzYpO1xuICAgICAgICAgIHN0ZXAgPSBzdGVwID8gcGFyc2VJbnQoc3RlcCwgMzYpIDogMDtcbiAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQobGFzdENvZGUgKz0gc2tpcCwgbVt0eXBlXSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0ZXA7IGktLTspIHtcbiAgICAgICAgICAgIGpvaW5pbmdUeXBlTWFwLnNldCgrK2xhc3RDb2RlLCBtW3R5cGVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gam9pbmluZ1R5cGVNYXAuZ2V0KGNoKSB8fCBKVF9OT05fSk9JTklOR1xuICB9XG5cbiAgY29uc3QgSVNPTCA9IDEsIElOSVQgPSAyLCBGSU5BID0gMywgTUVESSA9IDQ7XG4gIGNvbnN0IGZvcm1zVG9GZWF0dXJlcyA9IFtudWxsLCAnaXNvbCcsICdpbml0JywgJ2ZpbmEnLCAnbWVkaSddO1xuXG4gIGZ1bmN0aW9uIGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpIHtcbiAgICAvLyBUaGlzIGltcGxlbWVudHMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbjh3aWxsaXMvb3BlbnR5cGUtc2hhcGluZy1kb2N1bWVudHMvYmxvYi9tYXN0ZXIvb3BlbnR5cGUtc2hhcGluZy1hcmFiaWMtZ2VuZXJhbC5tZFxuICAgIGNvbnN0IGpvaW5pbmdGb3JtcyA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIGxldCBwcmV2Sm9pbmluZ1R5cGUgPSBKVF9OT05fSk9JTklORztcbiAgICBsZXQgcHJldkZvcm0gPSBJU09MO1xuICAgIGxldCBwcmV2SW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgIGxldCBqb2luaW5nVHlwZSA9IGdldENoYXJKb2luaW5nVHlwZShjb2RlKSB8IDA7XG4gICAgICBsZXQgZm9ybSA9IElTT0w7XG4gICAgICBpZiAoam9pbmluZ1R5cGUgJiBKVF9UUkFOU1BBUkVOVCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKHByZXZKb2luaW5nVHlwZSAmIChKVF9MRUZUIHwgSlRfRFVBTCB8IEpUX0pPSU5fQ0FVU0lORykpIHtcbiAgICAgICAgaWYgKGpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfRFVBTCB8IEpUX0pPSU5fQ0FVU0lORykpIHtcbiAgICAgICAgICBmb3JtID0gRklOQTtcbiAgICAgICAgICAvLyBpc29sLT5pbml0LCBmaW5hLT5tZWRpXG4gICAgICAgICAgaWYgKHByZXZGb3JtID09PSBJU09MIHx8IHByZXZGb3JtID09PSBGSU5BKSB7XG4gICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqb2luaW5nVHlwZSAmIChKVF9MRUZUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSU5JVCB8fCBwcmV2Rm9ybSA9PT0gTUVESSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByZXZKb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX05PTl9KT0lOSU5HKSkge1xuICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSU5JVCB8fCBwcmV2Rm9ybSA9PT0gTUVESSkge1xuICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZGb3JtID0gam9pbmluZ0Zvcm1zW2ldID0gZm9ybTtcbiAgICAgIHByZXZKb2luaW5nVHlwZSA9IGpvaW5pbmdUeXBlO1xuICAgICAgcHJldkluZGV4ID0gaTtcbiAgICAgIGlmIChjb2RlID4gMHhmZmZmKSBpKys7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGNoLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KSkpXG4gICAgLy8gY29uc29sZS5sb2coc3RyLnNwbGl0KCcnKS5tYXAoY2ggPT4gZ2V0Q2hhckpvaW5pbmdUeXBlKGNoLmNvZGVQb2ludEF0KDApKSkpXG4gICAgLy8gY29uc29sZS5sb2coQXJyYXkuZnJvbShqb2luaW5nRm9ybXMpLm1hcChmID0+IGZvcm1zVG9GZWF0dXJlc1tmXSB8fCAnbm9uZScpKVxuICAgIHJldHVybiBqb2luaW5nRm9ybXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvR2x5cGhzIChmb250LCBzdHIpIHtcbiAgICBjb25zdCBnbHlwaElkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjYyA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgIGlmIChjYyA+IDB4ZmZmZikgaSsrO1xuICAgICAgZ2x5cGhJZHMucHVzaChUeXByLlUuY29kZVRvR2x5cGgoZm9udCwgY2MpKTtcbiAgICB9XG5cbiAgICBjb25zdCBnc3ViID0gZm9udFsnR1NVQiddO1xuICAgIGlmIChnc3ViKSB7XG4gICAgICBjb25zdCB7bG9va3VwTGlzdCwgZmVhdHVyZUxpc3R9ID0gZ3N1YjtcbiAgICAgIGxldCBqb2luaW5nRm9ybXM7XG4gICAgICBjb25zdCBzdXBwb3J0ZWRGZWF0dXJlcyA9IC9eKHJsaWd8bGlnYXxtc2V0fGlzb2x8aW5pdHxmaW5hfG1lZGl8aGFsZnxwcmVzfGJsd3N8Y2NtcCkkLztcbiAgICAgIGNvbnN0IHVzZWRMb29rdXBzID0gW107XG4gICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgICBpZiAoc3VwcG9ydGVkRmVhdHVyZXMudGVzdChmZWF0dXJlLnRhZykpIHtcbiAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgZmVhdHVyZS50YWIubGVuZ3RoOyB0aSsrKSB7XG4gICAgICAgICAgICBpZiAodXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSkgY29udGludWVcbiAgICAgICAgICAgIHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0gPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGFiID0gbG9va3VwTGlzdFtmZWF0dXJlLnRhYlt0aV1dO1xuICAgICAgICAgICAgY29uc3QgaXNKb2luaW5nRmVhdHVyZSA9IC9eKGlzb2x8aW5pdHxmaW5hfG1lZGkpJC8udGVzdChmZWF0dXJlLnRhZyk7XG4gICAgICAgICAgICBpZiAoaXNKb2luaW5nRmVhdHVyZSAmJiAham9pbmluZ0Zvcm1zKSB7IC8vbGF6eVxuICAgICAgICAgICAgICBqb2luaW5nRm9ybXMgPSBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBnbHlwaElkcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFqb2luaW5nRm9ybXMgfHwgIWlzSm9pbmluZ0ZlYXR1cmUgfHwgZm9ybXNUb0ZlYXR1cmVzW2pvaW5pbmdGb3Jtc1tjaV1dID09PSBmZWF0dXJlLnRhZykge1xuICAgICAgICAgICAgICAgIFR5cHIuVS5fYXBwbHlTdWJzKGdseXBoSWRzLCBjaSwgdGFiLCBsb29rdXBMaXN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoSWRzXG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYWR2YW5jZXMgYW5kIHgveSBvZmZzZXRzIGZvciBlYWNoIGdseXBoLCBlLmcuIGtlcm5pbmcgYW5kIG1hcmtcbiAgLy8gYXR0YWNobWVudHMuIFRoaXMgaXMgYSBtb3JlIGNvbXBsZXRlIHZlcnNpb24gb2YgVHlwci5VLmdldFBhaXJBZGp1c3RtZW50XG4gIC8vIGFuZCBzaG91bGQgYmVjb21lIGFuIHVwc3RyZWFtIHJlcGxhY2VtZW50IGV2ZW50dWFsbHkuXG4gIGZ1bmN0aW9uIGNhbGNHbHlwaFBvc2l0aW9ucyhmb250LCBnbHlwaElkcykge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBJbnQxNkFycmF5KGdseXBoSWRzLmxlbmd0aCAqIDMpOyAvLyBbb2Zmc2V0WCwgb2Zmc2V0WSwgYWR2YW5jZVgsIC4uLl1cbiAgICBsZXQgZ2x5cGhJbmRleCA9IDA7XG4gICAgZm9yICg7IGdseXBoSW5kZXggPCBnbHlwaElkcy5sZW5ndGg7IGdseXBoSW5kZXgrKykge1xuICAgICAgY29uc3QgZ2x5cGhJZCA9IGdseXBoSWRzW2dseXBoSW5kZXhdO1xuICAgICAgaWYgKGdseXBoSWQgPT09IC0xKSBjb250aW51ZTtcblxuICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMl0gPSBmb250LmhtdHguYVdpZHRoW2dseXBoSWRdOyAvLyBwb3B1bGF0ZSBhZHZhbmNlWCBpbi4uLmFkdmFuY2UuXG5cbiAgICAgIGNvbnN0IGdwb3MgPSBmb250LkdQT1M7XG4gICAgICBpZiAoZ3Bvcykge1xuICAgICAgICBjb25zdCBsbGlzdCA9IGdwb3MubG9va3VwTGlzdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IGxsaXN0W2ldO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9va3VwLnRhYnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IGxvb2t1cC50YWJzW2pdO1xuICAgICAgICAgICAgLy8gU2luZ2xlIGNoYXIgcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAobG9va3VwLmx0eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIuY292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICBpZiAoaW5kICE9PSAtMSAmJiB0YWIucG9zKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlWYWx1ZVJlY29yZCh0YWIucG9zLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYWlycyAoa2VybmluZylcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICBsZXQgYWRqID0gbnVsbDtcbiAgICAgICAgICAgICAgbGV0IHByZXZHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoKTtcbiAgICAgICAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdmVyYWdlSW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmNvdmVyYWdlLCBnbHlwaElkc1twcmV2R2x5cGhJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmFnZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhYi5mbXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0YWIucGFpcnNldHNbY292ZXJhZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmlnaHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRba10uZ2lkMiA9PT0gZ2x5cGhJZCkgYWRqID0gcmlnaHRba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiLmZtdCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjMSA9IFR5cHIuVS5fZ2V0R2x5cGhDbGFzcyhnbHlwaElkc1twcmV2R2x5cGhJbmRleF0sIHRhYi5jbGFzc0RlZjEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjMiA9IFR5cHIuVS5fZ2V0R2x5cGhDbGFzcyhnbHlwaElkLCB0YWIuY2xhc3NEZWYyKTtcbiAgICAgICAgICAgICAgICAgICAgYWRqID0gdGFiLm1hdHJpeFtjMV1bYzJdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGFkaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRqLnZhbDEpIGFwcGx5VmFsdWVSZWNvcmQoYWRqLnZhbDEsIHByZXZHbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkai52YWwyKSBhcHBseVZhbHVlUmVjb3JkKGFkai52YWwyLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgdG8gYmFzZVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwLmx0eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtBcnJJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIubWFya0NvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgaWYgKG1hcmtBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlR2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KGlzQmFzZUdseXBoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQXJySW5kZXggPSBiYXNlR2x5cGhJbmRleCA9PT0gLTEgPyAtMSA6IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIuYmFzZUNvdmVyYWdlLCBnbHlwaElkc1tiYXNlR2x5cGhJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXJrUmVjb3JkID0gdGFiLm1hcmtBcnJheVttYXJrQXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZUFuY2hvciA9IHRhYi5iYXNlQXJyYXlbYmFzZUFyckluZGV4XVttYXJrUmVjb3JkLm1hcmtDbGFzc107XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDNdID0gYmFzZUFuY2hvci54IC0gbWFya1JlY29yZC54ICsgcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogM10gLSBwb3NpdGlvbnNbYmFzZUdseXBoSW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAxXSA9IGJhc2VBbmNob3IueSAtIG1hcmtSZWNvcmQueSArIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayB0byBtYXJrXG4gICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDYpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFyazFBcnJJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIubWFyazFDb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgIGlmIChtYXJrMUFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmV2R2x5cGhJZCA9IGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XTtcbiAgICAgICAgICAgICAgICAgIGlmIChnZXRHbHlwaENsYXNzKGZvbnQsIHByZXZHbHlwaElkKSA9PT0gMykgeyAvLyBvbmx5IGNoZWNrIG1hcmsgZ2x5cGhzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsyQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmsyQ292ZXJhZ2UsIHByZXZHbHlwaElkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmsyQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazFSZWNvcmQgPSB0YWIubWFyazFBcnJheVttYXJrMUFyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMkFuY2hvciA9IHRhYi5tYXJrMkFycmF5W21hcmsyQXJySW5kZXhdW21hcmsxUmVjb3JkLm1hcmtDbGFzc107XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzXSA9IG1hcmsyQW5jaG9yLnggLSBtYXJrMVJlY29yZC54ICsgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogM10gLSBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMV0gPSBtYXJrMkFuY2hvci55IC0gbWFyazFSZWNvcmQueSArIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sga2VybiB0YWJsZSBpZiBubyBHUE9TXG4gICAgICBlbHNlIGlmIChmb250Lmtlcm4gJiYgIWZvbnQuY2ZmKSB7XG4gICAgICAgIGNvbnN0IHByZXZHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoKTtcbiAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IGluZDEgPSBmb250Lmtlcm4uZ2x5cGgxLmluZGV4T2YoZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdKTtcbiAgICAgICAgICBpZiAoaW5kMSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZDIgPSBmb250Lmtlcm4ucnZhbFtpbmQxXS5nbHlwaDIuaW5kZXhPZihnbHlwaElkKTtcbiAgICAgICAgICAgIGlmIChpbmQyICE9PSAtMSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMl0gKz0gZm9udC5rZXJuLnJ2YWxbaW5kMV0udmFsc1tpbmQyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb25zO1xuXG4gICAgZnVuY3Rpb24gZ2V0UHJldkdseXBoSW5kZXgoZmlsdGVyKSB7XG4gICAgICBmb3IgKGxldCBpID0gZ2x5cGhJbmRleCAtIDE7IGkgPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKGdseXBoSWRzW2ldICE9PSAtMSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoZ2x5cGhJZHNbaV0pKSkge1xuICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Jhc2VHbHlwaChnbHlwaElkKSB7XG4gICAgICByZXR1cm4gZ2V0R2x5cGhDbGFzcyhmb250LCBnbHlwaElkKSA9PT0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVZhbHVlUmVjb3JkKHNvdXJjZSwgZ2kpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uc1tnaSAqIDMgKyBpXSArPSBzb3VyY2VbaV0gfHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRHbHlwaENsYXNzKGZvbnQsIGdseXBoSWQpIHtcbiAgICBjb25zdCBjbGFzc0RlZiA9IGZvbnQuR0RFRiAmJiBmb250LkdERUYuZ2x5cGhDbGFzc0RlZjtcbiAgICByZXR1cm4gY2xhc3NEZWYgPyBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZCwgY2xhc3NEZWYpIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0TnVtKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgUGFyc2VkRm9udFxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcEZvbnRPYmoodHlwckZvbnQpIHtcbiAgICBjb25zdCBnbHlwaE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBjb25zdCBvczIgPSB0eXByRm9udFsnT1MvMiddO1xuICAgIGNvbnN0IGhoZWEgPSB0eXByRm9udC5oaGVhO1xuICAgIGNvbnN0IHVuaXRzUGVyRW0gPSB0eXByRm9udC5oZWFkLnVuaXRzUGVyRW07XG4gICAgY29uc3QgYXNjZW5kZXIgPSBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvQXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5hc2NlbmRlciwgdW5pdHNQZXJFbSk7XG5cbiAgICAvKiogQHR5cGUgUGFyc2VkRm9udCAqL1xuICAgIGNvbnN0IGZvbnRPYmogPSB7XG4gICAgICB1bml0c1BlckVtLFxuICAgICAgYXNjZW5kZXIsXG4gICAgICBkZXNjZW5kZXI6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9EZXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5kZXNjZW5kZXIsIDApLFxuICAgICAgY2FwSGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnNDYXBIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIHhIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc3hIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIGxpbmVHYXA6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9MaW5lR2FwLCBoaGVhICYmIGhoZWEubGluZUdhcCksXG4gICAgICBzdXBwb3J0c0NvZGVQb2ludChjb2RlKSB7XG4gICAgICAgIHJldHVybiBUeXByLlUuY29kZVRvR2x5cGgodHlwckZvbnQsIGNvZGUpID4gMFxuICAgICAgfSxcbiAgICAgIGZvckVhY2hHbHlwaCh0ZXh0LCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHBlblggPSAwO1xuICAgICAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gZm9udE9iai51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICAgICAgY29uc3QgZ2x5cGhJZHMgPSBzdHJpbmdUb0dseXBocyh0eXByRm9udCwgdGV4dCk7XG4gICAgICAgIGxldCBjaGFySW5kZXggPSAwO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBjYWxjR2x5cGhQb3NpdGlvbnModHlwckZvbnQsIGdseXBoSWRzKTtcblxuICAgICAgICBnbHlwaElkcy5mb3JFYWNoKChnbHlwaElkLCBpKSA9PiB7XG4gICAgICAgICAgLy8gVHlwciByZXR1cm5zIGEgZ2x5cGggaW5kZXggcGVyIHN0cmluZyBjb2RlcG9pbnQsIHdpdGggLTFzIGluIHBsYWNlIG9mIHRob3NlIHRoYXRcbiAgICAgICAgICAvLyB3ZXJlIG9taXR0ZWQgZHVlIHRvIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbi4gU28gd2UgY2FuIHRyYWNrIG9yaWdpbmFsIGluZGV4IGluIHRoZVxuICAgICAgICAgIC8vIHN0cmluZyB2aWEgc2ltcGxlIGluY3JlbWVudCwgYW5kIHNraXAgZXZlcnl0aGluZyBlbHNlIHdoZW4gc2VlaW5nIGEgLTEuXG4gICAgICAgICAgaWYgKGdseXBoSWQgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaElkXTtcbiAgICAgICAgICAgIGlmICghZ2x5cGhPYmopIHtcbiAgICAgICAgICAgICAgY29uc3Qge2NtZHMsIGNyZHN9ID0gVHlwci5VLmdseXBoVG9QYXRoKHR5cHJGb250LCBnbHlwaElkKTtcblxuICAgICAgICAgICAgICAvLyBCdWlsZCBwYXRoIHN0cmluZ1xuICAgICAgICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgY3Jkc0lkeCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjbWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV07XG4gICAgICAgICAgICAgICAgcGF0aCArPSBjbWRzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IG51bUFyZ3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgcGF0aCArPSAoaiA+IDEgPyAnLCcgOiAnJykgKyBjcmRzW2NyZHNJZHgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmluZCBleHRlbnRzIC0gR2x5ZiBnaXZlcyB0aGlzIGluIG1ldGFkYXRhIGJ1dCBub3QgQ0ZGLCBhbmQgVHlwciBkb2Vzbid0XG4gICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdHdvLCBzbyBpdCdzIHNpbXBsZXN0IGp1c3QgdG8gaXRlcmF0ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgIGxldCB4TWluLCB5TWluLCB4TWF4LCB5TWF4O1xuICAgICAgICAgICAgICBpZiAoY3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4TWluID0geU1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHhNYXggPSB5TWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeCA9IGNyZHNbaV07XG4gICAgICAgICAgICAgICAgICBsZXQgeSA9IGNyZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgICAgICAgICAgICAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggPSB5TWluID0geU1heCA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSWRdID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBnbHlwaElkLFxuICAgICAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogdHlwckZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJZF0sXG4gICAgICAgICAgICAgICAgeE1pbixcbiAgICAgICAgICAgICAgICB5TWluLFxuICAgICAgICAgICAgICAgIHhNYXgsXG4gICAgICAgICAgICAgICAgeU1heCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBnbHlwaE9iaixcbiAgICAgICAgICAgICAgcGVuWCArIHBvc2l0aW9uc1tpICogM10gKiBmb250U2NhbGUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uc1tpICogMyArIDFdICogZm9udFNjYWxlLFxuICAgICAgICAgICAgICBjaGFySW5kZXhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBlblggKz0gcG9zaXRpb25zW2kgKiAzICsgMl0gKiBmb250U2NhbGU7XG4gICAgICAgICAgICBpZiAobGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICBwZW5YICs9IGxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhckluZGV4ICs9ICh0ZXh0LmNvZGVQb2ludEF0KGNoYXJJbmRleCkgPiAweGZmZmYgPyAyIDogMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwZW5YXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmb250T2JqXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgRm9udFBhcnNlclxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlKGJ1ZmZlcikge1xuICAgIC8vIExvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBXT0ZGIGZpbGUgYW5kIGNvbnZlcnQgaXQgaWYgc286XG4gICAgY29uc3QgcGVlayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgNCk7XG4gICAgY29uc3QgdGFnID0gVHlwci5fYmluLnJlYWRBU0NJSShwZWVrLCAwLCA0KTtcbiAgICBpZiAodGFnID09PSAnd09GRicpIHtcbiAgICAgIGJ1ZmZlciA9IHdvZmYyb3RmKGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd3T0YyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMiBmb250cyBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBGb250T2JqKFR5cHIucGFyc2UoYnVmZmVyKVswXSlcbiAgfVxufVxuXG5cbmNvbnN0IHdvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwciBGb250IFBhcnNlcicsXG4gIGRlcGVuZGVuY2llczogW3R5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnldLFxuICBpbml0KHR5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnkpIHtcbiAgICBjb25zdCBUeXByID0gdHlwckZhY3RvcnkoKTtcbiAgICBjb25zdCB3b2ZmMm90ZiA9IHdvZmYyb3RmRmFjdG9yeSgpO1xuICAgIHJldHVybiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKVxuICB9XG59KTtcblxuLyohXG5DdXN0b20gYnVuZGxlIG9mIEB1bmljb2RlLWZvbnQtcmVzb2x2ZXIvY2xpZW50IHYxLjAuMiAoaHR0cHM6Ly9naXRodWIuY29tL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXIpXG5mb3IgdXNlIGluIFRyb2lrYSB0ZXh0IHJlbmRlcmluZy4gXG5PcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzXG4qL1xuZnVuY3Rpb24gdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkoKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49ZnVuY3Rpb24oKXt0aGlzLmJ1Y2tldHM9bmV3IE1hcDt9O24ucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXt2YXIgbj10Pj41O3RoaXMuYnVja2V0cy5zZXQobiwodGhpcy5idWNrZXRzLmdldChuKXx8MCl8MTw8KDMxJnQpKTt9LG4ucHJvdG90eXBlLmhhcz1mdW5jdGlvbih0KXt2YXIgbj10aGlzLmJ1Y2tldHMuZ2V0KHQ+PjUpO3JldHVybiB2b2lkIDAhPT1uJiYwIT0obiYxPDwoMzEmdCkpfSxuLnByb3RvdHlwZS5zZXJpYWxpemU9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdGhpcy5idWNrZXRzLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dC5wdXNoKCgrcikudG9TdHJpbmcoMzYpK1wiOlwiK24udG9TdHJpbmcoMzYpKTt9KSksdC5qb2luKFwiLFwiKX0sbi5wcm90b3R5cGUuZGVzZXJpYWxpemU9ZnVuY3Rpb24odCl7dmFyIG49dGhpczt0aGlzLmJ1Y2tldHMuY2xlYXIoKSx0LnNwbGl0KFwiLFwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj10LnNwbGl0KFwiOlwiKTtuLmJ1Y2tldHMuc2V0KHBhcnNlSW50KHJbMF0sMzYpLHBhcnNlSW50KHJbMV0sMzYpKTt9KSk7fTt2YXIgcj1NYXRoLnBvdygyLDgpLGU9ci0xLG89fmU7ZnVuY3Rpb24gYSh0KXt2YXIgbj1mdW5jdGlvbih0KXtyZXR1cm4gdCZvfSh0KS50b1N0cmluZygxNiksZT1mdW5jdGlvbih0KXtyZXR1cm4gKHQmbykrci0xfSh0KS50b1N0cmluZygxNik7cmV0dXJuIFwiY29kZXBvaW50LWluZGV4L3BsYW5lXCIrKHQ+PjE2KStcIi9cIituK1wiLVwiK2UrXCIuanNvblwifWZ1bmN0aW9uIGkodCxuKXt2YXIgcj10JmUsbz1uLmNvZGVQb2ludEF0KHIvNnwwKTtyZXR1cm4gMCE9KChvPShvfHw0OCktNDgpJjE8PHIlNil9ZnVuY3Rpb24gdSh0LG4pe3ZhciByOyhyPXQsci5yZXBsYWNlKC9VXFwrL2dpLFwiXCIpLnJlcGxhY2UoL14sK3wsKyQvZyxcIlwiKS5zcGxpdCgvLCsvKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwbGl0KFwiLVwiKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludCh0LnRyaW0oKSwxNil9KSl9KSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sZT10WzFdO3ZvaWQgMD09PWUmJihlPXIpLG4ocixlKTt9KSk7fWZ1bmN0aW9uIGModCxuKXt1KHQsKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXQ7ZTw9cjtlKyspbihlKTt9KSk7fXZhciBzPXt9LGY9e30sbD1uZXcgV2Vha01hcCx2PVwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXJAdjEuMC4xL3BhY2thZ2VzL2RhdGFcIjtmdW5jdGlvbiBkKHQpe3ZhciByPWwuZ2V0KHQpO3JldHVybiByfHwocj1uZXcgbixjKHQucmFuZ2VzLChmdW5jdGlvbih0KXtyZXR1cm4gci5hZGQodCl9KSksbC5zZXQodCxyKSkscn12YXIgaCxwPW5ldyBNYXA7ZnVuY3Rpb24gZyh0LG4scil7cmV0dXJuIHRbbl0/bjp0W3JdP3I6ZnVuY3Rpb24odCl7Zm9yKHZhciBuIGluIHQpcmV0dXJuIG59KHQpfWZ1bmN0aW9uIHcodCxuKXt2YXIgcj1uO2lmKCF0LmluY2x1ZGVzKHIpKXtyPTEvMDtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylNYXRoLmFicyh0W2VdLW4pPE1hdGguYWJzKHItbikmJihyPXRbZV0pO31yZXR1cm4gcn1mdW5jdGlvbiBrKHQpe3JldHVybiBofHwoaD1uZXcgU2V0LGMoXCI5LUQsMjAsODUsQTAsMTY4MCwyMDAwLTIwMEEsMjAyOC0yMDJGLDIwNUYsMzAwMFwiLChmdW5jdGlvbih0KXtoLmFkZCh0KTt9KSkpLGguaGFzKHQpfXJldHVybiB0LkNvZGVQb2ludFNldD1uLHQuY2xlYXJDYWNoZT1mdW5jdGlvbigpe3M9e30sZj17fTt9LHQuZ2V0Rm9udHNGb3JTdHJpbmc9ZnVuY3Rpb24odCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIHIsZT1uLmxhbmc7dm9pZCAwPT09ZSYmKGU9L1xccHtTY3JpcHQ9SGFuZ3VsfS91LnRlc3Qocj10KT9cImtvXCI6L1xccHtTY3JpcHQ9SGlyYWdhbmF9fFxccHtTY3JpcHQ9S2F0YWthbmF9L3UudGVzdChyKT9cImphXCI6XCJlblwiKTt2YXIgbz1uLmNhdGVnb3J5O3ZvaWQgMD09PW8mJihvPVwic2Fucy1zZXJpZlwiKTt2YXIgdT1uLnN0eWxlO3ZvaWQgMD09PXUmJih1PVwibm9ybWFsXCIpO3ZhciBjPW4ud2VpZ2h0O3ZvaWQgMD09PWMmJihjPTQwMCk7dmFyIGw9KG4uZGF0YVVybHx8dikucmVwbGFjZSgvXFwvJC9nLFwiXCIpLGg9bmV3IE1hcCx5PW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxiPXt9LG09e30sQT1uZXcgQXJyYXkodC5sZW5ndGgpLFM9bmV3IE1hcCxqPSExO2Z1bmN0aW9uIE0odCl7dmFyIG49cC5nZXQodCk7cmV0dXJuIG58fChuPWZldGNoKGwrXCIvXCIrdCkudGhlbigoZnVuY3Rpb24odCl7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKHQuc3RhdHVzVGV4dCk7cmV0dXJuIHQuanNvbigpLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCFBcnJheS5pc0FycmF5KHQpfHwxIT09dFswXSl0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3Qgc2NoZW1hIHZlcnNpb247IG5lZWQgMSwgZ290IFwiK3RbMF0pO3JldHVybiB0WzFdfSkpfSkpLmNhdGNoKChmdW5jdGlvbihuKXtpZihsIT09dilyZXR1cm4ganx8KGNvbnNvbGUuZXJyb3IoJ3VuaWNvZGUtZm9udC1yZXNvbHZlcjogRmFpbGVkIGxvYWRpbmcgZnJvbSBkYXRhVXJsIFwiJytsKydcIiwgdHJ5aW5nIGRlZmF1bHQgQ0ROLiAnK24ubWVzc2FnZSksaj0hMCksbD12LHAuZGVsZXRlKHQpLE0odCk7dGhyb3cgbn0pKSxwLnNldCh0LG4pKSxufWZvcih2YXIgUD1mdW5jdGlvbihuKXt2YXIgcj10LmNvZGVQb2ludEF0KG4pLGU9YShyKTtBW25dPWUsc1tlXXx8Uy5oYXMoZSl8fFMuc2V0KGUsTShlKS50aGVuKChmdW5jdGlvbih0KXtzW2VdPXQ7fSkpKSxyPjY1NTM1JiYobisrLEU9bik7fSxFPTA7RTx0Lmxlbmd0aDtFKyspUChFKTtyZXR1cm4gUHJvbWlzZS5hbGwoUy52YWx1ZXMoKSkudGhlbigoZnVuY3Rpb24oKXtTLmNsZWFyKCk7Zm9yKHZhciBuPWZ1bmN0aW9uKG4pe3ZhciBvPXQuY29kZVBvaW50QXQobiksYT1udWxsLHU9c1tBW25dXSxjPXZvaWQgMDtmb3IodmFyIGwgaW4gdSl7dmFyIHY9bVtsXTtpZih2b2lkIDA9PT12JiYodj1tW2xdPW5ldyBSZWdFeHAobCkudGVzdChlfHxcImVuXCIpKSx2KXtmb3IodmFyIGQgaW4gYz1sLHVbbF0paWYoaShvLHVbbF1bZF0pKXthPWQ7YnJlYWt9YnJlYWt9fWlmKCFhKXQ6Zm9yKHZhciBoIGluIHUpaWYoaCE9PWMpZm9yKHZhciBwIGluIHVbaF0paWYoaShvLHVbaF1bcF0pKXthPXA7YnJlYWsgdH1hfHwoY29uc29sZS5kZWJ1ZyhcIk5vIGZvbnQgY292ZXJhZ2UgZm9yIFUrXCIrby50b1N0cmluZygxNikpLGE9XCJsYXRpblwiKSxBW25dPWEsZlthXXx8Uy5oYXMoYSl8fFMuc2V0KGEsTShcImZvbnQtbWV0YS9cIithK1wiLmpzb25cIikudGhlbigoZnVuY3Rpb24odCl7ZlthXT10O30pKSksbz42NTUzNSYmKG4rKyxyPW4pO30scj0wO3I8dC5sZW5ndGg7cisrKW4ocik7cmV0dXJuIFByb21pc2UuYWxsKFMudmFsdWVzKCkpfSkpLnRoZW4oKGZ1bmN0aW9uKCl7Zm9yKHZhciBuLHI9bnVsbCxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBhPXQuY29kZVBvaW50QXQoZSk7aWYociYmKGsoYSl8fGQocikuaGFzKGEpKSl5W2VdPXlbZS0xXTtlbHNlIHtyPWZbQVtlXV07dmFyIGk9YltyLmlkXTtpZighaSl7dmFyIHM9ci50eXBlZm9ybXMsdj1nKHMsbyxcInNhbnMtc2VyaWZcIikscD1nKHNbdl0sdSxcIm5vcm1hbFwiKSxtPXcobnVsbD09PShuPXNbdl0pfHx2b2lkIDA9PT1uP3ZvaWQgMDpuW3BdLGMpO2k9YltyLmlkXT1sK1wiL2ZvbnQtZmlsZXMvXCIrci5pZCtcIi9cIit2K1wiLlwiK3ArXCIuXCIrbStcIi53b2ZmXCI7fXZhciBTPWguZ2V0KGkpO251bGw9PVMmJihTPWguc2l6ZSxoLnNldChpLFMpKSx5W2VdPVM7fWE+NjU1MzUmJihlKysseVtlXT15W2UtMV0pO31yZXR1cm4ge2ZvbnRVcmxzOkFycmF5LmZyb20oaC5rZXlzKCkpLGNoYXJzOnl9fSkpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0fSh7fSl9XG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZyB8IHtzcmM6c3RyaW5nLCBsYWJlbD86c3RyaW5nLCB1bmljb2RlUmFuZ2U/OnN0cmluZywgbGFuZz86c3RyaW5nfX0gVXNlckZvbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDbGllbnRPcHRpb25zfSBGb250UmVzb2x2ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PFVzZXJGb250PnxVc2VyRm9udH0gW2ZvbnRzXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnaXRhbGljJ30gW3N0eWxlXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnYm9sZCd8bnVtYmVyfSBbc3R5bGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VuaWNvZGVGb250c1VSTF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZvbnRSZXNvbHZlclJlc3VsdFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBjaGFyc1xuICogQHByb3BlcnR5IHtBcnJheTxQYXJzZWRGb250ICYge3NyYzpzdHJpbmd9Pn0gZm9udHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gRm9udFJlc29sdmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHsoRm9udFJlc29sdmVyUmVzdWx0KSA9PiB2b2lkfSBjYWxsYmFja1xuICogQHBhcmFtIHtGb250UmVzb2x2ZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuXG4vKipcbiAqIEZhY3RvcnkgZm9yIHRoZSBGb250UmVzb2x2ZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0ZvbnRQYXJzZXJ9IGZvbnRQYXJzZXJcbiAqIEBwYXJhbSB7e2dldEZvbnRzRm9yU3RyaW5nOiBmdW5jdGlvbiwgQ29kZVBvaW50U2V0OiBmdW5jdGlvbn19IHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRcbiAqIEByZXR1cm4ge0ZvbnRSZXNvbHZlcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9udFJlc29sdmVyKGZvbnRQYXJzZXIsIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBQYXJzZWRGb250Pn1cbiAgICovXG4gIGNvbnN0IHBhcnNlZEZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvKipcbiAgICogQHR5cGUge1JlY29yZDxzdHJpbmcsIEFycmF5PChQYXJzZWRGb250KSA9PiB2b2lkPj59XG4gICAqL1xuICBjb25zdCBsb2FkaW5nRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgZ2l2ZW4gZm9udCB1cmxcbiAgICovXG4gIGZ1bmN0aW9uIGRvTG9hZEZvbnQodXJsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbHVyZSBsb2FkaW5nIGZvbnQgJHt1cmx9YCwgZXJyKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID4gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmb250T2JqID0gZm9udFBhcnNlcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGZvbnRPYmouc3JjID0gdXJsO1xuICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBMb2FkIGEgZ2l2ZW4gZm9udCB1cmwgaWYgbmVlZGVkLCBpbnZva2luZyBhIGNhbGxiYWNrIHdoZW4gaXQncyBsb2FkZWQuIElmIGFscmVhZHlcbiAgICogbG9hZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRVcmxcbiAgICogQHBhcmFtIHsoZm9udDogUGFyc2VkRm9udCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRGb250KGZvbnRVcmwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGZvbnQgPSBwYXJzZWRGb250c1tmb250VXJsXTtcbiAgICBpZiAoZm9udCkge1xuICAgICAgY2FsbGJhY2soZm9udCk7XG4gICAgfSBlbHNlIGlmIChsb2FkaW5nRm9udHNbZm9udFVybF0pIHtcbiAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdID0gW2NhbGxiYWNrXTtcbiAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgIGZvbnRPYmouc3JjID0gZm9udFVybDtcbiAgICAgICAgcGFyc2VkRm9udHNbZm9udFVybF0gPSBmb250T2JqO1xuICAgICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0uZm9yRWFjaChjYiA9PiBjYihmb250T2JqKSk7XG4gICAgICAgIGRlbGV0ZSBsb2FkaW5nRm9udHNbZm9udFVybF07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIGRldGVybWluZSB3aGljaCBmb250cyBhcmUgcmVxdWlyZWQgdG8gZnVsbHkgcmVuZGVyIGl0IGFuZFxuICAgKiBlbnN1cmUgdGhvc2UgZm9udHMgYXJlIGxvYWRlZC5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAodGV4dCwgY2FsbGJhY2ssIHtcbiAgICBsYW5nLFxuICAgIGZvbnRzOiB1c2VyRm9udHMgPSBbXSxcbiAgICBzdHlsZSA9ICdub3JtYWwnLFxuICAgIHdlaWdodCA9ICdub3JtYWwnLFxuICAgIHVuaWNvZGVGb250c1VSTFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBjaGFyUmVzb2x1dGlvbnMgPSBuZXcgVWludDhBcnJheSh0ZXh0Lmxlbmd0aCk7XG4gICAgY29uc3QgZm9udFJlc29sdXRpb25zID0gW107XG4gICAgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgICAgYWxsRG9uZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRJbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZhbGxiYWNrUmFuZ2VzID0gW107IC8vIFtbc3RhcnQsIGVuZF0sIC4uLl1cblxuICAgIGlmIChzdHlsZSAhPT0gJ2l0YWxpYycpIHN0eWxlID0gJ25vcm1hbCc7XG4gICAgaWYgKHR5cGVvZiB3ZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICB3ZWlnaHQgPSB3ZWlnaHQgPT09ICdib2xkJyA/IDcwMCA6IDQwMDtcbiAgICB9XG5cbiAgICBpZiAodXNlckZvbnRzICYmICFBcnJheS5pc0FycmF5KHVzZXJGb250cykpIHtcbiAgICAgIHVzZXJGb250cyA9IFt1c2VyRm9udHNdO1xuICAgIH1cbiAgICB1c2VyRm9udHMgPSB1c2VyRm9udHMuc2xpY2UoKVxuICAgICAgLy8gZmlsdGVyIGJ5IGxhbmd1YWdlXG4gICAgICAuZmlsdGVyKGRlZiA9PiAhZGVmLmxhbmcgfHwgZGVmLmxhbmcudGVzdChsYW5nKSlcbiAgICAgIC8vIHN3aXRjaCBvcmRlciBmb3IgZWFzaWVyIGl0ZXJhdGlvblxuICAgICAgLnJldmVyc2UoKTtcbiAgICBpZiAodXNlckZvbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgVU5LTk9XTiA9IDA7XG4gICAgICBjb25zdCBSRVNPTFZFRCA9IDE7XG4gICAgICBjb25zdCBORUVEU19GQUxMQkFDSyA9IDI7XG4gICAgICBsZXQgcHJldkNoYXJSZXN1bHQgPSBVTktOT1dOXG5cbiAgICAgIDsoZnVuY3Rpb24gcmVzb2x2ZVVzZXJGb250cyAoc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXgsIGlMZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHRleHQuY29kZVBvaW50QXQoaSk7XG4gICAgICAgICAgLy8gQ2FycnkgcHJldmlvdXMgY2hhcmFjdGVyJ3MgcmVzdWx0IGZvcndhcmQgaWY6XG4gICAgICAgICAgLy8gLSBpdCByZXNvbHZlZCB0byBhIGZvbnQgdGhhdCBhbHNvIGNvdmVycyB0aGlzIGNoYXJhY3RlclxuICAgICAgICAgIC8vIC0gdGhpcyBjaGFyYWN0ZXIgaXMgd2hpdGVzcGFjZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwcmV2Q2hhclJlc3VsdCA9PT0gUkVTT0xWRUQgJiYgZm9udFJlc29sdXRpb25zW2NoYXJSZXNvbHV0aW9uc1tpIC0gMV1dLnN1cHBvcnRzQ29kZVBvaW50KGNvZGVQb2ludCkpIHx8XG4gICAgICAgICAgICAvXFxzLy50ZXN0KHRleHRbaV0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBjaGFyUmVzb2x1dGlvbnNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSykge1xuICAgICAgICAgICAgICBmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGggLSAxXVsxXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY2hhclJlc29sdXRpb25zW2ldLCBqTGVuID0gdXNlckZvbnRzLmxlbmd0aDsgaiA8PSBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGogPT09IGpMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSB1c2VyIGZvbnRzIG1hdGNoZWQ7IG5lZWRzIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0sgP1xuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV0gOlxuICAgICAgICAgICAgICAgICAgKGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aF0gPSBbaSwgaV0pO1xuICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gaTtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhclJlc3VsdCA9IE5FRURTX0ZBTExCQUNLO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tpXSA9IGo7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzcmMsIHVuaWNvZGVSYW5nZSB9ID0gdXNlckZvbnRzW2pdO1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBieSBvcHRpb25hbCBleHBsaWNpdCB1bmljb2RlIHJhbmdlc1xuICAgICAgICAgICAgICAgIGlmICghdW5pY29kZVJhbmdlIHx8IGlzQ29kZUluUmFuZ2VzKGNvZGVQb2ludCwgdW5pY29kZVJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IHBhcnNlZEZvbnRzW3NyY107XG4gICAgICAgICAgICAgICAgICAvLyBmb250IG5vdCB5ZXQgbG9hZGVkLCBsb2FkIGl0IGFuZCByZXN1bWVcbiAgICAgICAgICAgICAgICAgIGlmICghZm9udE9iaikge1xuICAgICAgICAgICAgICAgICAgICBsb2FkRm9udChzcmMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVXNlckZvbnRzKGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZvbnQgYWN0dWFsbHkgY29udGFpbnMgYSBnbHlwaCBmb3IgdGhpcyBjaGFyLCBsb2NrIGl0IGluXG4gICAgICAgICAgICAgICAgICBpZiAoZm9udE9iai5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb250SW5kZXggPSBmb250SW5kaWNlcy5nZXQoZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9udEluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvbnRJbmRleCA9IGZvbnRSZXNvbHV0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zLnB1c2goZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgZm9udEluZGljZXMuc2V0KGZvbnRPYmosIGZvbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gZm9udEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hhclJlc3VsdCA9IFJFU09MVkVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmICYmIGkgKyAxIDwgaUxlbikge1xuICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2kgKyAxXSA9IGNoYXJSZXNvbHV0aW9uc1tpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0spIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV1bMV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlRmFsbGJhY2tzKCk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFja1Jhbmdlcy5wdXNoKFswLCB0ZXh0Lmxlbmd0aCAtIDFdKTtcbiAgICAgIHJlc29sdmVGYWxsYmFja3MoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlRmFsbGJhY2tzKCkge1xuICAgICAgaWYgKGZhbGxiYWNrUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAvLyBDb21iaW5lIGFsbCBmYWxsYmFjayBzdWJzdHJpbmdzIGludG8gYSBzaW5nbGUgc3RyaW5nIGZvciBxdWVyeWluZ1xuICAgICAgICBjb25zdCBmYWxsYmFja1N0cmluZyA9IGZhbGxiYWNrUmFuZ2VzLm1hcChyYW5nZSA9PiB0ZXh0LnN1YnN0cmluZyhyYW5nZVswXSwgcmFuZ2VbMV0gKyAxKSkuam9pbignXFxuJyk7XG4gICAgICAgIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQuZ2V0Rm9udHNGb3JTdHJpbmcoZmFsbGJhY2tTdHJpbmcsIHtcbiAgICAgICAgICBsYW5nOiBsYW5nIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgZGF0YVVybDogdW5pY29kZUZvbnRzVVJMXG4gICAgICAgIH0pLnRoZW4oKHtmb250VXJscywgY2hhcnN9KSA9PiB7XG4gICAgICAgICAgLy8gRXh0cmFjdCByZXN1bHRzIGFuZCBwdXQgdGhlbSBiYWNrIGluIHRoZSBtYWluIGFycmF5XG4gICAgICAgICAgY29uc3QgZm9udEluZGV4T2Zmc2V0ID0gZm9udFJlc29sdXRpb25zLmxlbmd0aDtcbiAgICAgICAgICBsZXQgY2hhcklkeCA9IDA7XG4gICAgICAgICAgZmFsbGJhY2tSYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZW5kSWR4ID0gcmFuZ2VbMV0gLSByYW5nZVswXTsgaSA8PSBlbmRJZHg7IGkrKykge1xuICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbcmFuZ2VbMF0gKyBpXSA9IGNoYXJzW2NoYXJJZHgrK10gKyBmb250SW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFySWR4Kys7IC8vc2tpcCBzZWdtZW50IHNlcGFyYXRvclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTG9hZCBhbmQgcGFyc2UgdGhlIGZhbGxiYWNrIGZvbnRzIC0gYXZvaWRpbmcgUHJvbWlzZSBoZXJlIHRvIHByZXZlbnQgcG9seWZpbGxzIGluIHRoZSB3b3JrZXJcbiAgICAgICAgICBsZXQgbG9hZGVkQ291bnQgPSAwO1xuICAgICAgICAgIGZvbnRVcmxzLmZvckVhY2goKHVybCwgaSkgPT4ge1xuICAgICAgICAgICAgbG9hZEZvbnQodXJsLCBmb250T2JqID0+IHtcbiAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zW2kgKyBmb250SW5kZXhPZmZzZXRdID0gZm9udE9iajtcbiAgICAgICAgICAgICAgaWYgKCsrbG9hZGVkQ291bnQgPT09IGZvbnRVcmxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsbERvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsRG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbERvbmUoKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGNoYXJzOiBjaGFyUmVzb2x1dGlvbnMsXG4gICAgICAgIGZvbnRzOiBmb250UmVzb2x1dGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ29kZUluUmFuZ2VzKGNvZGUsIHJhbmdlcykge1xuICAgICAgLy8gdG9kbyBvcHRpbWl6ZSBzZWFyY2ggLSBDb2RlUG9pbnRTZXQgZnJvbSB1bmljb2RlLWZvbnQtcmVzb2x2ZXI/XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJhbmdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZCA9IHN0YXJ0XSA9IHJhbmdlc1trXTtcbiAgICAgICAgaWYgKHN0YXJ0IDw9IGNvZGUgJiYgY29kZSA8PSBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdGb250UmVzb2x2ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBjcmVhdGVGb250UmVzb2x2ZXIsXG4gICAgd29ya2VyTW9kdWxlLFxuICAgIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5LFxuICBdLFxuICBpbml0KGNyZWF0ZUZvbnRSZXNvbHZlciwgZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkpIHtcbiAgICByZXR1cm4gY3JlYXRlRm9udFJlc29sdmVyKGZvbnRQYXJzZXIsIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KCkpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfCdsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfSBBbmNob3JYVmFsdWVcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfCd0b3AnfCd0b3AtYmFzZWxpbmUnfCd0b3AtY2FwJ3wndG9wLWV4J3wnbWlkZGxlJ3wnYm90dG9tLWJhc2VsaW5lJ3wnYm90dG9tJ30gQW5jaG9yWVZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0UGFyYW1zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dFxuICogQHByb3BlcnR5IHtVc2VyRm9udHxVc2VyRm9udFtdfSBbZm9udF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2RmR2x5cGhTaXplPTY0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb250U2l6ZT0xXVxuICogQHByb3BlcnR5IHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfSBbZm9udFdlaWdodD0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtmb250U3R5bGU9J25vcm1hbCddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xldHRlclNwYWNpbmc9MF1cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8bnVtYmVyfSBbbGluZUhlaWdodD0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4V2lkdGhdXG4gKiBAcHJvcGVydHkgeydsdHInfCdydGwnfSBbZGlyZWN0aW9uPSdsdHInXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0SW5kZW50PTBdXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdub3dyYXAnfSBbd2hpdGVTcGFjZT0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2JyZWFrLXdvcmQnfSBbb3ZlcmZsb3dXcmFwPSdub3JtYWwnXVxuICogQHByb3BlcnR5IHtBbmNob3JYVmFsdWV9IFthbmNob3JYPTBdXG4gKiBAcHJvcGVydHkge0FuY2hvcllWYWx1ZX0gW2FuY2hvclk9MF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21ldHJpY3NPbmx5PWZhbHNlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gKiBAcHJvcGVydHkge0ZvbnRSZXNvbHZlclJlc3VsdH0gW3ByZVJlc29sdmVkRm9udHNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbmNsdWRlQ2FyZXRQb3NpdGlvbnM9ZmFsc2VdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NodW5rZWRCb3VuZHNTaXplPTgxOTJdXG4gKiBAcHJvcGVydHkge3tbcmFuZ2VTdGFydEluZGV4XTogbnVtYmVyfX0gW2NvbG9yUmFuZ2VzXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldFJlc3VsdFxuICogQHByb3BlcnR5IHtVaW50MTZBcnJheX0gZ2x5cGhJZHMgaWQgZm9yIGVhY2ggZ2x5cGgsIHNwZWNpZmljIHRvIHRoYXQgZ2x5cGgncyBmb250XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGdseXBoRm9udEluZGljZXMgaW5kZXggaW50byBmb250RGF0YSBmb3IgZWFjaCBnbHlwaFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoUG9zaXRpb25zIHgseSBvZiBlYWNoIGdseXBoJ3Mgb3JpZ2luIGluIGxheW91dFxuICogQHByb3BlcnR5IHt7W2ZvbnRdOiB7W2dseXBoSWRdOiB7cGF0aDogc3RyaW5nLCBwYXRoQm91bmRzOiBudW1iZXJbXX19fX0gZ2x5cGhEYXRhIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAqIEBwcm9wZXJ0eSB7VHlwZXNldEZvbnREYXRhW119IGZvbnREYXRhIGRhdGEgYWJvdXQgZWFjaCBmb250IHVzZWQgaW4gdGhlIHRleHRcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBbY2FyZXRQb3NpdGlvbnNdIHN0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSBjb2xvciBmb3IgZWFjaCBnbHlwaCwgaWYgY29sb3IgcmFuZ2VzIHN1cHBsaWVkXG4gKiAgICAgICAgIGNodW5rZWRCb3VuZHMsIC8vdG90YWwgcmVjdHMgcGVyIChuPWNodW5rZWRCb3VuZHNTaXplKSBjb25zZWN1dGl2ZSBnbHlwaHNcbiAqICAgICAgICAgZm9udFNpemUsIC8vY2FsY3VsYXRlZCBlbSBoZWlnaHRcbiAqICAgICAgICAgdG9wQmFzZWxpbmU6IGFuY2hvcllPZmZzZXQgKyBsaW5lc1swXS5iYXNlbGluZSwgLy95IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmVcbiAqICAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICogICAgICAgICAgIGFuY2hvclhPZmZzZXQsXG4gKiAgICAgICAgICAgYW5jaG9yWU9mZnNldCAtIHRvdGFsSGVpZ2h0LFxuICogICAgICAgICAgIGFuY2hvclhPZmZzZXQgKyBtYXhMaW5lV2lkdGgsXG4gKiAgICAgICAgICAgYW5jaG9yWU9mZnNldFxuICogICAgICAgICBdLFxuICogICAgICAgICB2aXNpYmxlQm91bmRzLCAvL3RvdGFsIGJvdW5kcyBvZiB2aXNpYmxlIHRleHQgcGF0aHMsIG1heSBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIGJsb2NrQm91bmRzXG4gKiAgICAgICAgIHRpbWluZ3NcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR5cGVzZXRGb250RGF0YVxuICogQHByb3BlcnR5IHNyY1xuICogQHByb3BlcnR5IHVuaXRzUGVyRW1cbiAqIEBwcm9wZXJ0eSBhc2NlbmRlclxuICogQHByb3BlcnR5IGRlc2NlbmRlclxuICogQHByb3BlcnR5IGxpbmVIZWlnaHRcbiAqIEBwcm9wZXJ0eSBjYXBIZWlnaHRcbiAqIEBwcm9wZXJ0eSB4SGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb24gLSBjb21wdXRlIGZvbnRzIGFuZCBsYXlvdXQgZm9yIHNvbWUgdGV4dC5cbiAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gcGFyYW1zXG4gKiBAcGFyYW0geyhUeXBlc2V0UmVzdWx0KSA9PiB2b2lkfSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHR5cGVzZXR0aW5nIGlzIGNvbXBsZXRlLlxuICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gVHlwZXNldHRlck1lYXN1cmVGdW5jdGlvbiAtIGNvbXB1dGUgd2lkdGgvaGVpZ2h0IGZvciBzb21lIHRleHQuXG4gKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IHBhcmFtc1xuICogQHBhcmFtIHsod2lkdGg6bnVtYmVyLCBoZWlnaHQ6bnVtYmVyKSA9PiB2b2lkfSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG1lYXN1cmVtZW50IGlzIGNvbXBsZXRlLlxuICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAqL1xuXG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHR5cGVzZXR0aW5nIHJlcXVlc3RzLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIG5vIGNsb3N1cmUgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IGl0IGNhbiBiZSBlYXNpbHkgaW5qZWN0ZWRcbiAqIGludG8gdGhlIHNvdXJjZSBmb3IgYSBXb3JrZXIgd2l0aG91dCByZXF1aXJpbmcgYSBidWlsZCBzdGVwIG9yIGNvbXBsZXggZGVwZW5kZW5jeSBsb2FkaW5nLiBBbGwgaXRzXG4gKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtGb250UmVzb2x2ZXJ9IHJlc29sdmVGb250cyAtIGZ1bmN0aW9uIHRvIHJlc29sdmUgYSBzdHJpbmcgdG8gcGFyc2VkIGZvbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gYmlkaSAtIHRoZSBiaWRpLmpzIGltcGxlbWVudGF0aW9uIG9iamVjdFxuICogQHJldHVybiB7e3R5cGVzZXQ6IFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb24sIG1lYXN1cmU6IFR5cGVzZXR0ZXJNZWFzdXJlRnVuY3Rpb259fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUeXBlc2V0dGVyKHJlc29sdmVGb250cywgYmlkaSkge1xuICBjb25zdCBJTkYgPSBJbmZpbml0eTtcblxuICAvLyBTZXQgb2YgVW5pY29kZSBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IGNoYXJhY3RlcnMsIHRoZXNlIHdpbGwgbm90IHByb2R1Y2UgdmlzaWJsZSBnbHlwaHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG4gIGNvbnN0IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTID0gL1tcXHUwMEFEXFx1MDM0RlxcdTA2MUNcXHUxMTVGLVxcdTExNjBcXHUxN0I0LVxcdTE3QjVcXHUxODBCLVxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUzMTY0XFx1RkUwMC1cXHVGRTBGXFx1RkVGRlxcdUZGQTBcXHVGRkYwLVxcdUZGRjhdLztcblxuICAvLyBUaGlzIHJlZ2V4IChpbnN0ZWFkIG9mIC9cXHMvKSBhbGxvd3MgdXMgdG8gc2VsZWN0IGFsbCB3aGl0ZXNwYWNlIEVYQ0VQVCBmb3Igbm9uLWJyZWFraW5nIHdoaXRlIHNwYWNlc1xuICBjb25zdCBsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlID0gYFteXFxcXFNcXFxcdTAwQTBdYDtcblxuICAvLyBJbmNvbXBsZXRlIHNldCBvZiBjaGFyYWN0ZXJzIHRoYXQgYWxsb3cgbGluZSBicmVha2luZyBhZnRlciB0aGVtXG4gIC8vIEluIHRoZSBmdXR1cmUgd2UgbWF5IGNvbnNpZGVyIGEgZnVsbCBVbmljb2RlIGxpbmUgYnJlYWtpbmcgYWxnb3JpdGhtIGltcGw6IGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIxNFxuICBjb25zdCBCUkVBS19BRlRFUl9DSEFSUyA9IG5ldyBSZWdFeHAoYCR7bGluZUJyZWFraW5nV2hpdGVTcGFjZX18W1xcXFwtXFxcXHUwMDdDXFxcXHUwMEFEXFxcXHUyMDEwXFxcXHUyMDEyLVxcXFx1MjAxNFxcXFx1MjAyN1xcXFx1MjA1NlxcXFx1MkUxN1xcXFx1MkU0MF1gKTtcblxuICAvKipcbiAgICogTG9hZCBhbmQgcGFyc2UgYWxsIHRoZSBuZWNlc3NhcnkgZm9udHMgdG8gcmVuZGVyIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIHRoZW4gZ3JvdXBcbiAgICogdGhlbSBpbnRvIGNvbnNlY3V0aXZlIHJ1bnMgb2YgY2hhcmFjdGVycyBzaGFyaW5nIGEgZm9udC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZvbnRSdW5zKHt0ZXh0LCBsYW5nLCBmb250cywgc3R5bGUsIHdlaWdodCwgcHJlUmVzb2x2ZWRGb250cywgdW5pY29kZUZvbnRzVVJMfSwgb25Eb25lKSB7XG4gICAgY29uc3Qgb25SZXNvbHZlZCA9ICh7Y2hhcnMsIGZvbnRzOiBwYXJzZWRGb250c30pID0+IHtcbiAgICAgIGxldCBjdXJSdW4sIHByZXZWYWw7XG4gICAgICBjb25zdCBydW5zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGFyc1tpXSAhPT0gcHJldlZhbCkge1xuICAgICAgICAgIHByZXZWYWwgPSBjaGFyc1tpXTtcbiAgICAgICAgICBydW5zLnB1c2goY3VyUnVuID0geyBzdGFydDogaSwgZW5kOiBpLCBmb250T2JqOiBwYXJzZWRGb250c1tjaGFyc1tpXV19KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJSdW4uZW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25Eb25lKHJ1bnMpO1xuICAgIH07XG4gICAgaWYgKHByZVJlc29sdmVkRm9udHMpIHtcbiAgICAgIG9uUmVzb2x2ZWQocHJlUmVzb2x2ZWRGb250cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVGb250cyhcbiAgICAgICAgdGV4dCxcbiAgICAgICAgb25SZXNvbHZlZCxcbiAgICAgICAgeyBsYW5nLCBmb250cywgc3R5bGUsIHdlaWdodCwgdW5pY29kZUZvbnRzVVJMIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAqIFByb2Nlc3MgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgYW5kIGZvcm1hdHRpbmcgcGFyYW1ldGVycywgYW5kIHJldHVybiBhbGwgaW5mb1xuICAgKiBuZWNlc3NhcnkgdG8gcmVuZGVyIGFsbCBpdHMgZ2x5cGhzLlxuICAgKiBAdHlwZSBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlc2V0KFxuICAgIHtcbiAgICAgIHRleHQ9JycsXG4gICAgICBmb250LFxuICAgICAgbGFuZyxcbiAgICAgIHNkZkdseXBoU2l6ZT02NCxcbiAgICAgIGZvbnRTaXplPTQwMCxcbiAgICAgIGZvbnRXZWlnaHQ9MSxcbiAgICAgIGZvbnRTdHlsZT0nbm9ybWFsJyxcbiAgICAgIGxldHRlclNwYWNpbmc9MCxcbiAgICAgIGxpbmVIZWlnaHQ9J25vcm1hbCcsXG4gICAgICBtYXhXaWR0aD1JTkYsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0ZXh0QWxpZ249J2xlZnQnLFxuICAgICAgdGV4dEluZGVudD0wLFxuICAgICAgd2hpdGVTcGFjZT0nbm9ybWFsJyxcbiAgICAgIG92ZXJmbG93V3JhcD0nbm9ybWFsJyxcbiAgICAgIGFuY2hvclggPSAwLFxuICAgICAgYW5jaG9yWSA9IDAsXG4gICAgICBtZXRyaWNzT25seT1mYWxzZSxcbiAgICAgIHVuaWNvZGVGb250c1VSTCxcbiAgICAgIHByZVJlc29sdmVkRm9udHM9bnVsbCxcbiAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9ucz1mYWxzZSxcbiAgICAgIGNodW5rZWRCb3VuZHNTaXplPTgxOTIsXG4gICAgICBjb2xvclJhbmdlcz1udWxsXG4gICAgfSxcbiAgICBjYWxsYmFja1xuICApIHtcbiAgICBjb25zdCBtYWluU3RhcnQgPSBub3coKTtcbiAgICBjb25zdCB0aW1pbmdzID0ge2ZvbnRMb2FkOiAwLCB0eXBlc2V0dGluZzogMH07XG5cbiAgICAvLyBFbnN1cmUgbmV3bGluZXMgYXJlIG5vcm1hbGl6ZWRcbiAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1R5cGVzZXR0ZXI6IGdvdCB0ZXh0IHdpdGggXFxcXHIgY2hhcnM7IG5vcm1hbGl6aW5nIHRvIFxcXFxuJyk7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHdlJ3ZlIGdvdCBudW1iZXJzIG5vdCBzdHJpbmdzXG4gICAgZm9udFNpemUgPSArZm9udFNpemU7XG4gICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgIG1heFdpZHRoID0gK21heFdpZHRoO1xuICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0IHx8ICdub3JtYWwnO1xuICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgIGNhbGN1bGF0ZUZvbnRSdW5zKHtcbiAgICAgIHRleHQsXG4gICAgICBsYW5nLFxuICAgICAgc3R5bGU6IGZvbnRTdHlsZSxcbiAgICAgIHdlaWdodDogZm9udFdlaWdodCxcbiAgICAgIGZvbnRzOiB0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycgPyBbe3NyYzogZm9udH1dIDogZm9udCxcbiAgICAgIHVuaWNvZGVGb250c1VSTCxcbiAgICAgIHByZVJlc29sdmVkRm9udHNcbiAgICB9LCBydW5zID0+IHtcbiAgICAgIHRpbWluZ3MuZm9udExvYWQgPSBub3coKSAtIG1haW5TdGFydDtcbiAgICAgIGNvbnN0IGhhc01heFdpZHRoID0gaXNGaW5pdGUobWF4V2lkdGgpO1xuICAgICAgbGV0IGdseXBoSWRzID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaEZvbnRJbmRpY2VzID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhEYXRhID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaENvbG9ycyA9IG51bGw7XG4gICAgICBsZXQgY2FyZXRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgbGV0IHZpc2libGVCb3VuZHMgPSBudWxsO1xuICAgICAgbGV0IGNodW5rZWRCb3VuZHMgPSBudWxsO1xuICAgICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgICBsZXQgcmVuZGVyYWJsZUdseXBoQ291bnQgPSAwO1xuICAgICAgbGV0IGNhbldyYXAgPSB3aGl0ZVNwYWNlICE9PSAnbm93cmFwJztcbiAgICAgIGNvbnN0IG1ldHJpY3NCeUZvbnQgPSBuZXcgTWFwKCk7IC8vIGZvbnRPYmogLT4gbWV0cmljc1xuICAgICAgY29uc3QgdHlwZXNldFN0YXJ0ID0gbm93KCk7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICBsZXQgcHJldlJ1bkVuZFggPSAwO1xuICAgICAgbGV0IGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICBjb25zdCBsaW5lcyA9IFtjdXJyZW50TGluZV07XG4gICAgICBydW5zLmZvckVhY2gocnVuID0+IHtcbiAgICAgICAgY29uc3QgeyBmb250T2JqIH0gPSBydW47XG4gICAgICAgIGNvbnN0IHsgYXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0IH0gPSBmb250T2JqO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzIGZvciBlYWNoIGZvbnQgdXNlZFxuICAgICAgICBsZXQgZm9udERhdGEgPSBtZXRyaWNzQnlGb250LmdldChmb250T2JqKTtcbiAgICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICAgIC8vIEZpbmQgY29udmVyc2lvbiBiZXR3ZWVuIG5hdGl2ZSBmb250IHVuaXRzIGFuZCBmb250U2l6ZSB1bml0c1xuICAgICAgICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSB2YWx1ZSBmb3IgJ25vcm1hbCcgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQncyBhY3R1YWwgbWV0cmljc1xuICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICAgICAgY29uc3QgY2FsY0xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/XG4gICAgICAgICAgICAoYXNjZW5kZXIgLSBkZXNjZW5kZXIgKyBsaW5lR2FwKSAqIGZvbnRTaXplTXVsdCA6IGxpbmVIZWlnaHQgKiBmb250U2l6ZTtcblxuICAgICAgICAgIC8vIERldGVybWluZSBsaW5lIGhlaWdodCBhbmQgbGVhZGluZyBhZGp1c3RtZW50c1xuICAgICAgICAgIGNvbnN0IGhhbGZMZWFkaW5nID0gKGNhbGNMaW5lSGVpZ2h0IC0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCkgLyAyO1xuICAgICAgICAgIGNvbnN0IGNhcmV0SGVpZ2h0ID0gTWF0aC5taW4oY2FsY0xpbmVIZWlnaHQsIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpO1xuICAgICAgICAgIGNvbnN0IGNhcmV0VG9wID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgKyBjYXJldEhlaWdodCAvIDI7XG4gICAgICAgICAgZm9udERhdGEgPSB7XG4gICAgICAgICAgICBpbmRleDogbWV0cmljc0J5Rm9udC5zaXplLFxuICAgICAgICAgICAgc3JjOiBmb250T2JqLnNyYyxcbiAgICAgICAgICAgIGZvbnRPYmosXG4gICAgICAgICAgICBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICB1bml0c1BlckVtLFxuICAgICAgICAgICAgYXNjZW5kZXI6IGFzY2VuZGVyICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICBjYXBIZWlnaHQ6IGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIHhIZWlnaHQ6IHhIZWlnaHQgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBjYWxjTGluZUhlaWdodCxcbiAgICAgICAgICAgIGJhc2VsaW5lOiAtaGFsZkxlYWRpbmcgLSBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy8gYmFzZWxpbmUgb2Zmc2V0IGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBjYXA6IC1oYWxmTGVhZGluZyAtIGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy8gY2FwIGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBleDogLWhhbGZMZWFkaW5nIC0geEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy8gZXggZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgIGNhcmV0VG9wLFxuICAgICAgICAgICAgY2FyZXRCb3R0b206IGNhcmV0VG9wIC0gY2FyZXRIZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1ldHJpY3NCeUZvbnQuc2V0KGZvbnRPYmosIGZvbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZvbnRTaXplTXVsdCB9ID0gZm9udERhdGE7XG5cbiAgICAgICAgY29uc3QgcnVuVGV4dCA9IHRleHQuc2xpY2UocnVuLnN0YXJ0LCBydW4uZW5kICsgMSk7XG4gICAgICAgIGxldCBwcmV2R2x5cGhYLCBwcmV2R2x5cGhPYmo7XG4gICAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHJ1blRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCAoZ2x5cGhPYmosIGdseXBoWCwgZ2x5cGhZLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgICBnbHlwaFggKz0gcHJldlJ1bkVuZFg7XG4gICAgICAgICAgY2hhckluZGV4ICs9IHJ1bi5zdGFydDtcbiAgICAgICAgICBwcmV2R2x5cGhYID0gZ2x5cGhYO1xuICAgICAgICAgIHByZXZHbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJBdChjaGFySW5kZXgpO1xuICAgICAgICAgIGNvbnN0IGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgY29uc3QgY3VyTGluZUNvdW50ID0gY3VycmVudExpbmUuY291bnQ7XG4gICAgICAgICAgbGV0IG5leHRMaW5lO1xuXG4gICAgICAgICAgLy8gQ2FsYyBpc1doaXRlc3BhY2UgYW5kIGlzRW1wdHkgb25jZSBwZXIgZ2x5cGhPYmpcbiAgICAgICAgICBpZiAoISgnaXNFbXB0eScgaW4gZ2x5cGhPYmopKSB7XG4gICAgICAgICAgICBnbHlwaE9iai5pc1doaXRlc3BhY2UgPSAhIWNoYXIgJiYgbmV3IFJlZ0V4cChsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlKS50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgZ2x5cGhPYmouY2FuQnJlYWtBZnRlciA9ICEhY2hhciAmJiBCUkVBS19BRlRFUl9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgZ2x5cGhPYmouaXNFbXB0eSA9IGdseXBoT2JqLnhNaW4gPT09IGdseXBoT2JqLnhNYXggfHwgZ2x5cGhPYmoueU1pbiA9PT0gZ2x5cGhPYmoueU1heCB8fCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZUdseXBoQ291bnQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgICBpZiAoY2FuV3JhcCAmJiBoYXNNYXhXaWR0aCAmJiAhZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGdseXBoWCArIGdseXBoV2lkdGggKyBsaW5lWE9mZnNldCA+IG1heFdpZHRoICYmIGN1ckxpbmVDb3VudCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZmlyc3QgY2hhciBhZnRlciBhIHdoaXRlc3BhY2UsIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGN1ckxpbmVDb3VudCAtIDEpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQmFjayB1cCBsb29raW5nIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHRvIHdyYXAgYXRcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGN1ckxpbmVDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG92ZXJmbG93V3JhcCA9PT0gJ2JyZWFrLXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IGN1cnJlbnRMaW5lLnNwbGl0QXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbmV4dExpbmUuY291bnQ7IGotLTspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lLmlzU29mdFdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IG5leHRMaW5lO1xuICAgICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbWF4V2lkdGg7IC8vYWZ0ZXIgc29mdCB3cmFwcGluZyB1c2UgbWF4V2lkdGggYXMgY2FsY3VsYXRlZCB3aWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmbHkgPSBjdXJyZW50TGluZS5nbHlwaEF0KGN1cnJlbnRMaW5lLmNvdW50KTtcbiAgICAgICAgICBmbHkuZ2x5cGhPYmogPSBnbHlwaE9iajtcbiAgICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICAgIGZseS55ID0gZ2x5cGhZO1xuICAgICAgICAgIGZseS53aWR0aCA9IGdseXBoV2lkdGg7XG4gICAgICAgICAgZmx5LmNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICBmbHkuZm9udERhdGEgPSBmb250RGF0YTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC0oZ2x5cGhYICsgZ2x5cGhXaWR0aCArIChsZXR0ZXJTcGFjaW5nICogZm9udFNpemUpKSArIHRleHRJbmRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiBhIHJ1biB3ZSBtdXN0IGNhcHR1cmUgdGhlIHggcG9zaXRpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgbmV4dCBydW5cbiAgICAgICAgcHJldlJ1bkVuZFggPSBwcmV2R2x5cGhYICsgcHJldkdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTaXplTXVsdCArIGxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgd2lkdGgvaGVpZ2h0L2Jhc2VsaW5lIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgbGV0IGlzVHJhaWxpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxpbmUuY291bnQ7IGktLTspIHtcbiAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgLy8gb21pdCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gd2lkdGggY2FsY3VsYXRpb25cbiAgICAgICAgICBpZiAoaXNUcmFpbGluZ1doaXRlc3BhY2UgJiYgIWdseXBoSW5mby5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGxpbmUud2lkdGggPSBnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1RyYWlsaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB1c2UgdGhlIHRhbGxlc3QgbGluZSBoZWlnaHQsIGxvd2VzdCBiYXNlbGluZSwgYW5kIGhpZ2hlc3QgY2FwL2V4XG4gICAgICAgICAgbGV0IHtsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHQsIGJhc2VsaW5lfSA9IGdseXBoSW5mby5mb250RGF0YTtcbiAgICAgICAgICBpZiAobGluZUhlaWdodCA+IGxpbmUubGluZUhlaWdodCkgbGluZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICBjb25zdCBiYXNlbGluZURpZmYgPSBiYXNlbGluZSAtIGxpbmUuYmFzZWxpbmU7XG4gICAgICAgICAgaWYgKGJhc2VsaW5lRGlmZiA8IDApIHsgLy9zaGlmdCBhbGwgbWV0cmljcyBkb3duXG4gICAgICAgICAgICBsaW5lLmJhc2VsaW5lICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgIGxpbmUuY2FwICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgIGxpbmUuZXggKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb21wYXJlIGNhcC9leCBiYXNlZCBvbiBuZXcgbG93ZXN0IGJhc2VsaW5lXG4gICAgICAgICAgbGluZS5jYXAgPSBNYXRoLm1heChsaW5lLmNhcCwgbGluZS5iYXNlbGluZSArIGNhcEhlaWdodCk7XG4gICAgICAgICAgbGluZS5leCA9IE1hdGgubWF4KGxpbmUuZXgsIGxpbmUuYmFzZWxpbmUgKyB4SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lLmJhc2VsaW5lIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICBsaW5lLmNhcCAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgbGluZS5leCAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZS5saW5lSGVpZ2h0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpbmQgb3ZlcmFsbCBwb3NpdGlvbiBhZGp1c3RtZW50cyBmb3IgYW5jaG9yaW5nXG4gICAgICBsZXQgYW5jaG9yWE9mZnNldCA9IDA7XG4gICAgICBsZXQgYW5jaG9yWU9mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yWCkge1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvclggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1hbmNob3JYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtbWF4TGluZVdpZHRoICogKFxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgICAgICBhbmNob3JYID09PSAnY2VudGVyJyA/IDAuNSA6XG4gICAgICAgICAgICBhbmNob3JYID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgICAgICBwYXJzZVBlcmNlbnQoYW5jaG9yWClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYW5jaG9yWSkge1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYW5jaG9yWU9mZnNldCA9IC1hbmNob3JZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSBhbmNob3JZID09PSAndG9wJyA/IDAgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1iYXNlbGluZScgPyAtbGluZXNbMF0uYmFzZWxpbmUgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1jYXAnID8gLWxpbmVzWzBdLmNhcCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWV4JyA/IC1saW5lc1swXS5leCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnbWlkZGxlJyA/IHRvdGFsSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tJyA/IHRvdGFsSGVpZ2h0IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20tYmFzZWxpbmUnID8gLWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmJhc2VsaW5lIDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JZKSAqIHRvdGFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBiaWRpIGxldmVsc1xuICAgICAgICBjb25zdCBiaWRpTGV2ZWxzUmVzdWx0ID0gYmlkaS5nZXRFbWJlZGRpbmdMZXZlbHModGV4dCwgZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgIC8vIGNvbGxlY3RpbmcgYWxsIHJlbmRlcmFibGUgZ2x5cGhzIGludG8gYSBzaW5nbGUgY29sbGVjdGlvbi5cbiAgICAgICAgZ2x5cGhJZHMgPSBuZXcgVWludDE2QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaEZvbnRJbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgZ2x5cGhEYXRhID0ge307XG4gICAgICAgIHZpc2libGVCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICBjYXJldFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGV4dC5sZW5ndGggKiA0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICBnbHlwaENvbG9ycyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbmRlcmFibGVHbHlwaEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHByZXZDaGFySW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGNvbG9yQ2hhckluZGV4ID0gLTE7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgbGV0IHtjb3VudDpsaW5lR2x5cGhDb3VudCwgd2lkdGg6bGluZVdpZHRofSA9IGxpbmU7XG5cbiAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgICBpZiAobGluZUdseXBoQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBDb3VudCB0cmFpbGluZyB3aGl0ZXNwYWNlcywgd2Ugd2FudCB0byBpZ25vcmUgdGhlc2UgZm9yIGNlcnRhaW4gdGhpbmdzXG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50OyBpLS0gJiYgbGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZTspIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgaG9yaXpvbnRhbCBhbGlnbm1lbnQgYWRqdXN0bWVudHNcbiAgICAgICAgICAgIGxldCBsaW5lWE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQganVzdGlmeUFkanVzdCA9IDA7XG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5JyAmJiBsaW5lLmlzU29mdFdyYXBwZWQpIHtcbiAgICAgICAgICAgICAgLy8gY291bnQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycywgYW5kIHdlJ2xsIGFkanVzdCB0aGUgb2Zmc2V0cyBwZXIgY2hhcmFjdGVyIGluIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgbGV0IHdoaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBqdXN0aWZ5QWRqdXN0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyB3aGl0ZXNwYWNlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCB8fCBsaW5lWE9mZnNldCkge1xuICAgICAgICAgICAgICBsZXQganVzdGlmeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmZvLnggKz0gbGluZVhPZmZzZXQgKyBqdXN0aWZ5T2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBub24tdHJhaWxpbmcgd2hpdGVzcGFjZXMgZm9yIGp1c3RpZnkgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgIT09IDAgJiYgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGkgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBqdXN0aWZ5T2Zmc2V0ICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8ud2lkdGggKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGVyZm9ybSBiaWRpIHJhbmdlIGZsaXBwaW5nXG4gICAgICAgICAgICBjb25zdCBmbGlwcyA9IGJpZGkuZ2V0UmVvcmRlclNlZ21lbnRzKFxuICAgICAgICAgICAgICB0ZXh0LCBiaWRpTGV2ZWxzUmVzdWx0LCBsaW5lLmdseXBoQXQoMCkuY2hhckluZGV4LCBsaW5lLmdseXBoQXQobGluZS5jb3VudCAtIDEpLmNoYXJJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGZpID0gMDsgZmkgPCBmbGlwcy5sZW5ndGg7IGZpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gZmxpcHNbZmldO1xuICAgICAgICAgICAgICAvLyBNYXAgc3RhcnQvZW5kIHN0cmluZyBpbmRpY2VzIHRvIGluZGljZXMgaW4gdGhlIGxpbmVcbiAgICAgICAgICAgICAgbGV0IGxlZnQgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuY2hhckluZGV4ID49IHN0YXJ0KSB7IC8vIGd0ZSB0byBoYW5kbGUgcmVtb3ZlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbkxpbmUgPSBpLCBlbmRJbkxpbmUgPSBpO1xuICAgICAgICAgICAgICAgICAgZm9yICg7IGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50OyBlbmRJbkxpbmUrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IGxpbmUuZ2x5cGhBdChlbmRJbkxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5jaGFySW5kZXggPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7IC8vZG9uJ3QgaW5jbHVkZSB0cmFpbGluZyB3cyBpbiBmbGlwIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGluZm8ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgaW5mby54ICsgaW5mby53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydEluTGluZTsgaiA8IGVuZEluTGluZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChqKTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLnggPSByaWdodCAtIChnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aCAtIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhcnJheXNcbiAgICAgICAgICAgIGxldCBnbHlwaE9iajtcbiAgICAgICAgICAgIGNvbnN0IHNldEdseXBoT2JqID0gZyA9PiBnbHlwaE9iaiA9IGc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJZCA9IGdseXBoT2JqLmluZGV4O1xuXG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgbWlycm9yZWQgY2hhcmFjdGVycyBpbiBydGxcbiAgICAgICAgICAgICAgY29uc3QgcnRsID0gYmlkaUxldmVsc1Jlc3VsdC5sZXZlbHNbZ2x5cGhJbmZvLmNoYXJJbmRleF0gJiAxOyAvL29kZCBsZXZlbCBtZWFucyBydGxcbiAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pcnJvcmVkID0gYmlkaS5nZXRNaXJyb3JlZENoYXJhY3Rlcih0ZXh0W2dseXBoSW5mby5jaGFySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAobWlycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGdseXBoSW5mby5mb250RGF0YS5mb250T2JqLmZvckVhY2hHbHlwaChtaXJyb3JlZCwgMCwgMCwgc2V0R2x5cGhPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFkZCBjYXJldCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjaGFySW5kZXgsIGZvbnREYXRhfSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRSaWdodCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0XSA9IHJ0bCA/IGNhcmV0UmlnaHQgOiBjYXJldExlZnQ7IC8vc3RhcnQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDJdID0gbGluZS5iYXNlbGluZSArIGZvbnREYXRhLmNhcmV0Qm90dG9tICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gYm90dG9tIHlcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0ICsgM10gPSBsaW5lLmJhc2VsaW5lICsgZm9udERhdGEuY2FyZXRUb3AgKyBhbmNob3JZT2Zmc2V0OyAvL2NvbW1vbiB0b3AgeVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2tpcHBlZCBhbnkgY2hhcnMgZnJvbSB0aGUgcHJldmlvdXMgZ2x5cGggKGR1ZSB0byBsaWdhdHVyZSBzdWJzKSwgZmlsbCBpbiBjYXJldFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBmb3IgdGhvc2UgbWlzc2luZyBjaGFyIGluZGljZXM7IGN1cnJlbnRseSB0aGlzIHVzZXMgYSBiZXN0LWd1ZXNzIGJ5IGRpdmlkaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpZ2F0dXJlJ3Mgd2lkdGggZXZlbmx5LiBJbiB0aGUgZnV0dXJlIHdlIG1heSB0cnkgdG8gdXNlIHRoZSBmb250J3MgTGlnYXR1cmVDYXJldExpc3RcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSB0byBnZXQgYmV0dGVyIGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IGNoYXJJbmRleCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgY29sb3IgcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgd2hpbGUoY2hhckluZGV4ID4gY29sb3JDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yQ2hhckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoY29sb3JDaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yUmFuZ2VzW2NvbG9yQ2hhckluZGV4XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBHZXQgYXRsYXMgZGF0YSBmb3IgcmVuZGVyYWJsZSBnbHlwaHNcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSByZW5kZXJhYmxlR2x5cGhJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHtmb250U2l6ZU11bHQsIHNyYzogZm9udFNyYywgaW5kZXg6IGZvbnRJbmRleH0gPSBnbHlwaEluZm8uZm9udERhdGE7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBnbHlwaCdzIHBhdGggZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRHbHlwaERhdGEgPSBnbHlwaERhdGFbZm9udFNyY10gfHwgKGdseXBoRGF0YVtmb250U3JjXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnRHbHlwaERhdGFbZ2x5cGhJZF0pIHtcbiAgICAgICAgICAgICAgICAgIGZvbnRHbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGdseXBoT2JqLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhCb3VuZHM6IFtnbHlwaE9iai54TWluLCBnbHlwaE9iai55TWluLCBnbHlwaE9iai54TWF4LCBnbHlwaE9iai55TWF4XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZmluYWwgZ2x5cGggcG9zaXRpb24gYW5kIGFkZCB0byBnbHlwaFBvc2l0aW9ucyBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFkgPSBnbHlwaEluZm8ueSArIGxpbmUuYmFzZWxpbmUgKyBhbmNob3JZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDJdID0gZ2x5cGhYO1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDIgKyAxXSA9IGdseXBoWTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIHRvdGFsIHZpc2libGUgYm91bmRzXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWDAgPSBnbHlwaFggKyBnbHlwaE9iai54TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kwID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMSA9IGdseXBoWCArIGdseXBoT2JqLnhNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTEgPSBnbHlwaFkgKyBnbHlwaE9iai55TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IHZpc2libGVCb3VuZHNbMF0pIHZpc2libGVCb3VuZHNbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCB2aXNpYmxlQm91bmRzWzFdKSB2aXNpYmxlQm91bmRzWzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gdmlzaWJsZUJvdW5kc1syXSkgdmlzaWJsZUJvdW5kc1syXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IHZpc2libGVCb3VuZHNbM10pIHZpc2libGVCb3VuZHNbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNodW5rIG9mIE4gZ2x5cGhzXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAlIGNodW5rZWRCb3VuZHNTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjaHVuayA9IHtzdGFydDogaWR4LCBlbmQ6IGlkeCwgcmVjdDogW0lORiwgSU5GLCAtSU5GLCAtSU5GXX07XG4gICAgICAgICAgICAgICAgICBjaHVua2VkQm91bmRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVuay5lbmQrKztcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1JlY3QgPSBjaHVuay5yZWN0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IGNodW5rUmVjdFswXSkgY2h1bmtSZWN0WzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgY2h1bmtSZWN0WzFdKSBjaHVua1JlY3RbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiBjaHVua1JlY3RbMl0pIGNodW5rUmVjdFsyXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IGNodW5rUmVjdFszXSkgY2h1bmtSZWN0WzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gZ2x5cGggaWRzIGFuZCBmb250IGluZGljZXMgYXJyYXlzXG4gICAgICAgICAgICAgICAgZ2x5cGhJZHNbaWR4XSA9IGdseXBoSWQ7XG4gICAgICAgICAgICAgICAgZ2x5cGhGb250SW5kaWNlc1tpZHhdID0gZm9udEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbG9yc1xuICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpZHggKiAzO1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnRdID0gY3VycmVudENvbG9yID4+IDE2ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAxXSA9IGN1cnJlbnRDb2xvciA+PiA4ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAyXSA9IGN1cnJlbnRDb2xvciAmIDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbGwgaW4gcmVtYWluaW5nIGNhcmV0IHBvc2l0aW9ucyBpbiBjYXNlIHRoZSBmaW5hbCBjaGFyYWN0ZXIgd2FzIGEgbGlnYXR1cmVcbiAgICAgICAgaWYgKGNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbGlnQ291bnQgPSB0ZXh0Lmxlbmd0aCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgaWYgKGxpZ0NvdW50ID4gMSkge1xuICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZFxuICAgICAgY29uc3QgZm9udERhdGEgPSBbXTtcbiAgICAgIG1ldHJpY3NCeUZvbnQuZm9yRWFjaCgoe2luZGV4LCBzcmMsIHVuaXRzUGVyRW0sIGFzY2VuZGVyLCBkZXNjZW5kZXIsIGxpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodH0pID0+IHtcbiAgICAgICAgZm9udERhdGFbaW5kZXhdID0ge3NyYywgdW5pdHNQZXJFbSwgYXNjZW5kZXIsIGRlc2NlbmRlciwgbGluZUhlaWdodCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaW1pbmcgc3RhdHNcbiAgICAgIHRpbWluZ3MudHlwZXNldHRpbmcgPSBub3coKSAtIHR5cGVzZXRTdGFydDtcblxuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBnbHlwaElkcywgLy9pZCBmb3IgZWFjaCBnbHlwaCwgc3BlY2lmaWMgdG8gdGhhdCBnbHlwaCdzIGZvbnRcbiAgICAgICAgZ2x5cGhGb250SW5kaWNlcywgLy9pbmRleCBpbnRvIGZvbnREYXRhIGZvciBlYWNoIGdseXBoXG4gICAgICAgIGdseXBoUG9zaXRpb25zLCAvL3gseSBvZiBlYWNoIGdseXBoJ3Mgb3JpZ2luIGluIGxheW91dFxuICAgICAgICBnbHlwaERhdGEsIC8vZGljdCBob2xkaW5nIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAgICAgICAgZm9udERhdGEsIC8vZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZCBpbiB0aGUgdGV4dFxuICAgICAgICBjYXJldFBvc2l0aW9ucywgLy9zdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gICAgICAgIC8vIGNhcmV0SGVpZ2h0LCAvL2hlaWdodCBvZiBjdXJzb3IgZnJvbSBib3R0b20gdG8gdG9wIC0gdG9kbyBwZXIgZ2x5cGg/XG4gICAgICAgIGdseXBoQ29sb3JzLCAvL2NvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICAgICAgICB0b3BCYXNlbGluZTogYW5jaG9yWU9mZnNldCArIGxpbmVzWzBdLmJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gdG90YWxIZWlnaHQsXG4gICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gICAgICAgIF0sXG4gICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAgICAgICAgdGltaW5nc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiB0ZXh0IHN0cmluZyBhbmQgZm9udCBwYXJhbWV0ZXJzLCBkZXRlcm1pbmUgdGhlIHJlc3VsdGluZyBibG9jayBkaW1lbnNpb25zXG4gICAqIGFmdGVyIHdyYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbWF4V2lkdGguXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gbWVhc3VyZShhcmdzLCBjYWxsYmFjaykge1xuICAgIHR5cGVzZXQoey4uLmFyZ3MsIG1ldHJpY3NPbmx5OiB0cnVlfSwgKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHJlc3VsdC5ibG9ja0JvdW5kcztcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgd2lkdGg6IHgxIC0geDAsXG4gICAgICAgIGhlaWdodDogeTEgLSB5MFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQoc3RyKSB7XG4gICAgbGV0IG1hdGNoID0gc3RyLm1hdGNoKC9eKFtcXGQuXSspJSQvKTtcbiAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICByZXR1cm4gaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBsaWdTdGFydEluZGV4LCBsaWdDb3VudCkge1xuICAgIGNvbnN0IGxpZ1N0YXJ0WCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0XTtcbiAgICBjb25zdCBsaWdFbmRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAxXTtcbiAgICBjb25zdCBsaWdCb3R0b20gPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDJdO1xuICAgIGNvbnN0IGxpZ1RvcCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgM107XG4gICAgY29uc3QgZ3Vlc3NlZEFkdmFuY2VYID0gKGxpZ0VuZFggLSBsaWdTdGFydFgpIC8gbGlnQ291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaWdDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gKGxpZ1N0YXJ0SW5kZXggKyBpKSAqIDQ7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4XSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIGk7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMV0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiAoaSArIDEpO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDJdID0gbGlnQm90dG9tO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDNdID0gbGlnVG9wO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbiAgfVxuXG4gIC8vIEFycmF5LWJhY2tlZCBzdHJ1Y3R1cmUgZm9yIGEgc2luZ2xlIGxpbmUncyBnbHlwaHMgZGF0YVxuICBmdW5jdGlvbiBUZXh0TGluZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICBjb25zdCB0ZXh0TGluZVByb3BzID0gWydnbHlwaE9iaicsICd4JywgJ3knLCAnd2lkdGgnLCAnY2hhckluZGV4JywgJ2ZvbnREYXRhJ107XG4gIFRleHRMaW5lLnByb3RvdHlwZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBsaW5lSGVpZ2h0OiAwLFxuICAgIGJhc2VsaW5lOiAwLFxuICAgIGNhcDogMCxcbiAgICBleDogMCxcbiAgICBpc1NvZnRXcmFwcGVkOiBmYWxzZSxcbiAgICBnZXQgY291bnQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICB9LFxuICAgIGdseXBoQXQoaSkge1xuICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgIGZseS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgZmx5LmluZGV4ID0gaTtcbiAgICAgIHJldHVybiBmbHlcbiAgICB9LFxuICAgIHNwbGl0QXQoaSkge1xuICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIG5ld0xpbmUuZGF0YSA9IHRoaXMuZGF0YS5zcGxpY2UoaSAqIHRleHRMaW5lUHJvcHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdMaW5lXG4gICAgfVxuICB9O1xuICBUZXh0TGluZS5mbHl3ZWlnaHQgPSB0ZXh0TGluZVByb3BzLnJlZHVjZSgob2JqLCBwcm9wLCBpLCBhbGwpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqXG4gIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlc2V0LFxuICAgIG1lYXN1cmUsXG4gIH1cbn1cblxuY29uc3Qgbm93ID0gKCkgPT4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG5cbmNvbnN0IG1haW5UaHJlYWRHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNERkdlbmVyYXRvcigpO1xuXG5sZXQgd2FybmVkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIHNpbmdsZSBnbHlwaCBwYXRoLCBwbGFjaW5nIHRoZSByZXN1bHQgaW50byBhIHdlYmdsIGNhbnZhcyBhdCBhXG4gKiBnaXZlbiBsb2NhdGlvbiBhbmQgY2hhbm5lbC4gVXRpbGl6ZXMgdGhlIHdlYmdsLXNkZi1nZW5lcmF0b3IgZXh0ZXJuYWwgcGFja2FnZSBmb3IgR1BVLWFjY2VsZXJhdGVkIFNERlxuICogZ2VuZXJhdGlvbiB3aGVuIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTREYod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZVdlYkdMID0gdHJ1ZSkge1xuICAvLyBBbGxvdyBvcHQtb3V0XG4gIGlmICghdXNlV2ViR0wpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICB9XG5cbiAgLy8gQXR0ZW1wdCBHUFUtYWNjZWxlcmF0ZWQgZ2VuZXJhdGlvbiBmaXJzdFxuICByZXR1cm4gZ2VuZXJhdGVTREZfR0wod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpLnRoZW4oXG4gICAgbnVsbCxcbiAgICBlcnIgPT4ge1xuICAgICAgLy8gV2ViR0wgZmFpbGVkIGVpdGhlciBkdWUgdG8gYSBoYXJkIGVycm9yIG9yIHVuZXhwZWN0ZWQgcmVzdWx0czsgZmFsbCBiYWNrIHRvIEpTIGluIHdvcmtlcnNcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlNgLCBlcnIpO1xuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgICB9XG4gIClcbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGNodW5rVGltZUJ1ZGdldCA9IDU7IC8vIG1zXG5sZXQgdGltZXIgPSAwO1xuXG5mdW5jdGlvbiBuZXh0Q2h1bmsoKSB7XG4gIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggJiYgbm93KCkgLSBzdGFydCA8IGNodW5rVGltZUJ1ZGdldCkge1xuICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgfVxuICB0aW1lciA9IHF1ZXVlLmxlbmd0aCA/IHNldFRpbWVvdXQobmV4dENodW5rLCAwKSA6IDA7XG59XG5cbi8qKlxuICogV2ViR0wtYmFzZWQgaW1wbGVtZW50YXRpb24gZXhlY3V0ZWQgb24gdGhlIG1haW4gdGhyZWFkLiBSZXF1ZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGltZS1ib3VuZGVkXG4gKiBtYWNyb3Rhc2sgY2h1bmtzIHRvIGFsbG93IHJlbmRlciBmcmFtZXMgdG8gZXhlY3V0ZSBpbiBiZXR3ZWVuLlxuICovXG5jb25zdCBnZW5lcmF0ZVNERl9HTCA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5nZW5lcmF0ZUludG9DYW52YXMoLi4uYXJncyk7XG4gICAgICAgIHJlc29sdmUoeyB0aW1pbmc6IG5vdygpIC0gc3RhcnQgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KG5leHRDaHVuaywgMCk7XG4gICAgfVxuICB9KVxufTtcblxuY29uc3QgdGhyZWFkQ291bnQgPSA0OyAvLyBob3cgbWFueSB3b3JrZXJzIHRvIHNwYXduXG5jb25zdCBpZGxlVGltZW91dCA9IDIwMDA7IC8vIHdvcmtlcnMgd2lsbCBiZSB0ZXJtaW5hdGVkIGFmdGVyIGJlaW5nIGlkbGUgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuY29uc3QgdGhyZWFkcyA9IHt9O1xubGV0IGNhbGxOdW0gPSAwO1xuXG4vKipcbiAqIEZhbGxiYWNrIEpTLWJhc2VkIGltcGxlbWVudGF0aW9uLCBmYW5uZWQgb3V0IHRvIGEgbnVtYmVyIG9mIHdvcmtlciB0aHJlYWRzIGZvciBwYXJhbGxlbGlzbVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgY29uc3Qgd29ya2VySWQgPSAnVHJvaWthVGV4dFNERkdlbmVyYXRvcl9KU18nICsgKChjYWxsTnVtKyspICUgdGhyZWFkQ291bnQpO1xuICBsZXQgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF07XG4gIGlmICghdGhyZWFkKSB7XG4gICAgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF0gPSB7XG4gICAgICB3b3JrZXJNb2R1bGU6IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICB3b3JrZXJJZCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yLFxuICAgICAgICAgIG5vd1xuICAgICAgICBdLFxuICAgICAgICBpbml0KF9jcmVhdGVTREZHZW5lcmF0b3IsIG5vdykge1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlID0gX2NyZWF0ZVNERkdlbmVyYXRvcigpLmphdmFzY3JpcHQuZ2VuZXJhdGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZURhdGEgPSBnZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRleHR1cmVEYXRhLFxuICAgICAgICAgICAgICB0aW1pbmc6IG5vdygpIC0gc3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQudGV4dHVyZURhdGEuYnVmZmVyXVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RzOiAwLFxuICAgICAgaWRsZVRpbWVyOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHRocmVhZC5yZXF1ZXN0cysrO1xuICBjbGVhclRpbWVvdXQodGhyZWFkLmlkbGVUaW1lcik7XG4gIHJldHVybiB0aHJlYWQud29ya2VyTW9kdWxlKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudClcbiAgICAudGhlbigoeyB0ZXh0dXJlRGF0YSwgdGltaW5nIH0pID0+IHtcbiAgICAgIC8vIGNvcHkgcmVzdWx0IGRhdGEgaW50byB0aGUgY2FudmFzXG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgLy8gZXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgaW50byByZ2JhXG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlRGF0YS5sZW5ndGggKiA0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW1hZ2VEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSB0ZXh0dXJlRGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZW5kZXJJbWFnZURhdGEoY2FudmFzLCBpbWFnZURhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEgPDwgKDMgLSBjaGFubmVsKSk7XG4gICAgICB0aW1pbmcgKz0gbm93KCkgLSBzdGFydDtcblxuICAgICAgLy8gY2xlYW4gdXAgd29ya2VycyBhZnRlciBhIHdoaWxlXG4gICAgICBpZiAoLS10aHJlYWQucmVxdWVzdHMgPT09IDApIHtcbiAgICAgICAgdGhyZWFkLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpOyB9LCBpZGxlVGltZW91dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0aW1pbmcgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHdhcm1VcFNERkNhbnZhcyhjYW52YXMpIHtcbiAgaWYgKCFjYW52YXMuX3dhcm0pIHtcbiAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmlzU3VwcG9ydGVkKGNhbnZhcyk7XG4gICAgY2FudmFzLl93YXJtID0gdHJ1ZTtcbiAgfVxufVxuXG5jb25zdCByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyA9IG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZztcblxuY29uc3QgQ09ORklHID0ge1xuICBkZWZhdWx0Rm9udFVSTDogbnVsbCxcbiAgdW5pY29kZUZvbnRzVVJMOiBudWxsLFxuICBzZGZHbHlwaFNpemU6IDY0LFxuICBzZGZNYXJnaW46IDEgLyAxNixcbiAgc2RmRXhwb25lbnQ6IDksXG4gIHRleHR1cmVXaWR0aDogMjA0OCxcbn07XG5jb25zdCB0ZW1wQ29sb3IgPSAvKiNfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5sZXQgaGFzUmVxdWVzdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG5vdyQxKCkge1xuICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbn1cblxuLyoqXG4gKiBDdXN0b21pemVzIHRoZSB0ZXh0IGJ1aWxkZXIgY29uZmlndXJhdGlvbi4gVGhpcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byB0aGUgZmlyc3QgZm9udCBwcm9jZXNzaW5nXG4gKiByZXF1ZXN0LCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWZhdWx0Rm9udFVSTCAtIFRoZSBVUkwgb2YgdGhlIGRlZmF1bHQgZm9udCB0byB1c2UgZm9yIHRleHQgcHJvY2Vzc2luZ1xuICogICAgICAgICAgICAgICAgIHJlcXVlc3RzLCBpbiBjYXNlIG5vbmUgaXMgc3BlY2lmaWVkIG9yIHRoZSBzcGVjaWZpZWRlIGZvbnQgZmFpbHMgdG8gbG9hZCBvciBwYXJzZS5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBcIlJvYm90byBSZWd1bGFyXCIgZnJvbSBHb29nbGUgRm9udHMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnVuaWNvZGVGb250c1VSTCAtIEEgY3VzdG9tIGxvY2F0aW9uIGZvciB0aGUgZmFsbGJhY2sgdW5pY29kZS1mb250LXJlc29sdmVyXG4gKiAgICAgICAgICAgICAgICAgZGF0YSBhbmQgZm9udCBmaWxlcywgaWYgeW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZSBkZWZhdWx0IENETi4gU2VlXG4gKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXIgZm9yIGRldGFpbHMuIEl0IGNhbiBhbHNvIGJlXG4gKiAgICAgICAgICAgICAgICAgY29uZmlndXJlZCBwZXIgdGV4dCBpbnN0YW5jZSwgYnV0IHRoaXMgbGV0cyB5b3UgZG8gaXQgb25jZSBnbG9iYWxseS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmR2x5cGhTaXplIC0gVGhlIGRlZmF1bHQgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGIChzaWduZWQgZGlzdGFuY2UgZmllbGQpXG4gKiAgICAgICAgICAgICAgICAgdGV4dHVyZSB1c2VkIGZvciByZW5kZXJpbmcuIE11c3QgYmUgYSBwb3dlci1vZi10d28gbnVtYmVyLCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMsXG4gKiAgICAgICAgICAgICAgICAgYnV0IG5vdGUgdGhhdCB0aGlzIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gcGVyIGNhbGwgdG8gYGdldFRleHRSZW5kZXJJbmZvKClgLlxuICogICAgICAgICAgICAgICAgIExhcmdlciBzaXplcyBjYW4gaW1wcm92ZSB0aGUgcXVhbGl0eSBvZiBnbHlwaCByZW5kZXJpbmcgYnkgaW5jcmVhc2luZyB0aGUgc2hhcnBuZXNzXG4gKiAgICAgICAgICAgICAgICAgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5LiBEZWZhdWx0c1xuICogICAgICAgICAgICAgICAgIHRvIDY0IHdoaWNoIGlzIGdlbmVyYWxseSBhIGdvb2QgYmFsYW5jZSBvZiBzaXplIGFuZCBxdWFsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZFeHBvbmVudCAtIFRoZSBleHBvbmVudCB1c2VkIHdoZW4gZW5jb2RpbmcgdGhlIFNERiB2YWx1ZXMuIEEgaGlnaGVyIGV4cG9uZW50XG4gKiAgICAgICAgICAgICAgICAgc2hpZnRzIHRoZSBlbmNvZGVkIDgtYml0IHZhbHVlcyB0byBhY2hpZXZlIGhpZ2hlciBwcmVjaXNpb24vYWNjdXJhY3kgYXQgdGV4ZWxzIG5lYXJlclxuICogICAgICAgICAgICAgICAgIHRoZSBnbHlwaCdzIHBhdGgsIHdpdGggbG93ZXIgcHJlY2lzaW9uIGZ1cnRoZXIgYXdheS4gRGVmYXVsdHMgdG8gOS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmTWFyZ2luIC0gSG93IG11Y2ggc3BhY2UgdG8gcmVzZXJ2ZSBpbiB0aGUgU0RGIGFzIG1hcmdpbiBvdXRzaWRlIHRoZSBnbHlwaCdzXG4gKiAgICAgICAgICAgICAgICAgcGF0aCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBTREYgd2lkdGguIEEgbGFyZ2VyIG1hcmdpbiBpbmNyZWFzZXMgdGhlIHF1YWxpdHkgb2ZcbiAqICAgICAgICAgICAgICAgICBleHRydWRlZCBnbHlwaCBvdXRsaW5lcywgYnV0IGRlY3JlYXNlcyB0aGUgcHJlY2lzaW9uIGF2YWlsYWJsZSBmb3IgdGhlIGdseXBoIGl0c2VsZi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byAxLzE2dGggb2YgdGhlIGdseXBoIHNpemUuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnRleHR1cmVXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgU0RGIHRleHR1cmU7IG11c3QgYmUgYSBwb3dlciBvZiAyLiBEZWZhdWx0cyB0b1xuICogICAgICAgICAgICAgICAgIDIwNDggd2hpY2ggaXMgYSBzYWZlIG1heGltdW0gdGV4dHVyZSBkaW1lbnNpb24gYWNjb3JkaW5nIHRvIHRoZSBzdGF0cyBhdFxuICogICAgICAgICAgICAgICAgIGh0dHBzOi8vd2ViZ2xzdGF0cy5jb20vd2ViZ2wvcGFyYW1ldGVyL01BWF9URVhUVVJFX1NJWkUgYW5kIHNob3VsZCBhbGxvdyBmb3IgYVxuICogICAgICAgICAgICAgICAgIHJlYXNvbmFibHkgbGFyZ2UgbnVtYmVyIG9mIGdseXBocyAoZGVmYXVsdCBnbHlwaCBzaXplIG9mIDY0XjIgYW5kIHNhZmUgdGV4dHVyZSBzaXplIG9mXG4gKiAgICAgICAgICAgICAgICAgMjA0OF4yLCB0aW1lcyA0IGNoYW5uZWxzLCBhbGxvd3MgZm9yIDQwOTYgZ2x5cGhzLikgVGhpcyBjYW4gYmUgaW5jcmVhc2VkIGlmIHlvdSBuZWVkIHRvXG4gKiAgICAgICAgICAgICAgICAgaW5jcmVhc2UgdGhlIGdseXBoIHNpemUgYW5kL29yIGhhdmUgYW4gZXh0cmFvcmRpbmFyeSBudW1iZXIgb2YgZ2x5cGhzLlxuICovXG5mdW5jdGlvbiBjb25maWd1cmVUZXh0QnVpbGRlcihjb25maWcpIHtcbiAgaWYgKGhhc1JlcXVlc3RlZCkge1xuICAgIGNvbnNvbGUud2FybignY29uZmlndXJlVGV4dEJ1aWxkZXIgY2FsbGVkIGFmdGVyIGZpcnN0IGZvbnQgcmVxdWVzdDsgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9IGVsc2Uge1xuICAgIGFzc2lnbihDT05GSUcsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBvc2l0b3J5IGZvciBhbGwgZm9udCBTREYgYXRsYXMgdGV4dHVyZXMgYW5kIHRoZWlyIGdseXBoIG1hcHBpbmdzLiBUaGVyZSBpcyBhIHNlcGFyYXRlIGF0bGFzIGZvclxuICogZWFjaCBzZGZHbHlwaFNpemUuIEVhY2ggYXRsYXMgaGFzIGEgc2luZ2xlIFRleHR1cmUgdGhhdCBob2xkcyBhbGwgZ2x5cGhzIGZvciBhbGwgZm9udHMuXG4gKlxuICogICB7XG4gKiAgICAgW3NkZkdseXBoU2l6ZV06IHtcbiAqICAgICAgIGdseXBoQ291bnQ6IG51bWJlcixcbiAqICAgICAgIHNkZkdseXBoU2l6ZTogbnVtYmVyLFxuICogICAgICAgc2RmVGV4dHVyZTogVGV4dHVyZSxcbiAqICAgICAgIHNkZkNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gKiAgICAgICBjb250ZXh0TG9zdDogYm9vbGVhbixcbiAqICAgICAgIGdseXBoc0J5Rm9udDogTWFwPGZvbnRVUkwsIE1hcDxnbHlwaElELCB7cGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveH0+PlxuICogICAgIH1cbiAqICAgfVxuICovXG5jb25zdCBhdGxhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcm9pa2FUZXh0UmVuZGVySW5mbyAtIEZvcm1hdCBvZiB0aGUgcmVzdWx0IGZyb20gYGdldFRleHRSZW5kZXJJbmZvYC5cbiAqIEBwcm9wZXJ0eSB7VHlwZXNldFBhcmFtc30gcGFyYW1ldGVycyAtIFRoZSBub3JtYWxpemVkIGlucHV0IGFyZ3VtZW50cyB0byB0aGUgcmVuZGVyIGNhbGwuXG4gKiBAcHJvcGVydHkge1RleHR1cmV9IHNkZlRleHR1cmUgLSBUaGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERjsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCBpbiBlbmNvZGluZyB0aGUgU0RGJ3MgdmFsdWVzOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBpbmRleCBpbiB0aGUgU0RGIGF0bGFzLlxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBbciwgZywgYl0gY29sb3IsIGlmIGBjb2xvclJhbmdlc2Agd2FzIHN1cHBsaWVkLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nOyBlYWNoIGlzXG4gKiAgICAgICAgICAgZm91ciBlbGVtZW50czogdGhlIHN0YXJ0aW5nIFgsIHRoZSBlbmRpbmcgWCwgdGhlIGJvdHRvbSBZLCBhbmQgdGhlIHRvcCBZIGZvciB0aGUgY2FyZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhcmV0SGVpZ2h0XSAtIEFuIGFwcHJvcHJpYXRlIGhlaWdodCBmb3IgYWxsIHNlbGVjdGlvbiBjYXJldHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW5kZXIgLSBUaGUgZm9udCdzIGFzY2VuZGVyIG1ldHJpYy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZXNjZW5kZXIgLSBUaGUgZm9udCdzIGRlc2NlbmRlciBtZXRyaWMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0IC0gVGhlIGZvbnQncyBjYXAgaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBjYXBpdGFsIGxldHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0geEhlaWdodCAtIFRoZSBmb250J3MgeCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVIZWlnaHQgLSBUaGUgZmluYWwgY29tcHV0ZWQgbGluZUhlaWdodCBtZWFzdXJlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BCYXNlbGluZSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBibG9ja0JvdW5kcyAtIFRoZSB0b3RhbCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcmVjdCBvZiB0aGUgd2hvbGUgdGV4dCBibG9jaztcbiAqICAgICAgICAgICB0aGlzIGNhbiBpbmNsdWRlIGV4dHJhIHZlcnRpY2FsIHNwYWNlIGJleW9uZCB0aGUgdmlzaWJsZSBnbHlwaHMgZHVlIHRvIGxpbmVIZWlnaHQsIGFuZCBpc1xuICogICAgICAgICAgIGVxdWl2YWxlbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgYSBibG9jay1sZXZlbCB0ZXh0IGVsZW1lbnQgaW4gQ1NTLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aXNpYmxlQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICogICAgICAgICAgIHVubGlrZSBgYmxvY2tCb3VuZHNgIHRoaXMgaXMgdGlnaHRseSB3cmFwcGVkIHRvIHRoZSB2aXNpYmxlIGdseXBoIHBhdGhzLlxuICogQHByb3BlcnR5IHtBcnJheTxvYmplY3Q+fSBjaHVua2VkQm91bmRzIC0gTGlzdCBvZiBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSBzZXQgb2YgTiBnbHlwaHMsXG4gKiAgICAgICAgICAgaW4gdGhlIGZvcm1hdCBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHRpbWluZ3MgLSBUaW1pbmcgaW5mbyBmb3IgdmFyaW91cyBwYXJ0cyBvZiB0aGUgcmVuZGVyaW5nIGxvZ2ljIGluY2x1ZGluZyBTREZcbiAqICAgICAgICAgICBnZW5lcmF0aW9uLCB0eXBlc2V0dGluZywgZXRjLlxuICogQGZyb3plblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGdldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mb1xuICovXG5cbi8qKlxuICogTWFpbiBlbnRyeSBwb2ludCBmb3IgcmVxdWVzdGluZyB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IHBhcmFtZXRlcnMuXG4gKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBwZXJmb3JtaW5nIG1vc3Qgb2YgdGhlIGxvZ2ljIGluIGEgd2ViIHdvcmtlciB0aHJlYWQuXG4gKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IGFyZ3NcbiAqIEBwYXJhbSB7Z2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRSZW5kZXJJbmZvKGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGhhc1JlcXVlc3RlZCA9IHRydWU7XG4gIGFyZ3MgPSBhc3NpZ24oe30sIGFyZ3MpO1xuICBjb25zdCB0b3RhbFN0YXJ0ID0gbm93JDEoKTtcblxuICAvLyBDb252ZXJ0IHJlbGF0aXZlIFVSTCB0byBhYnNvbHV0ZSBzbyBpdCBjYW4gYmUgcmVzb2x2ZWQgaW4gdGhlIHdvcmtlciwgYW5kIGFkZCBmYWxsYmFja3MuXG4gIC8vIEluIHRoZSBmdXR1cmUgd2UnbGwgYWxsb3cgYXJncy5mb250IHRvIGJlIGEgbGlzdCB3aXRoIHVuaWNvZGUgcmFuZ2VzIHRvby5cbiAgY29uc3QgeyBkZWZhdWx0Rm9udFVSTCB9ID0gQ09ORklHO1xuICBjb25zdCBmb250cyA9IFtdO1xuICBpZiAoZGVmYXVsdEZvbnRVUkwpIHtcbiAgICBmb250cy5wdXNoKHtsYWJlbDogJ2RlZmF1bHQnLCBzcmM6IHRvQWJzb2x1dGVVUkwoZGVmYXVsdEZvbnRVUkwpfSk7XG4gIH1cbiAgaWYgKGFyZ3MuZm9udCkge1xuICAgIGZvbnRzLnB1c2goe2xhYmVsOiAndXNlcicsIHNyYzogdG9BYnNvbHV0ZVVSTChhcmdzLmZvbnQpfSk7XG4gIH1cbiAgYXJncy5mb250ID0gZm9udHM7XG5cbiAgLy8gTm9ybWFsaXplIHRleHQgdG8gYSBzdHJpbmdcbiAgYXJncy50ZXh0ID0gJycgKyBhcmdzLnRleHQ7XG5cbiAgYXJncy5zZGZHbHlwaFNpemUgPSBhcmdzLnNkZkdseXBoU2l6ZSB8fCBDT05GSUcuc2RmR2x5cGhTaXplO1xuICBhcmdzLnVuaWNvZGVGb250c1VSTCA9IGFyZ3MudW5pY29kZUZvbnRzVVJMIHx8IENPTkZJRy51bmljb2RlRm9udHNVUkw7XG5cbiAgLy8gTm9ybWFsaXplIGNvbG9yc1xuICBpZiAoYXJncy5jb2xvclJhbmdlcyAhPSBudWxsKSB7XG4gICAgbGV0IGNvbG9ycyA9IHt9O1xuICAgIGZvciAobGV0IGtleSBpbiBhcmdzLmNvbG9yUmFuZ2VzKSB7XG4gICAgICBpZiAoYXJncy5jb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLmNvbG9yUmFuZ2VzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhbCA9IHRlbXBDb2xvci5zZXQodmFsKS5nZXRIZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvcnNba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJncy5jb2xvclJhbmdlcyA9IGNvbG9ycztcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUoYXJncyk7XG5cbiAgLy8gSW5pdCB0aGUgYXRsYXMgaWYgbmVlZGVkXG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3Qge3NkZkdseXBoU2l6ZX0gPSBhcmdzO1xuICBjb25zdCBnbHlwaHNQZXJSb3cgPSAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplICogNCk7XG4gIGxldCBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXTtcbiAgaWYgKCFhdGxhcykge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2RmR2x5cGhTaXplICogMjU2IC8gZ2x5cGhzUGVyUm93OyAvLyBzdGFydCB0YWxsIGVub3VnaCB0byBmaXQgMjU2IGdseXBoc1xuICAgIGF0bGFzID0gYXRsYXNlc1tzZGZHbHlwaFNpemVdID0ge1xuICAgICAgZ2x5cGhDb3VudDogMCxcbiAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgIHNkZkNhbnZhczogY2FudmFzLFxuICAgICAgc2RmVGV4dHVyZTogbmV3IFRleHR1cmUoXG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgTGluZWFyRmlsdGVyLFxuICAgICAgICBMaW5lYXJGaWx0ZXJcbiAgICAgICksXG4gICAgICBjb250ZXh0TG9zdDogZmFsc2UsXG4gICAgICBnbHlwaHNCeUZvbnQ6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgYXRsYXMuc2RmVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcyk7XG4gIH1cblxuICBjb25zdCB7c2RmVGV4dHVyZSwgc2RmQ2FudmFzfSA9IGF0bGFzO1xuXG4gIC8vIElzc3VlIHJlcXVlc3QgdG8gdGhlIHR5cGVzZXR0aW5nIGVuZ2luZSBpbiB0aGUgd29ya2VyXG4gIHR5cGVzZXRJbldvcmtlcihhcmdzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgY29uc3Qge2dseXBoSWRzLCBnbHlwaEZvbnRJbmRpY2VzLCBmb250RGF0YSwgZ2x5cGhQb3NpdGlvbnMsIGZvbnRTaXplLCB0aW1pbmdzfSA9IHJlc3VsdDtcbiAgICBjb25zdCBuZWVkZWRTREZzID0gW107XG4gICAgY29uc3QgZ2x5cGhCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBoSWRzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBib3VuZHNJZHggPSAwO1xuICAgIGxldCBwb3NpdGlvbnNJZHggPSAwO1xuICAgIGNvbnN0IHF1YWRzU3RhcnQgPSBub3ckMSgpO1xuXG4gICAgY29uc3QgZm9udEdseXBoTWFwcyA9IGZvbnREYXRhLm1hcChmb250ID0+IHtcbiAgICAgIGxldCBtYXAgPSBhdGxhcy5nbHlwaHNCeUZvbnQuZ2V0KGZvbnQuc3JjKTtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIGF0bGFzLmdseXBoc0J5Rm9udC5zZXQoZm9udC5zcmMsIG1hcCA9IG5ldyBNYXAoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwXG4gICAgfSk7XG5cbiAgICBnbHlwaElkcy5mb3JFYWNoKChnbHlwaElkLCBpKSA9PiB7XG4gICAgICBjb25zdCBmb250SW5kZXggPSBnbHlwaEZvbnRJbmRpY2VzW2ldO1xuICAgICAgY29uc3Qge3NyYzogZm9udFNyYywgdW5pdHNQZXJFbX0gPSBmb250RGF0YVtmb250SW5kZXhdO1xuICAgICAgbGV0IGdseXBoSW5mbyA9IGZvbnRHbHlwaE1hcHNbZm9udEluZGV4XS5nZXQoZ2x5cGhJZCk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBnbHlwaElkIG5vdCBzZWVuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBhdGxhc1xuICAgICAgaWYgKCFnbHlwaEluZm8pIHtcbiAgICAgICAgY29uc3Qge3BhdGgsIHBhdGhCb3VuZHN9ID0gcmVzdWx0LmdseXBoRGF0YVtmb250U3JjXVtnbHlwaElkXTtcblxuICAgICAgICAvLyBNYXJnaW4gYXJvdW5kIHBhdGggZWRnZXMgaW4gU0RGLCBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGdseXBoJ3MgbWF4IGRpbWVuc2lvbi5cbiAgICAgICAgLy8gTm90ZSB3ZSBhZGQgYW4gZXh0cmEgMC41IHB4IG92ZXIgdGhlIGNvbmZpZ3VyZWQgdmFsdWUgYmVjYXVzZSB0aGUgb3V0ZXIgMC41IGRvZXNuJ3QgY29udGFpblxuICAgICAgICAvLyB1c2VmdWwgaW50ZXJwb2xhdGVkIHZhbHVlcyBhbmQgd2lsbCBiZSBpZ25vcmVkIGFueXdheS5cbiAgICAgICAgY29uc3QgZm9udFVuaXRzTWFyZ2luID0gTWF0aC5tYXgocGF0aEJvdW5kc1syXSAtIHBhdGhCb3VuZHNbMF0sIHBhdGhCb3VuZHNbM10gLSBwYXRoQm91bmRzWzFdKVxuICAgICAgICAgIC8gc2RmR2x5cGhTaXplICogKENPTkZJRy5zZGZNYXJnaW4gKiBzZGZHbHlwaFNpemUgKyAwLjUpO1xuXG4gICAgICAgIGNvbnN0IGF0bGFzSW5kZXggPSBhdGxhcy5nbHlwaENvdW50Kys7XG4gICAgICAgIGNvbnN0IHNkZlZpZXdCb3ggPSBbXG4gICAgICAgICAgcGF0aEJvdW5kc1swXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzFdIC0gZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbMl0gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1szXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgXTtcbiAgICAgICAgZm9udEdseXBoTWFwc1tmb250SW5kZXhdLnNldChnbHlwaElkLCAoZ2x5cGhJbmZvID0geyBwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94IH0pKTtcblxuICAgICAgICAvLyBDb2xsZWN0IHRob3NlIHRoYXQgbmVlZCBTREYgZ2VuZXJhdGlvblxuICAgICAgICBuZWVkZWRTREZzLnB1c2goZ2x5cGhJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGJvdW5kcyBmb3IgcmVuZGVyYWJsZSBxdWFkc1xuICAgICAgLy8gVE9ETyBjYW4gd2UgZ2V0IHRoaXMgYmFjayBvZmYgdGhlIG1haW4gdGhyZWFkP1xuICAgICAgY29uc3Qge3NkZlZpZXdCb3h9ID0gZ2x5cGhJbmZvO1xuICAgICAgY29uc3QgcG9zWCA9IGdseXBoUG9zaXRpb25zW3Bvc2l0aW9uc0lkeCsrXTtcbiAgICAgIGNvbnN0IHBvc1kgPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NYICsgc2RmVmlld0JveFswXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1kgKyBzZGZWaWV3Qm94WzFdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMl0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFszXSAqIGZvbnRTaXplTXVsdDtcblxuICAgICAgLy8gQ29udmVydCBnbHlwaElkIHRvIFNERiBpbmRleCBmb3IgdGhlIHNoYWRlclxuICAgICAgZ2x5cGhJZHNbaV0gPSBnbHlwaEluZm8uYXRsYXNJbmRleDtcbiAgICB9KTtcbiAgICB0aW1pbmdzLnF1YWRzID0gKHRpbWluZ3MucXVhZHMgfHwgMCkgKyAobm93JDEoKSAtIHF1YWRzU3RhcnQpO1xuXG4gICAgY29uc3Qgc2RmU3RhcnQgPSBub3ckMSgpO1xuICAgIHRpbWluZ3Muc2RmID0ge307XG5cbiAgICAvLyBHcm93IHRoZSB0ZXh0dXJlIGhlaWdodCBieSBwb3dlciBvZiAyIGlmIG5lZWRlZFxuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBzZGZDYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IG5lZWRlZFJvd3MgPSBNYXRoLmNlaWwoYXRsYXMuZ2x5cGhDb3VudCAvIGdseXBoc1BlclJvdyk7XG4gICAgY29uc3QgbmVlZGVkSGVpZ2h0ID0gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMihuZWVkZWRSb3dzICogc2RmR2x5cGhTaXplKSkpO1xuICAgIGlmIChuZWVkZWRIZWlnaHQgPiBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAvLyBTaW5jZSByZXNpemluZyB0aGUgY2FudmFzIGNsZWFycyBpdHMgcmVuZGVyIGJ1ZmZlciwgaXQgbmVlZHMgc3BlY2lhbCBoYW5kbGluZyB0byBjb3B5IHRoZSBvbGQgY29udGVudHMgb3ZlclxuICAgICAgY29uc29sZS5pbmZvKGBJbmNyZWFzaW5nIFNERiB0ZXh0dXJlIHNpemUgJHtjdXJyZW50SGVpZ2h0fS0+JHtuZWVkZWRIZWlnaHR9YCk7XG4gICAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhzZGZDYW52YXMsIHRleHR1cmVXaWR0aCwgbmVlZGVkSGVpZ2h0KTtcbiAgICAgIC8vIEFzIG9mIFRocmVlIHIxMzYgdGV4dHVyZXMgY2Fubm90IGJlIHJlc2l6ZWQgb25jZSB0aGV5J3JlIGFsbG9jYXRlZCBvbiB0aGUgR1BVLCB3ZSBtdXN0IGRpc3Bvc2UgdG8gcmVhbGxvY2F0ZSBpdFxuICAgICAgc2RmVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgUHJvbWlzZS5hbGwobmVlZGVkU0RGcy5tYXAoZ2x5cGhJbmZvID0+XG4gICAgICBnZW5lcmF0ZUdseXBoU0RGKGdseXBoSW5mbywgYXRsYXMsIGFyZ3MuZ3B1QWNjZWxlcmF0ZVNERikudGhlbigoe3RpbWluZ30pID0+IHtcbiAgICAgICAgdGltaW5ncy5zZGZbZ2x5cGhJbmZvLmF0bGFzSW5kZXhdID0gdGltaW5nO1xuICAgICAgfSlcbiAgICApKS50aGVuKCgpID0+IHtcbiAgICAgIGlmIChuZWVkZWRTREZzLmxlbmd0aCAmJiAhYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgICAgc2RmVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aW1pbmdzLnNkZlRvdGFsID0gbm93JDEoKSAtIHNkZlN0YXJ0O1xuICAgICAgdGltaW5ncy50b3RhbCA9IG5vdyQxKCkgLSB0b3RhbFN0YXJ0O1xuICAgICAgLy8gY29uc29sZS5sb2coYFNERiAtICR7dGltaW5ncy5zZGZUb3RhbH0sIFRvdGFsIC0gJHt0aW1pbmdzLnRvdGFsIC0gdGltaW5ncy5mb250TG9hZH1gKVxuXG4gICAgICAvLyBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aGUgdGV4dCBsYXlvdXQgYXJyYXlzIGFuZCB1cGRhdGVkIHRleHR1cmVcbiAgICAgIGNhbGxiYWNrKE9iamVjdC5mcmVlemUoe1xuICAgICAgICBwYXJhbWV0ZXJzOiBhcmdzLFxuICAgICAgICBzZGZUZXh0dXJlLFxuICAgICAgICBzZGZHbHlwaFNpemUsXG4gICAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgICBnbHlwaEJvdW5kcyxcbiAgICAgICAgZ2x5cGhBdGxhc0luZGljZXM6IGdseXBoSWRzLFxuICAgICAgICBnbHlwaENvbG9yczogcmVzdWx0LmdseXBoQ29sb3JzLFxuICAgICAgICBjYXJldFBvc2l0aW9uczogcmVzdWx0LmNhcmV0UG9zaXRpb25zLFxuICAgICAgICBjaHVua2VkQm91bmRzOiByZXN1bHQuY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgYXNjZW5kZXI6IHJlc3VsdC5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiByZXN1bHQuZGVzY2VuZGVyLFxuICAgICAgICBsaW5lSGVpZ2h0OiByZXN1bHQubGluZUhlaWdodCxcbiAgICAgICAgY2FwSGVpZ2h0OiByZXN1bHQuY2FwSGVpZ2h0LFxuICAgICAgICB4SGVpZ2h0OiByZXN1bHQueEhlaWdodCxcbiAgICAgICAgdG9wQmFzZWxpbmU6IHJlc3VsdC50b3BCYXNlbGluZSxcbiAgICAgICAgYmxvY2tCb3VuZHM6IHJlc3VsdC5ibG9ja0JvdW5kcyxcbiAgICAgICAgdmlzaWJsZUJvdW5kczogcmVzdWx0LnZpc2libGVCb3VuZHMsXG4gICAgICAgIHRpbWluZ3M6IHJlc3VsdC50aW1pbmdzLFxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBXaGlsZSB0aGUgdHlwZXNldHRpbmcgcmVxdWVzdCBpcyBiZWluZyBoYW5kbGVkLCBnbyBhaGVhZCBhbmQgbWFrZSBzdXJlIHRoZSBhdGxhcyBjYW52YXMgY29udGV4dCBpc1xuICAvLyBcIndhcm1lZCB1cFwiOyB0aGUgZmlyc3QgcmVxdWVzdCB3aWxsIGJlIHRoZSBsb25nZXN0IGR1ZSB0byBzaGFkZXIgcHJvZ3JhbSBjb21waWxhdGlvbiBzbyB0aGlzIGdldHNcbiAgLy8gYSBoZWFkIHN0YXJ0IG9uIHRoYXQgcHJvY2VzcyBiZWZvcmUgU0RGcyBhY3R1YWxseSBzdGFydCBnZXR0aW5nIHByb2Nlc3NlZC5cbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKCFhdGxhcy5jb250ZXh0TG9zdCkge1xuICAgICAgd2FybVVwU0RGQ2FudmFzKHNkZkNhbnZhcyk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVHbHlwaFNERih7cGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveH0sIHtzZGZHbHlwaFNpemUsIHNkZkNhbnZhcywgY29udGV4dExvc3R9LCB1c2VHUFUpIHtcbiAgaWYgKGNvbnRleHRMb3N0KSB7XG4gICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgbG9zdCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvLCBqdXN0IHF1aXQgc2lsZW50bHkgYW5kIGxldCBpdFxuICAgIC8vIGdldCByZWdlbmVyYXRlZCB3aGVuIHRoZSBjb250ZXh0IGlzIHJlc3RvcmVkXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dGltaW5nOiAtMX0pXG4gIH1cbiAgY29uc3Qge3RleHR1cmVXaWR0aCwgc2RmRXhwb25lbnR9ID0gQ09ORklHO1xuICBjb25zdCBtYXhEaXN0ID0gTWF0aC5tYXgoc2RmVmlld0JveFsyXSAtIHNkZlZpZXdCb3hbMF0sIHNkZlZpZXdCb3hbM10gLSBzZGZWaWV3Qm94WzFdKTtcbiAgY29uc3Qgc3F1YXJlSW5kZXggPSBNYXRoLmZsb29yKGF0bGFzSW5kZXggLyA0KTtcbiAgY29uc3QgeCA9IHNxdWFyZUluZGV4ICUgKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSkgKiBzZGZHbHlwaFNpemU7XG4gIGNvbnN0IHkgPSBNYXRoLmZsb29yKHNxdWFyZUluZGV4IC8gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSkpICogc2RmR2x5cGhTaXplO1xuICBjb25zdCBjaGFubmVsID0gYXRsYXNJbmRleCAlIDQ7XG4gIHJldHVybiBnZW5lcmF0ZVNERihzZGZHbHlwaFNpemUsIHNkZkdseXBoU2l6ZSwgcGF0aCwgc2RmVmlld0JveCwgbWF4RGlzdCwgc2RmRXhwb25lbnQsIHNkZkNhbnZhcywgeCwgeSwgY2hhbm5lbCwgdXNlR1BVKVxufVxuXG5mdW5jdGlvbiBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcykge1xuICBjb25zdCBjYW52YXMgPSBhdGxhcy5zZGZDYW52YXM7XG5cbiAgLypcbiAgLy8gQmVnaW4gY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgaWYgKCF3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzKSB7XG4gICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXZWJHTERlYnVnVXRpbHNTY3JpcHQnKVxuICAgIGlmICghc2NyaXB0KSB7XG4gICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgICAgc2NyaXB0LmlkID0gJ1dlYkdMRGVidWdVdGlscydcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgICAgc2NyaXB0LnNyYyA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvS2hyb25vc0dyb3VwL1dlYkdMRGV2ZWxvcGVyVG9vbHNAYjQyZTcwMi9zcmMvZGVidWcvd2ViZ2wtZGVidWcuanMnXG4gICAgfVxuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzLm1ha2VMb3N0Q29udGV4dFNpbXVsYXRpbmdDYW52YXMoY2FudmFzKVxuICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDApXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIChldmVudCkgPT4ge1xuICAgIGNhbnZhcy5sb3NlQ29udGV4dEluTkNhbGxzKDUwMDApXG4gIH0pXG4gIC8vIEVuZCBjb250ZXh0IGxvc3Mgc2ltdWxhdGlvblxuICAqL1xuXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NvbnRleHQgTG9zdCcsIGV2ZW50KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGF0bGFzLmNvbnRleHRMb3N0ID0gdHJ1ZTtcbiAgfSk7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IFJlc3RvcmVkJywgZXZlbnQpO1xuICAgIGF0bGFzLmNvbnRleHRMb3N0ID0gZmFsc2U7XG4gICAgLy8gUmVnZW5lcmF0ZSBhbGwgZ2x5cGhzIGludG8gdGhlIHJlc3RvcmVkIGNhbnZhczpcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGF0bGFzLmdseXBoc0J5Rm9udC5mb3JFYWNoKGdseXBoTWFwID0+IHtcbiAgICAgIGdseXBoTWFwLmZvckVhY2goZ2x5cGggPT4ge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGdlbmVyYXRlR2x5cGhTREYoZ2x5cGgsIGF0bGFzLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgYXRsYXMuc2RmVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFByZWxvYWQgYSBnaXZlbiBmb250IGFuZCBvcHRpb25hbGx5IHByZS1nZW5lcmF0ZSBnbHlwaCBTREZzIGZvciBvbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzLlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIGF2b2lkIGxvbmcgcGF1c2VzIHdoZW4gZmlyc3Qgc2hvd2luZyB0ZXh0IGluIGEgc2NlbmUsIGJ5IHByZWxvYWRpbmcgdGhlXG4gKiBuZWVkZWQgZm9udHMgYW5kIGdseXBocyB1cCBmcm9udCBhbG9uZyB3aXRoIG90aGVyIGFzc2V0cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9udCAtIFVSTCBvZiB0aGUgZm9udCBmaWxlIHRvIHByZWxvYWQuIElmIG5vdCBnaXZlbiwgdGhlIGRlZmF1bHQgZm9udCB3aWxsXG4gKiAgICAgICAgYmUgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMuY2hhcmFjdGVycyAtIE9uZSBvciBtb3JlIGNoYXJhY3RlciBzZXF1ZW5jZXMgZm9yIHdoaWNoIHRvIHByZS1cbiAqICAgICAgICBnZW5lcmF0ZSBnbHlwaCBTREZzLiBOb3RlIHRoYXQgdGhpcyB3aWxsIGhvbm9yIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiwgc28geW91IG1heSBuZWVkXG4gKiAgICAgICAgdG8gc3BlY2lmeSBsaWdhdHVyZSBzZXF1ZW5jZXMgaW4gYWRkaXRpb24gdG8gdGhlaXIgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIHRvIGdldCBhbGxcbiAqICAgICAgICBwb3NzaWJsZSBnbHlwaHMsIGUuZy4gYFtcInRcIiwgXCJoXCIsIFwidGhcIl1gIHRvIGdldCB0aGUgXCJ0XCIgYW5kIFwiaFwiIGdseXBocyBwbHVzIHRoZSBcInRoXCIgbGlnYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZGZHbHlwaFNpemUgLSBUaGUgc2l6ZSBhdCB3aGljaCB0byBwcmVyZW5kZXIgdGhlIFNERiB0ZXh0dXJlcyBmb3IgdGhlXG4gKiAgICAgICAgc3BlY2lmaWVkIGBjaGFyYWN0ZXJzYC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHByZWxvYWRpbmcgaXMgY29tcGxldGUuXG4gKi9cbmZ1bmN0aW9uIHByZWxvYWRGb250KHtmb250LCBjaGFyYWN0ZXJzLCBzZGZHbHlwaFNpemV9LCBjYWxsYmFjaykge1xuICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoY2hhcmFjdGVycykgPyBjaGFyYWN0ZXJzLmpvaW4oJ1xcbicpIDogJycgKyBjaGFyYWN0ZXJzO1xuICBnZXRUZXh0UmVuZGVySW5mbyh7IGZvbnQsIHNkZkdseXBoU2l6ZSwgdGV4dCB9LCBjYWxsYmFjayk7XG59XG5cblxuLy8gTG9jYWwgYXNzaWduIGltcGwgc28gd2UgZG9uJ3QgaGF2ZSB0byBpbXBvcnQgdHJvaWthLWNvcmVcbmZ1bmN0aW9uIGFzc2lnbih0b09iaiwgZnJvbU9iaikge1xuICBmb3IgKGxldCBrZXkgaW4gZnJvbU9iaikge1xuICAgIGlmIChmcm9tT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRvT2JqW2tleV0gPSBmcm9tT2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0b09ialxufVxuXG4vLyBVdGlsaXR5IGZvciBtYWtpbmcgVVJMcyBhYnNvbHV0ZVxubGV0IGxpbmtFbDtcbmZ1bmN0aW9uIHRvQWJzb2x1dGVVUkwocGF0aCkge1xuICBpZiAoIWxpbmtFbCkge1xuICAgIGxpbmtFbCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgfVxuICBsaW5rRWwuaHJlZiA9IHBhdGg7XG4gIHJldHVybiBsaW5rRWwuaHJlZlxufVxuXG4vKipcbiAqIFNhZmFyaSA8IHYxNSBzZWVtcyB1bmFibGUgdG8gdXNlIHRoZSBTREYgd2ViZ2wgY2FudmFzIGFzIGEgdGV4dHVyZS4gVGhpcyBhcHBsaWVzIGEgd29ya2Fyb3VuZFxuICogd2hlcmUgaXQgcmVhZHMgdGhlIHBpeGVscyBvdXQgb2YgdGhhdCBjYW52YXMgYW5kIHVwbG9hZHMgdGhlbSBhcyBhIGRhdGEgdGV4dHVyZSBpbnN0ZWFkLCBhdFxuICogYSBzbGlnaHQgcGVyZm9ybWFuY2UgY29zdC5cbiAqL1xuZnVuY3Rpb24gc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKSB7XG4gIC8vIFVzZSBjcmVhdGVJbWFnZUJpdG1hcCBzdXBwb3J0IGFzIGEgcHJveHkgZm9yIFNhZmFyaTwxNSwgYWxsIG90aGVyIG1haW5zdHJlYW0gYnJvd3NlcnNcbiAgLy8gaGF2ZSBzdXBwb3J0ZWQgaXQgZm9yIGEgbG9uZyB3aGlsZSBzbyBhbnkgZmFsc2UgcG9zaXRpdmVzIHNob3VsZCBiZSBtaW5pbWFsLlxuICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5pbmZvKCdTYWZhcmk8MTU6IGFwcGx5aW5nIFNERiBjYW52YXMgd29ya2Fyb3VuZCcpO1xuICAgIGNvbnN0IHtzZGZDYW52YXMsIHNkZlRleHR1cmV9ID0gYXRsYXM7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2RmQ2FudmFzO1xuICAgIGNvbnN0IGdsID0gYXRsYXMuc2RmQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgbGV0IHBpeGVscyA9IHNkZlRleHR1cmUuaW1hZ2UuZGF0YTtcbiAgICBpZiAoIXBpeGVscyB8fCBwaXhlbHMubGVuZ3RoICE9PSB3aWR0aCAqIGhlaWdodCAqIDQpIHtcbiAgICAgIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBzZGZUZXh0dXJlLmltYWdlID0ge3dpZHRoLCBoZWlnaHQsIGRhdGE6IHBpeGVsc307XG4gICAgICBzZGZUZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICBzZGZUZXh0dXJlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gIH1cbn1cblxuY29uc3QgdHlwZXNldHRlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIGNyZWF0ZVR5cGVzZXR0ZXIsXG4gICAgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlLFxuICAgIGJpZGlGYWN0b3J5LFxuICBdLFxuICBpbml0KGNyZWF0ZVR5cGVzZXR0ZXIsIGZvbnRSZXNvbHZlciwgYmlkaUZhY3RvcnkpIHtcbiAgICByZXR1cm4gY3JlYXRlVHlwZXNldHRlcihmb250UmVzb2x2ZXIsIGJpZGlGYWN0b3J5KCkpXG4gIH1cbn0pO1xuXG5jb25zdCB0eXBlc2V0SW5Xb3JrZXIgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICB0eXBlc2V0dGVyV29ya2VyTW9kdWxlLFxuICBdLFxuICBpbml0KHR5cGVzZXR0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0eXBlc2V0dGVyLnR5cGVzZXQoYXJncywgcmVzb2x2ZSk7XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAvLyBNYXJrIGFycmF5IGJ1ZmZlcnMgYXMgdHJhbnNmZXJhYmxlIHRvIGF2b2lkIGNsb25pbmcgZHVyaW5nIHBvc3RNZXNzYWdlXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIGZvciAobGV0IHAgaW4gcmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0W3BdICYmIHJlc3VsdFtwXS5idWZmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHJlc3VsdFtwXS5idWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlc1xuICB9XG59KTtcblxuZnVuY3Rpb24gZHVtcFNERlRleHR1cmVzKCkge1xuICBPYmplY3Qua2V5cyhhdGxhc2VzKS5mb3JFYWNoKHNpemUgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGNhbnZhcztcbiAgICBjb25zb2xlLmxvZyhcIiVjLlwiLCBgXG4gICAgICBiYWNrZ3JvdW5kOiB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHt3aWR0aH1weCAke2hlaWdodH1weDtcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHt3aWR0aH1weDtcbiAgICBgKTtcbiAgfSk7XG59XG5cbmNvbnN0IHRlbXBsYXRlR2VvbWV0cmllcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICBsZXQgZ2VvbSA9IHRlbXBsYXRlR2VvbWV0cmllc1tkZXRhaWxdO1xuICBpZiAoIWdlb20pIHtcbiAgICAvLyBHZW9tZXRyeSBpcyB0d28gcGxhbmVzIGJhY2stdG8tYmFjaywgd2hpY2ggd2lsbCBhbHdheXMgYmUgcmVuZGVyZWQgRnJvbnRTaWRlIG9ubHkgYnV0XG4gICAgLy8gYXBwZWFyIGFzIERvdWJsZVNpZGUgYnkgZGVmYXVsdC4gRnJvbnRTaWRlL0JhY2tTaWRlIGFyZSBlbXVsYXRlZCB1c2luZyBkcmF3UmFuZ2UuXG4gICAgLy8gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGhpdCBvZiB0d28gZHJhdyBjYWxscyBmb3IgRG91YmxlU2lkZSBtYXRlcmlhbHNcbiAgICAvLyBpbnRyb2R1Y2VkIGJ5IFRocmVlLmpzIGluIHIxMzAgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3XG4gICAgY29uc3QgZnJvbnQgPSBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCBkZXRhaWwsIGRldGFpbCk7XG4gICAgY29uc3QgYmFjayA9IGZyb250LmNsb25lKCk7XG4gICAgY29uc3QgZnJvbnRBdHRycyA9IGZyb250LmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgYmFja0F0dHJzID0gYmFjay5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgdmVydENvdW50ID0gZnJvbnRBdHRycy51di5jb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRDb3VudDsgaSsrKSB7XG4gICAgICBiYWNrQXR0cnMucG9zaXRpb24uYXJyYXlbaSAqIDNdICo9IC0xOyAvLyBmbGlwIHBvc2l0aW9uIHhcbiAgICAgIGJhY2tBdHRycy5ub3JtYWwuYXJyYXlbaSAqIDMgKyAyXSAqPSAtMTsgLy8gZmxpcCBub3JtYWwgelxuICAgIH1cbiAgICBbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb21iaW5lZC5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgIFsuLi5mcm9udEF0dHJzW25hbWVdLmFycmF5LCAuLi5iYWNrQXR0cnNbbmFtZV0uYXJyYXldLFxuICAgICAgICBmcm9udEF0dHJzW25hbWVdLml0ZW1TaXplKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb21iaW5lZC5zZXRJbmRleChbLi4uZnJvbnQuaW5kZXguYXJyYXksIC4uLmJhY2suaW5kZXguYXJyYXkubWFwKG4gPT4gbiArIHZlcnRDb3VudCldKTtcbiAgICBjb21iaW5lZC50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICAgIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXSA9IGNvbWJpbmVkO1xuICB9XG4gIHJldHVybiBnZW9tXG59XG5cbmNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbmNvbnN0IGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG5jb25zdCBnbHlwaENvbG9yQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQ29sb3InO1xuXG4vKipcbkBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG5BIHNwZWNpYWxpemVkIEdlb21ldHJ5IGZvciByZW5kZXJpbmcgYSBzZXQgb2YgdGV4dCBnbHlwaHMuIFVzZXMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgdG9cbnJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG5nZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICBXaGVyZSBOID0gbnVtYmVyIG9mIGdseXBocy4uLlxuXG4gIEluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogNCAqIDNcbiAgLSBpbmRleDogMiAqIDNcbiAgLSBub3JtYWw6IDQgKiAzXG4gIC0gdXY6IDQgKiAyXG4gIC0gZ2x5cGggeC95IGJvdW5kczogTiAqIDRcbiAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICA9IDVOICsgMzhcblxuICBOb24taW5zdGFuY2VkOlxuICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgLSBpbmRleDogTiAqIDIgKiAzXG4gIC0gbm9ybWFsOiBOICogNCAqIDNcbiAgLSB1djogTiAqIDQgKiAyXG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSAzOU5cblxuQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbndoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4qL1xuY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvLyBEZWZpbmUgZ3JvdXBzIGZvciByZW5kZXJpbmcgdGV4dCBvdXRsaW5lIGFzIGEgc2VwYXJhdGUgcGFzczsgdGhlc2Ugd2lsbCBvbmx5XG4gICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgdGhpcy5ncm91cHMgPSBbXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMH0sXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICBdO1xuXG4gICAgLy8gUHJlYWxsb2NhdGUgZW1wdHkgYm91bmRpbmcgb2JqZWN0c1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ1NwaGVyZSBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgfVxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdCb3ggcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICAvLyBTaW5jZSBvdXIgYmFzZSBnZW9tZXRyeSBjb250YWlucyB0cmlhbmdsZXMgZm9yIGJvdGggZnJvbnQgYW5kIGJhY2sgc2lkZXMsIHdlIGNhbiBlbXVsYXRlXG4gIC8vIHRoZSBcInNpZGVcIiBieSByZXN0cmljdGluZyB0aGUgZHJhdyByYW5nZS5cbiAgc2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLmdldEluZGV4KCkuY291bnQ7XG4gICAgdGhpcy5zZXREcmF3UmFuZ2Uoc2lkZSA9PT0gQmFja1NpZGUgPyB2ZXJ0cyAvIDIgOiAwLCBzaWRlID09PSBEb3VibGVTaWRlID8gdmVydHMgOiB2ZXJ0cyAvIDIpO1xuICB9XG5cbiAgc2V0IGRldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoZGV0YWlsICE9PSB0aGlzLl9kZXRhaWwpIHtcbiAgICAgIHRoaXMuX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgIGRldGFpbCA9IDE7XG4gICAgICB9XG4gICAgICBsZXQgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICA7Wydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gPSB0cGwuYXR0cmlidXRlc1thdHRyXS5jbG9uZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgZGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXRhaWxcbiAgfVxuXG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgaWYgKHIgIT09IHRoaXMuX2N1cnZlUmFkaXVzKSB7XG4gICAgICB0aGlzLl9jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJ2ZVJhZGl1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHBsYW5hciBib3VuZHMgZm9yIGFsbCBnbHlwaHNcbiAgICogICAgICAgIHRvIGJlIHJlbmRlcmVkLCA0IGVudHJpZXMgZm9yIGVhY2ggZ2x5cGg6IHgxLHgyLHkxLHkxXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAqICAgICAgICB0aGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgW21pblgsIG1pblksIG1heFgsIG1heFldIGFjcm9zcyBhbGwgZ2x5cGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgKiAgICAgICAgY29uc2VjdXRpdmUgZ2x5cGhzOiBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLiBUaGlzIGNhbiBiZVxuICAgKiAgICAgICAgdXNlZCB3aXRoIGBhcHBseUNsaXBSZWN0YCB0byBjaG9vc2UgYW4gb3B0aW1pemVkIGBpbnN0YW5jZUNvdW50YC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAqL1xuICB1cGRhdGVHbHlwaHMoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCBibG9ja0JvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQm91bmRzQXR0ck5hbWUsIGdseXBoQm91bmRzLCA0KTtcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhDb2xvckF0dHJOYW1lLCBnbHlwaENvbG9ycywgMyk7XG4gICAgdGhpcy5fYmxvY2tCb3VuZHMgPSBibG9ja0JvdW5kcztcbiAgICB0aGlzLl9jaHVua2VkQm91bmRzID0gY2h1bmtlZEJvdW5kcztcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2Jsb2NrQm91bmRzO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIGNvbnN0IHsgY3VydmVSYWRpdXMsIGJvdW5kaW5nQm94OiBiYm94IH0gPSB0aGlzO1xuICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHsgUEksIGZsb29yLCBtaW4sIG1heCwgc2luLCBjb3MgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IGhhbGZQaSA9IFBJIC8gMjtcbiAgICAgICAgY29uc3QgdHdvUGkgPSBQSSAqIDI7XG4gICAgICAgIGNvbnN0IGFic1IgPSBNYXRoLmFicyhjdXJ2ZVJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGJvdW5kc1swXSAvIGFic1I7XG4gICAgICAgIGNvbnN0IHJpZ2h0QW5nbGUgPSBib3VuZHNbMl0gLyBhYnNSO1xuICAgICAgICBjb25zdCBtaW5YID0gZmxvb3IoKGxlZnRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgID8gLWFic1IgOiBtaW4oc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IGZsb29yKChsZWZ0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IGFic1IgOiBtYXgoc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WiA9IGZsb29yKChsZWZ0QW5nbGUgKyBQSSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgUEkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSICogMiA6IG1heChhYnNSIC0gY29zKGxlZnRBbmdsZSkgKiBhYnNSLCBhYnNSIC0gY29zKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGJib3gubWluLnNldChtaW5YLCBib3VuZHNbMV0sIGN1cnZlUmFkaXVzIDwgMCA/IC1tYXhaIDogMCk7XG4gICAgICAgIGJib3gubWF4LnNldChtYXhYLCBib3VuZHNbM10sIGN1cnZlUmFkaXVzIDwgMCA/IDAgOiBtYXhaKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJib3gubWluLnNldChib3VuZHNbMF0sIGJvdW5kc1sxXSwgMCk7XG4gICAgICAgIGJib3gubWF4LnNldChib3VuZHNbMl0sIGJvdW5kc1szXSwgMCk7XG4gICAgICB9XG4gICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuYm91bmRpbmdTcGhlcmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNsaXBwaW5nIHJlY3QsIGFuZCB0aGUgY2h1bmtlZEJvdW5kcyBmcm9tIHRoZSBsYXN0IHVwZGF0ZUdseXBocyBjYWxsLCBjaG9vc2UgdGhlIGxvd2VzdFxuICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICogZm9yIGxvbmcgYmxvY2tzIG9mIHRleHQgdGhhdCBhcmUgY2xpcHBlZCwgdG8gc2tpcCB2ZXJ0ZXggc2hhZGVyIGV2YWx1YXRpb24gZm9yIGdseXBocyB0aGF0IHdvdWxkXG4gICAqIGJlIGNsaXBwZWQgYW55d2F5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc2luY2UgYGRyYXdFbGVtZW50c0luc3RhbmNlZFtBTkdMRV1gIG9ubHkgYWNjZXB0cyBhbiBpbnN0YW5jZSBjb3VudCBhbmQgbm90IGEgc3RhcnRpbmdcbiAgICogb2Zmc2V0LCB0aGlzIG9wdGltaXphdGlvbiBiZWNvbWVzIGxlc3MgZWZmZWN0aXZlIGFzIHRoZSBjbGlwUmVjdCBtb3ZlcyBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICogYnV0IGF0IHRoZSBleHBlbnNlIG9mIG11Y2ggbGFyZ2VyIGF0dHJpYnV0ZSBidWZmZXJzIChzZWUgY2xhc3Nkb2MgYWJvdmUuKVxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAqL1xuICBhcHBseUNsaXBSZWN0KGNsaXBSZWN0KSB7XG4gICAgbGV0IGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICBsZXQgY2h1bmtzID0gdGhpcy5fY2h1bmtlZEJvdW5kcztcbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb3VudCA9IGNodW5rc1tpXS5lbmQ7XG4gICAgICAgIGxldCByZWN0ID0gY2h1bmtzW2ldLnJlY3Q7XG4gICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgaWYgKHJlY3RbMV0gPCBjbGlwUmVjdC53ICYmIHJlY3RbM10gPiBjbGlwUmVjdC55ICYmIHJlY3RbMF0gPCBjbGlwUmVjdC56ICYmIHJlY3RbMl0gPiBjbGlwUmVjdC54KSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBjb3VudDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckF0dHIoZ2VvbSwgYXR0ck5hbWUsIG5ld0FycmF5LCBpdGVtU2l6ZSkge1xuICBjb25zdCBhdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICBpZiAobmV3QXJyYXkpIHtcbiAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgaWYgKGF0dHIgJiYgYXR0ci5hcnJheS5sZW5ndGggPT09IG5ld0FycmF5Lmxlbmd0aCkge1xuICAgICAgYXR0ci5hcnJheS5zZXQobmV3QXJyYXkpO1xuICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb20uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ld0FycmF5LCBpdGVtU2l6ZSkpO1xuICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjYWNoZWQgbWF4IGluc3RhbmNlIGNvdW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTk3MDZcbiAgICAgIC8vIEl0J3MgdW5jbGVhciBpZiB0aGlzIGlzIGEgdGhyZWVqcyBidWcgb3IgYSB0cnVseSB1bnN1cHBvcnRlZCBzY2VuYXJpbzsgZGlzY3Vzc2lvbiBpblxuICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgIC8vIGRpZmZlcmVudCBzaXplIGlzIHN1cHBvcnRlZCwgYnV0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xNzQxOCBzdHJvbmdseVxuICAgICAgLy8gaW1wbGllcyBpdCBzaG91bGQgYmUgc3VwcG9ydGVkLiBJdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG9cbiAgICAgIGRlbGV0ZSBnZW9tLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgZ2VvbS5kaXNwb3NlKCk7IC8vZm9yIHIxMTgrLCBtb3JlIHJvYnVzdCBmZWVsaW5nLCBidXQgbW9yZSBoZWF2eS1oYW5kZWQgdGhhbiBJJ2QgbGlrZVxuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgZ2VvbS5kZWxldGVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICB9XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IFZFUlRFWF9ERUZTID0gYFxudW5pZm9ybSB2ZWMyIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERkdseXBoU2l6ZTtcbnVuaWZvcm0gdmVjNCB1VHJvaWthVG90YWxCb3VuZHM7XG51bmlmb3JtIHZlYzQgdVRyb2lrYUNsaXBSZWN0O1xudW5pZm9ybSBtYXQzIHVUcm9pa2FPcmllbnQ7XG51bmlmb3JtIGJvb2wgdVRyb2lrYVVzZUdseXBoQ29sb3JzO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRGlzdGFuY2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMyIHVUcm9pa2FQb3NpdGlvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUN1cnZlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgYVRyb2lrYUdseXBoQm91bmRzO1xuYXR0cmlidXRlIGZsb2F0IGFUcm9pa2FHbHlwaEluZGV4O1xuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbmNvbnN0IFZFUlRFWF9UUkFOU0ZPUk0gPSBgXG52ZWM0IGJvdW5kcyA9IGFUcm9pa2FHbHlwaEJvdW5kcztcbmJvdW5kcy54eiArPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueDtcbmJvdW5kcy55dyAtPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueTtcblxudmVjNCBvdXRsaW5lQm91bmRzID0gdmVjNChcbiAgYm91bmRzLnh5IC0gdVRyb2lrYURpc3RhbmNlT2Zmc2V0IC0gdVRyb2lrYUJsdXJSYWRpdXMsXG4gIGJvdW5kcy56dyArIHVUcm9pa2FEaXN0YW5jZU9mZnNldCArIHVUcm9pa2FCbHVyUmFkaXVzXG4pO1xudmVjNCBjbGlwcGVkQm91bmRzID0gdmVjNChcbiAgY2xhbXAob3V0bGluZUJvdW5kcy54eSwgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpLFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnp3LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dylcbik7XG5cbnZlYzIgY2xpcHBlZFhZID0gKG1peChjbGlwcGVkQm91bmRzLnh5LCBjbGlwcGVkQm91bmRzLnp3LCBwb3NpdGlvbi54eSkgLSBib3VuZHMueHkpIC8gKGJvdW5kcy56dyAtIGJvdW5kcy54eSk7XG5cbnBvc2l0aW9uLnh5ID0gbWl4KGJvdW5kcy54eSwgYm91bmRzLnp3LCBjbGlwcGVkWFkpO1xuXG51diA9IChwb3NpdGlvbi54eSAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLnp3IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KTtcblxuZmxvYXQgcmFkID0gdVRyb2lrYUN1cnZlUmFkaXVzO1xuaWYgKHJhZCAhPSAwLjApIHtcbiAgZmxvYXQgYW5nbGUgPSBwb3NpdGlvbi54IC8gcmFkO1xuICBwb3NpdGlvbi54eiA9IHZlYzIoc2luKGFuZ2xlKSAqIHJhZCwgcmFkIC0gY29zKGFuZ2xlKSAqIHJhZCk7XG4gIG5vcm1hbC54eiA9IHZlYzIoc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG59XG4gIFxucG9zaXRpb24gPSB1VHJvaWthT3JpZW50ICogcG9zaXRpb247XG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xuXG52VHJvaWthR2x5cGhVViA9IGNsaXBwZWRYWS54eTtcbnZUcm9pa2FHbHlwaERpbWVuc2lvbnMgPSB2ZWMyKGJvdW5kc1syXSAtIGJvdW5kc1swXSwgYm91bmRzWzNdIC0gYm91bmRzWzFdKTtcblxuJHsnJy8qIE5PVEU6IGl0IHNlZW1zIGltcG9ydGFudCB0byBjYWxjdWxhdGUgdGhlIGdseXBoJ3MgYm91bmRpbmcgdGV4dHVyZSBVVnMgaGVyZSBpbiB0aGVcbiAgdmVydGV4IHNoYWRlciwgcmF0aGVyIHRoYW4gaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgYXMgdGhlIGxhdHRlciBnaXZlcyBzdHJhbmdlIGFydGlmYWN0c1xuICBvbiBzb21lIGdseXBocyAodGhvc2UgaW4gdGhlIGxlZnRtb3N0IHRleHR1cmUgY29sdW1uKSBvbiBzb21lIHN5c3RlbXMuIFRoZSBleGFjdCByZWFzb25cbiAgaXNuJ3QgdW5kZXJzdG9vZCBidXQgZG9pbmcgdGhpcyBoZXJlLCB0aGVuIG1peCgpLWluZyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBzZWVtcyB0byB3b3JrLiAqL31cbmZsb2F0IHR4Q29scyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZS54IC8gdVRyb2lrYVNERkdseXBoU2l6ZTtcbnZlYzIgdHhVdlBlclNxdWFyZSA9IHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG52ZWMyIHR4U3RhcnRVViA9IHR4VXZQZXJTcXVhcmUgKiB2ZWMyKFxuICBtb2QoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApLCB0eENvbHMpLFxuICBmbG9vcihmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCkgLyB0eENvbHMpXG4pO1xudlRyb2lrYVRleHR1cmVVVkJvdW5kcyA9IHZlYzQodHhTdGFydFVWLCB2ZWMyKHR4U3RhcnRVVikgKyB0eFV2UGVyU3F1YXJlKTtcbnZUcm9pa2FUZXh0dXJlQ2hhbm5lbCA9IG1vZChhVHJvaWthR2x5cGhJbmRleCwgNC4wKTtcbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRmlsbE9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FPdXRsaW5lT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBGUkFHTUVOVF9UUkFOU0ZPUk0gPSBgXG5mbG9hdCBhYURpc3QgPSB0cm9pa2FHZXRBQURpc3QoKTtcbmZsb2F0IGZyYWdEaXN0YW5jZSA9IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKTtcbmZsb2F0IGVkZ2VBbHBoYSA9IHVUcm9pa2FTREZEZWJ1ZyA/XG4gIHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZUcm9pa2FHbHlwaFVWKSA6XG4gIHRyb2lrYUdldEVkZ2VBbHBoYShmcmFnRGlzdGFuY2UsIHVUcm9pa2FEaXN0YW5jZU9mZnNldCwgbWF4KGFhRGlzdCwgdVRyb2lrYUJsdXJSYWRpdXMpKTtcblxuI2lmICFkZWZpbmVkKElTX0RFUFRIX01BVEVSSUFMKSAmJiAhZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbnZlYzQgZmlsbFJHQkEgPSBnbF9GcmFnQ29sb3I7XG5maWxsUkdCQS5hICo9IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnZlYzQgc3Ryb2tlUkdCQSA9IHVUcm9pa2FTdHJva2VXaWR0aCA9PSAwLjAgPyBmaWxsUkdCQSA6IHZlYzQodVRyb2lrYVN0cm9rZUNvbG9yLCB1VHJvaWthU3Ryb2tlT3BhY2l0eSk7XG5pZiAoZmlsbFJHQkEuYSA9PSAwLjApIGZpbGxSR0JBLnJnYiA9IHN0cm9rZVJHQkEucmdiO1xuZ2xfRnJhZ0NvbG9yID0gbWl4KGZpbGxSR0JBLCBzdHJva2VSR0JBLCBzbW9vdGhzdGVwKFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoIC0gYWFEaXN0LFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoICsgYWFEaXN0LFxuICBmcmFnRGlzdGFuY2VcbikpO1xuZ2xfRnJhZ0NvbG9yLmEgKj0gZWRnZUFscGhhO1xuI2VuZGlmXG5cbmlmIChlZGdlQWxwaGEgPT0gMC4wKSB7XG4gIGRpc2NhcmQ7XG59XG5gO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgY29uc3QgdGV4dE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgZXh0ZW5zaW9uczoge1xuICAgICAgZGVyaXZhdGl2ZXM6IHRydWVcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU0RGRXhwb25lbnQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IFZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgdVRyb2lrYUNsaXBSZWN0OiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FEaXN0YW5jZU9mZnNldDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FPdXRsaW5lT3BhY2l0eToge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FGaWxsT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FQb3NpdGlvbk9mZnNldDoge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FCbHVyUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZUNvbG9yOiB7dmFsdWU6IG5ldyBDb2xvcigpfSxcbiAgICAgIHVUcm9pa2FTdHJva2VPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgdVRyb2lrYU9yaWVudDoge3ZhbHVlOiBuZXcgTWF0cml4MygpfSxcbiAgICAgIHVUcm9pa2FVc2VHbHlwaENvbG9yczoge3ZhbHVlOiB0cnVlfSxcbiAgICAgIHVUcm9pa2FTREZEZWJ1Zzoge3ZhbHVlOiBmYWxzZX1cbiAgICB9LFxuICAgIHZlcnRleERlZnM6IFZFUlRFWF9ERUZTLFxuICAgIHZlcnRleFRyYW5zZm9ybTogVkVSVEVYX1RSQU5TRk9STSxcbiAgICBmcmFnbWVudERlZnM6IEZSQUdNRU5UX0RFRlMsXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybTogRlJBR01FTlRfVFJBTlNGT1JNLFxuICAgIGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSkge1xuICAgICAgbGV0IHVEaWZmdXNlUkUgPSAvXFxidW5pZm9ybVxccyt2ZWMzXFxzK2RpZmZ1c2VcXGIvO1xuICAgICAgaWYgKHVEaWZmdXNlUkUudGVzdChmcmFnbWVudFNoYWRlcikpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIGBkaWZmdXNlYCB3aXRoIG91ciB2YXJ5aW5nXG4gICAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAucmVwbGFjZSh1RGlmZnVzZVJFLCAndmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxiZGlmZnVzZVxcYi9nLCAndlRyb2lrYUdseXBoQ29sb3InKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2ZXJ0ZXggc2hhZGVyIGRlY2xhcmVzIHRoZSB1bmlmb3JtIHNvIHdlIGNhbiBncmFiIGl0IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgaWYgKCF1RGlmZnVzZVJFLnRlc3QodmVydGV4U2hhZGVyKSkge1xuICAgICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAgICAgdm9pZE1haW5SZWdFeHAsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxuJCZcXG52VHJvaWthR2x5cGhDb2xvciA9IHVUcm9pa2FVc2VHbHlwaENvbG9ycyA/IGFUcm9pa2FHbHlwaENvbG9yIC8gMjU1LjAgOiBkaWZmdXNlO1xcbidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcmNlIHRyYW5zcGFyZW5jeSAtIFRPRE8gaXMgdGhpcyByZWFzb25hYmxlP1xuICB0ZXh0TWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgIGlzVHJvaWthVGV4dE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgLy8gV2ViR0xTaGFkb3dNYXAgcmV2ZXJzZXMgdGhlIHNpZGUgb2YgdGhlIHNoYWRvdyBtYXRlcmlhbCBieSBkZWZhdWx0LCB3aGljaCBmYWlsc1xuICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICBzaGFkb3dTaWRlOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZGVcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIC8vbm8tb3BcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXh0TWF0ZXJpYWxcbn1cblxuY29uc3QgZGVmYXVsdE1hdGVyaWFsID0gLyojX19QVVJFX18qLyBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICBjb2xvcjogMHhmZmZmZmYsXG4gIHNpZGU6IERvdWJsZVNpZGUsXG4gIHRyYW5zcGFyZW50OiB0cnVlXG59KTtcbmNvbnN0IGRlZmF1bHRTdHJva2VDb2xvciA9IDB4ODA4MDgwO1xuXG5jb25zdCB0ZW1wTWF0NCA9IC8qI19fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IHRlbXBWZWMzYSA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBWZWMzYiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBBcnJheSA9IFtdO1xuY29uc3Qgb3JpZ2luID0gLyojX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgZGVmYXVsdE9yaWVudCA9ICcreCt5JztcblxuZnVuY3Rpb24gZmlyc3Qobykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvXG59XG5cbmxldCBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxKSxcbiAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgKTtcbiAgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5sZXQgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCAzMiwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5cbmNvbnN0IHN5bmNTdGFydEV2ZW50ID0geyB0eXBlOiAnc3luY3N0YXJ0JyB9O1xuY29uc3Qgc3luY0NvbXBsZXRlRXZlbnQgPSB7IHR5cGU6ICdzeW5jY29tcGxldGUnIH07XG5cbmNvbnN0IFNZTkNBQkxFX1BST1BTID0gW1xuICAnZm9udCcsXG4gICdmb250U2l6ZScsXG4gICdmb250U3R5bGUnLFxuICAnZm9udFdlaWdodCcsXG4gICdsYW5nJyxcbiAgJ2xldHRlclNwYWNpbmcnLFxuICAnbGluZUhlaWdodCcsXG4gICdtYXhXaWR0aCcsXG4gICdvdmVyZmxvd1dyYXAnLFxuICAndGV4dCcsXG4gICdkaXJlY3Rpb24nLFxuICAndGV4dEFsaWduJyxcbiAgJ3RleHRJbmRlbnQnLFxuICAnd2hpdGVTcGFjZScsXG4gICdhbmNob3JYJyxcbiAgJ2FuY2hvclknLFxuICAnY29sb3JSYW5nZXMnLFxuICAnc2RmR2x5cGhTaXplJ1xuXTtcblxuY29uc3QgQ09QWUFCTEVfUFJPUFMgPSBTWU5DQUJMRV9QUk9QUy5jb25jYXQoXG4gICdtYXRlcmlhbCcsXG4gICdjb2xvcicsXG4gICdkZXB0aE9mZnNldCcsXG4gICdjbGlwUmVjdCcsXG4gICdjdXJ2ZVJhZGl1cycsXG4gICdvcmllbnRhdGlvbicsXG4gICdnbHlwaEdlb21ldHJ5RGV0YWlsJ1xuKTtcblxuLyoqXG4gKiBAY2xhc3MgVGV4dFxuICpcbiAqIEEgVGhyZWVKUyBNZXNoIHRoYXQgcmVuZGVycyBhIHN0cmluZyBvZiB0ZXh0IG9uIGEgcGxhbmUgaW4gM0Qgc3BhY2UgdXNpbmcgc2lnbmVkIGRpc3RhbmNlXG4gKiBmaWVsZHMgKFNERikuXG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2x5cGhzR2VvbWV0cnkoKTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbnVsbCk7XG5cbiAgICAvLyA9PT0gVGV4dCBsYXlvdXQgcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRcbiAgICAgKiBUaGUgc3RyaW5nIG9mIHRleHQgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdGhpcy50ZXh0ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICogRGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB4IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzLCBhIHN0cmluZyBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbFxuICAgICAqIHRleHQgYmxvY2sgd2lkdGggZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6ICdsZWZ0JywgJ2NlbnRlcicsXG4gICAgICogb3IgJ3JpZ2h0Jy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWVxuICAgICAqIERlZmluZXMgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHkgcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMgKG5vdGU6IGRvd24gaXMgbmVnYXRpdmUgeSksIGEgc3RyaW5nXG4gICAgICogcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgdGV4dCBibG9jayBoZWlnaHQgZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6XG4gICAgICogJ3RvcCcsICd0b3AtYmFzZWxpbmUnLCAndG9wLWNhcCcsICd0b3AtZXgnLCAnbWlkZGxlJywgJ2JvdHRvbS1iYXNlbGluZScsIG9yICdib3R0b20nLlxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGN1cnZlUmFkaXVzXG4gICAgICogRGVmaW5lcyBhIGN5bGluZHJpY2FsIHJhZGl1cyBhbG9uZyB3aGljaCB0aGUgdGV4dCdzIHBsYW5lIHdpbGwgYmUgY3VydmVkLiBQb3NpdGl2ZSBudW1iZXJzIHB1dFxuICAgICAqIHRoZSBjeWxpbmRlcidzIGNlbnRlcmxpbmUgKG9yaWVudGVkIHZlcnRpY2FsbHkpIHRoYXQgZGlzdGFuY2UgaW4gZnJvbnQgb2YgdGhlIHRleHQsIGZvciBhIGNvbmNhdmVcbiAgICAgKiBjdXJ2YXR1cmUsIHdoaWxlIG5lZ2F0aXZlIG51bWJlcnMgcHV0IGl0IGJlaGluZCB0aGUgdGV4dCBmb3IgYSBjb252ZXggY3VydmF0dXJlLiBUaGUgY2VudGVybGluZVxuICAgICAqIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSB0ZXh0J3MgbG9jYWwgb3JpZ2luOyB5b3UgY2FuIHVzZSBgYW5jaG9yWGAgdG8gb2Zmc2V0IGl0LlxuICAgICAqXG4gICAgICogU2luY2UgZWFjaCBnbHlwaCBpcyBieSBkZWZhdWx0IHJlbmRlcmVkIHdpdGggYSBzaW1wbGUgcXVhZCwgZWFjaCBnbHlwaCByZW1haW5zIGEgZmxhdCBwbGFuZVxuICAgICAqIGludGVybmFsbHkuIFlvdSBjYW4gdXNlIGBnbHlwaEdlb21ldHJ5RGV0YWlsYCB0byBhZGQgbW9yZSB2ZXJ0aWNlcyBmb3IgY3VydmF0dXJlIGluc2lkZSBnbHlwaHMuXG4gICAgICovXG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRpcmVjdGlvblxuICAgICAqIFNldHMgdGhlIGJhc2UgZGlyZWN0aW9uIGZvciB0aGUgdGV4dC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgXCJhdXRvXCIgd2lsbCBjaG9vc2UgYSBkaXJlY3Rpb24gYmFzZWRcbiAgICAgKiBvbiB0aGUgdGV4dCdzIGNvbnRlbnQgYWNjb3JkaW5nIHRvIHRoZSBiaWRpIHNwZWMuIEEgdmFsdWUgb2YgXCJsdHJcIiBvciBcInJ0bFwiIHdpbGwgZm9yY2UgdGhlIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9ICdhdXRvJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfSBmb250XG4gICAgICogVVJMIG9mIGEgY3VzdG9tIGZvbnQgdG8gYmUgdXNlZC4gRm9udCBmaWxlcyBjYW4gYmUgaW4gLnR0ZiwgLm90Ziwgb3IgLndvZmYgKG5vdCAud29mZjIpIGZvcm1hdHMuXG4gICAgICogRGVmYXVsdHMgdG8gTm90byBTYW5zLlxuICAgICAqL1xuICAgIHRoaXMuZm9udCA9IG51bGw7IC8vd2lsbCB1c2UgZGVmYXVsdCBmcm9tIFRleHRCdWlsZGVyXG5cbiAgICB0aGlzLnVuaWNvZGVGb250c1VSTCA9IG51bGw7IC8vZGVmYXVsdHMgdG8gQ0ROXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICogVGhlIHNpemUgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBmb250IGluIGxvY2FsIHVuaXRzOyBjb3JyZXNwb25kcyB0byB0aGUgZW0tYm94IGhlaWdodFxuICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFNpemUgPSAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfVxuICAgICAqIFRoZSB3ZWlnaHQgb2YgdGhlIGZvbnQuIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIGZhbGxiYWNrIE5vdG8gZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnaXRhbGljJ31cbiAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZvbnQuIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIGZhbGxiYWNrIE5vdG8gZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5mb250U3R5bGUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfSBsYW5nXG4gICAgICogVGhlIGxhbmd1YWdlIGNvZGUgb2YgdGhpcyB0ZXh0OyBjYW4gYmUgdXNlZCBmb3IgZXhwbGljaXRseSBzZWxlY3RpbmcgY2VydGFpbiBDSksgZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5sYW5nID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAgICogU2V0cyBhIHVuaWZvcm0gYWRqdXN0bWVudCB0byBzcGFjaW5nIGJldHdlZW4gbGV0dGVycyBhZnRlciBrZXJuaW5nIGlzIGFwcGxpZWQuIFBvc2l0aXZlXG4gICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAqL1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBsaW5lSGVpZ2h0XG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LCBhcyBhIG11bHRpcGxlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byAnbm9ybWFsJ1xuICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4V2lkdGhcbiAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgdGV4dCBibG9jaywgYWJvdmUgd2hpY2ggdGV4dCBtYXkgc3RhcnQgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICB0aGlzLm1heFdpZHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG92ZXJmbG93V3JhcFxuICAgICAqIERlZmluZXMgaG93IHRleHQgd3JhcHMgaWYgdGhlIGB3aGl0ZVNwYWNlYCBwcm9wZXJ0eSBpcyBgbm9ybWFsYC4gQ2FuIGJlIGVpdGhlciBgJ25vcm1hbCdgXG4gICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICogRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0ZXh0SW5kZW50XG4gICAgICogSW5kZW50YXRpb24gZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaW5lOyBzZWUgQ1NTIGB0ZXh0LWluZGVudGAuXG4gICAgICovXG4gICAgdGhpcy50ZXh0SW5kZW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gd2hpdGVTcGFjZVxuICAgICAqIERlZmluZXMgd2hldGhlciB0ZXh0IHNob3VsZCB3cmFwIHdoZW4gYSBsaW5lIHJlYWNoZXMgdGhlIGBtYXhXaWR0aGAuIENhblxuICAgICAqIGJlIGVpdGhlciBgJ25vcm1hbCdgICh0aGUgZGVmYXVsdCksIHRvIGFsbG93IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGUgYG92ZXJmbG93V3JhcGAgcHJvcGVydHksXG4gICAgICogb3IgYCdub3dyYXAnYCB0byBwcmV2ZW50IHdyYXBwaW5nLiBOb3RlIHRoYXQgYCdub3JtYWwnYCBoZXJlIGhvbm9ycyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICAgKiBtYW51YWxseSBicmVhayBsaW5lcywgbWFraW5nIGl0IGJlaGF2ZSBtb3JlIGxpa2UgYCdwcmUtd3JhcCdgIGRvZXMgaW4gQ1NTLlxuICAgICAqL1xuICAgIHRoaXMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuXG5cbiAgICAvLyA9PT0gUHJlc2VudGF0aW9uIHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICogRGVmaW5lcyBhIF9iYXNlXyBtYXRlcmlhbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZXh0LiBUaGlzIG1hdGVyaWFsIHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggYSBtYXRlcmlhbCBkZXJpdmVkIGZyb20gaXQsIHRoYXQgYWRkcyBzaGFkZXIgY29kZSB0b1xuICAgICAqIGRlY3JlYXNlIHRoZSBhbHBoYSBmb3IgZWFjaCBmcmFnbWVudCAocGl4ZWwpIG91dHNpZGUgdGhlIHRleHQgZ2x5cGhzLCB3aXRoIGFudGlhbGlhc2luZy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IHdpbGwgZGVyaXZlIGZyb20gYSBzaW1wbGUgd2hpdGUgTWVzaEJhc2ljTWF0ZXJpYWwsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAgICAgKiBvZiB0aGUgb3RoZXIgbWVzaCBtYXRlcmlhbHMgdG8gZ2FpbiBvdGhlciBmZWF0dXJlcyBsaWtlIGxpZ2h0aW5nLCB0ZXh0dXJlIG1hcHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIEFsc28gc2VlIHRoZSBgY29sb3JgIHNob3J0Y3V0IHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gY29sb3JcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIGBjb2xvcmAgb2YgdGhlIHRleHQncyBtYXRlcmlhbC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAqIGlmIHlvdSBkb24ndCB3YW50IHRvIHNwZWNpZnkgYSB3aG9sZSBjdXN0b20gYG1hdGVyaWFsYC4gQWxzbywgaWYgeW91IGRvIHVzZSBhIGN1c3RvbVxuICAgICAqIGBtYXRlcmlhbGAsIHRoaXMgY29sb3Igd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoaXMgcGFydGljdWFyIFRleHQgaW5zdGFuY2UsIGV2ZW4gaWZcbiAgICAgKiB0aGF0IHNhbWUgbWF0ZXJpYWwgaW5zdGFuY2UgaXMgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBUZXh0IG9iamVjdHMuXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8bnVsbH0gY29sb3JSYW5nZXNcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhpcyBhbGxvd3MgbW9yZSBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBjb2xvcnMgZm9yIGluZGl2aWR1YWwgb3IgcmFuZ2VzIG9mIGNoYXJhY3RlcnMsXG4gICAgICogdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWF0ZXJpYWwncyBgY29sb3JgLiBJdHMgZm9ybWF0IGlzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGVhY2hcbiAgICAgKiBkZWZpbmUgYSBzdGFydGluZyBjaGFyYWN0ZXIgaW5kZXggZm9yIGEgcmFuZ2UsIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHRoZSBjb2xvciBmb3IgZWFjaFxuICAgICAqIHJhbmdlLiBUaGUgY29sb3IgdmFsdWUgY2FuIGJlIGEgbnVtZXJpYyBoZXggY29sb3IgdmFsdWUsIGEgYFRIUkVFLkNvbG9yYCBvYmplY3QsIG9yXG4gICAgICogYW55IG9mIHRoZSBzdHJpbmdzIGFjY2VwdGVkIGJ5IGBUSFJFRS5Db2xvcmAuXG4gICAgICovXG4gICAgdGhpcy5jb2xvclJhbmdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lV2lkdGhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIHdpZHRoIG9mIGFuIG91dGxpbmUvaGFsbyB0byBiZSBkcmF3biBhcm91bmQgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgb3V0bGluZUNvbG9yYCBhbmQgYG91dGxpbmVPcGFjaXR5YC5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLCB3aGljaCBtZWFuc1xuICAgICAqIG5vIG91dGxpbmUgd2lsbCBiZSBkcmF3biB1bmxlc3MgYW4gYG91dGxpbmVPZmZzZXRYL1lgIG9yIGBvdXRsaW5lQmx1cmAgaXMgc2V0LlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IG91dGxpbmVDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBibGFjay5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVDb2xvciA9IDB4MDAwMDAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBvdXRsaW5lT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lQmx1clxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIGJsdXIgcmFkaXVzIGFwcGxpZWQgdG8gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIHRleHQncyBvdXRsaW5lLiBJZiB0aGUgYG91dGxpbmVXaWR0aGAgaXNcbiAgICAgKiB6ZXJvLCB0aGUgYmx1ciB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlIGdseXBoIGVkZ2UsIGxpa2UgQ1NTJ3MgYHRleHQtc2hhZG93YCBibHVyIHJhZGl1cy5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZUJsdXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9mZnNldFggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSB2ZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPZmZzZXRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IHN0cm9rZVdpZHRoXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbiBpbm5lciBzdHJva2UgZHJhd24gaW5zaWRlIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYHN0cm9rZUNvbG9yYCBhbmQgYHN0cm9rZU9wYWNpdHlgLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBzdHJva2VDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBncmF5LlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBkZWZhdWx0U3Ryb2tlQ29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHN0cm9rZU9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbGxPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBnbHlwaCdzIGZpbGwgZnJvbSAwIHRvIDEuIFRoaXMgYmVoYXZlcyBsaWtlIHRoZSBtYXRlcmlhbCdzIGBvcGFjaXR5YCBidXQgYWxsb3dzXG4gICAgICogZ2l2aW5nIHRoZSBmaWxsIGEgZGlmZmVyZW50IG9wYWNpdHkgdGhhbiB0aGUgYHN0cm9rZU9wYWNpdHlgLiBBIGZpbGxPcGFjaXR5IG9mIGAwYCBtYWtlcyB0aGVcbiAgICAgKiBpbnRlcmlvciBvZiB0aGUgZ2x5cGggaW52aXNpYmxlLCBsZWF2aW5nIGp1c3QgdGhlIGBzdHJva2VXaWR0aGAuIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZGVwdGhPZmZzZXRcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIG1hdGVyaWFsJ3MgYHBvbHlnb25PZmZzZXRgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMsXG4gICAgICogd2hpY2ggY2FuIGJlIHVzZWZ1bCBpbiBwcmV2ZW50aW5nIHotZmlnaHRpbmcgd2hlbiB0aGlzIHRleHQgaXMgbGFpZCBvbiB0b3Agb2YgYW5vdGhlclxuICAgICAqIHBsYW5lIGluIHRoZSBzY2VuZS4gUG9zaXRpdmUgbnVtYmVycyBhcmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEsIG5lZ2F0aXZlcyBjbG9zZXIuXG4gICAgICovXG4gICAgdGhpcy5kZXB0aE9mZnNldCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSBjbGlwUmVjdFxuICAgICAqIElmIHNwZWNpZmllZCwgZGVmaW5lcyBhIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIG9mIGEgcmVjdGFuZ2xlIG91dHNpZGUgb2Ygd2hpY2ggYWxsXG4gICAgICogcGl4ZWxzIHdpbGwgYmUgZGlzY2FyZGVkLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGNsaXAgb3ZlcmZsb3dpbmcgdGV4dCB3aGVuXG4gICAgICogYHdoaXRlU3BhY2U9J25vd3JhcCdgLlxuICAgICAqL1xuICAgIHRoaXMuY2xpcFJlY3QgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBvcmllbnRhdGlvblxuICAgICAqIERlZmluZXMgdGhlIGF4aXMgcGxhbmUgb24gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IHdoZW4gdGhlIG1lc2ggaGFzIG5vIGV4dHJhXG4gICAgICogcm90YXRpb24gdHJhbnNmb3JtLiBJdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgd2l0aCB0d28gYXhlczogdGhlIGhvcml6b250YWwgYXhpcyB3aXRoXG4gICAgICogcG9zaXRpdmUgcG9pbnRpbmcgcmlnaHQsIGFuZCB0aGUgdmVydGljYWwgYXhpcyB3aXRoIHBvc2l0aXZlIHBvaW50aW5nIHVwLiBCeSBkZWZhdWx0IHRoaXNcbiAgICAgKiBpcyAnK3greScsIG1lYW5pbmcgdGhlIHRleHQgc2l0cyBvbiB0aGUgeHkgcGxhbmUgd2l0aCB0aGUgdGV4dCdzIHRvcCB0b3dhcmQgcG9zaXRpdmUgeVxuICAgICAqIGFuZCBmYWNpbmcgcG9zaXRpdmUgei4gQSB2YWx1ZSBvZiAnK3gteicgd291bGQgcGxhY2UgaXQgb24gdGhlIHh6IHBsYW5lIHdpdGggdGhlIHRleHQnc1xuICAgICAqIHRvcCB0b3dhcmQgbmVnYXRpdmUgeiBhbmQgZmFjaW5nIHBvc2l0aXZlIHkuXG4gICAgICovXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IGRlZmF1bHRPcmllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGdseXBoR2VvbWV0cnlEZXRhaWxcbiAgICAgKiBDb250cm9scyBudW1iZXIgb2YgdmVydGljYWwvaG9yaXpvbnRhbCBzZWdtZW50cyB0aGF0IG1ha2UgdXAgZWFjaCBnbHlwaCdzIHJlY3Rhbmd1bGFyXG4gICAgICogcGxhbmUuIERlZmF1bHRzIHRvIDEuIFRoaXMgY2FuIGJlIGluY3JlYXNlZCB0byBwcm92aWRlIG1vcmUgZ2VvbWV0cmljYWwgZGV0YWlsIGZvciBjdXN0b21cbiAgICAgKiB2ZXJ0ZXggc2hhZGVyIGVmZmVjdHMsIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIHRoaXMuZ2x5cGhHZW9tZXRyeURldGFpbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8bnVsbH0gc2RmR2x5cGhTaXplXG4gICAgICogVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKSB1c2VkIGZvciByZW5kZXJpbmcuIFRoaXMgbXVzdCBiZSBhXG4gICAgICogcG93ZXItb2YtdHdvIG51bWJlci4gRGVmYXVsdHMgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHlcbiAgICAgKiBmb3IgbW9zdCBmb250cy4gTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nXG4gICAgICogdGhlIHNoYXJwbmVzcyBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAqIGluY3JlYXNlZCBtZW1vcnkgZm9vdHByaW50IGFuZCBsb25nZXIgU0RGIGdlbmVyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICB0aGlzLnNkZkdseXBoU2l6ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBncHVBY2NlbGVyYXRlU0RGXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBTREYgZ2VuZXJhdGlvbiBwcm9jZXNzIHdpbGwgYmUgR1BVLWFjY2VsZXJhdGVkIHdpdGggV2ViR0wgd2hlbiBwb3NzaWJsZSxcbiAgICAgKiBtYWtpbmcgaXQgbXVjaCBmYXN0ZXIgZXNwZWNpYWxseSBmb3IgY29tcGxleCBnbHlwaHMsIGFuZCBmYWxsaW5nIGJhY2sgdG8gYSBKYXZhU2NyaXB0IHZlcnNpb25cbiAgICAgKiBleGVjdXRlZCBpbiB3ZWIgd29ya2VycyB3aGVuIHN1cHBvcnQgaXNuJ3QgYXZhaWxhYmxlLiBJdCBzaG91bGQgYXV0b21hdGljYWxseSBkZXRlY3Qgc3VwcG9ydCxcbiAgICAgKiBidXQgaXQncyBzdGlsbCBzb21ld2hhdCBleHBlcmltZW50YWwsIHNvIHlvdSBjYW4gc2V0IGl0IHRvIGBmYWxzZWAgdG8gZm9yY2UgaXQgdG8gdXNlIHRoZSBKU1xuICAgICAqIHZlcnNpb24gaWYgeW91IGVuY291bnRlciBpc3N1ZXMgd2l0aCBpdC5cbiAgICAgKi9cbiAgICB0aGlzLmdwdUFjY2VsZXJhdGVTREYgPSB0cnVlO1xuXG4gICAgdGhpcy5kZWJ1Z1NERiA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRleHQgcmVuZGVyaW5nIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB0ZXh0LXJlbGF0ZWQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jIHByb2Nlc3MsIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaXRcbiAgICogZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHN5bmMoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fbmVlZHNTeW5jKSB7XG4gICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBhbm90aGVyIHN5bmMgc3RpbGwgaW4gcHJvZ3Jlc3MsIHF1ZXVlXG4gICAgICBpZiAodGhpcy5faXNTeW5jaW5nKSB7XG4gICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNTdGFydEV2ZW50KTtcblxuICAgICAgICBnZXRUZXh0UmVuZGVySW5mbyh7XG4gICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICBsYW5nOiB0aGlzLmxhbmcsXG4gICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUgfHwgMC4xLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBmb250U3R5bGU6IHRoaXMuZm9udFN0eWxlIHx8ICdub3JtYWwnLFxuICAgICAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyB8fCAwLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBtYXhXaWR0aDogdGhpcy5tYXhXaWR0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uIHx8ICdhdXRvJyxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgICAgIHRleHRJbmRlbnQ6IHRoaXMudGV4dEluZGVudCxcbiAgICAgICAgICB3aGl0ZVNwYWNlOiB0aGlzLndoaXRlU3BhY2UsXG4gICAgICAgICAgb3ZlcmZsb3dXcmFwOiB0aGlzLm92ZXJmbG93V3JhcCxcbiAgICAgICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgIGNvbG9yUmFuZ2VzOiB0aGlzLmNvbG9yUmFuZ2VzLFxuICAgICAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9uczogdHJ1ZSwgLy9UT0RPIHBhcmFtZXRlcml6ZVxuICAgICAgICAgIHNkZkdseXBoU2l6ZTogdGhpcy5zZGZHbHlwaFNpemUsXG4gICAgICAgICAgZ3B1QWNjZWxlcmF0ZVNERjogdGhpcy5ncHVBY2NlbGVyYXRlU0RGLFxuICAgICAgICAgIHVuaWNvZGVGb250c1VSTDogdGhpcy51bmljb2RlRm9udHNVUkwsXG4gICAgICAgIH0sIHRleHRSZW5kZXJJbmZvID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFNhdmUgcmVzdWx0IGZvciBsYXRlciB1c2UgaW4gb25CZWZvcmVSZW5kZXJcbiAgICAgICAgICB0aGlzLl90ZXh0UmVuZGVySW5mbyA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgICAgdGhpcy5nZW9tZXRyeS51cGRhdGVHbHlwaHMoXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uYmxvY2tCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5jaHVua2VkQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhDb2xvcnNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgd2UgaGFkIGV4dHJhIHN5bmMgcmVxdWVzdHMgcXVldWVkIHVwLCBraWNrIGl0IG9mZlxuICAgICAgICAgIGNvbnN0IHF1ZXVlZCA9IHRoaXMuX3F1ZXVlZFN5bmNzO1xuICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICBxdWV1ZWQuZm9yRWFjaChmbiA9PiBmbiAmJiBmbigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jQ29tcGxldGVFdmVudCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAqIGVhcmxpZXN0IHNvIGlmIHBvc3NpYmxlIGl0J3MgYSBnb29kIGlkZWEgdG8gY2FsbCBzeW5jKCkgbWFudWFsbHkgYXMgc29vbiBhc1xuICAgKiBhbGwgdGhlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkJlZm9yZVJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuICAgIHRoaXMuc3luYygpO1xuXG4gICAgLy8gVGhpcyBtYXkgbm90IGFsd2F5cyBiZSBhIHRleHQgbWF0ZXJpYWwsIGUuZy4gaWYgdGhlcmUncyBhIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgcHJlc2VudFxuICAgIGlmIChtYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byBmb3JjZSB0aGUgbWF0ZXJpYWwgdG8gRnJvbnRTaWRlIHRvIGF2b2lkIHRoZSBkb3VibGUtZHJhdy1jYWxsIHBlcmZvcm1hbmNlIGhpdFxuICAgIC8vIGludHJvZHVjZWQgaW4gVGhyZWUuanMgcjEzMDogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3IC0gVGhlIHNpZGVkbmVzc1xuICAgIC8vIGlzIGluc3RlYWQgYXBwbGllZCB2aWEgZHJhd1JhbmdlIGluIHRoZSBHbHlwaHNHZW9tZXRyeS5cbiAgICBtYXRlcmlhbC5faGFkT3duU2lkZSA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdzaWRlJyk7XG4gICAgdGhpcy5nZW9tZXRyeS5zZXRTaWRlKG1hdGVyaWFsLl9hY3R1YWxTaWRlID0gbWF0ZXJpYWwuc2lkZSk7XG4gICAgbWF0ZXJpYWwuc2lkZSA9IEZyb250U2lkZTtcbiAgfVxuXG4gIG9uQWZ0ZXJSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1hdGVyaWFsIHNpZGVcbiAgICBpZiAobWF0ZXJpYWwuX2hhZE93blNpZGUpIHtcbiAgICAgIG1hdGVyaWFsLnNpZGUgPSBtYXRlcmlhbC5fYWN0dWFsU2lkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hdGVyaWFsLnNpZGU7IC8vIGJhY2sgdG8gaW5oZXJpdGluZyBmcm9tIGJhc2UgbWF0ZXJpYWxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gZGlzcG9zZSB0aGUgZ2VvbWV0cnkgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICogTm90ZTogd2UgZG9uJ3QgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGhlcmUgYmVjYXVzZSBpZiBhbnl0aGluZyBlbHNlIGlzXG4gICAqIHNoYXJpbmcgdGhlIHNhbWUgYmFzZSBtYXRlcmlhbCBpdCB3aWxsIHJlc3VsdCBpbiBhIHBhdXNlIG5leHQgZnJhbWUgYXMgdGhlIHByb2dyYW1cbiAgICogaXMgcmVjb21waWxlZC4gSW5zdGVhZCB1c2VycyBjYW4gZGlzcG9zZSB0aGUgYmFzZSBtYXRlcmlhbCBtYW51YWxseSwgbGlrZSBub3JtYWwsXG4gICAqIGFuZCB3ZSdsbCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgYXQgdGhhdCB0aW1lLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge1Ryb2lrYVRleHRSZW5kZXJJbmZvfG51bGx9IHRleHRSZW5kZXJJbmZvXG4gICAqIEByZWFkb25seVxuICAgKiBUaGUgY3VycmVudCBwcm9jZXNzZWQgcmVuZGVyaW5nIGRhdGEgZm9yIHRoaXMgVGV4dE1lc2gsIHJldHVybmVkIGJ5IHRoZSBUZXh0QnVpbGRlciBhZnRlclxuICAgKiBhIGBzeW5jKClgIGNhbGwuIFRoaXMgd2lsbCBiZSBgbnVsbGAgaW5pdGlhbGx5LCBhbmQgbWF5IGJlIHN0YWxlIGZvciBhIHNob3J0IHBlcmlvZCB1bnRpbFxuICAgKiB0aGUgYXN5bmNocm91cyBgc3luYygpYCBwcm9jZXNzIGNvbXBsZXRlcy5cbiAgICovXG4gIGdldCB0ZXh0UmVuZGVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlbmRlckluZm8gfHwgbnVsbFxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdE1hdGVyaWFsLmNsb25lKCkpO1xuICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB0ZXh0IG91dGxpbmUgaXMgY29uZmlndXJlZCwgcmVuZGVyIGl0IGFzIGEgcHJlbGltaW5hcnkgZHJhdyB1c2luZyBUaHJlZSdzIG11bHRpLW1hdGVyaWFsXG4gICAgLy8gZmVhdHVyZSAoc2VlIEdseXBoc0dlb21ldHJ5IHdoaWNoIHNldHMgdXAgYGdyb3Vwc2AgZm9yIHRoaXMgcHVycG9zZSkgRG9pbmcgaXQgd2l0aCBtdWx0aVxuICAgIC8vIG1hdGVyaWFscyBlbnN1cmVzIHRoZSBsYXllcnMgYXJlIGFsd2F5cyByZW5kZXJlZCBjb25zZWN1dGl2ZWx5IGluIGEgY29uc2lzdGVudCBvcmRlci5cbiAgICAvLyBFYWNoIGxheWVyIHdpbGwgdHJpZ2dlciBvbkJlZm9yZVJlbmRlciB3aXRoIHRoZSBhcHByb3ByaWF0ZSBtYXRlcmlhbC5cbiAgICBpZiAodGhpcy5vdXRsaW5lV2lkdGggfHwgdGhpcy5vdXRsaW5lQmx1ciB8fCB0aGlzLm91dGxpbmVPZmZzZXRYIHx8IHRoaXMub3V0bGluZU9mZnNldFkpIHtcbiAgICAgIGxldCBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGw7XG4gICAgICBpZiAoIW91dGxpbmVNYXRlcmlhbCkge1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGwgPSBPYmplY3QuY3JlYXRlKGRlcml2ZWRNYXRlcmlhbCwge1xuICAgICAgICAgIGlkOiB7dmFsdWU6IGRlcml2ZWRNYXRlcmlhbC5pZCArIDAuMX1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwubWFwID0gbnVsbDsgLy8/Pz9cbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLFxuICAgICAgICBkZXJpdmVkTWF0ZXJpYWxcbiAgICAgIF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgIH1cbiAgfVxuICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgaWYgKGJhc2VNYXRlcmlhbCAmJiBiYXNlTWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHsgLy9wcmV2ZW50IGRvdWJsZS1kZXJpdmF0aW9uXG4gICAgICB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWwuYmFzZU1hdGVyaWFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGV0YWlsXG4gIH1cbiAgc2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoZGV0YWlsKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kZXRhaWwgPSBkZXRhaWw7XG4gIH1cblxuICBnZXQgY3VydmVSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXNcbiAgfVxuICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXMgPSByO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gIH1cbiAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpIHtcbiAgICBjb25zdCBpc091dGxpbmUgPSBtYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWw7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICBjb25zdCB0ZXh0SW5mbyA9IHRoaXMudGV4dFJlbmRlckluZm87XG4gICAgaWYgKHRleHRJbmZvKSB7XG4gICAgICBjb25zdCB7c2RmVGV4dHVyZSwgYmxvY2tCb3VuZHN9ID0gdGV4dEluZm87XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZS52YWx1ZSA9IHNkZlRleHR1cmU7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZVNpemUudmFsdWUuc2V0KHNkZlRleHR1cmUuaW1hZ2Uud2lkdGgsIHNkZlRleHR1cmUuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZHbHlwaFNpemUudmFsdWUgPSB0ZXh0SW5mby5zZGZHbHlwaFNpemU7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGRXhwb25lbnQudmFsdWUgPSB0ZXh0SW5mby5zZGZFeHBvbmVudDtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FUb3RhbEJvdW5kcy52YWx1ZS5mcm9tQXJyYXkoYmxvY2tCb3VuZHMpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVVzZUdseXBoQ29sb3JzLnZhbHVlID0gIWlzT3V0bGluZSAmJiAhIXRleHRJbmZvLmdseXBoQ29sb3JzO1xuXG4gICAgICBsZXQgZGlzdGFuY2VPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJsdXJSYWRpdXMgPSAwO1xuICAgICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcbiAgICAgIGxldCBmaWxsT3BhY2l0eTtcbiAgICAgIGxldCBzdHJva2VPcGFjaXR5O1xuICAgICAgbGV0IHN0cm9rZUNvbG9yO1xuICAgICAgbGV0IG9mZnNldFggPSAwO1xuICAgICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgIGxldCB7b3V0bGluZVdpZHRoLCBvdXRsaW5lT2Zmc2V0WCwgb3V0bGluZU9mZnNldFksIG91dGxpbmVCbHVyLCBvdXRsaW5lT3BhY2l0eX0gPSB0aGlzO1xuICAgICAgICBkaXN0YW5jZU9mZnNldCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lV2lkdGgpIHx8IDA7XG4gICAgICAgIGJsdXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZUJsdXIpIHx8IDApO1xuICAgICAgICBmaWxsT3BhY2l0eSA9IG91dGxpbmVPcGFjaXR5O1xuICAgICAgICBvZmZzZXRYID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRYKSB8fCAwO1xuICAgICAgICBvZmZzZXRZID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRZKSB8fCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQodGhpcy5zdHJva2VXaWR0aCkgfHwgMCk7XG4gICAgICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgICAgIHN0cm9rZUNvbG9yID0gdGhpcy5zdHJva2VDb2xvcjtcbiAgICAgICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlQ29sb3IudmFsdWUuc2V0KHN0cm9rZUNvbG9yID09IG51bGwgPyBkZWZhdWx0U3Ryb2tlQ29sb3IgOiBzdHJva2VDb2xvcik7XG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PSBudWxsKSBzdHJva2VPcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsT3BhY2l0eSA9IHRoaXMuZmlsbE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FEaXN0YW5jZU9mZnNldC52YWx1ZSA9IGRpc3RhbmNlT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnNldChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VXaWR0aC52YWx1ZSA9IHN0cm9rZVdpZHRoO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FDdXJ2ZVJhZGl1cy52YWx1ZSA9IHRoaXMuY3VydmVSYWRpdXMgfHwgMDtcblxuICAgICAgbGV0IGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLmZyb21BcnJheShjbGlwUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgY29uc3QgcGFkID0gKHRoaXMuZm9udFNpemUgfHwgMC4xKSAqIDEwMDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1sxXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1syXSArIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLmRlcHRoT2Zmc2V0IHx8IDA7XG5cbiAgICAvLyBTaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOyB0aGlzIGlzXG4gICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgY29uc3QgY29sb3IgPSBpc091dGxpbmUgPyAodGhpcy5vdXRsaW5lQ29sb3IgfHwgMCkgOiB0aGlzLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2xvck9iaiA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdjb2xvcicpID8gbWF0ZXJpYWwuY29sb3IgOiAobWF0ZXJpYWwuY29sb3IgPSBuZXcgQ29sb3IoKSk7XG4gICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbG9yT2JqLnNldChjb2xvck9iai5faW5wdXQgPSBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFzZSBvcmllbnRhdGlvblxuICAgIGxldCBvcmllbnQgPSB0aGlzLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnQ7XG4gICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICBsZXQgcm90TWF0ID0gdW5pZm9ybXMudVRyb2lrYU9yaWVudC52YWx1ZTtcbiAgICAgIG9yaWVudCA9IG9yaWVudC5yZXBsYWNlKC9bXi0reHl6XS9nLCAnJyk7XG4gICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IFssIGhTaWduLCBoQXhpcywgdlNpZ24sIHZBeGlzXSA9IG1hdGNoO1xuICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgIHRlbXBWZWMzYi5zZXQoMCwgMCwgMClbdkF4aXNdID0gdlNpZ24gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsLl9vcmllbnRhdGlvbiA9IG9yaWVudDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VQZXJjZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICB2YWx1ZSA9IChpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMCkgKiB0aGlzLmZvbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiBsb2NhbCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGFyZ2V0LmNvcHkocG9zaXRpb24pOyAvL3NpbXBsZSBub24tY3VydmVkIGNhc2UgaXMgMToxXG4gICAgY29uc3QgciA9IHRoaXMuY3VydmVSYWRpdXM7XG4gICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgdGFyZ2V0LnggPSBNYXRoLmF0YW4yKHBvc2l0aW9uLngsIE1hdGguYWJzKHIpIC0gTWF0aC5hYnMocG9zaXRpb24ueikpICogTWF0aC5hYnMocik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICB3b3JsZFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHModGhpcy53b3JsZFRvTG9jYWwodGVtcFZlYzNhKSwgdGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZSBDdXN0b20gcmF5Y2FzdGluZyB0byB0ZXN0IGFnYWluc3QgdGhlIHdob2xlIHRleHQgYmxvY2sncyBtYXggcmVjdGFuZ3VsYXIgYm91bmRzXG4gICAqIFRPRE8gaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIHRoaXMgbW9yZSBncmFudWxhciwgbGlrZSB3aXRoaW4gaW5kaXZpZHVhbCBsaW5lIG9yIGdseXBoIHJlY3RzP1xuICAgKi9cbiAgcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICBjb25zdCB7dGV4dFJlbmRlckluZm8sIGN1cnZlUmFkaXVzfSA9IHRoaXM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcztcbiAgICAgIGNvbnN0IHJheWNhc3RNZXNoID0gY3VydmVSYWRpdXMgPyBnZXRDdXJ2ZWRSYXljYXN0TWVzaCgpIDogZ2V0RmxhdFJheWNhc3RNZXNoKCk7XG4gICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHV2fSA9IGdlb20uYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICBjb25zdCB5ID0gYm91bmRzWzFdICsgKHV2LmdldFkoaSkgKiAoYm91bmRzWzNdIC0gYm91bmRzWzFdKSk7XG4gICAgICAgIGxldCB6ID0gMDtcbiAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgeiA9IGN1cnZlUmFkaXVzIC0gTWF0aC5jb3MoeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIHggPSBNYXRoLnNpbih4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24uc2V0WFlaKGksIHgsIHksIHopO1xuICAgICAgfVxuICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICBnZW9tLmJvdW5kaW5nQm94ID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ0JveDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICB0ZW1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCB0ZW1wQXJyYXkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVtcEFycmF5W2ldLm9iamVjdCA9IHRoaXM7XG4gICAgICAgIGludGVyc2VjdHMucHVzaCh0ZW1wQXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvcHkoc291cmNlKSB7XG4gICAgLy8gUHJldmVudCBjb3B5aW5nIHRoZSBnZW9tZXRyeSByZWZlcmVuY2Ugc28gd2UgZG9uJ3QgZW5kIHVwIHNoYXJpbmcgYXR0cmlidXRlcyBiZXR3ZWVuIGluc3RhbmNlc1xuICAgIGNvbnN0IGdlb20gPSB0aGlzLmdlb21ldHJ5O1xuICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbTtcblxuICAgIENPUFlBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gIH1cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcblNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSAnX3ByaXZhdGVfJyArIHByb3A7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdGhpc1twcml2YXRlS2V5XSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vLz09PSBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIGNhcmV0cyBhbmQgc2VsZWN0aW9uIHJhbmdlcyA9PT0vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRleHRDYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IHBvc2l0aW9uIG9mIHRoZSBjYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjYXJldCdzIGJvdHRvbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIGhlaWdodCBvZiB0aGUgY2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFySW5kZXggLSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyBvZiB0aGlzIGNhcmV0J3MgdGFyZ2V0XG4gKiAgIGNoYXJhY3RlcjsgdGhlIGNhcmV0IHdpbGwgYmUgZm9yIHRoZSBwb3NpdGlvbiBfYmVmb3JlXyB0aGF0IGNoYXJhY3Rlci5cbiAqL1xuXG4vKipcbiAqIEdpdmVuIGEgbG9jYWwgeC95IGNvb3JkaW5hdGUgaW4gdGhlIHRleHQgYmxvY2sgcGxhbmUsIGZpbmQgdGhlIG5lYXJlc3QgY2FyZXQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mbyAtIGEgcmVzdWx0IG9iamVjdCBmcm9tIFRleHRCdWlsZGVyI2dldFRleHRSZW5kZXJJbmZvXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge1RleHRDYXJldCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldENhcmV0QXRQb2ludCh0ZXh0UmVuZGVySW5mbywgeCwgeSkge1xuICBsZXQgY2xvc2VzdENhcmV0ID0gbnVsbDtcbiAgY29uc3Qgcm93cyA9IGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pO1xuXG4gIC8vIEZpbmQgbmVhcmVzdCByb3cgYnkgeSBmaXJzdFxuICBsZXQgY2xvc2VzdFJvdyA9IG51bGw7XG4gIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGlmICghY2xvc2VzdFJvdyB8fCBNYXRoLmFicyh5IC0gKHJvdy50b3AgKyByb3cuYm90dG9tKSAvIDIpIDwgTWF0aC5hYnMoeSAtIChjbG9zZXN0Um93LnRvcCArIGNsb3Nlc3RSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICBjbG9zZXN0Um93ID0gcm93O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlbiBmaW5kIGNsb3Nlc3QgY2FyZXQgYnkgeCB3aXRoaW4gdGhhdCByb3dcbiAgY2xvc2VzdFJvdy5jYXJldHMuZm9yRWFjaChjYXJldCA9PiB7XG4gICAgaWYgKCFjbG9zZXN0Q2FyZXQgfHwgTWF0aC5hYnMoeCAtIGNhcmV0LngpIDwgTWF0aC5hYnMoeCAtIGNsb3Nlc3RDYXJldC54KSkge1xuICAgICAgY2xvc2VzdENhcmV0ID0gY2FyZXQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsb3Nlc3RDYXJldFxufVxuXG5cbmNvbnN0IF9yZWN0c0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHaXZlbiBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBpbmRleGVzLCByZXR1cm4gYSBsaXN0IG9mIHJlY3RhbmdsZXMgY292ZXJpbmcgYWxsIHRoZVxuICogY2hhcmFjdGVycyB3aXRoaW4gdGhhdCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgaW4gdGhlIHNlbGVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAqIEByZXR1cm4ge0FycmF5PHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219PiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3RzKHRleHRSZW5kZXJJbmZvLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZWN0cztcbiAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgLSB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgbGV0IHByZXZSZXN1bHQgPSBfcmVjdHNDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICAgIGlmIChwcmV2UmVzdWx0ICYmIHByZXZSZXN1bHQuc3RhcnQgPT09IHN0YXJ0ICYmIHByZXZSZXN1bHQuZW5kID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBwcmV2UmVzdWx0LnJlY3RzXG4gICAgfVxuXG4gICAgY29uc3Qge2NhcmV0UG9zaXRpb25zfSA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICBjb25zdCBzID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICAgIGVuZCA9IHM7XG4gICAgfVxuICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoICsgMSk7XG5cbiAgICAvLyBCdWlsZCBsaXN0IG9mIHJlY3RzLCBleHBhbmRpbmcgdGhlIGN1cnJlbnQgcmVjdCBmb3IgYWxsIGNoYXJhY3RlcnMgaW4gYSBydW4gYW5kIHN0YXJ0aW5nXG4gICAgLy8gYSBuZXcgcmVjdCB3aGVuZXZlciByZWFjaGluZyBhIG5ldyBsaW5lIG9yIGEgbmV3IGJpZGkgZGlyZWN0aW9uXG4gICAgcmVjdHMgPSBbXTtcbiAgICBsZXQgY3VycmVudFJlY3QgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCB4MSA9IGNhcmV0UG9zaXRpb25zW2kgKiA0XTtcbiAgICAgIGNvbnN0IHgyID0gY2FyZXRQb3NpdGlvbnNbaSAqIDQgKyAxXTtcbiAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heCh4MSwgeDIpO1xuICAgICAgY29uc3QgYm90dG9tID0gY2FyZXRQb3NpdGlvbnNbaSAqIDQgKyAyXTtcbiAgICAgIGNvbnN0IHRvcCA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgM107XG4gICAgICBpZiAoIWN1cnJlbnRSZWN0IHx8IGJvdHRvbSAhPT0gY3VycmVudFJlY3QuYm90dG9tIHx8IHRvcCAhPT0gY3VycmVudFJlY3QudG9wIHx8IGxlZnQgPiBjdXJyZW50UmVjdC5yaWdodCB8fCByaWdodCA8IGN1cnJlbnRSZWN0LmxlZnQpIHtcbiAgICAgICAgY3VycmVudFJlY3QgPSB7XG4gICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgcmlnaHQ6IC1JbmZpbml0eSxcbiAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICB9O1xuICAgICAgICByZWN0cy5wdXNoKGN1cnJlbnRSZWN0KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSZWN0LmxlZnQgPSBNYXRoLm1pbihsZWZ0LCBjdXJyZW50UmVjdC5sZWZ0KTtcbiAgICAgIGN1cnJlbnRSZWN0LnJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGN1cnJlbnRSZWN0LnJpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBhbnkgb3ZlcmxhcHBpbmcgcmVjdHMsIGUuZy4gdGhvc2UgZm9ybWVkIGJ5IGFkamFjZW50IGJpZGkgcnVuc1xuICAgIHJlY3RzLnNvcnQoKGEsIGIpID0+IGIuYm90dG9tIC0gYS5ib3R0b20gfHwgYS5sZWZ0IC0gYi5sZWZ0KTtcbiAgICBmb3IgKGxldCBpID0gcmVjdHMubGVuZ3RoIC0gMTsgaS0tID4gMDspIHtcbiAgICAgIGNvbnN0IHJlY3RBID0gcmVjdHNbaV07XG4gICAgICBjb25zdCByZWN0QiA9IHJlY3RzW2kgKyAxXTtcbiAgICAgIGlmIChyZWN0QS5ib3R0b20gPT09IHJlY3RCLmJvdHRvbSAmJiByZWN0QS50b3AgPT09IHJlY3RCLnRvcCAmJiByZWN0QS5sZWZ0IDw9IHJlY3RCLnJpZ2h0ICYmIHJlY3RBLnJpZ2h0ID49IHJlY3RCLmxlZnQpIHtcbiAgICAgICAgcmVjdEIubGVmdCA9IE1hdGgubWluKHJlY3RCLmxlZnQsIHJlY3RBLmxlZnQpO1xuICAgICAgICByZWN0Qi5yaWdodCA9IE1hdGgubWF4KHJlY3RCLnJpZ2h0LCByZWN0QS5yaWdodCk7XG4gICAgICAgIHJlY3RzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVjdHNDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHtzdGFydCwgZW5kLCByZWN0c30pO1xuICB9XG4gIHJldHVybiByZWN0c1xufVxuXG5jb25zdCBfY2FyZXRzQnlSb3dDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR3JvdXAgYSBzZXQgb2YgY2FyZXRzIGJ5IHJvdyBvZiB0ZXh0LCBjYWNoaW5nIHRoZSByZXN1bHQuIEEgc2luZ2xlIHJvdyBvZiB0ZXh0IG1heSBjb250YWluIGNhcmV0cyBvZlxuICogZGlmZmVyaW5nIHBvc2l0aW9ucy9oZWlnaHRzIGlmIGl0IGhhcyBtdWx0aXBsZSBmb250cywgYW5kIHRoZXkgbWF5IG92ZXJsYXAgc2xpZ2h0bHkgYWNyb3NzIHJvd3MsIHNvIHRoaXNcbiAqIHVzZXMgYW4gYXNzdW1wdGlvbiBvZiBcImF0IGxlYXN0IG92ZXJsYXBwaW5nIGJ5IGhhbGZcIiB0byBwdXQgdGhlbSBpbiB0aGUgc2FtZSByb3cuXG4gKiBAcmV0dXJuIEFycmF5PHtib3R0b206IG51bWJlciwgdG9wOiBudW1iZXIsIGNhcmV0czogVGV4dENhcmV0W119PlxuICovXG5mdW5jdGlvbiBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKSB7XG4gIC8vIHRleHRSZW5kZXJJbmZvIGlzIGZyb3plbiBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgYmFzZWQgb24gaXRcbiAgbGV0IHJvd3MgPSBfY2FyZXRzQnlSb3dDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICBpZiAoIXJvd3MpIHtcbiAgICByb3dzID0gW107XG4gICAgY29uc3Qge2NhcmV0UG9zaXRpb25zfSA9IHRleHRSZW5kZXJJbmZvO1xuICAgIGxldCBjdXJSb3c7XG5cbiAgICBjb25zdCB2aXNpdENhcmV0ID0gKHgsIGJvdHRvbSwgdG9wLCBjaGFySW5kZXgpID0+IHtcbiAgICAgIC8vIG5ldyByb3cgaWYgbm90IG92ZXJsYXBwaW5nIGJ5IGF0IGxlYXN0IGhhbGZcbiAgICAgIGlmICghY3VyUm93IHx8ICh0b3AgPCAoY3VyUm93LnRvcCArIGN1clJvdy5ib3R0b20pIC8gMikpIHtcbiAgICAgICAgcm93cy5wdXNoKGN1clJvdyA9IHtib3R0b20sIHRvcCwgY2FyZXRzOiBbXX0pO1xuICAgICAgfVxuICAgICAgLy8gZXhwYW5kIHZlcnRpY2FsIGxpbWl0cyBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0b3AgPiBjdXJSb3cudG9wKSBjdXJSb3cudG9wID0gdG9wO1xuICAgICAgaWYgKGJvdHRvbSA8IGN1clJvdy5ib3R0b20pIGN1clJvdy5ib3R0b20gPSBib3R0b207XG4gICAgICBjdXJSb3cuY2FyZXRzLnB1c2goe1xuICAgICAgICB4LFxuICAgICAgICB5OiBib3R0b20sXG4gICAgICAgIGhlaWdodDogdG9wIC0gYm90dG9tLFxuICAgICAgICBjaGFySW5kZXgsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZpc2l0Q2FyZXQoY2FyZXRQb3NpdGlvbnNbaV0sIGNhcmV0UG9zaXRpb25zW2kgKyAyXSwgY2FyZXRQb3NpdGlvbnNbaSArIDNdLCBpIC8gNCk7XG4gICAgfVxuICAgIC8vIEFkZCBvbmUgbW9yZSBjYXJldCBhZnRlciB0aGUgZmluYWwgY2hhclxuICAgIHZpc2l0Q2FyZXQoY2FyZXRQb3NpdGlvbnNbaSAtIDNdLCBjYXJldFBvc2l0aW9uc1tpIC0gMl0sIGNhcmV0UG9zaXRpb25zW2kgLSAxXSwgaSAvIDQpO1xuICB9XG4gIF9jYXJldHNCeVJvd0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywgcm93cyk7XG4gIHJldHVybiByb3dzXG59XG5cbmV4cG9ydCB7IEdseXBoc0dlb21ldHJ5LCBUZXh0LCBjb25maWd1cmVUZXh0QnVpbGRlciwgY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCwgZHVtcFNERlRleHR1cmVzLCBmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUsIGdldENhcmV0QXRQb2ludCwgZ2V0U2VsZWN0aW9uUmVjdHMsIGdldFRleHRSZW5kZXJJbmZvLCBwcmVsb2FkRm9udCwgdHlwZXNldHRlcldvcmtlck1vZHVsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/troika-three-text/dist/troika-three-text.esm.js\n"));

/***/ }),

/***/ "./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: function() { return /* binding */ BezierMesh; },\n/* harmony export */   createDerivedMaterial: function() { return /* binding */ createDerivedMaterial; },\n/* harmony export */   expandShaderIncludes: function() { return /* binding */ expandShaderIncludes; },\n/* harmony export */   getShaderUniformTypes: function() { return /* binding */ getShaderUniformTypes; },\n/* harmony export */   getShadersForMaterial: function() { return /* binding */ getShadersForMaterial; },\n/* harmony export */   invertMatrix4: function() { return /* binding */ invertMatrix4; },\n/* harmony export */   voidMainRegExp: function() { return /* binding */ voidMainRegExp; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4TTs7QUFFOU07QUFDQSxxREFBcUQ7QUFDckQsVUFBVTtBQUNWO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLGtFQUFrRSxrQkFBa0I7QUFDdkcsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSw0QkFBNEIsR0FBRyw4QkFBOEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFdBQVc7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0MscURBQXFELHFCQUFxQjs7QUFFMUU7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQiwrQ0FBK0MsV0FBVyxTQUFTO0FBQ25FLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6Qyx3QkFBd0IsWUFBWTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFpQixHQUFHLGNBQWMsbURBQWdCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QixJQUFJLHNCQUFzQixJQUFJLGtCQUFrQjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLEVBQUU7QUFDRjtBQUNBLG9CQUFvQjtBQUNwQiw0QkFBNEIsSUFBSTtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkIsZ0JBQWdCLEtBQUs7QUFDckIsWUFBWSxLQUFLO0FBQ2pCLHVCQUF1QixJQUFJLG1CQUFtQixJQUFJLGtCQUFrQixJQUFJLGNBQWMsSUFBSTtBQUMxRixFQUFFO0FBQ0Y7QUFDQTtBQUNBLDZGQUE2RixPQUFPLEdBQUcsSUFBSTtBQUMzRyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHFCQUFxQixHQUFHLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQixHQUFHO0FBQ3JCLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxnQ0FBZ0MsV0FBVyxxQ0FBcUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLGtEQUFrRCwwQ0FBTztBQUN6RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVywwQ0FBTyxHQUFHO0FBQ3RDLG1CQUFtQixXQUFXLDBDQUFPLEdBQUc7QUFDeEMsbUJBQW1CLFdBQVcsMENBQU8sR0FBRztBQUN4QyxpQkFBaUIsV0FBVywwQ0FBTyxHQUFHO0FBQ3RDLGlCQUFpQixZQUFZO0FBQzdCLGtCQUFrQixXQUFXLDBDQUFPLElBQUk7QUFDeEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2Qyx1REFBb0IsRUFBRSx1QkFBdUIsNkNBQVUsQ0FBQzs7O0FBR3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1Q0FBSTtBQUM3QjtBQUNBO0FBQ0EsVUFBVSxtREFBZ0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQ0FBTztBQUM3Qix3QkFBd0IsMENBQU87QUFDL0Isd0JBQXdCLDBDQUFPO0FBQy9CLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS11dGlscy9kaXN0L3Ryb2lrYS10aHJlZS11dGlscy5lc20uanM/NTc1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGFkZXJDaHVuaywgVW5pZm9ybXNVdGlscywgTWVzaERlcHRoTWF0ZXJpYWwsIFJHQkFEZXB0aFBhY2tpbmcsIE1lc2hEaXN0YW5jZU1hdGVyaWFsLCBTaGFkZXJMaWIsIE1hdHJpeDQsIFZlY3RvcjMsIE1lc2gsIEN5bGluZGVyR2VvbWV0cnksIFZlY3RvcjIsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlIH0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIGB2b2lkIG1haW4oKSB7YCBvcGVuZXIgbGluZSBpbiBHTFNMLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3Qgdm9pZE1haW5SZWdFeHAgPSAvXFxidm9pZFxccyttYWluXFxzKlxcKFxccypcXClcXHMqey9nO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYWxsIGAjaW5jbHVkZSA8eHl6PmAgc3RhdGVtZW50cyB3aXRoaW4gc3RyaW5nIG9mIHNoYWRlciBjb2RlLlxuICogQ29waWVkIGZyb20gdGhyZWUncyBXZWJHTFByb2dyYW0jcGFyc2VJbmNsdWRlcyBmb3IgZXh0ZXJuYWwgdXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgR0xTTCBzb3VyY2UgY29kZSB0byBldmFsdWF0ZVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgR0xTTCBjb2RlIHdpdGggYWxsIGluY2x1ZGVzIGV4cGFuZGVkXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNoYWRlckluY2x1ZGVzKCBzb3VyY2UgKSB7XG4gIGNvbnN0IHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuICBmdW5jdGlvbiByZXBsYWNlKG1hdGNoLCBpbmNsdWRlKSB7XG4gICAgbGV0IGNodW5rID0gU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG4gICAgcmV0dXJuIGNodW5rID8gZXhwYW5kU2hhZGVySW5jbHVkZXMoY2h1bmspIDogbWF0Y2hcbiAgfVxuICByZXR1cm4gc291cmNlLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKVxufVxuXG4vKlxuICogVGhpcyBpcyBhIGRpcmVjdCBjb3B5IG9mIE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQgZnJvbSBUaHJlZS5qcywgdG8gcHJlc2VydmUgY29tcGF0aWJpbGl0eSB3aXRoIHRocmVlXG4gKiB2ZXJzaW9ucyBiZWZvcmUgMC4xMTMuMCBhcyBpdCB3YXMgY2hhbmdlZCBmcm9tIE1hdGggdG8gTWF0aFV0aWxzIGluIHRoYXQgdmVyc2lvbi5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZDhiNWFhM2IyNzBjMTcwOTZiOTA5NDVjZDJkNmQxYjEzYWFlYzUzL3NyYy9tYXRoL01hdGhVdGlscy5qcyNMMTZcbiAqL1xuXG5jb25zdCBfbHV0ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2x1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyAoaSkudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cbiAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMSAmIDB4ZmZdICsgX2x1dFtkMSA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdICsgX2x1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gK1xuICAgIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdO1xuXG4gIC8vIC50b1VwcGVyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cbiAgcmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKVxuXG59XG5cbi8vIExvY2FsIGFzc2lnbiBwb2x5ZmlsbCB0byBhdm9pZCBpbXBvcnRpbmcgdHJvaWthLWNvcmVcbmNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oLyp0YXJnZXQsIC4uLnNvdXJjZXMqLykge1xuICBsZXQgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKGxldCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufTtcblxuXG5jb25zdCBlcG9jaCA9IERhdGUubm93KCk7XG5jb25zdCBDT05TVFJVQ1RPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBTSEFERVJfVVBHUkFERV9DQUNIRSA9IG5ldyBNYXAoKTtcblxuLy8gTWF0ZXJpYWwgaWRzIG11c3QgYmUgaW50ZWdlcnMsIGJ1dCB3ZSBjYW4ndCBhY2Nlc3MgdGhlIGluY3JlbWVudCBmcm9tIFRocmVlJ3MgYE1hdGVyaWFsYCBtb2R1bGUsXG4vLyBzbyBsZXQncyBjaG9vc2UgYSBzdWZmaWNpZW50bHkgbGFyZ2Ugc3RhcnRpbmcgdmFsdWUgdGhhdCBzaG91bGQgdGhlb3JldGljYWxseSBuZXZlciBjb2xsaWRlLlxubGV0IG1hdGVyaWFsSW5zdGFuY2VJZCA9IDFlMTA7XG5cbi8qKlxuICogQSB1dGlsaXR5IGZvciBjcmVhdGluZyBhIGN1c3RvbSBzaGFkZXIgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGFub3RoZXIgbWF0ZXJpYWwnc1xuICogc2hhZGVycy4gVGhpcyBhbGxvd3MgeW91IHRvIGluamVjdCBjdXN0b20gc2hhZGVyIGxvZ2ljIGFuZCB0cmFuc2Zvcm1zIGludG8gdGhlXG4gKiBidWlsdGluIFRocmVlSlMgbWF0ZXJpYWxzIHdpdGhvdXQgaGF2aW5nIHRvIHJlY3JlYXRlIHRoZW0gZnJvbSBzY3JhdGNoLlxuICpcbiAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IGJhc2VNYXRlcmlhbCAtIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCB0byBkZXJpdmUgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG93IHRoZSBiYXNlIG1hdGVyaWFsIHNob3VsZCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmluZXMgLSBDdXN0b20gYGRlZmluZXNgIGZvciB0aGUgbWF0ZXJpYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy51bmlmb3JtcyAtIEN1c3RvbSBgdW5pZm9ybXNgIGZvciB1c2UgaW4gdGhlIG1vZGlmaWVkIHNoYWRlci4gVGhlc2UgY2FuXG4gKiAgICAgICAgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkIHZpYSB0aGUgcmVzdWx0aW5nIG1hdGVyaWFsJ3MgYHVuaWZvcm1zYCBwcm9wZXJ0eSwganVzdCBsaWtlXG4gKiAgICAgICAgaW4gYSBTaGFkZXJNYXRlcmlhbC4gWW91IGRvIG5vdCBuZWVkIHRvIHJlcGVhdCB0aGUgYmFzZSBtYXRlcmlhbCdzIG93biB1bmlmb3JtcyBoZXJlLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZVVuaWZvcm0gLSBJZiBzcGVjaWZpZWQsIGEgdW5pZm9ybSBvZiB0aGlzIG5hbWUgd2lsbCBiZSBpbmplY3RlZCBpbnRvXG4gKiAgICAgICAgYm90aCBzaGFkZXJzLCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVwZGF0ZWQgb24gZWFjaCByZW5kZXIgZnJhbWUgd2l0aCBhIG51bWJlciBvZlxuICogICAgICAgIGVsYXBzZWQgbWlsbGlzZWNvbmRzLiBUaGUgXCJ6ZXJvXCIgZXBvY2ggdGltZSBpcyBub3Qgc2lnbmlmaWNhbnQgc28gZG9uJ3QgcmVseSBvbiB0aGlzIGFzIGFcbiAqICAgICAgICB0cnVlIGNhbGVuZGFyIHRpbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHZlcnRleFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgdmVydGV4XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSBmcmFnbWVudCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBnbF9GcmFnQ29sb3JgXG4gKiAgICAgICAgb3V0cHV0IHZhbHVlLiBXaWxsIGJlIGluamVjdGVkIG5lYXIgdGhlIGVuZCBvZiB0aGUgYHZvaWQgbWFpbmAgZnVuY3Rpb24sIGJ1dCBiZWZvcmUgYW55XG4gKiAgICAgICAgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBhbmQgYmVmb3JlIHRoZVxuICogICAgICAgIGBmcmFnbWVudE1haW5PdXRyb2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPHt2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9Pjp7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2hhaW5lZCAtIFNldCB0byBgdHJ1ZWAgdG8gcHJvdG90eXBlLWNoYWluIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIHRoZSBiYXNlXG4gKiAgICAgICAgbWF0ZXJpYWwsIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvcHlpbmcgaXQuIFRoaXMgYWxsb3dzIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvXG4gKiAgICAgICAgYXV0b21hdGljYWxseSBwaWNrIHVwIGNoYW5nZXMgbWFkZSB0byB0aGUgYmFzZSBtYXRlcmlhbCBhbmQgaXRzIHByb3BlcnRpZXMuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICogICAgICAgIHdoZXJlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGlzIGhpZGRlbiBmcm9tIHRoZSB1c2VyIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgYWxsb3dpbmcgdGhlbVxuICogICAgICAgIHRvIHdvcmsgd2l0aCB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgbGlrZSBub3JtYWwuIEJ1dCBpdCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgbm90XG4gKiAgICAgICAgaGFuZGxlZCBjYXJlZnVsbHkuXG4gKlxuICogQHJldHVybiB7VEhSRUUuTWF0ZXJpYWx9XG4gKlxuICogVGhlIHJldHVybmVkIG1hdGVyaWFsIHdpbGwgYWxzbyBoYXZlIHR3byBuZXcgbWV0aG9kcywgYGdldERlcHRoTWF0ZXJpYWwoKWAgYW5kIGBnZXREaXN0YW5jZU1hdGVyaWFsKClgLFxuICogd2hpY2ggY2FuIGJlIGNhbGxlZCB0byBnZXQgYSB2YXJpYW50IG9mIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGZvciB1c2UgaW4gc2hhZG93IGNhc3RpbmcuIElmIHRoZVxuICogdGFyZ2V0IG1lc2ggaXMgZXhwZWN0ZWQgdG8gY2FzdCBzaGFkb3dzLCB0aGVuIHlvdSBjYW4gYXNzaWduIHRoZXNlIHRvIHRoZSBtZXNoJ3MgYGN1c3RvbURlcHRoTWF0ZXJpYWxgXG4gKiAoZm9yIGRpcmVjdGlvbmFsIGFuZCBzcG90IGxpZ2h0cykgYW5kL29yIGBjdXN0b21EaXN0YW5jZU1hdGVyaWFsYCAoZm9yIHBvaW50IGxpZ2h0cykgcHJvcGVydGllcyB0b1xuICogYWxsb3cgdGhlIGNhc3Qgc2hhZG93IHRvIGhvbm9yIHlvdXIgZGVyaXZlZCBzaGFkZXIncyB2ZXJ0ZXggdHJhbnNmb3JtcyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy4gVGhlc2VcbiAqIHdpbGwgYWxzbyBzZXQgYSBjdXN0b20gYCNkZWZpbmUgSVNfREVQVEhfTUFURVJJQUxgIG9yIGAjZGVmaW5lIElTX0RJU1RBTkNFX01BVEVSSUFMYCB0aGF0IHlvdSBjYW4gbG9va1xuICogZm9yIGluIHlvdXIgZGVyaXZlZCBzaGFkZXJzIHdpdGggYCNpZmRlZmAgdG8gY3VzdG9taXplIHRoZWlyIGJlaGF2aW9yIGZvciB0aGUgZGVwdGggb3IgZGlzdGFuY2VcbiAqIHNjZW5hcmlvcywgZS5nLiBza2lwcGluZyBhbnRpYWxpYXNpbmcgb3IgZXhwZW5zaXZlIHNoYWRlciBsb2dpYy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwgb3B0aW9ucykge1xuICAvLyBHZW5lcmF0ZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgY29udGVudCBvZiB0aGVzZSBgb3B0aW9uc2AuIFdlJ2xsIHVzZSB0aGlzXG4gIC8vIHRocm91Z2hvdXQgZm9yIGNhY2hpbmcgYW5kIGZvciBnZW5lcmF0aW5nIHRoZSB1cGdyYWRlZCBzaGFkZXIgY29kZS4gVGhpcyBpbmNyZWFzZXNcbiAgLy8gdGhlIGxpa2VsaWhvb2QgdGhhdCB0aGUgcmVzdWx0aW5nIHNoYWRlcnMgd2lsbCBsaW5lIHVwIGFjcm9zcyBtdWx0aXBsZSBjYWxscyBzb1xuICAvLyB0aGVpciBHTCBwcm9ncmFtcyBjYW4gYmUgc2hhcmVkIGFuZCBjYWNoZWQuXG4gIGNvbnN0IG9wdGlvbnNLZXkgPSBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGRlcml2ZWQgZnJvbSB0aGlzIGJhc2VNYXRlcmlhbCB1c2luZyB0aGlzXG4gIC8vIHVuaXF1ZSBzZXQgb2Ygb3B0aW9ucywgYW5kIGlmIHNvIHJldXNlIHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCBzb21lIGFsbG9jYXRpb25zLlxuICBsZXQgY3RvcnNCeURlcml2YXRpb24gPSBDT05TVFJVQ1RPUl9DQUNIRS5nZXQoYmFzZU1hdGVyaWFsKTtcbiAgaWYgKCFjdG9yc0J5RGVyaXZhdGlvbikge1xuICAgIENPTlNUUlVDVE9SX0NBQ0hFLnNldChiYXNlTWF0ZXJpYWwsIChjdG9yc0J5RGVyaXZhdGlvbiA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgfVxuICBpZiAoY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0pIHtcbiAgICByZXR1cm4gbmV3IGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKClcbiAgfVxuXG4gIGNvbnN0IHByaXZhdGVCZWZvcmVDb21waWxlUHJvcCA9IGBfb25CZWZvcmVDb21waWxlJHtvcHRpb25zS2V5fWA7XG5cbiAgLy8gUHJpdmF0ZSBvbkJlZm9yZUNvbXBpbGUgaGFuZGxlciB0aGF0IGluamVjdHMgdGhlIG1vZGlmaWVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIHdoZW5cbiAgLy8gdGhlIHJlbmRlcmVyIHN3aXRjaGVzIHRvIHRoaXMgbWF0ZXJpYWwncyBwcm9ncmFtXG4gIGNvbnN0IG9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uIChzaGFkZXJJbmZvLCByZW5kZXJlcikge1xuICAgIGJhc2VNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUuY2FsbCh0aGlzLCBzaGFkZXJJbmZvLCByZW5kZXJlcik7XG5cbiAgICAvLyBVcGdyYWRlIHRoZSBzaGFkZXJzLCBjYWNoaW5nIHRoZSByZXN1bHQgYnkgaW5jb21pbmcgc291cmNlIGNvZGVcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciArICd8JyArIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXI7XG4gICAgbGV0IHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XTtcbiAgICBpZiAoIXVwZ3JhZGVkU2hhZGVycykge1xuICAgICAgY29uc3QgdXBncmFkZWQgPSB1cGdyYWRlU2hhZGVycyh0aGlzLCBzaGFkZXJJbmZvLCBvcHRpb25zLCBvcHRpb25zS2V5KTtcbiAgICAgIHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XSA9IHVwZ3JhZGVkO1xuICAgIH1cblxuICAgIC8vIEluamVjdCB1cGdyYWRlZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyBpbnRvIHRoZSBwcm9ncmFtXG4gICAgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMudmVydGV4U2hhZGVyO1xuICAgIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMuZnJhZ21lbnRTaGFkZXI7XG4gICAgYXNzaWduKHNoYWRlckluZm8udW5pZm9ybXMsIHRoaXMudW5pZm9ybXMpO1xuXG4gICAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICAgIGlmIChvcHRpb25zLnRpbWVVbmlmb3JtKSB7XG4gICAgICBzaGFkZXJJbmZvLnVuaWZvcm1zW29wdGlvbnMudGltZVVuaWZvcm1dID0ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7cmV0dXJuIERhdGUubm93KCkgLSBlcG9jaH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXNlcnMgY2FuIHN0aWxsIGFkZCB0aGVpciBvd24gaGFuZGxlcnMgb24gdG9wIG9mIG91cnNcbiAgICBpZiAodGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKSB7XG4gICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0oc2hhZGVySW5mbyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IERlcml2ZWRNYXRlcmlhbCA9IGZ1bmN0aW9uIERlcml2ZWRNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZGVyaXZlKG9wdGlvbnMuY2hhaW5lZCA/IGJhc2VNYXRlcmlhbCA6IGJhc2VNYXRlcmlhbC5jbG9uZSgpKVxuICB9O1xuXG4gIGNvbnN0IGRlcml2ZSA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAvLyBQcm90b3R5cGUgY2hhaW4gdG8gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBjb25zdCBkZXJpdmVkID0gT2JqZWN0LmNyZWF0ZShiYXNlLCBkZXNjcmlwdG9yKTtcblxuICAgIC8vIFN0b3JlIHRoZSBiYXNlTWF0ZXJpYWwgZm9yIHJlZmVyZW5jZTsgdGhpcyBpcyBhbHdheXMgdGhlIG9yaWdpbmFsIGV2ZW4gd2hlbiBjbG9uaW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdiYXNlTWF0ZXJpYWwnLCB7IHZhbHVlOiBiYXNlTWF0ZXJpYWwgfSk7XG5cbiAgICAvLyBOZWVkcyBpdHMgb3duIGlkc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbEluc3RhbmNlSWQrKyB9KTtcbiAgICBkZXJpdmVkLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuICAgIC8vIE1lcmdlIHVuaWZvcm1zLCBkZWZpbmVzLCBhbmQgZXh0ZW5zaW9uc1xuICAgIGRlcml2ZWQudW5pZm9ybXMgPSBhc3NpZ24oe30sIGJhc2UudW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lcyA9IGFzc2lnbih7fSwgYmFzZS5kZWZpbmVzLCBvcHRpb25zLmRlZmluZXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lc1tgVFJPSUtBX0RFUklWRURfTUFURVJJQUxfJHtvcHRpb25zS2V5fWBdID0gJyc7IC8vZm9yY2UgYSBwcm9ncmFtIGNoYW5nZSBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgZGVyaXZlZC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlLmV4dGVuc2lvbnMsIG9wdGlvbnMuZXh0ZW5zaW9ucyk7XG5cbiAgICAvLyBEb24ndCBpbmhlcml0IEV2ZW50RGlzcGF0Y2hlciBsaXN0ZW5lcnNcbiAgICBkZXJpdmVkLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVyaXZlZFxuICB9O1xuXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogRGVyaXZlZE1hdGVyaWFsfSxcbiAgICBpc0Rlcml2ZWRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgfSxcbiAgICAgIHNldChmbikge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIFVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmU6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG59XG5cblxuZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gIGxldCB7XG4gICAgdmVydGV4RGVmcyxcbiAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgdmVydGV4TWFpbk91dHJvLFxuICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICBmcmFnbWVudERlZnMsXG4gICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICBjdXN0b21SZXdyaXRlcixcbiAgICB0aW1lVW5pZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICB9XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xmb2d8cHJlbXVsdGlwbGllZF9hbHBoYXxkaXRoZXJpbmcpX2ZyYWdtZW50KT4vZ20sXG4gICAgICAnXFxuLy8hQkVHSU5fUE9TVF9DSFVOSyAkMVxcbiQmXFxuLy8hRU5EX1BPU1RfQ0hVTktcXG4nXG4gICAgKTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcbiAgfVxuXG4gIC8vIEFwcGx5IGN1c3RvbSByZXdyaXRlciBmdW5jdGlvblxuICBpZiAoY3VzdG9tUmV3cml0ZXIpIHtcbiAgICBsZXQgcmVzID0gY3VzdG9tUmV3cml0ZXIoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9KTtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSByZXMudmVydGV4U2hhZGVyO1xuICAgIGZyYWdtZW50U2hhZGVyID0gcmVzLmZyYWdtZW50U2hhZGVyO1xuICB9XG5cbiAgLy8gVGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gbmVlZHMgdG8gZ28gYmVmb3JlIGFueSBwb3N0cHJvY2Vzc2luZyBjaHVua3MsIHNvIGV4dHJhY3RcbiAgLy8gdGhvc2UgYW5kIHJlLWluc2VydCB0aGVtIGludG8gdGhlIG91dHJvIGluIHRoZSBjb3JyZWN0IHBsYWNlOlxuICBpZiAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSkge1xuICAgIGxldCBwb3N0Q2h1bmtzID0gW107XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgL15cXC9cXC8hQkVHSU5fUE9TVF9DSFVOS1teXSs/XlxcL1xcLyFFTkRfUE9TVF9DSFVOSy9nbSwgLy8gW15dKz8gPSBub24tZ3JlZWR5IG1hdGNoIG9mIGFueSBjaGFycyBpbmNsdWRpbmcgbmV3bGluZXNcbiAgICAgIG1hdGNoID0+IHtcbiAgICAgICAgcG9zdENodW5rcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgKTtcbiAgICBmcmFnbWVudE1haW5PdXRybyA9IGAke2ZyYWdtZW50Q29sb3JUcmFuc2Zvcm19XFxuJHtwb3N0Q2h1bmtzLmpvaW4oJ1xcbicpfVxcbiR7ZnJhZ21lbnRNYWluT3V0cm99YDtcbiAgfVxuXG4gIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgaWYgKHRpbWVVbmlmb3JtKSB7XG4gICAgY29uc3QgY29kZSA9IGBcXG51bmlmb3JtIGZsb2F0ICR7dGltZVVuaWZvcm19O1xcbmA7XG4gICAgdmVydGV4RGVmcyA9IGNvZGUgKyB2ZXJ0ZXhEZWZzO1xuICAgIGZyYWdtZW50RGVmcyA9IGNvZGUgKyBmcmFnbWVudERlZnM7XG4gIH1cblxuICAvLyBJbmplY3QgYSBmdW5jdGlvbiBmb3IgdGhlIHZlcnRleFRyYW5zZm9ybSBhbmQgcmVuYW1lIGFsbCB1c2FnZXMgb2YgcG9zaXRpb24vbm9ybWFsL3V2XG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0pIHtcbiAgICAvLyBIb2lzdCB0aGVzZSBkZWZzIHRvIHRoZSB2ZXJ5IHRvcCBzbyB0aGV5IHdvcmsgaW4gb3RoZXIgZnVuY3Rpb24gZGVmc1xuICAgIHZlcnRleFNoYWRlciA9IGB2ZWMzIHRyb2lrYV9wb3NpdGlvbl8ke2tleX07XG52ZWMzIHRyb2lrYV9ub3JtYWxfJHtrZXl9O1xudmVjMiB0cm9pa2FfdXZfJHtrZXl9O1xuJHt2ZXJ0ZXhTaGFkZXJ9XG5gO1xuICAgIHZlcnRleERlZnMgPSBgJHt2ZXJ0ZXhEZWZzfVxudm9pZCB0cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0oaW5vdXQgdmVjMyBwb3NpdGlvbiwgaW5vdXQgdmVjMyBub3JtYWwsIGlub3V0IHZlYzIgdXYpIHtcbiAgJHt2ZXJ0ZXhUcmFuc2Zvcm19XG59XG5gO1xuICAgIHZlcnRleE1haW5JbnRybyA9IGBcbnRyb2lrYV9wb3NpdGlvbl8ke2tleX0gPSB2ZWMzKHBvc2l0aW9uKTtcbnRyb2lrYV9ub3JtYWxfJHtrZXl9ID0gdmVjMyhub3JtYWwpO1xudHJvaWthX3V2XyR7a2V5fSA9IHZlYzIodXYpO1xudHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KHRyb2lrYV9wb3NpdGlvbl8ke2tleX0sIHRyb2lrYV9ub3JtYWxfJHtrZXl9LCB0cm9pa2FfdXZfJHtrZXl9KTtcbiR7dmVydGV4TWFpbkludHJvfVxuYDtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiKHBvc2l0aW9ufG5vcm1hbHx1dilcXGIvZywgKG1hdGNoLCBtYXRjaDEsIGluZGV4LCBmdWxsU3RyKSA9PiB7XG4gICAgICByZXR1cm4gL1xcYmF0dHJpYnV0ZVxccyt2ZWNbMjNdXFxzKyQvLnRlc3QoZnVsbFN0ci5zdWJzdHIoMCwgaW5kZXgpKSA/IG1hdGNoMSA6IGB0cm9pa2FfJHttYXRjaDF9XyR7a2V5fWBcbiAgICB9KTtcblxuICAgIC8vIFRocmVlIHIxNTIgaW50cm9kdWNlZCB0aGUgTUFQX1VWIHRva2VuLCByZXBsYWNlIGl0IHRvbyBpZiBpdCdzIHBvaW50aW5nIHRvIHRoZSBtYWluICd1didcbiAgICAvLyBQZXJoYXBzIHRoZSBvdGhlciB0ZXh0dXJlcyB0b28gZ29pbmcgZm9yd2FyZD9cbiAgICBpZiAoIShtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmNoYW5uZWwgPiAwKSkge1xuICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYk1BUF9VVlxcYi9nLCBgdHJvaWthX3V2XyR7a2V5fWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluamVjdCBkZWZzIGFuZCBpbnRyby9vdXRybyBzbmlwcGV0c1xuICB2ZXJ0ZXhTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZSh2ZXJ0ZXhTaGFkZXIsIGtleSwgdmVydGV4RGVmcywgdmVydGV4TWFpbkludHJvLCB2ZXJ0ZXhNYWluT3V0cm8pO1xuICBmcmFnbWVudFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKGZyYWdtZW50U2hhZGVyLCBrZXksIGZyYWdtZW50RGVmcywgZnJhZ21lbnRNYWluSW50cm8sIGZyYWdtZW50TWFpbk91dHJvKTtcblxuICByZXR1cm4ge1xuICAgIHZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlclxuICB9XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9TaGFkZXJDb2RlKHNoYWRlckNvZGUsIGlkLCBkZWZzLCBpbnRybywgb3V0cm8pIHtcbiAgaWYgKGludHJvIHx8IG91dHJvIHx8IGRlZnMpIHtcbiAgICBzaGFkZXJDb2RlID0gc2hhZGVyQ29kZS5yZXBsYWNlKHZvaWRNYWluUmVnRXhwLCBgXG4ke2RlZnN9XG52b2lkIHRyb2lrYU9yaWdNYWluJHtpZH0oKSB7YFxuICAgICk7XG4gICAgc2hhZGVyQ29kZSArPSBgXG52b2lkIG1haW4oKSB7XG4gICR7aW50cm99XG4gIHRyb2lrYU9yaWdNYWluJHtpZH0oKTtcbiAgJHtvdXRyb31cbn1gO1xuICB9XG4gIHJldHVybiBzaGFkZXJDb2RlXG59XG5cblxuZnVuY3Rpb24gb3B0aW9uc0pzb25SZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIHJldHVybiBrZXkgPT09ICd1bmlmb3JtcycgPyB1bmRlZmluZWQgOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWVcbn1cblxubGV0IF9pZEN0ciA9IDA7XG5jb25zdCBvcHRpb25zSGFzaGVzVG9JZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc0hhc2ggPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBvcHRpb25zSnNvblJlcGxhY2VyKTtcbiAgbGV0IGlkID0gb3B0aW9uc0hhc2hlc1RvSWRzLmdldChvcHRpb25zSGFzaCk7XG4gIGlmIChpZCA9PSBudWxsKSB7XG4gICAgb3B0aW9uc0hhc2hlc1RvSWRzLnNldChvcHRpb25zSGFzaCwgKGlkID0gKytfaWRDdHIpKTtcbiAgfVxuICByZXR1cm4gaWRcbn1cblxuLy8gQ29waWVkIGZyb20gdGhyZWVqcyBXZWJHTFByb2dyYW1zLmpzIHNvIHdlIGNhbiByZXNvbHZlIGJ1aWx0aW4gbWF0ZXJpYWxzIHRvIHRoZWlyIHNoYWRlcnNcbi8vIFRPRE8gaG93IGNhbiB3ZSBrZWVwIHRoaXMgZnJvbSBnZXR0aW5nIHN0YWxlP1xuY29uc3QgTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyA9IHtcbiAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gIE1lc2hEaXN0YW5jZU1hdGVyaWFsOiAnZGlzdGFuY2VSR0JBJyxcbiAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gIE1lc2hUb29uTWF0ZXJpYWw6ICd0b29uJyxcbiAgTWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICBTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdycsXG4gIFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIFRocmVlLmpzIGBNYXRlcmlhbGAgaW5zdGFuY2UsIGZpbmQgdGhlIHNoYWRlcnMvdW5pZm9ybXMgdGhhdCB3aWxsIGJlXG4gKiB1c2VkIHRvIHJlbmRlciB0aGF0IG1hdGVyaWFsLlxuICpcbiAqIEBwYXJhbSBtYXRlcmlhbCAtIHRoZSBNYXRlcmlhbCBpbnN0YW5jZVxuICogQHJldHVybiB7b2JqZWN0fSAtIHRoZSBtYXRlcmlhbCdzIHNoYWRlciBpbmZvOiBge3VuaWZvcm1zOnt9LCBmcmFnbWVudFNoYWRlcjonJywgdmVydGV4U2hhZGVyOicnfWBcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhZGVyc0Zvck1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gIGxldCBidWlsdGluVHlwZSA9IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlNbbWF0ZXJpYWwudHlwZV07XG4gIHJldHVybiBidWlsdGluVHlwZSA/IFNoYWRlckxpYltidWlsdGluVHlwZV0gOiBtYXRlcmlhbCAvL1RPRE8gZmFsbGJhY2sgZm9yIHVua25vd24gdHlwZT9cbn1cblxuLyoqXG4gKiBGaW5kIGFsbCB1bmlmb3JtcyBhbmQgdGhlaXIgdHlwZXMgd2l0aGluIGEgc2hhZGVyIGNvZGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXIgLSBUaGUgc2hhZGVyIGNvZGUgdG8gcGFyc2VcbiAqIEByZXR1cm4ge29iamVjdH0gbWFwcGluZyBvZiB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGdsc2wgdHlwZVxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJVbmlmb3JtVHlwZXMoc2hhZGVyKSB7XG4gIGxldCB1bmlmb3JtUkUgPSAvXFxidW5pZm9ybVxccysoaW50fGZsb2F0fHZlY1syMzRdfG1hdFszNF0pXFxzKyhbQS1aYS16X11bXFx3XSopL2c7XG4gIGxldCB1bmlmb3JtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHVuaWZvcm1SRS5leGVjKHNoYWRlcikpICE9PSBudWxsKSB7XG4gICAgdW5pZm9ybXNbbWF0Y2hbMl1dID0gbWF0Y2hbMV07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zXG59XG5cbi8qKlxuICogSGVscGVyIGZvciBzbW9vdGhpbmcgb3V0IHRoZSBgbS5nZXRJbnZlcnNlKHgpYCAtLT4gYG0uY29weSh4KS5pbnZlcnQoKWAgY29udmVyc2lvblxuICogdGhhdCBoYXBwZW5lZCBpbiBUaHJlZUpTIHIxMjMuXG4gKiBAcGFyYW0ge01hdHJpeDR9IHNyY01hdHJpeFxuICogQHBhcmFtIHtNYXRyaXg0fSBbdGd0TWF0cml4XVxuICovXG5mdW5jdGlvbiBpbnZlcnRNYXRyaXg0KHNyY01hdHJpeCwgdGd0TWF0cml4ID0gbmV3IE1hdHJpeDQoKSkge1xuICBpZiAodHlwZW9mIHRndE1hdHJpeC5pbnZlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0Z3RNYXRyaXguY29weShzcmNNYXRyaXgpLmludmVydCgpO1xuICB9IGVsc2Uge1xuICAgIHRndE1hdHJpeC5nZXRJbnZlcnNlKHNyY01hdHJpeCk7XG4gIH1cbiAgcmV0dXJuIHRndE1hdHJpeFxufVxuXG4vKlxuSW5wdXQgZ2VvbWV0cnkgaXMgYSBjeWxpbmRlciB3aXRoIHI9MSwgaGVpZ2h0IGluIHkgZGltZW5zaW9uIGZyb20gMCB0byAxLFxuZGl2aWRlZCBpbnRvIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgaGVpZ2h0IHNlZ21lbnRzLlxuKi9cblxuY29uc3QgdmVydGV4RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBwb2ludEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEI7XG51bmlmb3JtIHZlYzMgcG9pbnRCO1xudW5pZm9ybSBmbG9hdCByYWRpdXM7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5cbnZlYzMgY3ViaWNCZXppZXIodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIGZsb2F0IGIwID0gdDIgKiB0MiAqIHQyO1xuICBmbG9hdCBiMSA9IDMuMCAqIHQgKiB0MiAqIHQyO1xuICBmbG9hdCBiMiA9IDMuMCAqIHQgKiB0ICogdDI7XG4gIGZsb2F0IGIzID0gdCAqIHQgKiB0O1xuICByZXR1cm4gYjAgKiBwMSArIGIxICogYzEgKyBiMiAqIGMyICsgYjMgKiBwMjtcbn1cblxudmVjMyBjdWJpY0JlemllckRlcml2YXRpdmUodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIHJldHVybiAtMy4wICogcDEgKiB0MiAqIHQyICtcbiAgICBjMSAqICgzLjAgKiB0MiAqIHQyIC0gNi4wICogdDIgKiB0KSArXG4gICAgYzIgKiAoNi4wICogdDIgKiB0IC0gMy4wICogdCAqIHQpICtcbiAgICAzLjAgKiBwMiAqIHQgKiB0O1xufVxuYDtcblxuY29uc3QgdmVydGV4VHJhbnNmb3JtID0gYFxuZmxvYXQgdCA9IHBvc2l0aW9uLnk7XG5iZXppZXJUID0gdDtcbnZlYzMgYmV6aWVyQ2VudGVyUG9zID0gY3ViaWNCZXppZXIocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCk7XG52ZWMzIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCkpO1xuXG4vLyBNYWtlIFwic2lkZXdheXNcIiBhbHdheXMgcGVycGVuZGljdWxhciB0byB0aGUgY2FtZXJhIHJheTsgdGhpcyBlbnN1cmVzIHRoYXQgYW55IHR3aXN0c1xuLy8gaW4gdGhlIGN5bGluZGVyIG9jY3VyIHdoZXJlIHlvdSB3b24ndCBzZWUgdGhlbTogXG52ZWMzIHZpZXdEaXJlY3Rpb24gPSBub3JtYWxNYXRyaXggKiB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuaWYgKGJlemllckRpciA9PSB2aWV3RGlyZWN0aW9uKSB7XG4gIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCA9PSAxLjAgPyB0IC0gMC4wMDAxIDogdCArIDAuMDAwMSkpO1xufVxudmVjMyBzaWRld2F5cyA9IG5vcm1hbGl6ZShjcm9zcyhiZXppZXJEaXIsIHZpZXdEaXJlY3Rpb24pKTtcbnZlYzMgdXBpc2ggPSBub3JtYWxpemUoY3Jvc3Moc2lkZXdheXMsIGJlemllckRpcikpO1xuXG4vLyBCdWlsZCBhIG1hdHJpeCBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgZGlzYyBpbiB0aGUgY3lsaW5kZXI6XG5tYXQ0IGRpc2NUeDtcbmRpc2NUeFswXS54eXogPSBzaWRld2F5cyAqIHJhZGl1cztcbmRpc2NUeFsxXS54eXogPSBiZXppZXJEaXIgKiByYWRpdXM7XG5kaXNjVHhbMl0ueHl6ID0gdXBpc2ggKiByYWRpdXM7XG5kaXNjVHhbM10ueHl6ID0gYmV6aWVyQ2VudGVyUG9zO1xuZGlzY1R4WzNdWzNdID0gMS4wO1xuXG4vLyBBcHBseSB0cmFuc2Zvcm0sIGlnbm9yaW5nIG9yaWdpbmFsIHlcbnBvc2l0aW9uID0gKGRpc2NUeCAqIHZlYzQocG9zaXRpb24ueCwgMC4wLCBwb3NpdGlvbi56LCAxLjApKS54eXo7XG5ub3JtYWwgPSBub3JtYWxpemUobWF0MyhkaXNjVHgpICogbm9ybWFsKTtcbmA7XG5cbmNvbnN0IGZyYWdtZW50RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBkYXNoaW5nO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuYDtcblxuY29uc3QgZnJhZ21lbnRNYWluSW50cm8gPSBgXG5pZiAoZGFzaGluZy54ICsgZGFzaGluZy55ID4gMC4wKSB7XG4gIGZsb2F0IGRhc2hGcmFjID0gbW9kKGJlemllclQgLSBkYXNoaW5nLnosIGRhc2hpbmcueCArIGRhc2hpbmcueSk7XG4gIGlmIChkYXNoRnJhYyA+IGRhc2hpbmcueCkge1xuICAgIGRpc2NhcmQ7XG4gIH1cbn1cbmA7XG5cbi8vIERlYnVnZ2luZzogc2VwYXJhdGUgY29sb3IgZm9yIGVhY2ggb2YgdGhlIDYgc2lkZXM6XG4vLyBjb25zdCBmcmFnbWVudENvbG9yVHJhbnNmb3JtID0gYFxuLy8gZmxvYXQgc2lkZU51bSA9IGZsb29yKHZVVi54ICogNi4wKTtcbi8vIHZlYzMgbWl4Q29sb3IgPSBzaWRlTnVtIDwgMS4wID8gdmVjMygxLjAsIDAuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCAyLjAgPyB2ZWMzKDAuMCwgMS4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDMuMCA/IHZlYzMoMS4wLCAxLjAsIDAuMCkgOlxuLy8gICBzaWRlTnVtIDwgNC4wID8gdmVjMygwLjAsIDAuMCwgMS4wKSA6XG4vLyAgIHNpZGVOdW0gPCA1LjAgPyB2ZWMzKDAuMCwgMS4wLCAwLjApIDpcbi8vICAgdmVjMygxLjAsIDAuMCwgMS4wKTtcbi8vIGdsX0ZyYWdDb2xvci54eXogPSBtaXgoZ2xfRnJhZ0NvbG9yLnh5eiwgbWl4Q29sb3IsIDAuNSk7XG4vLyBgXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gIHJldHVybiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgYmFzZU1hdGVyaWFsLFxuICAgIHtcbiAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBwb2ludEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xBOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBjb250cm9sQjoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgcG9pbnRCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICByYWRpdXM6IHt2YWx1ZTogMC4wMX0sXG4gICAgICAgIGRhc2hpbmc6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0gLy9vbiwgb2ZmLCBvZmZzZXRcbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhEZWZzLFxuICAgICAgdmVydGV4VHJhbnNmb3JtLFxuICAgICAgZnJhZ21lbnREZWZzLFxuICAgICAgZnJhZ21lbnRNYWluSW50cm9cbiAgICB9XG4gIClcbn1cblxubGV0IGdlb21ldHJ5ID0gbnVsbDtcblxuY29uc3QgZGVmYXVsdEJhc2VNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9uZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe2NvbG9yOiAweGZmZmZmZiwgc2lkZTogRG91YmxlU2lkZX0pO1xuXG5cbi8qKlxuICogQSBUaHJlZUpTIGBNZXNoYCB0aGF0IGJlbmRzIGEgdHViZSBzaGFwZSBhbG9uZyBhIDNEIGN1YmljIGJlemllciBwYXRoLiBUaGUgYmVuZGluZyBpcyBkb25lXG4gKiBieSBkZWZvcm1pbmcgYSBzdHJhaWdodCBjeWxpbmRyaWNhbCBnZW9tZXRyeSBpbiB0aGUgdmVydGV4IHNoYWRlciBiYXNlZCBvbiBhIHNldCBvZiBmb3VyXG4gKiBjb250cm9sIHBvaW50IHVuaWZvcm1zLiBJdCBwYXRjaGVzIHRoZSBuZWNlc3NhcnkgR0xTTCBpbnRvIHRoZSBtZXNoJ3MgYXNzaWduZWQgYG1hdGVyaWFsYFxuICogYXV0b21hdGljYWxseS5cbiAqXG4gKiBUaGUgY3ViaXogYmV6aWVyIHBhdGggaXMgZGV0ZXJtaW5lZCBieSBpdHMgZm91ciBgVmVjdG9yM2AgcHJvcGVydGllczpcbiAqIC0gYHBvaW50QWBcbiAqIC0gYGNvbnRyb2xBYFxuICogLSBgY29udHJvbEJgXG4gKiAtIGBwb2ludEJgXG4gKlxuICogVGhlIHR1YmUncyByYWRpdXMgaXMgY29udHJvbGxlZCBieSBpdHMgYHJhZGl1c2AgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIGAwLjAxYC5cbiAqXG4gKiBZb3UgY2FuIGFsc28gZ2l2ZSB0aGUgdHViZSBhIGRhc2hlZCBhcHBlYXJhbmNlIHdpdGggdHdvIHByb3BlcnRpZXM6XG4gKlxuICogLSBgZGFzaEFycmF5YCAtIGFuIGFycmF5IG9mIHR3byBudW1iZXJzLCBkZWZpbmluZyB0aGUgbGVuZ3RoIG9mIFwib25cIiBhbmQgXCJvZmZcIiBwYXJ0cyBvZlxuICogICB0aGUgZGFzaC4gRWFjaCBpcyBhIDAtMSByYXRpbyBvZiB0aGUgZW50aXJlIHBhdGgncyBsZW5ndGguIChBY3R1YWxseSB0aGlzIGlzIHRoZSBgdGAgbGVuZ3RoXG4gKiAgIHVzZWQgYXMgaW5wdXQgdG8gdGhlIGN1YmljIGJlemllciBmdW5jdGlvbiwgbm90IGl0cyB2aXNpYmxlIGxlbmd0aC4pXG4gKiAtIGBkYXNoT2Zmc2V0YCAtIG9mZnNldCBvZiB3aGVyZSB0aGUgZGFzaCBzdGFydHMuIFlvdSBjYW4gYW5pbWF0ZSB0aGlzIHRvIG1ha2UgdGhlIGRhc2hlcyBtb3ZlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZGFzaGVzIHdpbGwgYXBwZWFyIGxpa2UgYSBob2xsb3cgdHViZSwgbm90IHNvbGlkLiBUaGlzIHdpbGwgYmUgbW9yZSBhcHBhcmVudCBvblxuICogdGhpY2tlciB0dWJlcy5cbiAqXG4gKiBUT0RPOiBwcm9wZXIgZ2VvbWV0cnkgYm91bmRpbmcgc3BoZXJlIGFuZCByYXljYXN0aW5nXG4gKiBUT0RPOiBhbGxvdyBjb250cm9sIG9mIHRoZSBnZW9tZXRyeSdzIHNlZ21lbnQgY291bnRzXG4gKi9cbmNsYXNzIEJlemllck1lc2ggZXh0ZW5kcyBNZXNoIHtcbiAgc3RhdGljIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiBnZW9tZXRyeSB8fCAoZ2VvbWV0cnkgPVxuICAgICAgbmV3IEN5bGluZGVyR2VvbWV0cnkoMSwgMSwgMSwgNiwgNjQpLnRyYW5zbGF0ZSgwLCAwLjUsIDApXG4gICAgKVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICBCZXppZXJNZXNoLmdldEdlb21ldHJ5KCksXG4gICAgICBkZWZhdWx0QmFzZU1hdGVyaWFsXG4gICAgKTtcblxuICAgIHRoaXMucG9pbnRBID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNvbnRyb2xBID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNvbnRyb2xCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnBvaW50QiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjAxO1xuICAgIHRoaXMuZGFzaEFycmF5ID0gbmV3IFZlY3RvcjIoKTtcbiAgICB0aGlzLmRhc2hPZmZzZXQgPSAwO1xuXG4gICAgLy8gVE9ETyAtIGRpc2FibGluZyBmcnVzdHVtIGN1bGxpbmcgdW50aWwgSSBmaWd1cmUgb3V0IGhvdyB0byBjdXN0b21pemUgdGhlXG4gICAgLy8gIGdlb21ldHJ5J3MgYm91bmRpbmcgc3BoZXJlIHRoYXQgZ2V0cyB1c2VkXG4gICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0QmFzZU1hdGVyaWFsLmNsb25lKCkpO1xuICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZXJpdmVkTWF0ZXJpYWxcbiAgfVxuICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgfVxuICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgfVxuXG4gIG9uQmVmb3JlUmVuZGVyKCkge1xuICAgIGNvbnN0IHt1bmlmb3Jtc30gPSB0aGlzLm1hdGVyaWFsO1xuICAgIGNvbnN0IHtwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCByYWRpdXMsIGRhc2hBcnJheSwgZGFzaE9mZnNldH0gPSB0aGlzO1xuICAgIHVuaWZvcm1zLnBvaW50QS52YWx1ZS5jb3B5KHBvaW50QSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEEudmFsdWUuY29weShjb250cm9sQSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgdW5pZm9ybXMucG9pbnRCLnZhbHVlLmNvcHkocG9pbnRCKTtcbiAgICB1bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICB9XG5cbiAgcmF5Y2FzdCgvKnJheWNhc3RlciwgaW50ZXJzZWN0cyovKSB7XG4gICAgLy8gVE9ETyAtIGp1c3QgZmFpbCBmb3Igbm93XG4gIH1cbn1cblxuZXhwb3J0IHsgQmV6aWVyTWVzaCwgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCBleHBhbmRTaGFkZXJJbmNsdWRlcywgZ2V0U2hhZGVyVW5pZm9ybVR5cGVzLCBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwsIGludmVydE1hdHJpeDQsIHZvaWRNYWluUmVnRXhwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n"));

/***/ }),

/***/ "./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineWorkerModule: function() { return /* binding */ defineWorkerModule; },\n/* harmony export */   stringifyFunction: function() { return /* binding */ stringifyFunction; },\n/* harmony export */   terminateWorker: function() { return /* binding */ terminateWorker; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n    ) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && \"development\" === 'test') {} else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options)\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUJBQXlCO0FBQ3pCLGlEQUFpRDs7QUFFakQ7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvRUFBb0U7QUFDdkgsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLE9BQU8sb0JBQW9CLGFBQW9CLGFBQWEsRUFBQyxDQUFDO0FBQy9FO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVrRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMuZXNtLmpzP2ZmMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWluIGNvbnRlbnQgZm9yIHRoZSB3b3JrZXIgdGhhdCBoYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBleGVjdXRpb24gb2ZcbiAqIG1vZHVsZXMgd2l0aGluIGl0LlxuICovXG5mdW5jdGlvbiB3b3JrZXJCb290c3RyYXAoKSB7XG4gIHZhciBtb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBIYW5kbGUgbWVzc2FnZXMgZm9yIHJlZ2lzdGVyaW5nIGEgbW9kdWxlXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gcmVmLmRlcGVuZGVuY2llczsgaWYgKCBkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCApIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHZhciBpbml0ID0gcmVmLmluaXQ7IGlmICggaW5pdCA9PT0gdm9pZCAwICkgaW5pdCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB2YXIgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlZi5nZXRUcmFuc2ZlcmFibGVzOyBpZiAoIGdldFRyYW5zZmVyYWJsZXMgPT09IHZvaWQgMCApIGdldFRyYW5zZmVyYWJsZXMgPSBudWxsO1xuXG4gICAgLy8gT25seSByZWdpc3RlciBvbmNlXG4gICAgaWYgKG1vZHVsZXNbaWRdKSB7IHJldHVybiB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gSWYgYW55IGRlcGVuZGVuY2llcyBhcmUgbW9kdWxlcywgZW5zdXJlIHRoZXkncmUgcmVnaXN0ZXJlZCBhbmQgZ3JhYiB0aGVpciB2YWx1ZVxuICAgICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgIGlmIChkZXAgJiYgZGVwLmlzV29ya2VyTW9kdWxlKSB7XG4gICAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGVwLCBmdW5jdGlvbiAoZGVwUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVwUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHsgdGhyb3cgZGVwUmVzdWx0IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZXAgPSBtb2R1bGVzW2RlcC5pZF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlaHlkcmF0ZSBmdW5jdGlvbnNcbiAgICAgIGluaXQgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5pbml0XCIpLCBpbml0KTtcbiAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5nZXRUcmFuc2ZlcmFibGVzXCIpLCBnZXRUcmFuc2ZlcmFibGVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBzdG9yZSBpdHMgdmFsdWVcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dvcmtlciBtb2R1bGUgaW5pdCBmdW5jdGlvbiBmYWlsZWQgdG8gcmVoeWRyYXRlJyk7XG4gICAgICB9XG4gICAgICBtb2R1bGVzW2lkXSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXNcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGlmICghKGVyciAmJiBlcnIubm9Mb2cpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciBjYWxsaW5nIGEgcmVnaXN0ZXJlZCBtb2R1bGUncyByZXN1bHQgZnVuY3Rpb25cbiAgZnVuY3Rpb24gY2FsbE1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZiQxO1xuXG4gICAgdmFyIGlkID0gcmVmLmlkO1xuICAgIHZhciBhcmdzID0gcmVmLmFyZ3M7XG4gICAgaWYgKCFtb2R1bGVzW2lkXSB8fCB0eXBlb2YgbW9kdWxlc1tpZF0udmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcigoXCJXb3JrZXIgbW9kdWxlIFwiICsgaWQgKyBcIjogbm90IGZvdW5kIG9yIGl0cyAnaW5pdCcgZGlkIG5vdCByZXR1cm4gYSBmdW5jdGlvblwiKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZWYkMSA9IG1vZHVsZXNbaWRdKS52YWx1ZS5hcHBseShyZWYkMSwgYXJncyk7XG4gICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIGZ1bmN0aW9uIChyZWopIHsgcmV0dXJuIGNhbGxiYWNrKHJlaiBpbnN0YW5jZW9mIEVycm9yID8gcmVqIDogbmV3IEVycm9yKCcnICsgcmVqKSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IG1vZHVsZXNbaWRdLmdldFRyYW5zZmVyYWJsZXMgJiYgbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpO1xuICAgICAgICBpZiAoIXR4IHx8ICFBcnJheS5pc0FycmF5KHR4KSB8fCAhdHgubGVuZ3RoKSB7XG4gICAgICAgICAgdHggPSB1bmRlZmluZWQ7IC8vcG9zdE1lc3NhZ2UgaXMgdmVyeSBwaWNreSBhYm91dCBub3QgcGFzc2luZyBudWxsIG9yIGVtcHR5IHRyYW5zZmVyYWJsZXNcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhyZXN1bHQsIHR4KTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWh5ZHJhdGUobmFtZSwgc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICBzZWxmLnRyb2lrYURlZmluZSA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXN1bHQgPSByOyB9O1xuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoXG4gICAgICAgIFsoXCIvKiogXCIgKyAobmFtZS5yZXBsYWNlKC9cXCovZywgJycpKSArIFwiICoqL1xcblxcbnRyb2lrYURlZmluZShcXG5cIiArIHN0ciArIFwiXFxuKVwiKV0sXG4gICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICApXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaW1wb3J0U2NyaXB0cyh1cmwpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBkZWxldGUgc2VsZi50cm9pa2FEZWZpbmU7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYWxsIG1lc3NhZ2VzIHdpdGhpbiB0aGUgd29ya2VyXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJlZiA9IGUuZGF0YTtcbiAgICB2YXIgbWVzc2FnZUlkID0gcmVmLm1lc3NhZ2VJZDtcbiAgICB2YXIgYWN0aW9uID0gcmVmLmFjdGlvbjtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICAvLyBNb2R1bGUgcmVnaXN0cmF0aW9uXG4gICAgICBpZiAoYWN0aW9uID09PSAncmVnaXN0ZXJNb2R1bGUnKSB7XG4gICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHtpc0NhbGxhYmxlOiB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEludm9jYXRpb25cbiAgICAgIGlmIChhY3Rpb24gPT09ICdjYWxsTW9kdWxlJykge1xuICAgICAgICBjYWxsTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLnN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZhbGxiYWNrIGZvciBgZGVmaW5lV29ya2VyTW9kdWxlYCB0aGF0IGJlaGF2ZXMgaWRlbnRpY2FsbHkgYnV0IHJ1bnMgaW4gdGhlIG1haW5cbiAqIHRocmVhZCwgZm9yIHdoZW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgd2ViIHdvcmtlcnMgb3IgdGhleVxuICogYXJlIGRpc2FsbG93ZWQgZHVlIHRvIGUuZy4gQ1NQIHNlY3VyaXR5IHJlc3RyaWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVGdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uIChpbml0UmVzdWx0KSB7XG4gICAgICBpZiAodHlwZW9mIGluaXRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuYXBwbHkodm9pZCAwLCBhcmdzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgY2FuIGlnbm9yZSBnZXRUcmFuc2ZlcmFibGVzIGluIG1haW4gdGhyZWFkLiBUT0RPIHdvcmtlcklkP1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcbiAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcblxuICAgIC8vIFJlc29sdmUgZGVwZW5kZW5jaWVzXG4gICAgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAgJiYgZGVwLl9nZXRJbml0UmVzdWx0ID8gZGVwLl9nZXRJbml0UmVzdWx0KCkgOiBkZXA7IH1cbiAgICApIDogW107XG5cbiAgICAvLyBJbnZva2UgaW5pdCB3aXRoIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXNcbiAgICB2YXIgaW5pdFByb21pc2UgPSBQcm9taXNlLmFsbChkZXBlbmRlbmNpZXMpLnRoZW4oZnVuY3Rpb24gKGRlcHMpIHtcbiAgICAgIHJldHVybiBpbml0LmFwcGx5KG51bGwsIGRlcHMpXG4gICAgfSk7XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzb2x2ZWQgcHJvbWlzZSBmb3Igc3Vic2VxdWVudCBjYWxsc1xuICAgIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbml0UHJvbWlzZTsgfTtcblxuICAgIHJldHVybiBpbml0UHJvbWlzZVxuICB9O1xuICByZXR1cm4gbW9kdWxlRnVuY1xufVxuXG52YXIgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgLy8gT25seSBhdHRlbXB0IHdvcmtlciBpbml0aWFsaXphdGlvbiBpbiBicm93c2VyczsgZWxzZXdoZXJlIGl0IHdvdWxkIGp1c3QgYmVcbiAgLy8gbm9pc2UgZS5nLiBsb2FkaW5nIGludG8gYSBOb2RlIGVudmlyb25tZW50IGZvciBTU1IuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPIGFkZGl0aW9uYWwgY2hlY2tzIGZvciB0aGluZ3MgbGlrZSBpbXBvcnRTY3JpcHRzIHdpdGhpbiB0aGUgd29ya2VyP1xuICAgICAgLy8gIFdvdWxkIG5lZWQgdG8gYmUgYW4gYXN5bmMgY2hlY2suXG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihcbiAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJyddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KSlcbiAgICAgICk7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSA7IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAoXCJUcm9pa2EgY3JlYXRlV29ya2VyTW9kdWxlOiB3ZWIgd29ya2VycyBub3QgYWxsb3dlZDsgZmFsbGluZyBiYWNrIHRvIG1haW4gdGhyZWFkIGV4ZWN1dGlvbi4gQ2F1c2U6IFtcIiArIChlcnIubWVzc2FnZSkgKyBcIl1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZWQgcmVzdWx0XG4gIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1cHBvcnRlZDsgfTtcbiAgcmV0dXJuIHN1cHBvcnRlZFxufTtcblxudmFyIF93b3JrZXJNb2R1bGVJZCA9IDA7XG52YXIgX21lc3NhZ2VJZCA9IDA7XG52YXIgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG52YXIgd29ya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgcmVnaXN0ZXJlZE1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvL3dvcmtlcklkIC0+IFNldDx1bnJlZ2lzdGVyRm4+XG52YXIgb3BlblJlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vKipcbiAqIERlZmluZSBhIG1vZHVsZSBvZiBjb2RlIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aXRoIGEgd2ViIHdvcmtlci4gVGhpcyBwcm92aWRlcyBhIHNpbXBsZVxuICogaW50ZXJmYWNlIGZvciBtb3ZpbmcgY2h1bmtzIG9mIGxvZ2ljIG9mZiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBtYW5hZ2luZyB0aGVpciBkZXBlbmRlbmNpZXNcbiAqIGFtb25nIG9uZSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmluaXRcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmRlcGVuZGVuY2llc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdldFRyYW5zZmVyYWJsZXNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53b3JrZXJJZF1cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSk6IHt0aGVufX1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lV29ya2VyTW9kdWxlKG9wdGlvbnMpIHtcbiAgaWYgKCghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5pbml0ICE9PSAnZnVuY3Rpb24nKSAmJiAhX2FsbG93SW5pdEFzU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBgb3B0aW9ucy5pbml0YCBmdW5jdGlvbicpXG4gIH1cbiAgdmFyIGRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xuICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcbiAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSBvcHRpb25zLmdldFRyYW5zZmVyYWJsZXM7XG4gIHZhciB3b3JrZXJJZCA9IG9wdGlvbnMud29ya2VySWQ7XG5cbiAgaWYgKCFzdXBwb3J0c1dvcmtlcnMoKSkge1xuICAgIHJldHVybiBkZWZpbmVNYWluVGhyZWFkTW9kdWxlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAod29ya2VySWQgPT0gbnVsbCkge1xuICAgIHdvcmtlcklkID0gJyNkZWZhdWx0JztcbiAgfVxuICB2YXIgaWQgPSBcIndvcmtlck1vZHVsZVwiICsgKCsrX3dvcmtlck1vZHVsZUlkKTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgaWQ7XG4gIHZhciByZWdpc3RyYXRpb25Qcm9taXNlID0gbnVsbDtcblxuICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgLy8gV3JhcCByYXcgZnVuY3Rpb25zIGFzIHdvcmtlciBtb2R1bGVzIHdpdGggbm8gZGVwZW5kZW5jaWVzXG4gICAgaWYgKHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbicgJiYgIWRlcC53b3JrZXJNb2R1bGVEYXRhKSB7XG4gICAgICBfYWxsb3dJbml0QXNTdHJpbmcgPSB0cnVlO1xuICAgICAgZGVwID0gZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICAgICAgd29ya2VySWQ6IHdvcmtlcklkLFxuICAgICAgICBuYW1lOiAoXCI8XCIgKyBuYW1lICsgXCI+IGZ1bmN0aW9uIGRlcGVuZGVuY3k6IFwiICsgKGRlcC5uYW1lKSksXG4gICAgICAgIGluaXQ6IChcImZ1bmN0aW9uKCl7cmV0dXJuIChcXG5cIiArIChzdHJpbmdpZnlGdW5jdGlvbihkZXApKSArIFwiXFxuKX1cIilcbiAgICAgIH0pO1xuICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEdyYWIgcG9zdGFibGUgZGF0YSBmb3Igd29ya2VyIG1vZHVsZXNcbiAgICBpZiAoZGVwICYmIGRlcC53b3JrZXJNb2R1bGVEYXRhKSB7XG4gICAgICBkZXAgPSBkZXAud29ya2VyTW9kdWxlRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcFxuICB9KTtcblxuICBmdW5jdGlvbiBtb2R1bGVGdW5jKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoaXMgbW9kdWxlIGlmIG5lZWRlZFxuICAgIGlmICghcmVnaXN0cmF0aW9uUHJvbWlzZSkge1xuICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IGNhbGxXb3JrZXIod29ya2VySWQsJ3JlZ2lzdGVyTW9kdWxlJywgbW9kdWxlRnVuYy53b3JrZXJNb2R1bGVEYXRhKTtcbiAgICAgIHZhciB1bnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgcmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdLmRlbGV0ZSh1bnJlZ2lzdGVyKTtcbiAgICAgIH1cbiAgICAgIDsocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdIHx8IChyZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0gPSBuZXcgU2V0KCkpKS5hZGQodW5yZWdpc3Rlcik7XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIHRoZSBtb2R1bGUsIHJldHVybmluZyBhIHByb21pc2VcbiAgICByZXR1cm4gcmVnaXN0cmF0aW9uUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVmLmlzQ2FsbGFibGU7XG5cbiAgICAgIGlmIChpc0NhbGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBjYWxsV29ya2VyKHdvcmtlcklkLCdjYWxsTW9kdWxlJywge2lkOiBpZCwgYXJnczogYXJnc30pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBtb2R1bGUgZnVuY3Rpb24gd2FzIGNhbGxlZCBidXQgYGluaXRgIGRpZCBub3QgcmV0dXJuIGEgY2FsbGFibGUgZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgbW9kdWxlRnVuYy53b3JrZXJNb2R1bGVEYXRhID0ge1xuICAgIGlzV29ya2VyTW9kdWxlOiB0cnVlLFxuICAgIGlkOiBpZCxcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICAgIGluaXQ6IHN0cmluZ2lmeUZ1bmN0aW9uKGluaXQpLFxuICAgIGdldFRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXMgJiYgc3RyaW5naWZ5RnVuY3Rpb24oZ2V0VHJhbnNmZXJhYmxlcylcbiAgfTtcbiAgcmV0dXJuIG1vZHVsZUZ1bmNcbn1cblxuLyoqXG4gKiBUZXJtaW5hdGUgYW4gYWN0aXZlIFdvcmtlciBieSBhIHdvcmtlcklkIHRoYXQgd2FzIHBhc3NlZCB0byBkZWZpbmVXb3JrZXJNb2R1bGUuXG4gKiBUaGlzIG9ubHkgdGVybWluYXRlcyB0aGUgV29ya2VyIGl0c2VsZjsgdGhlIHdvcmtlciBtb2R1bGUgd2lsbCByZW1haW4gYXZhaWxhYmxlXG4gKiBhbmQgaWYgeW91IGNhbGwgaXQgYWdhaW4gaXRzIFdvcmtlciB3aWxsIGJlIHJlc3Bhd25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JrZXJJZFxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpIHtcbiAgLy8gVW5yZWdpc3RlciBhbGwgbW9kdWxlcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZCBpbiB0aGF0IHdvcmtlclxuICBpZiAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdKSB7XG4gICAgcmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdLmZvckVhY2goZnVuY3Rpb24gKHVucmVnaXN0ZXIpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBUZXJtaW5hdGUgdGhlIFdvcmtlciBvYmplY3RcbiAgaWYgKHdvcmtlcnNbd29ya2VySWRdKSB7XG4gICAgd29ya2Vyc1t3b3JrZXJJZF0udGVybWluYXRlKCk7XG4gICAgZGVsZXRlIHdvcmtlcnNbd29ya2VySWRdO1xuICB9XG59XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBmdW5jdGlvbiBpbnRvIGEgZm9ybSB0aGF0IGNhbiBiZSBkZXNlcmlhbGl6ZWQgaW4gdGhlIHdvcmtlclxuICogQHBhcmFtIGZuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKGZuKSB7XG4gIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAvLyBJZiBpdCB3YXMgZGVmaW5lZCBpbiBvYmplY3QgbWV0aG9kL3Byb3BlcnR5IGZvcm1hdCwgaXQgbmVlZHMgdG8gYmUgbW9kaWZpZWRcbiAgaWYgKCEvXmZ1bmN0aW9uLy50ZXN0KHN0cikgJiYgL15cXHcrXFxzKlxcKC8udGVzdChzdHIpKSB7XG4gICAgc3RyID0gJ2Z1bmN0aW9uICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5cbmZ1bmN0aW9uIGdldFdvcmtlcih3b3JrZXJJZCkge1xuICB2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG4gIGlmICghd29ya2VyKSB7XG4gICAgLy8gQm9vdHN0cmFwIHRoZSB3b3JrZXIncyBjb250ZW50XG4gICAgdmFyIGJvb3RzdHJhcCA9IHN0cmluZ2lmeUZ1bmN0aW9uKHdvcmtlckJvb3RzdHJhcCk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHdvcmtlciBmcm9tIHRoZSBib290c3RyYXAgZnVuY3Rpb24gY29udGVudFxuICAgIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdID0gbmV3IFdvcmtlcihcbiAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFxuICAgICAgICAgIFsoXCIvKiogV29ya2VyIE1vZHVsZSBCb290c3RyYXA6IFwiICsgKHdvcmtlcklkLnJlcGxhY2UoL1xcKi9nLCAnJykpICsgXCIgKiovXFxuXFxuOyhcIiArIGJvb3RzdHJhcCArIFwiKSgpXCIpXSxcbiAgICAgICAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIFNpbmdsZSBoYW5kbGVyIGZvciByZXNwb25zZSBtZXNzYWdlcyBmcm9tIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGUuZGF0YTtcbiAgICAgIHZhciBtc2dJZCA9IHJlc3BvbnNlLm1lc3NhZ2VJZDtcbiAgICAgIHZhciBjYWxsYmFjayA9IG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyTW9kdWxlIHJlc3BvbnNlIHdpdGggZW1wdHkgb3IgdW5rbm93biBtZXNzYWdlSWQnKVxuICAgICAgfVxuICAgICAgZGVsZXRlIG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd29ya2VyXG59XG5cbi8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG5mdW5jdGlvbiBjYWxsV29ya2VyKHdvcmtlcklkLCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbWVzc2FnZUlkID0gKytfbWVzc2FnZUlkO1xuICAgIG9wZW5SZXF1ZXN0c1ttZXNzYWdlSWRdID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKChcIkVycm9yIGluIHdvcmtlciBcIiArIGFjdGlvbiArIFwiIGNhbGw6IFwiICsgKHJlc3BvbnNlLmVycm9yKSkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldFdvcmtlcih3b3JrZXJJZCkucG9zdE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfSlcbn1cblxuZXhwb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCBzdHJpbmdpZnlGdW5jdGlvbiwgdGVybWluYXRlV29ya2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\n"));

/***/ }),

/***/ "./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nfunction bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkubWpzP2U1OTIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYmlkaUZhY3RvcnkoKSB7XG52YXIgYmlkaSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIC8vIEJpZGkgY2hhcmFjdGVyIHR5cGVzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBEQVRBID0ge1xuICAgIFwiUlwiOiBcIjEzaywxYSwyLDMsMywyKzFqLGNoKzE2LGErMSw1KzIsMituLDUsYSw0LDYrMTYsNCszLGgrMWIsNG1vLDE3OXEsMis5LDIrMTEsMmk5Kzd5LDIrNjgsNCwzKzQsNSsxMyw0KzMsMis0aywzKzI5LDgrY2YsMXQrN3osdysxNywzKzNtLDF0KzN6LDE2bzErNXIsOCszMCw4K21jLDI5KzFyLDI5KzR2LDc1KzczXCIsXG4gICAgXCJFTlwiOiBcIjFjKzksM2QrMSw2LDE4Nys5LDUxMyw0KzUsNys5LHNmK2osMTc1aCs5LHF3K3EsMTYxZisxZCw0eHQrYSwyNWkrOVwiLFxuICAgIFwiRVNcIjogXCIxNywyLDZkcCsxLGYrMSxhdiwxNnZyLG14KzEsNG8sMlwiLFxuICAgIFwiRVRcIjogXCJ6KzIsM2grMyxiKzEseW0sM2UrMSwybyxwNCsxLDgsNnUsN2MsZzYsMXdjLDFuOSs0LDMwKzFiLDJuLDZkLHFoeCsxLGgwbSxhKzEsNDkrMiw2MysxLDQrMSw2YmIrMywxMmpqXCIsXG4gICAgXCJBTlwiOiBcIjE2bys1LDJqKzksMisxLDM1LGVkLDFmZjIrOSw4Nyt1XCIsXG4gICAgXCJDU1wiOiBcIjE4LDIrMSxiLDJ1LDEyayw1NXYsbCwxN3YwLDIsMyw1MywyKzEsYlwiLFxuICAgIFwiQlwiOiBcImEsMyxmKzIsMnYsNjkwXCIsXG4gICAgXCJTXCI6IFwiOSwyLGtcIixcbiAgICBcIldTXCI6IFwiYyxrLDRmNCwxdmsrYSx1LDFqLDMzNVwiLFxuICAgIFwiT05cIjogXCJ4KzEsNCs0LGgrNSxyKzUsciszLHosNSszLDIrMSwyKzEsNSwyKzIsMys0LG8sdyxjaSsxLDgrZCwzK2QsNis4LDIrZywzOSsxLDksNisxLDIsMzMsYjgsMysxLDNjKzEsNysxLDVyLGIsN2grMyxzYSs1LDIsM2krNixqZyszLHVyKzksMnYsaWorMSw5Zys5LDcrYSw4bSw0KzEsNDkreCwxNHUsMisyLGMrMixlKzIsZSsyLGUrMSxpK24sZStlLDIrcCx1KzIsZSsyLDM2KzEsMiszLDIrMSxiLDIrMiw2KzUsMiwyLDIsaCsxLDUrNCw2KzMsMytmLDE2KzIsNSszbCwzKzgxLDF5K3AsMis0MCxxK2EsbSsxMywycitjaCwyKzllLDc1K2hmLDMrdiwyKzJ3LDZlKzUsZis2LDc1KzJhLDFhK3AsMisyZyxkKzV4LHIrYiw2KzMsNCtvLGcsNisxLDYrMiwyaysxLDQsMmosNWgreiwxbSsxLDFlK2YsdCsyLDFmK2UsZCszLDRvKzMsMnMrMSx3LDUzNSsxcixoM2wrMWksOTMrMiwycyxiKzEsM2wreCwydiw0ZyszLDIxKzMsa3orMSxnNXYrMSw1YSxqKzksbit2LDIsMywyKzgsMisxLDMrMiwyLDMsNDYrMSw0KzQsaCs1LHIrNSxyK2EsM2grMiw0KzYsYis0LDc4LDFyKzI0LDQrYyw0LDFoYixleSs2LDEwMytqLDE2aitjLDF1eCs3LDUrZyxmc2gsamRxKzF0LDQsNTcrMmUscDEsMW0sMW0sMW0sMW0sNGt0KzEsN2orMTcsNSsycixkK2UsMytlLDIrZSwyKzEwLG0rNCx3LDFuKzUsMXEsNHorNSw0YityYiw5K2MsNCtjLDQrMzcsZCsyZyw4K2IsbCtiLDUrMWosOSs5LDcrMTMsOSt0LDMrMSwyNyszYywyKzI5LDIrM3EsZCtkLDMrNCw0KzIsNis2LGErbyw4KzYsYSsyLGUrNiwxNis0MiwyKzFpXCIsXG4gICAgXCJCTlwiOiBcIjArOCw2K2QsMnMrNSwyK3AsZSw0bTksMWt0KzIsMmIrNSw1KzUsMTdxOSt2LDdrLDZwKzgsNisxLDExOWQrMyw0NDArNyw5NnMrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrNzUsNnArMnJ6LDFiZW4rMSwxZWtmKzEsMWVrZisxXCIsXG4gICAgXCJOU01cIjogXCJsYyszMyw3bys2LDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMWQrayxoLDJ1KzYsMys1LDMrMSwyKzMsMTAsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLGcrMSxsKzEsdCsxLDFtKzEsNSszLDksbCsxLHUsMjEsOCsyLDIsMmosMys2LGQrNywyciwzKzgsYys1LDIzKzEscywyLDIsMWsrZCwyKzQsMisxLDYrYSwyK3osYSwydiszLDIrNSwyKzEsMysxLHErMSw1KzIsaCszLGUsMysxLDcsZyxqaysyLHFiKzIsdSsyLHUrMSx2KzEsMXQrMSwyKzYsOSwzK2EsYSwxYSsyLDNjKzEseiwzYisyLDUrMSxhLDcrMiw2NCsxLDMsMW4sMis2LDIsMiwzKzcsNys5LDMsMWQrZywxcyszLDFkLDIrNCwyLDYsMTUrOCxkKzEseCszLDMrMSwyKzIsMWwsMisxLDQsMisyLDFuKzcsMysxLDQ5KzIsMitjLDIrNiw1LDcsNCsxLDVqKzFsLDIrNCxrMSt3LDJkYisyLDN5LDJwK3YsZmYrMywzMCsxLG45eCszLDIrOSx4KzEsMjkrMSw3bCw0LDUscSsxLDYsNDgrMSxyK2gsZSwxMys3LHErYSwxYisyLDFkLDMrMywzKzEsMTQsMXcrNSwzKzEsMysxLGQsOSwxYywxZywyKzIsMysxLDYrMSwyLDE3KzEsOSw2biwzLDUsZm41LGtpK2YsaCtmLHIyLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrNSwzKzEsMTUrNSwzKzMsOSxhKzUsMysyLDFiK2MsMisxLGJiKzYsMis1LDJkK2wsMys2LDIrMSwyKzEsM2YrNSw0LDIrMSwyKzYsMiwyMSsxLDQsMiw5bysxLGYwYys0LDFvKzYsdDUsMXMrMywyYSxmNWwrMSw0M3QrMixpKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNixnemh5KzZuXCIsXG4gICAgXCJBTFwiOiBcIjE2dywzLDIsZSsxYix6KzIsMisycyxnKzEsOCsxLGIrbSwyK3QscysyaSxjK2UsNGgrZiwxZCsxZSwxYndlK2RwLDMrM3oseCtjLDIrMSwzNSszeSwycm0reiw1KzcsYis1LGR0K2wsYyt1LDE3bmwrMjcsMXQrMjcsNHgrNm4sMytkXCIsXG4gICAgXCJMUk9cIjogXCI2Y3RcIixcbiAgICBcIlJMT1wiOiBcIjZjdVwiLFxuICAgIFwiTFJFXCI6IFwiNmNxXCIsXG4gICAgXCJSTEVcIjogXCI2Y3JcIixcbiAgICBcIlBERlwiOiBcIjZjc1wiLFxuICAgIFwiTFJJXCI6IFwiNmVlXCIsXG4gICAgXCJSTElcIjogXCI2ZWZcIixcbiAgICBcIkZTSVwiOiBcIjZlZ1wiLFxuICAgIFwiUERJXCI6IFwiNmVoXCJcbiAgfTtcblxuICB2YXIgVFlQRVMgPSB7fTtcbiAgdmFyIFRZUEVTX1RPX05BTUVTID0ge307XG4gIFRZUEVTLkwgPSAxOyAvL0wgaXMgdGhlIGRlZmF1bHRcbiAgVFlQRVNfVE9fTkFNRVNbMV0gPSAnTCc7XG4gIE9iamVjdC5rZXlzKERBVEEpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICBUWVBFU1t0eXBlXSA9IDEgPDwgKGkgKyAxKTtcbiAgICBUWVBFU19UT19OQU1FU1tUWVBFU1t0eXBlXV0gPSB0eXBlO1xuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShUWVBFUyk7XG5cbiAgdmFyIElTT0xBVEVfSU5JVF9UWVBFUyA9IFRZUEVTLkxSSSB8IFRZUEVTLlJMSSB8IFRZUEVTLkZTSTtcbiAgdmFyIFNUUk9OR19UWVBFUyA9IFRZUEVTLkwgfCBUWVBFUy5SIHwgVFlQRVMuQUw7XG4gIHZhciBORVVUUkFMX0lTT0xBVEVfVFlQRVMgPSBUWVBFUy5CIHwgVFlQRVMuUyB8IFRZUEVTLldTIHwgVFlQRVMuT04gfCBUWVBFUy5GU0kgfCBUWVBFUy5MUkkgfCBUWVBFUy5STEkgfCBUWVBFUy5QREk7XG4gIHZhciBCTl9MSUtFX1RZUEVTID0gVFlQRVMuQk4gfCBUWVBFUy5STEUgfCBUWVBFUy5MUkUgfCBUWVBFUy5STE8gfCBUWVBFUy5MUk8gfCBUWVBFUy5QREY7XG4gIHZhciBUUkFJTElOR19UWVBFUyA9IFRZUEVTLlMgfCBUWVBFUy5XUyB8IFRZUEVTLkIgfCBJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFUy5QREkgfCBCTl9MSUtFX1RZUEVTO1xuXG4gIHZhciBtYXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHBhcnNlRGF0YSAoKSB7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG4gICAgICAgIGlmIChEQVRBLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgdmFyIGxhc3RDb2RlID0gMDtcbiAgICAgICAgICBEQVRBW3R5cGVdLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciByZWYgPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgICAgdmFyIHNraXAgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHJlZlsxXTtcbiAgICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLCAzNik7XG4gICAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgICBtYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKSB7XG4gICAgICAgICAgICAgIG1hcC5zZXQoKytsYXN0Q29kZSwgVFlQRVNbdHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciB0eXBlIGluIERBVEEpIGxvb3AoIHR5cGUgKTtcbiAgICAgIC8vY29uc29sZS5sb2coYGNoYXIgdHlwZXMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEJpZGlDaGFyVHlwZSAoY2hhcikge1xuICAgIHBhcnNlRGF0YSgpO1xuICAgIHJldHVybiBtYXAuZ2V0KGNoYXIuY29kZVBvaW50QXQoMCkpIHx8IFRZUEVTLkxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpZGlDaGFyVHlwZU5hbWUoY2hhcikge1xuICAgIHJldHVybiBUWVBFU19UT19OQU1FU1tnZXRCaWRpQ2hhclR5cGUoY2hhcildXG4gIH1cblxuICAvLyBCaWRpIGJyYWNrZXQgcGFpcnMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIGRhdGEkMSA9IHtcbiAgICBcInBhaXJzXCI6IFwiMTQ+MSwxZT4yLHU+Miwyd3Q+MSwxPjEsMWdlPjEsMXdwPjEsMWo+MSxmPjEsaG0+MSwxPjEsdT4xLHU2PjEsMT4xLCs1LDI4PjEsdz4xLDE+MSwrMyxiOD4xLDE+MSwrMywxPjMsLTE+LTEsMz4xLDE+MSwrMiwxcz4xLDE+MSx4PjEsdGg+MSwxPjEsKzIsZGI+MSwxPjEsKzMsMz4xLDE+MSwrMiwxNHFtPjEsMT4xLCsxLDRxPjEsMWU+Mix1PjIsMj4xLCsxXCIsXG4gICAgXCJjYW5vbmljYWxcIjogXCI2ZjE+LTZkeCw2ZHk+LTZkeCw2ZWM+LTZlZCw2ZWU+LTZlZCw2d3c+MmpqLC0yamk+MmpqLDE0cjQ+LTFlN2wsMWU3bT4tMWU3bCwxZTdtPi0xZTVjLDFlNWQ+LTFlNWIsMWU1Yz4tMTRxeCwxNHF5Pi0xNHF4LDE0dm4+LTFlY2csMWVjaD4tMWVjZywxZWR1Pi0xZWNnLDFlY2k+LTFlY2csMWVkYT4tMWVjZywxZWNpPi0xZWNnLDFlY2k+LTE2OHEsMTY4cj4tMTY4cSwxNjhzPi0xNHllLDE0eWY+LTE0eWVcIlxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gc3RyaW5nIHRoYXQgaG9sZHMgZW5jb2RlZCBjb2RlcG9pbnQgbWFwcGluZ3MsIGUuZy4gZm9yIGJyYWNrZXQgcGFpcnMgb3JcbiAgICogbWlycm9yaW5nIGNoYXJhY3RlcnMsIGFzIGVuY29kZWQgYnkgc2NyaXB0cy9nZW5lcmF0ZUJpZGlEYXRhLmpzLiBSZXR1cm5zIGFuIG9iamVjdFxuICAgKiBob2xkaW5nIHRoZSBgbWFwYCwgYW5kIG9wdGlvbmFsbHkgYSBgcmV2ZXJzZU1hcGAgaWYgYGluY2x1ZGVSZXZlcnNlOnRydWVgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZFN0cmluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVSZXZlcnNlIC0gdHJ1ZSBpZiB5b3Ugd2FudCByZXZlcnNlTWFwIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7e21hcDogTWFwPG51bWJlciwgbnVtYmVyPiwgcmV2ZXJzZU1hcD86IE1hcDxudW1iZXIsIG51bWJlcj59fVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJNYXAgKGVuY29kZWRTdHJpbmcsIGluY2x1ZGVSZXZlcnNlKSB7XG4gICAgdmFyIHJhZGl4ID0gMzY7XG4gICAgdmFyIGxhc3RDb2RlID0gMDtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciByZXZlcnNlTWFwID0gaW5jbHVkZVJldmVyc2UgJiYgbmV3IE1hcCgpO1xuICAgIHZhciBwcmV2UGFpcjtcbiAgICBlbmNvZGVkU3RyaW5nLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiB2aXNpdChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LmluZGV4T2YoJysnKSAhPT0gLTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9ICtlbnRyeTsgaS0tOykge1xuICAgICAgICAgIHZpc2l0KHByZXZQYWlyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBhaXIgPSBlbnRyeTtcbiAgICAgICAgdmFyIHJlZiA9IGVudHJ5LnNwbGl0KCc+Jyk7XG4gICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgYSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGEsIHJhZGl4KSk7XG4gICAgICAgIGIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChsYXN0Q29kZSArPSBwYXJzZUludChiLCByYWRpeCkpO1xuICAgICAgICBtYXAuc2V0KGEsIGIpO1xuICAgICAgICBpbmNsdWRlUmV2ZXJzZSAmJiByZXZlcnNlTWFwLnNldChiLCBhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBtYXA6IG1hcCwgcmV2ZXJzZU1hcDogcmV2ZXJzZU1hcCB9XG4gIH1cblxuICB2YXIgb3BlblRvQ2xvc2UsIGNsb3NlVG9PcGVuLCBjYW5vbmljYWw7XG5cbiAgZnVuY3Rpb24gcGFyc2UkMSAoKSB7XG4gICAgaWYgKCFvcGVuVG9DbG9zZSkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB2YXIgcmVmID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSQxLnBhaXJzLCB0cnVlKTtcbiAgICAgIHZhciBtYXAgPSByZWYubWFwO1xuICAgICAgdmFyIHJldmVyc2VNYXAgPSByZWYucmV2ZXJzZU1hcDtcbiAgICAgIG9wZW5Ub0Nsb3NlID0gbWFwO1xuICAgICAgY2xvc2VUb09wZW4gPSByZXZlcnNlTWFwO1xuICAgICAgY2Fub25pY2FsID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSQxLmNhbm9uaWNhbCwgZmFsc2UpLm1hcDtcbiAgICAgIC8vY29uc29sZS5sb2coYGJyYWNrZXRzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBvcGVuVG9DbG9zZS5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIGNsb3NlVG9PcGVuLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW5vbmljYWxCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBjYW5vbmljYWwuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIC8vIExvY2FsIHR5cGUgYWxpYXNlc1xuICB2YXIgVFlQRV9MID0gVFlQRVMuTDtcbiAgdmFyIFRZUEVfUiA9IFRZUEVTLlI7XG4gIHZhciBUWVBFX0VOID0gVFlQRVMuRU47XG4gIHZhciBUWVBFX0VTID0gVFlQRVMuRVM7XG4gIHZhciBUWVBFX0VUID0gVFlQRVMuRVQ7XG4gIHZhciBUWVBFX0FOID0gVFlQRVMuQU47XG4gIHZhciBUWVBFX0NTID0gVFlQRVMuQ1M7XG4gIHZhciBUWVBFX0IgPSBUWVBFUy5CO1xuICB2YXIgVFlQRV9TID0gVFlQRVMuUztcbiAgdmFyIFRZUEVfT04gPSBUWVBFUy5PTjtcbiAgdmFyIFRZUEVfQk4gPSBUWVBFUy5CTjtcbiAgdmFyIFRZUEVfTlNNID0gVFlQRVMuTlNNO1xuICB2YXIgVFlQRV9BTCA9IFRZUEVTLkFMO1xuICB2YXIgVFlQRV9MUk8gPSBUWVBFUy5MUk87XG4gIHZhciBUWVBFX1JMTyA9IFRZUEVTLlJMTztcbiAgdmFyIFRZUEVfTFJFID0gVFlQRVMuTFJFO1xuICB2YXIgVFlQRV9STEUgPSBUWVBFUy5STEU7XG4gIHZhciBUWVBFX1BERiA9IFRZUEVTLlBERjtcbiAgdmFyIFRZUEVfTFJJID0gVFlQRVMuTFJJO1xuICB2YXIgVFlQRV9STEkgPSBUWVBFUy5STEk7XG4gIHZhciBUWVBFX0ZTSSA9IFRZUEVTLkZTSTtcbiAgdmFyIFRZUEVfUERJID0gVFlQRVMuUERJO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHRcbiAgICogQHByb3BlcnR5IHt7c3RhcnQsIGVuZCwgbGV2ZWx9W119IHBhcmFncmFwaHNcbiAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBsZXZlbHNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgQmlkaXJlY3Rpb25hbCBBbGdvcml0aG0gdG8gYSBzdHJpbmcsIHJldHVybmluZyB0aGUgcmVzb2x2ZWQgZW1iZWRkaW5nIGxldmVsc1xuICAgKiBpbiBhIHNpbmdsZSBVaW50OEFycmF5IHBsdXMgYSBsaXN0IG9mIG9iamVjdHMgaG9sZGluZyBlYWNoIHBhcmFncmFwaCdzIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhbmQgcmVzb2x2ZWRcbiAgICogYmFzZSBlbWJlZGRpbmcgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgaW5wdXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7XCJsdHJcInxcInJ0bFwifFwiYXV0b1wifSBbYmFzZURpcmVjdGlvbl0gLSBVc2UgXCJsdHJcIiBvciBcInJ0bFwiIHRvIGZvcmNlIGEgYmFzZSBwYXJhZ3JhcGggZGlyZWN0aW9uLFxuICAgKiAgICAgICAgb3RoZXJ3aXNlIGEgZGlyZWN0aW9uIHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkgZnJvbSBlYWNoIHBhcmFncmFwaCdzIGNvbnRlbnRzLlxuICAgKiBAcmV0dXJuIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbWJlZGRpbmdMZXZlbHMgKHN0cmluZywgYmFzZURpcmVjdGlvbikge1xuICAgIHZhciBNQVhfREVQVEggPSAxMjU7XG5cbiAgICAvLyBTdGFydCBieSBtYXBwaW5nIGFsbCBjaGFyYWN0ZXJzIHRvIHRoZWlyIHVuaWNvZGUgdHlwZSwgYXMgYSBiaXRtYXNrIGludGVnZXJcbiAgICB2YXIgY2hhclR5cGVzID0gbmV3IFVpbnQzMkFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyVHlwZXNbaV0gPSBnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhclR5cGVDb3VudHMgPSBuZXcgTWFwKCk7IC8vd2lsbCBiZSBjbGVhcmVkIGF0IHN0YXJ0IG9mIGVhY2ggcGFyYWdyYXBoXG4gICAgZnVuY3Rpb24gY2hhbmdlQ2hhclR5cGUoaSwgdHlwZSkge1xuICAgICAgdmFyIG9sZFR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICBjaGFyVHlwZXNbaV0gPSB0eXBlO1xuICAgICAgY2hhclR5cGVDb3VudHMuc2V0KG9sZFR5cGUsIGNoYXJUeXBlQ291bnRzLmdldChvbGRUeXBlKSAtIDEpO1xuICAgICAgaWYgKG9sZFR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgLSAxKTtcbiAgICAgIH1cbiAgICAgIGNoYXJUeXBlQ291bnRzLnNldCh0eXBlLCAoY2hhclR5cGVDb3VudHMuZ2V0KHR5cGUpIHx8IDApICsgMSk7XG4gICAgICBpZiAodHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgfHwgMCkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZW1iZWRMZXZlbHMgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKTtcbiAgICB2YXIgaXNvbGF0aW9uUGFpcnMgPSBuZXcgTWFwKCk7IC8vaW5pdC0+cGRpIGFuZCBwZGktPmluaXRcblxuICAgIC8vID09PSAzLjMuMSBUaGUgUGFyYWdyYXBoIExldmVsID09PVxuICAgIC8vIDMuMy4xIFAxOiBTcGxpdCB0aGUgdGV4dCBpbnRvIHBhcmFncmFwaHNcbiAgICB2YXIgcGFyYWdyYXBocyA9IFtdOyAvLyBbe3N0YXJ0LCBlbmQsIGxldmVsfSwgLi4uXVxuICAgIHZhciBwYXJhZ3JhcGggPSBudWxsO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHN0cmluZy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICBpZiAoIXBhcmFncmFwaCkge1xuICAgICAgICBwYXJhZ3JhcGhzLnB1c2gocGFyYWdyYXBoID0ge1xuICAgICAgICAgIHN0YXJ0OiBpJDEsXG4gICAgICAgICAgZW5kOiBzdHJpbmcubGVuZ3RoIC0gMSxcbiAgICAgICAgICAvLyAzLjMuMSBQMi1QMzogRGV0ZXJtaW5lIHRoZSBwYXJhZ3JhcGggbGV2ZWxcbiAgICAgICAgICBsZXZlbDogYmFzZURpcmVjdGlvbiA9PT0gJ3J0bCcgPyAxIDogYmFzZURpcmVjdGlvbiA9PT0gJ2x0cicgPyAwIDogZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwoaSQxLCBmYWxzZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhclR5cGVzW2kkMV0gJiBUWVBFX0IpIHtcbiAgICAgICAgcGFyYWdyYXBoLmVuZCA9IGkkMTtcbiAgICAgICAgcGFyYWdyYXBoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRk9STUFUVElOR19UWVBFUyA9IFRZUEVfUkxFIHwgVFlQRV9MUkUgfCBUWVBFX1JMTyB8IFRZUEVfTFJPIHwgSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRV9QREkgfCBUWVBFX1BERiB8IFRZUEVfQjtcbiAgICB2YXIgbmV4dEV2ZW4gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiArICgobiAmIDEpID8gMSA6IDIpOyB9O1xuICAgIHZhciBuZXh0T2RkID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKyAoKG4gJiAxKSA/IDIgOiAxKTsgfTtcblxuICAgIC8vIEV2ZXJ5dGhpbmcgZnJvbSBoZXJlIG9uIHdpbGwgb3BlcmF0ZSBwZXIgcGFyYWdyYXBoLlxuICAgIGZvciAodmFyIHBhcmFJZHggPSAwOyBwYXJhSWR4IDwgcGFyYWdyYXBocy5sZW5ndGg7IHBhcmFJZHgrKykge1xuICAgICAgcGFyYWdyYXBoID0gcGFyYWdyYXBoc1twYXJhSWR4XTtcbiAgICAgIHZhciBzdGF0dXNTdGFjayA9IFt7XG4gICAgICAgIF9sZXZlbDogcGFyYWdyYXBoLmxldmVsLFxuICAgICAgICBfb3ZlcnJpZGU6IDAsIC8vMD1uZXV0cmFsLCAxPUwsIDI9UlxuICAgICAgICBfaXNvbGF0ZTogMCAvL2Jvb2xcbiAgICAgIH1dO1xuICAgICAgdmFyIHN0YWNrVG9wID0gKHZvaWQgMCk7XG4gICAgICB2YXIgb3ZlcmZsb3dJc29sYXRlQ291bnQgPSAwO1xuICAgICAgdmFyIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPSAwO1xuICAgICAgdmFyIHZhbGlkSXNvbGF0ZUNvdW50ID0gMDtcbiAgICAgIGNoYXJUeXBlQ291bnRzLmNsZWFyKCk7XG5cbiAgICAgIC8vID09PSAzLjMuMiBFeHBsaWNpdCBMZXZlbHMgYW5kIERpcmVjdGlvbnMgPT09XG4gICAgICBmb3IgKHZhciBpJDIgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMiA8PSBwYXJhZ3JhcGguZW5kOyBpJDIrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaSQyXTtcbiAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBjb3VudHNcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KGNoYXJUeXBlLCAoY2hhclR5cGVDb3VudHMuZ2V0KGNoYXJUeXBlKSB8fCAwKSArIDEpO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgfHwgMCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGxpY2l0IEVtYmVkZGluZ3M6IDMuMy4yIFgyIC0gWDNcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgRk9STUFUVElOR19UWVBFUykgeyAvL3ByZWZpbHRlciBhbGwgZm9ybWF0dGVyc1xuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIChUWVBFX1JMRSB8IFRZUEVfTFJFKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxFID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvdmVyZmxvd0lzb2xhdGVDb3VudCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhwbGljaXQgT3ZlcnJpZGVzOiAzLjMuMiBYNCAtIFg1XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiAoVFlQRV9STE8gfCBUWVBFX0xSTykpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgdmFyIGxldmVsJDEgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxPID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsJDEgPD0gTUFYX0RFUFRIICYmICFvdmVyZmxvd0lzb2xhdGVDb3VudCAmJiAhb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCkge1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsJDEsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAoY2hhclR5cGUgJiBUWVBFX1JMTykgPyBUWVBFX1IgOiBUWVBFX0wsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvdmVyZmxvd0lzb2xhdGVDb3VudCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSXNvbGF0ZXM6IDMuMy4yIFg1YSAtIFg1Y1xuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgICAvLyBYNWMgLSBGU0kgYmVjb21lcyBlaXRoZXIgUkxJIG9yIExSSVxuICAgICAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9GU0kpIHtcbiAgICAgICAgICAgICAgY2hhclR5cGUgPSBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbChpJDIgKyAxLCB0cnVlKSA9PT0gMSA/IFRZUEVfUkxJIDogVFlQRV9MUkk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZXZlbCQyID0gKGNoYXJUeXBlID09PSBUWVBFX1JMSSA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCQyIDw9IE1BWF9ERVBUSCAmJiBvdmVyZmxvd0lzb2xhdGVDb3VudCA9PT0gMCAmJiBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhbGlkSXNvbGF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwkMixcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDEsXG4gICAgICAgICAgICAgICAgX2lzb2xJbml0SW5kZXg6IGkkMlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93SXNvbGF0ZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGVybWluYXRpbmcgSXNvbGF0ZXM6IDMuMy4yIFg2YVxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd0lzb2xhdGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dJc29sYXRlQ291bnQtLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWRJc29sYXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoIXN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdLl9pc29sYXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWRkIHRvIGlzb2xhdGlvbiBwYWlycyBiaWRpcmVjdGlvbmFsIG1hcHBpbmc6XG4gICAgICAgICAgICAgIHZhciBpc29sSW5pdEluZGV4ID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV0uX2lzb2xJbml0SW5kZXg7XG4gICAgICAgICAgICAgIGlmIChpc29sSW5pdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpc29sYXRpb25QYWlycy5zZXQoaXNvbEluaXRJbmRleCwgaSQyKTtcbiAgICAgICAgICAgICAgICBpc29sYXRpb25QYWlycy5zZXQoaSQyLCBpc29sSW5pdEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgdmFsaWRJc29sYXRlQ291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAvLyBUZXJtaW5hdGluZyBFbWJlZGRpbmdzIGFuZCBPdmVycmlkZXM6IDMuMy4yIFg3XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX1BERikge1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93SXNvbGF0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQtLTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RhY2tUb3AuX2lzb2xhdGUgJiYgc3RhdHVzU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuZCBvZiBQYXJhZ3JhcGg6IDMuMy4yIFg4XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX0IpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9uLWZvcm1hdHRpbmcgY2hhcmFjdGVyczogMy4zLjIgWDZcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIGV4Y2x1c2lvbiBvZiBCTiBzZWVtcyB0byBnbyBhZ2FpbnN0IHdoYXQgc2VjdGlvbiA1LjIgc2F5cywgYnV0IGlzIHJlcXVpcmVkIGZvciB0ZXN0IHBhc3NhZ2VcbiAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlICYmIGNoYXJUeXBlICE9PSBUWVBFX0JOKSB7XG4gICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vID09PSAzLjMuMyBQcmVwYXJhdGlvbnMgZm9yIEltcGxpY2l0IFByb2Nlc3NpbmcgPT09XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgUkxFLCBMUkUsIFJMTywgTFJPLCBQREYsIGFuZCBCTiBjaGFyYWN0ZXJzOiAzLjMuMyBYOVxuICAgICAgLy8gTm90ZTogRHVlIHRvIHNlY3Rpb24gNS4yLCB3ZSB3b24ndCByZW1vdmUgdGhlbSwgYnV0IHdlJ2xsIHVzZSB0aGUgQk5fTElLRV9UWVBFUyBiaXRzZXQgdG9cbiAgICAgIC8vIGVhc2lseSBpZ25vcmUgdGhlbSBhbGwgZnJvbSBoZXJlIG9uIG91dC5cblxuICAgICAgLy8gMy4zLjMgWDEwXG4gICAgICAvLyBDb21wdXRlIHRoZSBzZXQgb2YgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZXMgYXMgc3BlY2lmaWVkIGJ5IEJEMTNcbiAgICAgIHZhciBsZXZlbFJ1bnMgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UnVuID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkkMyA9IHBhcmFncmFwaC5zdGFydDsgaSQzIDw9IHBhcmFncmFwaC5lbmQ7IGkkMysrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSQxID0gY2hhclR5cGVzW2kkM107XG4gICAgICAgIGlmICghKGNoYXJUeXBlJDEgJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgIHZhciBsdmwgPSBlbWJlZExldmVsc1tpJDNdO1xuICAgICAgICAgIHZhciBpc0lzb2xJbml0ID0gY2hhclR5cGUkMSAmIElTT0xBVEVfSU5JVF9UWVBFUztcbiAgICAgICAgICB2YXIgaXNQREkgPSBjaGFyVHlwZSQxID09PSBUWVBFX1BESTtcbiAgICAgICAgICBpZiAoY3VycmVudFJ1biAmJiBsdmwgPT09IGN1cnJlbnRSdW4uX2xldmVsKSB7XG4gICAgICAgICAgICBjdXJyZW50UnVuLl9lbmQgPSBpJDM7XG4gICAgICAgICAgICBjdXJyZW50UnVuLl9lbmRzV2l0aElzb2xJbml0ID0gaXNJc29sSW5pdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWxSdW5zLnB1c2goY3VycmVudFJ1biA9IHtcbiAgICAgICAgICAgICAgX3N0YXJ0OiBpJDMsXG4gICAgICAgICAgICAgIF9lbmQ6IGkkMyxcbiAgICAgICAgICAgICAgX2xldmVsOiBsdmwsXG4gICAgICAgICAgICAgIF9zdGFydHNXaXRoUERJOiBpc1BESSxcbiAgICAgICAgICAgICAgX2VuZHNXaXRoSXNvbEluaXQ6IGlzSXNvbEluaXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlzb2xhdGluZ1J1blNlcXMgPSBbXTsgLy8gW3tzZXFJbmRpY2VzOiBbXSwgc29zVHlwZTogTHxSLCBlb3NUeXBlOiBMfFJ9XVxuICAgICAgZm9yICh2YXIgcnVuSWR4ID0gMDsgcnVuSWR4IDwgbGV2ZWxSdW5zLmxlbmd0aDsgcnVuSWR4KyspIHtcbiAgICAgICAgdmFyIHJ1biA9IGxldmVsUnVuc1tydW5JZHhdO1xuICAgICAgICBpZiAoIXJ1bi5fc3RhcnRzV2l0aFBESSB8fCAocnVuLl9zdGFydHNXaXRoUERJICYmICFpc29sYXRpb25QYWlycy5oYXMocnVuLl9zdGFydCkpKSB7XG4gICAgICAgICAgdmFyIHNlcVJ1bnMgPSBbY3VycmVudFJ1biA9IHJ1bl07XG4gICAgICAgICAgZm9yICh2YXIgcGRpSW5kZXggPSAodm9pZCAwKTsgY3VycmVudFJ1biAmJiBjdXJyZW50UnVuLl9lbmRzV2l0aElzb2xJbml0ICYmIChwZGlJbmRleCA9IGlzb2xhdGlvblBhaXJzLmdldChjdXJyZW50UnVuLl9lbmQpKSAhPSBudWxsOykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gcnVuSWR4ICsgMTsgaSQ0IDwgbGV2ZWxSdW5zLmxlbmd0aDsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsUnVuc1tpJDRdLl9zdGFydCA9PT0gcGRpSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzZXFSdW5zLnB1c2goY3VycmVudFJ1biA9IGxldmVsUnVuc1tpJDRdKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGJ1aWxkIGZsYXQgbGlzdCBvZiBpbmRpY2VzIGFjcm9zcyBhbGwgcnVuczpcbiAgICAgICAgICB2YXIgc2VxSW5kaWNlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IHNlcVJ1bnMubGVuZ3RoOyBpJDUrKykge1xuICAgICAgICAgICAgdmFyIHJ1biQxID0gc2VxUnVuc1tpJDVdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJ1biQxLl9zdGFydDsgaiA8PSBydW4kMS5fZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgc2VxSW5kaWNlcy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNvcy9lb3MgdHlwZXM6XG4gICAgICAgICAgdmFyIGZpcnN0TGV2ZWwgPSBlbWJlZExldmVsc1tzZXFJbmRpY2VzWzBdXTtcbiAgICAgICAgICB2YXIgcHJldkxldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIGZvciAodmFyIGkkNiA9IHNlcUluZGljZXNbMF0gLSAxOyBpJDYgPj0gMDsgaSQ2LS0pIHtcbiAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tpJDZdICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgcHJldkxldmVsID0gZW1iZWRMZXZlbHNbaSQ2XTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHNlcUluZGljZXNbc2VxSW5kaWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgbGFzdExldmVsID0gZW1iZWRMZXZlbHNbbGFzdEluZGV4XTtcbiAgICAgICAgICB2YXIgbmV4dExldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tsYXN0SW5kZXhdICYgSVNPTEFURV9JTklUX1RZUEVTKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ3ID0gbGFzdEluZGV4ICsgMTsgaSQ3IDw9IHBhcmFncmFwaC5lbmQ7IGkkNysrKSB7XG4gICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tpJDddICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSBlbWJlZExldmVsc1tpJDddO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNvbGF0aW5nUnVuU2Vxcy5wdXNoKHtcbiAgICAgICAgICAgIF9zZXFJbmRpY2VzOiBzZXFJbmRpY2VzLFxuICAgICAgICAgICAgX3Nvc1R5cGU6IE1hdGgubWF4KHByZXZMZXZlbCwgZmlyc3RMZXZlbCkgJSAyID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgX2Vvc1R5cGU6IE1hdGgubWF4KG5leHRMZXZlbCwgbGFzdExldmVsKSAlIDIgPyBUWVBFX1IgOiBUWVBFX0xcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbmV4dCBzdGVwcyBhcmUgZG9uZSBwZXIgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgICAgZm9yICh2YXIgc2VxSWR4ID0gMDsgc2VxSWR4IDwgaXNvbGF0aW5nUnVuU2Vxcy5sZW5ndGg7IHNlcUlkeCsrKSB7XG4gICAgICAgIHZhciByZWYgPSBpc29sYXRpbmdSdW5TZXFzW3NlcUlkeF07XG4gICAgICAgIHZhciBzZXFJbmRpY2VzJDEgPSByZWYuX3NlcUluZGljZXM7XG4gICAgICAgIHZhciBzb3NUeXBlID0gcmVmLl9zb3NUeXBlO1xuICAgICAgICB2YXIgZW9zVHlwZSA9IHJlZi5fZW9zVHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCB0aGUgbGV2ZWwgcnVucyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIGhhdmUgdGhlIHNhbWUgZW1iZWRkaW5nIGxldmVsLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRE8gTk9UIGNoYW5nZSBhbnkgYGVtYmVkTGV2ZWxzW2ldYCB3aXRoaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZW1iZWREaXJlY3Rpb24gPSAoKGVtYmVkTGV2ZWxzW3NlcUluZGljZXMkMVswXV0pICYgMSkgPyBUWVBFX1IgOiBUWVBFX0w7XG5cbiAgICAgICAgLy8gPT09IDMuMy40IFJlc29sdmluZyBXZWFrIFR5cGVzID09PVxuXG4gICAgICAgIC8vIFcxICsgNS4yLiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIE5TTSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIHdob3NlXG4gICAgICAgIC8vIGJpZGlyZWN0aW9uYWwgdHlwZSBpcyBub3QgQk4sIGFuZCBzZXQgdGhlIE5TTSB0byBPTiBpZiBpdCBpcyBhbiBpc29sYXRlIGluaXRpYXRvciBvciBQREksIGFuZCB0byBpdHNcbiAgICAgICAgLy8gdHlwZSBvdGhlcndpc2UuIElmIHRoZSBOU00gaXMgdGhlIGZpcnN0IG5vbi1CTiBjaGFyYWN0ZXIsIGNoYW5nZSB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHNvcy5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX05TTSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2krKykge1xuICAgICAgICAgICAgdmFyIGkkOCA9IHNlcUluZGljZXMkMVtzaV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOF0gJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUgPSBzb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiA9IHNpIC0gMTsgc2ogPj0gMDsgc2otLSkge1xuICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2pdXSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yIHNjYW4gYmFjayB0byBmaXJzdCBub24tQk5cbiAgICAgICAgICAgICAgICAgIHByZXZUeXBlID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzal1dO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQ4LCAocHJldlR5cGUgJiAoSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRV9QREkpKSA/IFRZUEVfT04gOiBwcmV2VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29zKVxuICAgICAgICAvLyBpcyBmb3VuZC4gSWYgYW4gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpYyBudW1iZXIuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQxID0gMDsgc2kkMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDErKykge1xuICAgICAgICAgICAgdmFyIGkkOSA9IHNlcUluZGljZXMkMVtzaSQxXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQ5XSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMSA9IHNpJDEgLSAxOyBzaiQxID49IC0xOyBzaiQxLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNoYXJUeXBlID0gc2okMSA9PT0gLTEgPyBzb3NUeXBlIDogY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQxXV07XG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGFyVHlwZSAmIFNUUk9OR19UWVBFUykge1xuICAgICAgICAgICAgICAgICAgaWYgKHByZXZDaGFyVHlwZSA9PT0gVFlQRV9BTCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDksIFRZUEVfQU4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQUwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMiA9IDA7IHNpJDIgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQyKyspIHtcbiAgICAgICAgICAgIHZhciBpJDEwID0gc2VxSW5kaWNlcyQxW3NpJDJdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEwXSAmIFRZUEVfQUwpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMCwgVFlQRV9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnMgY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uXG4gICAgICAgIC8vIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FUykgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQ1MpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMyA9IDE7IHNpJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoIC0gMTsgc2kkMysrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMSA9IHNlcUluZGljZXMkMVtzaSQzXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMV0gJiAoVFlQRV9FUyB8IFRZUEVfQ1MpKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQxID0gMCwgbmV4dFR5cGUgPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQyID0gc2kkMyAtIDE7IHNqJDIgPj0gMDsgc2okMi0tKSB7XG4gICAgICAgICAgICAgICAgcHJldlR5cGUkMSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okMl1dO1xuICAgICAgICAgICAgICAgIGlmICghKHByZXZUeXBlJDEgJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMyA9IHNpJDMgKyAxOyBzaiQzIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2okMysrKSB7XG4gICAgICAgICAgICAgICAgbmV4dFR5cGUgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDNdXTtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXh0VHlwZSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJldlR5cGUkMSA9PT0gbmV4dFR5cGUgJiYgKGNoYXJUeXBlc1tpJDExXSA9PT0gVFlQRV9FUyA/IHByZXZUeXBlJDEgPT09IFRZUEVfRU4gOiAocHJldlR5cGUkMSAmIChUWVBFX0VOIHwgVFlQRV9BTikpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTEsIHByZXZUeXBlJDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW4gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNCA9IDA7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ0KyspIHtcbiAgICAgICAgICAgIHZhciBpJDEyID0gc2VxSW5kaWNlcyQxW3NpJDRdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEyXSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNCA9IHNpJDQgLSAxOyBzaiQ0ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNF1dICYgKFRZUEVfRVQgfCBCTl9MSUtFX1RZUEVTKSk7IHNqJDQtLSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ0XSwgVFlQRV9FTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChzaSQ0Kys7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDRdXSAmIChUWVBFX0VUIHwgQk5fTElLRV9UWVBFUyB8IFRZUEVfRU4pKTsgc2kkNCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkNF1dICE9PSBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2kkNF0sIFRZUEVfRU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlciBOZXV0cmFsLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVQpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VTKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9DUykpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ1ID0gMDsgc2kkNSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDUrKykge1xuICAgICAgICAgICAgdmFyIGkkMTMgPSBzZXFJbmRpY2VzJDFbc2kkNV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTNdICYgKFRZUEVfRVQgfCBUWVBFX0VTIHwgVFlQRV9DUykpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMywgVFlQRV9PTik7XG4gICAgICAgICAgICAgIC8vIDUuMiB0cmFuc2Zvcm0gYWRqYWNlbnQgQk5zIHRvbzpcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNSA9IHNpJDUgLSAxOyBzaiQ1ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNV1dICYgQk5fTElLRV9UWVBFUyk7IHNqJDUtLSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ1XSwgVFlQRV9PTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNiA9IHNpJDUgKyAxOyBzaiQ2IDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ2XV0gJiBCTl9MSUtFX1RZUEVTKTsgc2okNisrKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDZdLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29zKVxuICAgICAgICAvLyBpcyBmb3VuZC4gSWYgYW4gTCBpcyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyBOT1RFOiBpbXBsZW1lbnRlZCBpbiBzaW5nbGUgZm9yd2FyZCBwYXNzIGZvciBlZmZpY2llbmN5XG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ2ID0gMCwgcHJldlN0cm9uZ1R5cGUgPSBzb3NUeXBlOyBzaSQ2IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNisrKSB7XG4gICAgICAgICAgICB2YXIgaSQxNCA9IHNlcUluZGljZXMkMVtzaSQ2XTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hhclR5cGVzW2kkMTRdO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2U3Ryb25nVHlwZSA9PT0gVFlQRV9MKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxNCwgVFlQRV9MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICYgU1RST05HX1RZUEVTKSB7XG4gICAgICAgICAgICAgIHByZXZTdHJvbmdUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA9PT0gMy4zLjUgUmVzb2x2aW5nIE5ldXRyYWwgYW5kIElzb2xhdGUgRm9ybWF0dGluZyBUeXBlcyA9PT1cblxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykpIHtcbiAgICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2Ugc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0XG4gICAgICAgICAgLy8gcG9zaXRpb25zIG9mIHRoZSBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzIHNjb3BlLCBiaWRpcmVjdGlvbmFsXG4gICAgICAgICAgLy8gdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgICAgdmFyIFJfVFlQRVNfRk9SX05fU1RFUFMgPSAoVFlQRV9SIHwgVFlQRV9FTiB8IFRZUEVfQU4pO1xuICAgICAgICAgIHZhciBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMgPSBSX1RZUEVTX0ZPUl9OX1NURVBTIHwgVFlQRV9MO1xuXG4gICAgICAgICAgLy8gKiBJZGVudGlmeSB0aGUgYnJhY2tldCBwYWlycyBpbiB0aGUgY3VycmVudCBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIGFjY29yZGluZyB0byBCRDE2LlxuICAgICAgICAgIHZhciBicmFja2V0UGFpcnMgPSBbXTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3BlbmVyU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDcgPSAwOyBzaSQ3IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNysrKSB7XG4gICAgICAgICAgICAgIC8vIE5PVEU6IGZvciBhbnkgcG90ZW50aWFsIGJyYWNrZXQgY2hhcmFjdGVyIHdlIGFsc28gdGVzdCB0aGF0IGl0IHN0aWxsIGNhcnJpZXMgYSBOSVxuICAgICAgICAgICAgICAvLyB0eXBlLCBhcyB0aGF0IG1heSBoYXZlIGJlZW4gY2hhbmdlZCBlYXJsaWVyLiBUaGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSBleHBsaWNpdGx5XG4gICAgICAgICAgICAgIC8vIGNhbGxlZCBvdXQgaW4gdGhlIHNwZWMsIGJ1dCBpcyByZXF1aXJlZCBmb3IgcGFzc2FnZSBvZiBjZXJ0YWluIHRlc3RzLlxuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ3XV0gJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkN11dO1xuICAgICAgICAgICAgICAgIHZhciBvcHBvc2l0ZUJyYWNrZXQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAvLyBPcGVuaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBpZiAob3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQoY2hhcikgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJTdGFjay5sZW5ndGggPCA2Mykge1xuICAgICAgICAgICAgICAgICAgICBvcGVuZXJTdGFjay5wdXNoKHsgY2hhcjogY2hhciwgc2VxSW5kZXg6IHNpJDcgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgob3Bwb3NpdGVCcmFja2V0ID0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQoY2hhcikpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBzdGFja0lkeCA9IG9wZW5lclN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSWR4ID49IDA7IHN0YWNrSWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrQ2hhciA9IG9wZW5lclN0YWNrW3N0YWNrSWR4XS5jaGFyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tDaGFyID09PSBvcHBvc2l0ZUJyYWNrZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFja0NoYXIgPT09IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0KGdldENhbm9uaWNhbEJyYWNrZXQoY2hhcikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQoZ2V0Q2Fub25pY2FsQnJhY2tldChzdGFja0NoYXIpKSA9PT0gY2hhclxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmFja2V0UGFpcnMucHVzaChbb3BlbmVyU3RhY2tbc3RhY2tJZHhdLnNlcUluZGV4LCBzaSQ3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlbmVyU3RhY2subGVuZ3RoID0gc3RhY2tJZHg7IC8vcG9wIHRoZSBtYXRjaGluZyBicmFja2V0IGFuZCBhbGwgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJhY2tldFBhaXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKiBGb3IgZWFjaCBicmFja2V0LXBhaXIgZWxlbWVudCBpbiB0aGUgbGlzdCBvZiBwYWlycyBvZiB0ZXh0IHBvc2l0aW9uc1xuICAgICAgICAgIGZvciAodmFyIHBhaXJJZHggPSAwOyBwYWlySWR4IDwgYnJhY2tldFBhaXJzLmxlbmd0aDsgcGFpcklkeCsrKSB7XG4gICAgICAgICAgICB2YXIgcmVmJDEgPSBicmFja2V0UGFpcnNbcGFpcklkeF07XG4gICAgICAgICAgICB2YXIgb3BlblNlcUlkeCA9IHJlZiQxWzBdO1xuICAgICAgICAgICAgdmFyIGNsb3NlU2VxSWR4ID0gcmVmJDFbMV07XG4gICAgICAgICAgICAvLyBhLiBJbnNwZWN0IHRoZSBiaWRpcmVjdGlvbmFsIHR5cGVzIG9mIHRoZSBjaGFyYWN0ZXJzIGVuY2xvc2VkIHdpdGhpbiB0aGUgYnJhY2tldCBwYWlyLlxuICAgICAgICAgICAgLy8gYi4gSWYgYW55IHN0cm9uZyB0eXBlIChlaXRoZXIgTCBvciBSKSBtYXRjaGluZyB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbiBpcyBmb3VuZCwgc2V0IHRoZSB0eXBlIGZvciBib3RoXG4gICAgICAgICAgICAvLyBicmFja2V0cyBpbiB0aGUgcGFpciB0byBtYXRjaCB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIHZhciBmb3VuZFN0cm9uZ1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB1c2VTdHJvbmdUeXBlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDggPSBvcGVuU2VxSWR4ICsgMTsgc2kkOCA8IGNsb3NlU2VxSWR4OyBzaSQ4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGkkMTUgPSBzZXFJbmRpY2VzJDFbc2kkOF07XG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxNV0gJiBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMpIHtcbiAgICAgICAgICAgICAgICBmb3VuZFN0cm9uZ1R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBsciA9IChjaGFyVHlwZXNbaSQxNV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICBpZiAobHIgPT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gbHI7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYy4gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhIHN0cm9uZyB0eXBlIGl0IG11c3QgYmUgb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uIFRoZXJlZm9yZSwgdGVzdFxuICAgICAgICAgICAgLy8gZm9yIGFuIGVzdGFibGlzaGVkIGNvbnRleHQgd2l0aCBhIHByZWNlZGluZyBzdHJvbmcgdHlwZSBieSBjaGVja2luZyBiYWNrd2FyZHMgYmVmb3JlIHRoZSBvcGVuaW5nIHBhaXJlZFxuICAgICAgICAgICAgLy8gYnJhY2tldCB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKEwsIFIsIG9yIHNvcykgaXMgZm91bmQuXG4gICAgICAgICAgICAvLyAgICAxLiBJZiB0aGUgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGlzIGFsc28gb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24sIGNvbnRleHQgaXMgZXN0YWJsaXNoZWQsIHNvXG4gICAgICAgICAgICAvLyAgICBzZXQgdGhlIHR5cGUgZm9yIGJvdGggYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gdGhhdCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAvLyAgICAyLiBPdGhlcndpc2Ugc2V0IHRoZSB0eXBlIGZvciBib3RoIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvdW5kU3Ryb25nVHlwZSAmJiAhdXNlU3Ryb25nVHlwZSkge1xuICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gc29zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kkOSA9IG9wZW5TZXFJZHggLSAxOyBzaSQ5ID49IDA7IHNpJDktLSkge1xuICAgICAgICAgICAgICAgIHZhciBpJDE2ID0gc2VxSW5kaWNlcyQxW3NpJDldO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxNl0gJiBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsciQxID0gKGNoYXJUeXBlc1tpJDE2XSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgaWYgKGxyJDEgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBsciQxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlKSB7XG4gICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbb3BlblNlcUlkeF1dID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtjbG9zZVNlcUlkeF1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgLy8gKiBBbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBoYWQgb3JpZ2luYWwgYmlkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgdHlwZSBOU00gcHJpb3IgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgIC8vIG9mIFcxIHRoYXQgaW1tZWRpYXRlbHkgZm9sbG93IGEgcGFpcmVkIGJyYWNrZXQgd2hpY2ggY2hhbmdlZCB0byBMIG9yIFIgdW5kZXIgTjAgc2hvdWxkIGNoYW5nZSB0byBtYXRjaFxuICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBvZiB0aGVpciBwcmVjZWRpbmcgYnJhY2tldC5cbiAgICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kkMTAgPSBvcGVuU2VxSWR4ICsgMTsgc2kkMTAgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMCsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEwXV0gJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkMTBdXSkgJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kkMTEgPSBjbG9zZVNlcUlkeCArIDE7IHNpJDExIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTErKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMV1dICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDExXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDExXV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgTklzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZGlyZWN0aW9uLlxuICAgICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIE5JcyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgIGZvciAodmFyIHNpJDEyID0gMDsgc2kkMTIgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMisrKSB7XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMl1dICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgICAgIHZhciBuaVJ1blN0YXJ0ID0gc2kkMTIsIG5pUnVuRW5kID0gc2kkMTI7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQyID0gc29zVHlwZTsgLy9zaSA9PT0gMCA/IHNvc1R5cGUgOiAoY2hhclR5cGVzW3NlcUluZGljZXNbc2kgLSAxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgICAgICBmb3IgKHZhciBzaTIgPSBzaSQxMiAtIDE7IHNpMiA+PSAwOyBzaTItLSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMl1dICYgQk5fTElLRV9UWVBFUykge1xuICAgICAgICAgICAgICAgICAgbmlSdW5TdGFydCA9IHNpMjsgLy81LjIgdHJlYXQgQk5zIGFkamFjZW50IHRvIE5JcyBhcyBOSXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJldlR5cGUkMiA9IChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMl1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmV4dFR5cGUkMSA9IGVvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNpMiQxID0gc2kkMTIgKyAxOyBzaTIkMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpMiQxKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTIkMV1dICYgKE5FVVRSQUxfSVNPTEFURV9UWVBFUyB8IEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICBuaVJ1bkVuZCA9IHNpMiQxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0VHlwZSQxID0gKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyJDFdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNyA9IG5pUnVuU3RhcnQ7IHNqJDcgPD0gbmlSdW5FbmQ7IHNqJDcrKykge1xuICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okN11dID0gcHJldlR5cGUkMiA9PT0gbmV4dFR5cGUkMSA/IHByZXZUeXBlJDIgOiBlbWJlZERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzaSQxMiA9IG5pUnVuRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA9PT0gMy4zLjYgUmVzb2x2aW5nIEltcGxpY2l0IExldmVscyA9PT1cblxuICAgICAgZm9yICh2YXIgaSQxNyA9IHBhcmFncmFwaC5zdGFydDsgaSQxNyA8PSBwYXJhZ3JhcGguZW5kOyBpJDE3KyspIHtcbiAgICAgICAgdmFyIGxldmVsJDMgPSBlbWJlZExldmVsc1tpJDE3XTtcbiAgICAgICAgdmFyIHR5cGUkMSA9IGNoYXJUeXBlc1tpJDE3XTtcbiAgICAgICAgLy8gSTIuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIG9kZCAocmlnaHQtdG8tbGVmdCkgZW1iZWRkaW5nIGxldmVsLCB0aG9zZSBvZiB0eXBlIEwsIEVOIG9yIEFOIGdvIHVwIG9uZSBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsJDMgJiAxKSB7XG4gICAgICAgICAgaWYgKHR5cGUkMSAmIChUWVBFX0wgfCBUWVBFX0VOIHwgVFlQRV9BTikpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgLy8gSTEuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIGV2ZW4gKGxlZnQtdG8tcmlnaHQpIGVtYmVkZGluZyBsZXZlbCwgdGhvc2Ugb2YgdHlwZSBSIGdvIHVwIG9uZSBsZXZlbFxuICAgICAgICAvLyBhbmQgdGhvc2Ugb2YgdHlwZSBBTiBvciBFTiBnbyB1cCB0d28gbGV2ZWxzLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZSQxICYgVFlQRV9SKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQxICYgKFRZUEVfQU4gfCBUWVBFX0VOKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10gKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjI6IFJlc29sdmUgYW55IExSRSwgUkxFLCBMUk8sIFJMTywgUERGLCBvciBCTiB0byB0aGUgbGV2ZWwgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgaWYgdGhlcmUgaXMgb25lLFxuICAgICAgICAvLyBhbmQgb3RoZXJ3aXNlIHRvIHRoZSBiYXNlIGxldmVsLlxuICAgICAgICBpZiAodHlwZSQxICYgQk5fTElLRV9UWVBFUykge1xuICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddID0gaSQxNyA9PT0gMCA/IHBhcmFncmFwaC5sZXZlbCA6IGVtYmVkTGV2ZWxzW2kkMTcgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuNCBMMS4xLTQ6IFJlc2V0IHRoZSBlbWJlZGRpbmcgbGV2ZWwgb2Ygc2VnbWVudC9wYXJhZ3JhcGggc2VwYXJhdG9ycywgYW5kIGFueSBzZXF1ZW5jZSBvZiB3aGl0ZXNwYWNlIG9yXG4gICAgICAgIC8vIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGVtIG9yIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaCwgdG8gdGhlIHBhcmFncmFwaCBsZXZlbC5cbiAgICAgICAgLy8gTk9URTogdGhpcyB3aWxsIGFsc28gbmVlZCB0byBiZSBhcHBsaWVkIHRvIGVhY2ggaW5kaXZpZHVhbCBsaW5lIGVuZGluZyBhZnRlciBsaW5lIHdyYXBwaW5nIG9jY3Vycy5cbiAgICAgICAgaWYgKGkkMTcgPT09IHBhcmFncmFwaC5lbmQgfHwgZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpJDE3XSkgJiAoVFlQRV9TIHwgVFlQRV9CKSkge1xuICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkMTc7IGokMSA+PSAwICYmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2okMV0pICYgVFJBSUxJTkdfVFlQRVMpOyBqJDEtLSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaiQxXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBET05FISBUaGUgcmVzb2x2ZWQgbGV2ZWxzIGNhbiB0aGVuIGJlIHVzZWQsIGFmdGVyIGxpbmUgd3JhcHBpbmcsIHRvIGZsaXAgcnVucyBvZiBjaGFyYWN0ZXJzXG4gICAgLy8gYWNjb3JkaW5nIHRvIHNlY3Rpb24gMy40IFJlb3JkZXJpbmcgUmVzb2x2ZWQgTGV2ZWxzXG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogZW1iZWRMZXZlbHMsXG4gICAgICBwYXJhZ3JhcGhzOiBwYXJhZ3JhcGhzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwgKHN0YXJ0LCBpc0ZTSSkge1xuICAgICAgLy8gMy4zLjEgUDIgLSBQM1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgKFRZUEVfUiB8IFRZUEVfQUwpKSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNoYXJUeXBlICYgKFRZUEVfQiB8IFRZUEVfTCkpIHx8IChpc0ZTSSAmJiBjaGFyVHlwZSA9PT0gVFlQRV9QREkpKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICB2YXIgcGRpID0gaW5kZXhPZk1hdGNoaW5nUERJKGkpO1xuICAgICAgICAgIGkgPSBwZGkgPT09IC0xID8gc3RyaW5nLmxlbmd0aCA6IHBkaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleE9mTWF0Y2hpbmdQREkgKGlzb2xhdGVTdGFydCkge1xuICAgICAgLy8gMy4xLjIgQkQ5XG4gICAgICB2YXIgaXNvbGF0aW9uTGV2ZWwgPSAxO1xuICAgICAgZm9yICh2YXIgaSA9IGlzb2xhdGVTdGFydCArIDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX0IpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfUERJKSB7XG4gICAgICAgICAgaWYgKC0taXNvbGF0aW9uTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgaXNvbGF0aW9uTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICB9XG5cbiAgLy8gQmlkaSBtaXJyb3JlZCBjaGFycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgZGF0YSA9IFwiMTQ+MSxqPjIsdD4yLHU+MiwxYT5nLDJ2Mz4xLDE+MSwxZ2U+MSwxd2Q+MSxiPjEsMWo+MSxmPjEsYWk+MywtMj4zLCsxLDg+MWswLC0xanE+MXk3LC0xeTY+MWhmLC0xaGU+MWg2LC0xaDU+MWhhLC0xaDg+MXFpLC0xcHU+MSw2PjN1LC0zcz43LDY+MSwxPjEsZj4xLDE+MSwrMiwzPjEsMT4xLCsxMyw0PjEsMT4xLDY+MWVvLC0xZWU+MSwzPjFtZywtMW1lPjFtaywtMW1qPjFtaSwtMW1nPjFtaSwtMW1kPjEsMT4xLCsyLDE+MTBrLC0xMDM+MSwxPjEsND4xLDU+MSwxPjEsKzEwLDM+MSwxPjgsLTc+OCwrMSwtNj43LCsxLGE+MSwxPjEsdT4xLHU2PjEsMT4xLCs1LDI2PjEsMT4xLDI+MSwyPjIsOD4xLDc+MSw0PjEsMT4xLCs1LGI4PjEsMT4xLCszLDE+MywtMj4xLDI+MSwxPjEsKzIsYz4xLDM+MSwxPjEsKzIsaD4xLDM+MSxhPjEsMT4xLDI+MSwzPjEsMT4xLGQ+MSxmPjEsMz4xLDFhPjEsMT4xLDY+MSw3PjEsMTM+MSxrPjEsMT4xLCsxOSw0PjEsMT4xLCsyLDI+MSwxPjEsKzE4LG0+MSxhPjEsMT4xLGxrPjEsMT4xLDQ+MSwyPjEsZj4xLDM+MSwxPjEsKzMsZGI+MSwxPjEsKzMsMz4xLDE+MSwrMiwxNHFtPjEsMT4xLCsxLDY+MSw0aj4xLGo+Mix0PjIsdT4yLDI+MSwrMVwiO1xuXG4gIHZhciBtaXJyb3JNYXA7XG5cbiAgZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgIGlmICghbWlycm9yTWFwKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHZhciByZWYgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhLCB0cnVlKTtcbiAgICAgIHZhciBtYXAgPSByZWYubWFwO1xuICAgICAgdmFyIHJldmVyc2VNYXAgPSByZWYucmV2ZXJzZU1hcDtcbiAgICAgIC8vIENvbWJpbmUgYm90aCBtYXBzIGludG8gb25lXG4gICAgICByZXZlcnNlTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbWlycm9yTWFwID0gbWFwO1xuICAgICAgLy9jb25zb2xlLmxvZyhgbWlycm9yZWQgY2hhcnMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWlycm9yZWRDaGFyYWN0ZXIgKGNoYXIpIHtcbiAgICBwYXJzZSgpO1xuICAgIHJldHVybiBtaXJyb3JNYXAuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHN0cmluZyBhbmQgaXRzIHJlc29sdmVkIGVtYmVkZGluZyBsZXZlbHMsIGJ1aWxkIGEgbWFwIG9mIGluZGljZXMgdG8gcmVwbGFjZW1lbnQgY2hhcnNcbiAgICogZm9yIGFueSBjaGFyYWN0ZXJzIGluIHJpZ2h0LXRvLWxlZnQgc2VnbWVudHMgdGhhdCBoYXZlIGRlZmluZWQgbWlycm9yZWQgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHN0cmluZ1xuICAgKiBAcGFyYW0gZW1iZWRkaW5nTGV2ZWxzXG4gICAqIEBwYXJhbSBbc3RhcnRdXG4gICAqIEBwYXJhbSBbZW5kXVxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCBzdHJpbmc+fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwKHN0cmluZywgZW1iZWRkaW5nTGV2ZWxzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCA9PSBudWxsID8gMCA6ICtzdGFydCk7XG4gICAgZW5kID0gTWF0aC5taW4oc3RyTGVuIC0gMSwgZW5kID09IG51bGwgPyBzdHJMZW4gLSAxIDogK2VuZCk7XG5cbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgaWYgKGVtYmVkZGluZ0xldmVsc1tpXSAmIDEpIHsgLy9vbmx5IG9kZCAocnRsKSBsZXZlbHNcbiAgICAgICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyKHN0cmluZ1tpXSk7XG4gICAgICAgIGlmIChtaXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBtYXAuc2V0KGksIG1pcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc3RhcnQgYW5kIGVuZCBkZW5vdGluZyBhIHNpbmdsZSBsaW5lIHdpdGhpbiBhIHN0cmluZywgYW5kIGEgc2V0IG9mIHByZWNhbGN1bGF0ZWRcbiAgICogYmlkaSBlbWJlZGRpbmcgbGV2ZWxzLCBwcm9kdWNlIGEgbGlzdCBvZiBzZWdtZW50cyB3aG9zZSBvcmRlcmluZyBzaG91bGQgYmUgZmxpcHBlZCwgaW4gc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSB0aGUgZnVsbCBpbnB1dCBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkZGluZ0xldmVsc1Jlc3VsdCAtIHRoZSByZXN1bHQgb2JqZWN0IGZyb20gZ2V0RW1iZWRkaW5nTGV2ZWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gZmlyc3QgY2hhcmFjdGVyIGluIGEgc3Vic2V0IG9mIHRoZSBmdWxsIHN0cmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gLSBsYXN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyW11bXX0gLSB0aGUgbGlzdCBvZiBzdGFydC9lbmQgc2VnbWVudHMgdGhhdCBzaG91bGQgYmUgZmxpcHBlZCwgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyU2VnbWVudHMoc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ID09IG51bGwgPyAwIDogK3N0YXJ0KTtcbiAgICBlbmQgPSBNYXRoLm1pbihzdHJMZW4gLSAxLCBlbmQgPT0gbnVsbCA/IHN0ckxlbiAtIDEgOiArZW5kKTtcblxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIGVtYmVkZGluZ0xldmVsc1Jlc3VsdC5wYXJhZ3JhcGhzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFncmFwaCkge1xuICAgICAgdmFyIGxpbmVTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBwYXJhZ3JhcGguc3RhcnQpO1xuICAgICAgdmFyIGxpbmVFbmQgPSBNYXRoLm1pbihlbmQsIHBhcmFncmFwaC5lbmQpO1xuICAgICAgaWYgKGxpbmVTdGFydCA8IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gTG9jYWwgc2xpY2UgZm9yIG11dGF0aW9uXG4gICAgICAgIHZhciBsaW5lTGV2ZWxzID0gZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LmxldmVscy5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcblxuICAgICAgICAvLyAzLjQgTDEuNDogUmVzZXQgYW55IHNlcXVlbmNlIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBhbmQvb3IgaXNvbGF0ZSBmb3JtYXR0aW5nIGNoYXJhY3RlcnMgYXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiB0aGUgbGluZSB0byB0aGUgcGFyYWdyYXBoIGxldmVsLlxuICAgICAgICBmb3IgKHZhciBpID0gbGluZUVuZDsgaSA+PSBsaW5lU3RhcnQgJiYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaV0pICYgVFJBSUxJTkdfVFlQRVMpOyBpLS0pIHtcbiAgICAgICAgICBsaW5lTGV2ZWxzW2ldID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTDIuIEZyb20gdGhlIGhpZ2hlc3QgbGV2ZWwgZm91bmQgaW4gdGhlIHRleHQgdG8gdGhlIGxvd2VzdCBvZGQgbGV2ZWwgb24gZWFjaCBsaW5lLCBpbmNsdWRpbmcgaW50ZXJtZWRpYXRlIGxldmVsc1xuICAgICAgICAvLyBub3QgYWN0dWFsbHkgcHJlc2VudCBpbiB0aGUgdGV4dCwgcmV2ZXJzZSBhbnkgY29udGlndW91cyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIGF0IHRoYXQgbGV2ZWwgb3IgaGlnaGVyLlxuICAgICAgICB2YXIgbWF4TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgIHZhciBtaW5PZGRMZXZlbCA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lTGV2ZWxzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsaW5lTGV2ZWxzW2kkMV07XG4gICAgICAgICAgaWYgKGxldmVsID4gbWF4TGV2ZWwpIHsgbWF4TGV2ZWwgPSBsZXZlbDsgfVxuICAgICAgICAgIGlmIChsZXZlbCA8IG1pbk9kZExldmVsKSB7IG1pbk9kZExldmVsID0gbGV2ZWwgfCAxOyB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbHZsID0gbWF4TGV2ZWw7IGx2bCA+PSBtaW5PZGRMZXZlbDsgbHZsLS0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBsaW5lTGV2ZWxzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lTGV2ZWxzW2kkMl0gPj0gbHZsKSB7XG4gICAgICAgICAgICAgIHZhciBzZWdTdGFydCA9IGkkMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGkkMiArIDEgPCBsaW5lTGV2ZWxzLmxlbmd0aCAmJiBsaW5lTGV2ZWxzW2kkMiArIDFdID49IGx2bCkge1xuICAgICAgICAgICAgICAgIGkkMisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpJDIgPiBzZWdTdGFydCkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW3NlZ1N0YXJ0ICsgbGluZVN0YXJ0LCBpJDIgKyBsaW5lU3RhcnRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWdtZW50c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkTGV2ZWxzUmVzdWx0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBuZXcgc3RyaW5nIHdpdGggYmlkaSBzZWdtZW50cyByZW9yZGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJlZFN0cmluZyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGluZGljZXMgPSBnZXRSZW9yZGVyZWRJbmRpY2VzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpO1xuICAgIHZhciBjaGFycyA9IFtdLmNvbmNhdCggc3RyaW5nICk7XG4gICAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFySW5kZXgsIGkpIHtcbiAgICAgIGNoYXJzW2ldID0gKFxuICAgICAgICAoZW1iZWRMZXZlbHNSZXN1bHQubGV2ZWxzW2NoYXJJbmRleF0gJiAxKSA/IGdldE1pcnJvcmVkQ2hhcmFjdGVyKHN0cmluZ1tjaGFySW5kZXhdKSA6IG51bGxcbiAgICAgICkgfHwgc3RyaW5nW2NoYXJJbmRleF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRMZXZlbHNSZXN1bHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSB3aXRoIGNoYXJhY3RlciBpbmRpY2VzIGluIHRoZWlyIG5ldyBiaWRpIG9yZGVyXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyZWRJbmRpY2VzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBnZXRSZW9yZGVyU2VnbWVudHMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCk7XG4gICAgLy8gRmlsbCBhbiBhcnJheSB3aXRoIGluZGljZXNcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgLy8gUmV2ZXJzZSBlYWNoIHNlZ21lbnQgaW4gb3JkZXJcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBzdGFydCA9IHJlZlswXTtcbiAgICAgIHZhciBlbmQgPSByZWZbMV07XG5cbiAgICAgIHZhciBzbGljZSA9IGluZGljZXMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IHNsaWNlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBpbmRpY2VzW2VuZCAtIGldID0gc2xpY2VbaV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGljZXNcbiAgfVxuXG4gIGV4cG9ydHMuY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldDtcbiAgZXhwb3J0cy5nZXRCaWRpQ2hhclR5cGUgPSBnZXRCaWRpQ2hhclR5cGU7XG4gIGV4cG9ydHMuZ2V0QmlkaUNoYXJUeXBlTmFtZSA9IGdldEJpZGlDaGFyVHlwZU5hbWU7XG4gIGV4cG9ydHMuZ2V0Q2Fub25pY2FsQnJhY2tldCA9IGdldENhbm9uaWNhbEJyYWNrZXQ7XG4gIGV4cG9ydHMuZ2V0RW1iZWRkaW5nTGV2ZWxzID0gZ2V0RW1iZWRkaW5nTGV2ZWxzO1xuICBleHBvcnRzLmdldE1pcnJvcmVkQ2hhcmFjdGVyID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXI7XG4gIGV4cG9ydHMuZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwO1xuICBleHBvcnRzLmdldFJlb3JkZXJTZWdtZW50cyA9IGdldFJlb3JkZXJTZWdtZW50cztcbiAgZXhwb3J0cy5nZXRSZW9yZGVyZWRJbmRpY2VzID0gZ2V0UmVvcmRlcmVkSW5kaWNlcztcbiAgZXhwb3J0cy5nZXRSZW9yZGVyZWRTdHJpbmcgPSBnZXRSZW9yZGVyZWRTdHJpbmc7XG4gIGV4cG9ydHMub3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQgPSBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG5yZXR1cm4gYmlkaX1cblxuZXhwb3J0IGRlZmF1bHQgYmlkaUZhY3Rvcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bidi-js/dist/bidi.mjs\n"));

/***/ }),

/***/ "./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SDFGenerator; }\n/* harmony export */ });\nfunction SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLCtDQUErQztBQUNwRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsK0NBQStDO0FBQ3BFLGFBQWEsc0RBQXNEO0FBQ25FO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtEQUFrRCxtQkFBbUIsaUJBQWlCLFlBQVksUUFBUSx5REFBeUQ7O0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxxREFBcUQ7QUFDMUUsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUSwyRkFBMkY7QUFDaEg7QUFDQSxhQUFhLFFBQVEsOEVBQThFO0FBQ25HO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQ7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dlYmdsLXNkZi1nZW5lcmF0b3IvZGlzdC93ZWJnbC1zZGYtZ2VuZXJhdG9yLm1qcz9iZTEwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNERkdlbmVyYXRvcigpIHtcbnZhciBleHBvcnRzID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcG9pbnRPblF1YWRyYXRpY0JlemllciAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdCwgcG9pbnRPdXQpIHtcbiAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHgwICsgMiAqIHQyICogdCAqIHgxICsgdCAqIHQgKiB4MjtcbiAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHkwICsgMiAqIHQyICogdCAqIHkxICsgdCAqIHQgKiB5MjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwb2ludCBvbiBhIGN1YmljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcG9pbnRPbkN1YmljQmV6aWVyICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHQsIHBvaW50T3V0KSB7XG4gICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgcG9pbnRPdXQueCA9IHQyICogdDIgKiB0MiAqIHgwICsgMyAqIHQyICogdDIgKiB0ICogeDEgKyAzICogdDIgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgcG9pbnRPdXQueSA9IHQyICogdDIgKiB0MiAqIHkwICsgMyAqIHQyICogdDIgKiB0ICogeTEgKyAzICogdDIgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBwYXRoIHN0cmluZyBpbnRvIGl0cyBjb25zdGl0dWVudCBsaW5lL2N1cnZlIGNvbW1hbmRzLCBpbnZva2luZyBhIGNhbGxiYWNrIGZvciBlYWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZyAtIEFuIFNWRy1saWtlIHBhdGggc3RyaW5nIHRvIHBhcnNlOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1pcbiAgICogQHBhcmFtIHtmdW5jdGlvbihcbiAgICogICBjb21tYW5kOiAnTCd8J1EnfCdDJyxcbiAgICogICBzdGFydFg6IG51bWJlcixcbiAgICogICBzdGFydFk6IG51bWJlcixcbiAgICogICBlbmRYOiBudW1iZXIsXG4gICAqICAgZW5kWTogbnVtYmVyLFxuICAgKiAgIGN0cmwxWD86IG51bWJlcixcbiAgICogICBjdHJsMVk/OiBudW1iZXIsXG4gICAqICAgY3RybDJYPzogbnVtYmVyLFxuICAgKiAgIGN0cmwyWT86IG51bWJlclxuICAgKiApfSBjb21tYW5kQ2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBwYXJzZWQgcGF0aCBjb21tYW5kLCBwYXNzaW5nIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIGlkZW50aWZpZXIgKG9ubHkgTC9RL0MgY29tbWFuZHMpIGFuZCBpdHMgbnVtZXJpYyBhcmd1bWVudHMuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoUGF0aENvbW1hbmQocGF0aFN0cmluZywgY29tbWFuZENhbGxiYWNrKSB7XG4gICAgdmFyIHNlZ21lbnRSRSA9IC8oW01MUUNaXSkoW15NTFFDWl0qKS9nO1xuICAgIHZhciBtYXRjaCwgZmlyc3RYLCBmaXJzdFksIHByZXZYLCBwcmV2WTtcbiAgICB3aGlsZSAoKG1hdGNoID0gc2VnbWVudFJFLmV4ZWMocGF0aFN0cmluZykpKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoWzJdXG4gICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJylcbiAgICAgICAgLnNwbGl0KC9bLFxcc10rLylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VGbG9hdCh2KTsgfSk7XG4gICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHByZXZYID0gZmlyc3RYID0gYXJnc1swXTtcbiAgICAgICAgICBwcmV2WSA9IGZpcnN0WSA9IGFyZ3NbMV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgaWYgKGFyZ3NbMF0gIT09IHByZXZYIHx8IGFyZ3NbMV0gIT09IHByZXZZKSB7IC8vIHl1cCwgc29tZSBmb250cyBoYXZlIHplcm8tbGVuZ3RoIGxpbmUgY29tbWFuZHNcbiAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnTCcsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1swXSksIChwcmV2WSA9IGFyZ3NbMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ1EnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbMl0pLCAocHJldlkgPSBhcmdzWzNdKSwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnQycsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1s0XSksIChwcmV2WSA9IGFyZ3NbNV0pLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIGlmIChwcmV2WCAhPT0gZmlyc3RYIHx8IHByZXZZICE9PSBmaXJzdFkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnTCcsIHByZXZYLCBwcmV2WSwgZmlyc3RYLCBmaXJzdFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcGF0aCBzdHJpbmcgdG8gYSBzZXJpZXMgb2Ygc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZyAtIEFuIFNWRy1saWtlIHBhdGggc3RyaW5nIHRvIHBhcnNlOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1pcbiAgICogQHBhcmFtIHtmdW5jdGlvbih4MTpudW1iZXIsIHkxOm51bWJlciwgeDI6bnVtYmVyLCB5MjpudW1iZXIpfSBzZWdtZW50Q2FsbGJhY2sgLSBBIGNhbGxiYWNrXG4gICAqICAgICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IGxpbmUgc2VnbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnZlUG9pbnRzXSAtIEhvdyBtYW55IHN0cmFpZ2h0IGxpbmUgc2VnbWVudHMgdG8gdXNlIHdoZW4gYXBwcm94aW1hdGluZyBhXG4gICAqICAgICAgICBiZXppZXIgY3VydmUgaW4gdGhlIHBhdGguIERlZmF1bHRzIHRvIDE2LlxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aFRvTGluZVNlZ21lbnRzIChwYXRoU3RyaW5nLCBzZWdtZW50Q2FsbGJhY2ssIGN1cnZlUG9pbnRzKSB7XG4gICAgaWYgKCBjdXJ2ZVBvaW50cyA9PT0gdm9pZCAwICkgY3VydmVQb2ludHMgPSAxNjtcblxuICAgIHZhciB0ZW1wUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBmb3JFYWNoUGF0aENvbW1hbmQocGF0aFN0cmluZywgZnVuY3Rpb24gKGNvbW1hbmQsIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBjdHJsMVgsIGN0cmwxWSwgY3RybDJYLCBjdHJsMlkpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBzZWdtZW50Q2FsbGJhY2soc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVggPSBzdGFydFg7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVkgPSBzdGFydFk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjdXJ2ZVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgICBzdGFydFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgY3RybDFYLCBjdHJsMVksXG4gICAgICAgICAgICAgIGVuZFgsIGVuZFksXG4gICAgICAgICAgICAgIGkgLyAoY3VydmVQb2ludHMgLSAxKSxcbiAgICAgICAgICAgICAgdGVtcFBvaW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHByZXZDdXJ2ZVgsIHByZXZDdXJ2ZVksIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICBwcmV2Q3VydmVYID0gdGVtcFBvaW50Lng7XG4gICAgICAgICAgICBwcmV2Q3VydmVZID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWCQxID0gc3RhcnRYO1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVZJDEgPSBzdGFydFk7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgY3VydmVQb2ludHM7IGkkMSsrKSB7XG4gICAgICAgICAgICBwb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgICAgIHN0YXJ0WCwgc3RhcnRZLFxuICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgY3RybDJYLCBjdHJsMlksXG4gICAgICAgICAgICAgIGVuZFgsIGVuZFksXG4gICAgICAgICAgICAgIGkkMSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCQxLCBwcmV2Q3VydmVZJDEsIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICBwcmV2Q3VydmVYJDEgPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVkkMSA9IHRlbXBQb2ludC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmlld3BvcnRRdWFkVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7YXR0cmlidXRlIHZlYzIgYVVWO3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dlVWPWFVVjtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICB2YXIgY29weVRleEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh0ZXgsdlVWKTt9XCI7XG5cbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICB2YXIgZ2xDb250ZXh0UGFyYW1zID0ge1xuICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgbGl0dGxlIGhlbHBlciBsaWJyYXJ5IGZvciBXZWJHTC4gSXQgYXNzaXN0cyB3aXRoIHN0YXRlIG1hbmFnZW1lbnQgZm9yIGEgR0wgY29udGV4dC5cbiAgICogSXQncyBwcmV0dHkgdGlnaHRseSB3cmFwcGVkIHRvIHRoZSBuZWVkcyBvZiB0aGlzIHBhY2thZ2UsIG5vdCB2ZXJ5IGdlbmVyYWwtcHVycG9zZS5cbiAgICpcbiAgICogQHBhcmFtIHsgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMgfSBnbE9yQ2FudmFzIC0gdGhlIEdMIGNvbnRleHQgdG8gd3JhcFxuICAgKiBAcGFyYW0geyAoe2dsLCBnZXRFeHRlbnNpb24sIHdpdGhQcm9ncmFtLCB3aXRoVGV4dHVyZSwgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciwgaGFuZGxlQ29udGV4dExvc3N9KSA9PiB2b2lkIH0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIHdpdGhXZWJHTENvbnRleHQgKGdsT3JDYW52YXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGdsID0gZ2xPckNhbnZhcy5nZXRDb250ZXh0ID8gZ2xPckNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsQ29udGV4dFBhcmFtcykgOiBnbE9yQ2FudmFzO1xuICAgIHZhciB3cmFwcGVyID0gY2FjaGUuZ2V0KGdsKTtcbiAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgIHZhciBpc1dlYkdMMiA9IHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgdmFyIHByb2dyYW1zID0ge307XG4gICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcbiAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgdmFyIGZyYW1lYnVmZmVyU3RhY2sgPSBbXTtcblxuICAgICAgZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVDb250ZXh0TG9zcygpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCBmYWxzZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEV4dGVuc2lvbiAobmFtZSkge1xuICAgICAgICB2YXIgZXh0ID0gZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuICAgICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKG5hbWUgKyBcIiBub3Qgc3VwcG9ydGVkXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIgKHNyYywgdHlwZSkge1xuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIC8vIGNvbnN0IHN0YXR1cyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKVxuICAgICAgICAvLyBpZiAoIXN0YXR1cyAmJiAhZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCkpXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHNoYWRlclxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3aXRoUHJvZ3JhbSAobmFtZSwgdmVydCwgZnJhZywgZnVuYykge1xuICAgICAgICBpZiAoIXByb2dyYW1zW25hbWVdKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcih2ZXJ0LCBnbC5WRVJURVhfU0hBREVSKSk7XG4gICAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGNvbXBpbGVTaGFkZXIoZnJhZywgZ2wuRlJBR01FTlRfU0hBREVSKSk7XG4gICAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgICBwcm9ncmFtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gdHJhbnNhY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgZnVuYyh7XG4gICAgICAgICAgICAgICAgc2V0VW5pZm9ybTogZnVuY3Rpb24gc2V0VW5pZm9ybSAodHlwZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgdmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgdW5pZm9ybUxvYyA9IHVuaWZvcm1zW25hbWVdIHx8ICh1bmlmb3Jtc1tuYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgICBnbFsoXCJ1bmlmb3JtXCIgKyB0eXBlKV0uYXBwbHkoZ2wsIFsgdW5pZm9ybUxvYyBdLmNvbmNhdCggdmFsdWVzICkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobmFtZSwgc2l6ZSwgdXNhZ2UsIGluc3RhbmNpbmdEaXZpc29yLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAoIWF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmOiBnbC5jcmVhdGVCdWZmZXIoKSwgLy8gVE9ETyBzaG91bGQgd2UgZGVzdHJveSBvdXIgYnVmZmVycz9cbiAgICAgICAgICAgICAgICAgICAgICBsb2M6IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyLmJ1Zik7XG4gICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIubG9jLCBzaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ci5sb2MpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ci5sb2MsIGluc3RhbmNpbmdEaXZpc29yKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IGF0dHIuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgdXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyYW1zW25hbWVdLnRyYW5zYWN0aW9uKGZ1bmMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3aXRoVGV4dHVyZSAobmFtZSwgZnVuYykge1xuICAgICAgICB0ZXh0dXJlVW5pdCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlc1tuYW1lXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICBmdW5jKHRleHR1cmUsIHRleHR1cmVVbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0ZXh0dXJlVW5pdC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jKSB7XG4gICAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhY2sucHVzaChmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmdW5jKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlclN0YWNrWy0tZnJhbWVidWZmZXJTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TG9zcyAoKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSB7fTtcbiAgICAgICAgcHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGV4dHVyZVVuaXQgPSAtMTtcbiAgICAgICAgZnJhbWVidWZmZXJTdGFjay5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjYWNoZS5zZXQoZ2wsIHdyYXBwZXIgPSB7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaXNXZWJHTDI6IGlzV2ViR0wyLFxuICAgICAgICBnZXRFeHRlbnNpb246IGdldEV4dGVuc2lvbixcbiAgICAgICAgd2l0aFByb2dyYW06IHdpdGhQcm9ncmFtLFxuICAgICAgICB3aXRoVGV4dHVyZTogd2l0aFRleHR1cmUsXG4gICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXI6IHdpdGhUZXh0dXJlRnJhbWVidWZmZXIsXG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzOiBoYW5kbGVDb250ZXh0TG9zcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsYmFjayh3cmFwcGVyKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGZyYW1lYnVmZmVyKSB7XG4gICAgaWYgKCBjaGFubmVscyA9PT0gdm9pZCAwICkgY2hhbm5lbHMgPSAxNTtcbiAgICBpZiAoIGZyYW1lYnVmZmVyID09PSB2b2lkIDAgKSBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciB3aXRoUHJvZ3JhbSA9IHJlZi53aXRoUHJvZ3JhbTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcblxuICAgICAgd2l0aFRleHR1cmUoJ2NvcHknLCBmdW5jdGlvbiAodGV4LCB0ZXhVbml0KSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2VEYXRhKTtcbiAgICAgICAgd2l0aFByb2dyYW0oJ2NvcHknLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIGNvcHlUZXhGcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG4gICAgICAgICAgdmFyIHNldEF0dHJpYnV0ZSA9IHJlZi5zZXRBdHRyaWJ1dGU7XG5cbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSkpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFpJywgJ2ltYWdlJywgdGV4VW5pdCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciB8fCBudWxsKTtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbHMgJiA4LCBjaGFubmVscyAmIDQsIGNoYW5uZWxzICYgMiwgY2hhbm5lbHMgJiAxKTtcbiAgICAgICAgICBnbC52aWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBnbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCAzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemluZyBhIGNhbnZhcyBjbGVhcnMgaXRzIGNvbnRlbnRzOyB0aGlzIHV0aWxpdHkgY29waWVzIHRoZSBwcmV2aW91cyBjb250ZW50cyBvdmVyLlxuICAgKiBAcGFyYW0gY2FudmFzXG4gICAqIEBwYXJhbSBuZXdXaWR0aFxuICAgKiBAcGFyYW0gbmV3SGVpZ2h0XG4gICAqL1xuICBmdW5jdGlvbiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhjYW52YXMsIG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgd2l0aFdlYkdMQ29udGV4dChjYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcblxuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHJlbmRlckltYWdlRGF0YShnbCwgZGF0YSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2ViZ2xVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgd2l0aFdlYkdMQ29udGV4dDogd2l0aFdlYkdMQ29udGV4dCxcbiAgICByZW5kZXJJbWFnZURhdGE6IHJlbmRlckltYWdlRGF0YSxcbiAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZzogcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmdcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUkMiAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50KSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuXG4gICAgdmFyIHRleHR1cmVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQpO1xuXG4gICAgdmFyIHZpZXdCb3hXaWR0aCA9IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdO1xuICAgIHZhciB2aWV3Qm94SGVpZ2h0ID0gdmlld0JveFszXSAtIHZpZXdCb3hbMV07XG5cbiAgICAvLyBEZWNvbXBvc2UgYWxsIHBhdGhzIGludG8gc3RyYWlnaHQgbGluZSBzZWdtZW50cyBhbmQgYWRkIHRoZW0gdG8gYW4gaW5kZXhcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyLFxuICAgICAgICBtaW5YOiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICBtaW5ZOiBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgICBtYXhYOiBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICBtYXhZOiBNYXRoLm1heCh5MSwgeTIpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgc2VnbWVudHMgYnkgbWF4WCwgdGhpcyB3aWxsIGxldCB1cyBzaG9ydC1jaXJjdWl0IHNvbWUgbG9vcHMgYmVsb3dcbiAgICBzZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm1heFggLSBiLm1heFg7IH0pO1xuXG4gICAgLy8gRm9yIGVhY2ggdGFyZ2V0IFNERiB0ZXhlbCwgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSBpdHMgY2VudGVyIHRvIGl0cyBuZWFyZXN0IGxpbmUgc2VnbWVudCxcbiAgICAvLyBtYXAgdGhhdCBkaXN0YW5jZSB0byBhbiBhbHBoYSB2YWx1ZSwgYW5kIHdyaXRlIHRoYXQgYWxwaGEgdG8gdGhlIHRleGVsXG4gICAgZm9yICh2YXIgc2RmWCA9IDA7IHNkZlggPCBzZGZXaWR0aDsgc2RmWCsrKSB7XG4gICAgICBmb3IgKHZhciBzZGZZID0gMDsgc2RmWSA8IHNkZkhlaWdodDsgc2RmWSsrKSB7XG4gICAgICAgIHZhciBzaWduZWREaXN0ID0gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZShcbiAgICAgICAgICB2aWV3Qm94WzBdICsgdmlld0JveFdpZHRoICogKHNkZlggKyAwLjUpIC8gc2RmV2lkdGgsXG4gICAgICAgICAgdmlld0JveFsxXSArIHZpZXdCb3hIZWlnaHQgKiAoc2RmWSArIDAuNSkgLyBzZGZIZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVc2UgYW4gZXhwb25lbnRpYWwgc2NhbGUgdG8gZW5zdXJlIHRoZSB0ZXhlbHMgdmVyeSBuZWFyIHRoZSBnbHlwaCBwYXRoIGhhdmUgYWRlcXVhdGVcbiAgICAgICAgLy8gcHJlY2lzaW9uLCB3aGlsZSBhbGxvd2luZyB0aGUgZGlzdGFuY2UgZmllbGQgdG8gY292ZXIgdGhlIGVudGlyZSB0ZXh0dXJlLCBnaXZlbiB0aGF0XG4gICAgICAgIC8vIHRoZXJlIGFyZSBvbmx5IDggYml0cyBhdmFpbGFibGUuIEZvcm11bGEgdmlzdWFsaXplZDogaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3VpYXE1YXFpYW1cbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5wb3coKDEgLSBNYXRoLmFicyhzaWduZWREaXN0KSAvIG1heERpc3RhbmNlKSwgc2RmRXhwb25lbnQpIC8gMjtcbiAgICAgICAgaWYgKHNpZ25lZERpc3QgPCAwKSB7XG4gICAgICAgICAgYWxwaGEgPSAxIC0gYWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChhbHBoYSAqIDI1NSkpKTsgLy9jbGFtcFxuICAgICAgICB0ZXh0dXJlRGF0YVtzZGZZICogc2RmV2lkdGggKyBzZGZYXSA9IGFscGhhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlRGF0YVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4geC95LCBzZWFyY2ggdGhlIGluZGV4IGZvciB0aGUgY2xvc2VzdCBsaW5lIHNlZ21lbnQgYW5kIHJldHVyblxuICAgICAqIGl0cyBzaWduZWQgZGlzdGFuY2UuIE5lZ2F0aXZlID0gaW5zaWRlLCBwb3NpdGl2ZSA9IG91dHNpZGUsIHplcm8gPSBvbiBlZGdlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZSAoeCwgeSkge1xuICAgICAgdmFyIGNsb3Nlc3REaXN0U3EgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHNlZy5tYXhYICsgY2xvc2VzdERpc3QgPD0geCkgeyBicmVhayB9IC8vc29ydGluZyBieSBtYXhYIG1lYW5zIG5vIG1vcmUgY2FuIGJlIGNsb3Nlciwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXRcbiAgICAgICAgaWYgKHggKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5YICYmIHkgLSBjbG9zZXN0RGlzdCA8IHNlZy5tYXhZICYmIHkgKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5ZKSB7XG4gICAgICAgICAgdmFyIGRpc3RTcSA9IGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBzZWcueDEsIHNlZy55MSwgc2VnLngyLCBzZWcueTIpO1xuICAgICAgICAgIGlmIChkaXN0U3EgPCBjbG9zZXN0RGlzdFNxKSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBNYXRoLnNxcnQoY2xvc2VzdERpc3RTcSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZsaXAgdG8gbmVnYXRpdmUgZGlzdGFuY2UgaWYgaW5zaWRlIHRoZSBwb2x5XG4gICAgICBpZiAoaXNQb2ludEluUG9seSh4LCB5KSkge1xuICAgICAgICBjbG9zZXN0RGlzdCA9IC1jbG9zZXN0RGlzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9zZXN0RGlzdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBsaWVzIGluc2lkZSBvciBvdXRzaWRlIHRoZSBnbHlwaC4gVXNlcyBhIHNpbXBsZVxuICAgICAqIHdpbmRpbmctbnVtYmVyIHJheSBjYXN0aW5nIGFsZ29yaXRobSB1c2luZyBhIHJheSBwb2ludGluZyBlYXN0IGZyb20gdGhlIHBvaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUG9pbnRJblBvbHkgKHgsIHkpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnLm1heFggPD0geCkgeyBicmVhayB9IC8vc29ydGluZyBieSBtYXhYIG1lYW5zIG5vIG1vcmUgY2FuIGNyb3NzLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICB2YXIgaW50ZXJzZWN0cyA9ICgoc2VnLnkxID4geSkgIT09IChzZWcueTIgPiB5KSkgJiYgKHggPCAoc2VnLngyIC0gc2VnLngxKSAqICh5IC0gc2VnLnkxKSAvIChzZWcueTIgLSBzZWcueTEpICsgc2VnLngxKTtcbiAgICAgICAgaWYgKGludGVyc2VjdHMpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IHNlZy55MSA8IHNlZy55MiA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRpbmcgIT09IDBcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDEoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzLCBmcmFtZWJ1ZmZlciwgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIHZhciBkYXRhID0gZ2VuZXJhdGUkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpO1xuICAgIC8vIEV4cGFuZCBzaW5nbGUtY2hhbm5lbCBkYXRhIHRvIHJiZ2FcbiAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAqIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiYURhdGFbaSAqIDQgKyBjaGFubmVsXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIHJlbmRlckltYWdlRGF0YShnbE9yQ2FudmFzLCByZ2JhRGF0YSwgeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpLCBmcmFtZWJ1ZmZlcik7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50IGF0IGNsb3Nlc3QgYXBwcm9hY2hcbiAgICovXG4gIGZ1bmN0aW9uIGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCAoeCwgeSwgbGluZVgwLCBsaW5lWTAsIGxpbmVYMSwgbGluZVkxKSB7XG4gICAgdmFyIGxkeCA9IGxpbmVYMSAtIGxpbmVYMDtcbiAgICB2YXIgbGR5ID0gbGluZVkxIC0gbGluZVkwO1xuICAgIHZhciBsZW5ndGhTcSA9IGxkeCAqIGxkeCArIGxkeSAqIGxkeTtcbiAgICB2YXIgdCA9IGxlbmd0aFNxID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0gbGluZVgwKSAqIGxkeCArICh5IC0gbGluZVkwKSAqIGxkeSkgLyBsZW5ndGhTcSkpIDogMDtcbiAgICB2YXIgZHggPSB4IC0gKGxpbmVYMCArIHQgKiBsZHgpO1xuICAgIHZhciBkeSA9IHkgLSAobGluZVkwICsgdCAqIGxkeSk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5XG4gIH1cblxuICB2YXIgamF2YXNjcmlwdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2VuZXJhdGU6IGdlbmVyYXRlJDIsXG4gICAgZ2VuZXJhdGVJbnRvQ2FudmFzOiBnZW5lcmF0ZUludG9DYW52YXMkMixcbiAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcjogZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMVxuICB9KTtcblxuICB2YXIgbWFpblZlcnRleCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7YXR0cmlidXRlIHZlYzIgYVVWO2F0dHJpYnV0ZSB2ZWM0IGFMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTt2b2lkIG1haW4oKXt2TGluZVNlZ21lbnQ9YUxpbmVTZWdtZW50O3ZHbHlwaFhZPW1peCh1R2x5cGhCb3VuZHMueHksdUdseXBoQm91bmRzLnp3LGFVVik7Z2xfUG9zaXRpb249dmVjNChtaXgodmVjMigtMS4wKSx2ZWMyKDEuMCksYVVWKSwwLjAsMS4wKTt9XCI7XG5cbiAgdmFyIG1haW5GcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7dW5pZm9ybSBmbG9hdCB1TWF4RGlzdGFuY2U7dW5pZm9ybSBmbG9hdCB1RXhwb25lbnQ7dmFyeWluZyB2ZWM0IHZMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzIgdkdseXBoWFk7ZmxvYXQgYWJzRGlzdFRvU2VnbWVudCh2ZWMyIHBvaW50LHZlYzIgbGluZUEsdmVjMiBsaW5lQil7dmVjMiBsaW5lRGlyPWxpbmVCLWxpbmVBO2Zsb2F0IGxlblNxPWRvdChsaW5lRGlyLGxpbmVEaXIpO2Zsb2F0IHQ9bGVuU3E9PTAuMCA/IDAuMCA6IGNsYW1wKGRvdChwb2ludC1saW5lQSxsaW5lRGlyKS9sZW5TcSwwLjAsMS4wKTt2ZWMyIGxpbmVQdD1saW5lQSt0KmxpbmVEaXI7cmV0dXJuIGRpc3RhbmNlKHBvaW50LGxpbmVQdCk7fXZvaWQgbWFpbigpe3ZlYzQgc2VnPXZMaW5lU2VnbWVudDt2ZWMyIHA9dkdseXBoWFk7ZmxvYXQgZGlzdD1hYnNEaXN0VG9TZWdtZW50KHAsc2VnLnh5LHNlZy56dyk7ZmxvYXQgdmFsPXBvdygxLjAtY2xhbXAoZGlzdC91TWF4RGlzdGFuY2UsMC4wLDEuMCksdUV4cG9uZW50KSowLjU7Ym9vbCBjcm9zc2luZz0oc2VnLnk+cC55IT1zZWcudz5wLnkpJiYocC54PChzZWcuei1zZWcueCkqKHAueS1zZWcueSkvKHNlZy53LXNlZy55KStzZWcueCk7Ym9vbCBjcm9zc2luZ1VwPWNyb3NzaW5nJiZ2TGluZVNlZ21lbnQueTx2TGluZVNlZ21lbnQudztnbF9GcmFnQ29sb3I9dmVjNChjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLGNyb3NzaW5nJiYhY3Jvc3NpbmdVcCA/IDEuMC8yNTUuMCA6IDAuMCwwLjAsdmFsKTt9XCI7XG5cbiAgdmFyIHBvc3RGcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gc2FtcGxlcjJEIHRleDt2YXJ5aW5nIHZlYzIgdlVWO3ZvaWQgbWFpbigpe3ZlYzQgY29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO2Jvb2wgaW5zaWRlPWNvbG9yLnIhPWNvbG9yLmc7ZmxvYXQgdmFsPWluc2lkZSA/IDEuMC1jb2xvci5hIDogY29sb3IuYTtnbF9GcmFnQ29sb3I9dmVjNCh2YWwpO31cIjtcblxuICAvLyBTaW5nbGUgdHJpYW5nbGUgY292ZXJpbmcgdmlld3BvcnRcbiAgdmFyIHZpZXdwb3J0VVZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pO1xuXG4gIHZhciBpbXBsaWNpdENvbnRleHQgPSBudWxsO1xuICB2YXIgaXNUZXN0aW5nU3VwcG9ydCA9IGZhbHNlO1xuICB2YXIgTlVMTF9PQkpFQ1QgPSB7fTtcbiAgdmFyIHN1cHBvcnRCeUNhbnZhcyA9IG5ldyBXZWFrTWFwKCk7IC8vIGNhbnZhcyAtPiBib29sXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVTdXBwb3J0IChnbE9yQ2FudmFzKSB7XG4gICAgaWYgKCFpc1Rlc3RpbmdTdXBwb3J0ICYmICFpc1N1cHBvcnRlZChnbE9yQ2FudmFzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlJDEgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcykge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIGdsT3JDYW52YXMgPT09IHZvaWQgMCApIGdsT3JDYW52YXMgPSBudWxsO1xuXG4gICAgaWYgKCFnbE9yQ2FudmFzKSB7XG4gICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0O1xuICAgICAgaWYgKCFnbE9yQ2FudmFzKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpXG4gICAgICAgICAgOiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZmZzY3JlZW5DYW52YXMgb3IgRE9NIGNhbnZhcyBub3Qgc3VwcG9ydGVkJylcbiAgICAgICAgfVxuICAgICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgeyBkZXB0aDogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTdXBwb3J0KGdsT3JDYW52YXMpO1xuXG4gICAgdmFyIHJnYmFEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQgKiA0KTsgLy9ub3QgVWludDhDbGFtcGVkQXJyYXksIGN1eiBTYWZhcmlcblxuICAgIC8vIFJlbmRlciBpbnRvIGEgYmFja2dyb3VuZCB0ZXh0dXJlIGZyYW1lYnVmZmVyXG4gICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG4gICAgICB2YXIgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciA9IHJlZi53aXRoVGV4dHVyZUZyYW1lYnVmZmVyO1xuXG4gICAgICB3aXRoVGV4dHVyZSgncmVhZGFibGUnLCBmdW5jdGlvbiAodGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jdGlvbiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcihcbiAgICAgICAgICAgIHNkZldpZHRoLFxuICAgICAgICAgICAgc2RmSGVpZ2h0LFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHZpZXdCb3gsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCAvLyByZWQgY2hhbm5lbFxuICAgICAgICAgICk7XG4gICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZ2JhRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhlIHJlZCBjaGFubmVsXG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgcmdiYURhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaisrXSA9IHJnYmFEYXRhW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMkMShzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCBudWxsLCB4LCB5LCBjaGFubmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgLy8gVmVyaWZ5IHN1cHBvcnRcbiAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICAvLyBDb21wdXRlIHBhdGggc2VnbWVudHNcbiAgICB2YXIgbGluZVNlZ21lbnRDb29yZHMgPSBbXTtcbiAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBsaW5lU2VnbWVudENvb3Jkcy5wdXNoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9KTtcbiAgICBsaW5lU2VnbWVudENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkobGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICB2YXIgaXNXZWJHTDIgPSByZWYuaXNXZWJHTDI7XG4gICAgICB2YXIgZ2V0RXh0ZW5zaW9uID0gcmVmLmdldEV4dGVuc2lvbjtcbiAgICAgIHZhciB3aXRoUHJvZ3JhbSA9IHJlZi53aXRoUHJvZ3JhbTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG4gICAgICB2YXIgaGFuZGxlQ29udGV4dExvc3MgPSByZWYuaGFuZGxlQ29udGV4dExvc3M7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdyYXdEaXN0YW5jZXMnLCBmdW5jdGlvbiAoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQpIHtcbiAgICAgICAgaWYgKHNkZldpZHRoICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggfHwgc2RmSGVpZ2h0ICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggPSBzZGZXaWR0aCxcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQgPSBzZGZIZWlnaHQsXG4gICAgICAgICAgICAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuc2lnbmVkIGRpc3RhbmNlIHBhc3NcbiAgICAgICAgd2l0aFByb2dyYW0oJ21haW4nLCBtYWluVmVydGV4LCBtYWluRnJhZ21lbnQsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcbiAgICAgICAgICB2YXIgc2V0VW5pZm9ybSA9IHJlZi5zZXRVbmlmb3JtO1xuXG4gICAgICAgICAgLy8gSW5pdCBleHRlbnNpb25zXG4gICAgICAgICAgdmFyIGluc3RhbmNpbmdFeHRlbnNpb24gPSAhaXNXZWJHTDIgJiYgZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gICAgICAgICAgdmFyIGJsZW5kTWluTWF4RXh0ZW5zaW9uID0gIWlzV2ViR0wyICYmIGdldEV4dGVuc2lvbignRVhUX2JsZW5kX21pbm1heCcpO1xuXG4gICAgICAgICAgLy8gSW5pdC91cGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FMaW5lU2VnbWVudCcsIDQsIGdsLkRZTkFNSUNfRFJBVywgMSwgbGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgICAgICAgLy8gSW5pdC91cGRhdGUgdW5pZm9ybXNcbiAgICAgICAgICBzZXRVbmlmb3JtLmFwcGx5KHZvaWQgMCwgWyAnNGYnLCAndUdseXBoQm91bmRzJyBdLmNvbmNhdCggdmlld0JveCApKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1TWF4RGlzdGFuY2UnLCBtYXhEaXN0YW5jZSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWYnLCAndUV4cG9uZW50Jywgc2RmRXhwb25lbnQpO1xuXG4gICAgICAgICAgLy8gUmVuZGVyIGluaXRpYWwgdW5zaWduZWQgZGlzdGFuY2UgLyB3aW5kaW5nIG51bWJlciBpbmZvIHRvIGEgdGV4dHVyZVxuICAgICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuc2Npc3NvcigwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG4gICAgICAgICAgICAvLyBSZWQrR3JlZW4gY2hhbm5lbHMgYXJlIGluY3JlbWVudGVkIChGVU5DX0FERCkgZm9yIHNlZ21lbnQtcmF5IGNyb3NzaW5ncyB0byBnaXZlIGEgXCJ3aW5kaW5nIG51bWJlclwiLlxuICAgICAgICAgICAgLy8gQWxwaGEgaG9sZHMgdGhlIGNsb3Nlc3QgKE1BWCkgdW5zaWduZWQgZGlzdGFuY2UuXG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGlzV2ViR0wyID8gZ2wuTUFYIDogYmxlbmRNaW5NYXhFeHRlbnNpb24uTUFYX0VYVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jaW5nRXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShnbC5UUklBTkdMRVMsIDAsIDMsIGxpbmVTZWdtZW50Q29vcmRzLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVidWdcbiAgICAgICAgICAgIC8vIGNvbnN0IGRlYnVnID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQgKiA0KVxuICAgICAgICAgICAgLy8gZ2wucmVhZFBpeGVscygwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkZWJ1ZylcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnRlcm1lZGlhdGUgdGV4dHVyZSBkYXRhOiAnLCBkZWJ1ZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgdGV4dHVyZSB0byBhcHBseSBpbnNpZGUvb3V0c2lkZSBhbmQgd3JpdGUgdG8gdGhlIG91dHB1dCBmcmFtZWJ1ZmZlciByZWN0K2NoYW5uZWwuXG4gICAgICAgIHdpdGhQcm9ncmFtKCdwb3N0Jywgdmlld3BvcnRRdWFkVmVydGV4LCBwb3N0RnJhZ21lbnQsIGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcHJvZ3JhbS5zZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCB2aWV3cG9ydFVWcyk7XG4gICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtKCcxaScsICd0ZXgnLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGNoYW5uZWwgPT09IDAsIGNoYW5uZWwgPT09IDEsIGNoYW5uZWwgPT09IDIsIGNoYW5uZWwgPT09IDMpO1xuICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgIGdsLnNjaXNzb3IoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgY29udGV4dCBsb3NzIG9jY3VycmluZyBkdXJpbmcgYW55IG9mIHRoZSBhYm92ZSBjYWxsc1xuICAgICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICBoYW5kbGVDb250ZXh0TG9zcygpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dlYmdsIGNvbnRleHQgbG9zdCcpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoZ2xPckNhbnZhcykge1xuICAgIHZhciBrZXkgPSAoIWdsT3JDYW52YXMgfHwgZ2xPckNhbnZhcyA9PT0gaW1wbGljaXRDb250ZXh0KSA/IE5VTExfT0JKRUNUIDogKGdsT3JDYW52YXMuY2FudmFzIHx8IGdsT3JDYW52YXMpO1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0QnlDYW52YXMuZ2V0KGtleSk7XG4gICAgaWYgKHN1cHBvcnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpc1Rlc3RpbmdTdXBwb3J0ID0gdHJ1ZTtcbiAgICAgIHZhciBmYWlsUmVhc29uID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRldGVjdCBhbGwgZmFpbHVyZSBtb2RlcyB1cCBmcm9udCwgbGV0J3MganVzdCBkbyBhIHRyaWFsIHJ1biBvZiBhXG4gICAgICAgIC8vIHNpbXBsZSBwYXRoIGFuZCBjb21wYXJlIHdoYXQgd2UgZ2V0IGJhY2sgdG8gdGhlIGNvcnJlY3QgZXhwZWN0ZWQgcmVzdWx0LiBUaGlzIHdpbGxcbiAgICAgICAgLy8gYWxzbyBzZXJ2ZSB0byBwcmltZSB0aGUgc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgICAgICB2YXIgZXhwZWN0ZWRSZXN1bHQgPSBbXG4gICAgICAgICAgOTcsIDEwNiwgOTcsIDYxLFxuICAgICAgICAgIDk5LCAxMzcsIDExOCwgODAsXG4gICAgICAgICAgODAsIDExOCwgMTM3LCA5OSxcbiAgICAgICAgICA2MSwgOTcsIDEwNiwgOTdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHRlc3RSZXN1bHQgPSBnZW5lcmF0ZSQxKFxuICAgICAgICAgIDQsXG4gICAgICAgICAgNCxcbiAgICAgICAgICAnTTgsOEwxNiw4TDI0LDI0TDE2LDI0WicsXG4gICAgICAgICAgWzAsIDAsIDMyLCAzMl0sXG4gICAgICAgICAgMjQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBnbE9yQ2FudmFzXG4gICAgICAgICk7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRlc3RSZXN1bHQgJiYgZXhwZWN0ZWRSZXN1bHQubGVuZ3RoID09PSB0ZXN0UmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgIHRlc3RSZXN1bHQuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdmFsID09PSBleHBlY3RlZFJlc3VsdFtpXTsgfSk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgZmFpbFJlYXNvbiA9ICdiYWQgdHJpYWwgcnVuIHJlc3VsdHMnO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhleHBlY3RlZFJlc3VsdCwgdGVzdFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUT0RPIGlmIGl0IHRocmV3IGR1ZSB0byB3ZWJnbCBjb250ZXh0IGxvc3MsIHNob3VsZCB3ZSBtYXliZSBsZWF2ZSBpc1N1cHBvcnRlZCBhcyBudWxsIGFuZCB0cnkgYWdhaW4gbGF0ZXI/XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmYWlsUmVhc29uID0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoZmFpbFJlYXNvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQ6JywgZmFpbFJlYXNvbik7XG4gICAgICB9XG4gICAgICBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gICAgICBzdXBwb3J0QnlDYW52YXMuc2V0KGtleSwgc3VwcG9ydGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZFxuICB9XG5cbiAgdmFyIHdlYmdsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMSxcbiAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQxLFxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcixcbiAgICBpc1N1cHBvcnRlZDogaXNTdXBwb3J0ZWRcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIDJEIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZXaWR0aCAtIHdpZHRoIG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZkhlaWdodCAtIGhlaWdodCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gYW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZ2x5cGg7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWi5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld0JveCAtIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBpbiBmb250IHVuaXRzIGFsaWduaW5nIHdpdGggdGhlIHRleHR1cmUncyBlZGdlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heERpc3RhbmNlIC0gdGhlIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZ2x5cGggcGF0aCBpbiBmb250IHVuaXRzIHRoYXQgd2lsbCBiZSBlbmNvZGVkOyBkZWZhdWx0c1xuICAgKiAgICAgICAgdG8gaGFsZiB0aGUgbWF4aW11bSB2aWV3Qm94IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZGZFeHBvbmVudF0gLSBzcGVjaWZpZXMgYW4gZXhwb25lbnQgZm9yIGVuY29kaW5nIHRoZSBTREYncyBkaXN0YW5jZSB2YWx1ZXM7IGhpZ2hlciBleHBvbmVudHNcbiAgICogICAgICAgIHdpbGwgZ2l2ZSBncmVhdGVyIHByZWNpc2lvbiBuZWFyZXIgdGhlIGdseXBoJ3MgcGF0aC5cbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKFxuICAgIHNkZldpZHRoLFxuICAgIHNkZkhlaWdodCxcbiAgICBwYXRoLFxuICAgIHZpZXdCb3gsXG4gICAgbWF4RGlzdGFuY2UsXG4gICAgc2RmRXhwb25lbnRcbiAgKSB7XG4gICAgaWYgKCBtYXhEaXN0YW5jZSA9PT0gdm9pZCAwICkgbWF4RGlzdGFuY2UgPSBNYXRoLm1heCh2aWV3Qm94WzJdIC0gdmlld0JveFswXSwgdmlld0JveFszXSAtIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZSQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aCwgaW5zZXJ0aW5nIHRoZSByZXN1bHQgaW50byBhIFdlYkdMIGBjYW52YXNgIGF0IGEgZ2l2ZW4geC95IHBvc2l0aW9uXG4gICAqIGFuZCBjb2xvciBjaGFubmVsLiBUaGlzIGlzIGdlbmVyYWxseSBtdWNoIGZhc3RlciB0aGFuIGNhbGxpbmcgYGdlbmVyYXRlYCBiZWNhdXNlIGl0IGRvZXMgbm90IHJlcXVpcmUgcmVhZGluZyBwaXhlbHNcbiAgICogYmFjayBmcm9tIHRoZSBHUFUtPkNQVSAtLSB0aGUgYGNhbnZhc2AgY2FuIGJlIHVzZWQgZGlyZWN0bHkgYXMgYSBXZWJHTCB0ZXh0dXJlIGltYWdlLCBzbyBpdCBhbGwgc3RheXMgb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBhbiBTVkctbGlrZSBwYXRoIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnbHlwaDsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAqICAgICAgICB0byBoYWxmIHRoZSBtYXhpbXVtIHZpZXdCb3ggZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhc30gY2FudmFzIC0gYSBXZWJHTC1lbmFibGVkIGNhbnZhcyBpbnRvIHdoaWNoIHRoZSBTREYgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogICAgICAgIE9ubHkgdGhlIHJlbGV2YW50IHJlY3QvY2hhbm5lbCB3aWxsIGJlIG1vZGlmaWVkLCB0aGUgcmVzdCB3aWxsIGJlIHByZXNlcnZlZC4gVG8gYXZvaWQgdW5wcmVkaWN0YWJsZSByZXN1bHRzXG4gICAqICAgICAgICBkdWUgdG8gc2hhcmVkIEdMIGNvbnRleHQgc3RhdGUsIHRoaXMgY2FudmFzIHNob3VsZCBiZSBkZWRpY2F0ZWQgdG8gdXNlIGJ5IHRoaXMgbGlicmFyeSBhbG9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBwb3NpdGlvbiBhdCB3aGljaCB0byByZW5kZXIgdGhlIFNERi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBwb3NpdGlvbiBhdCB3aGljaCB0byByZW5kZXIgdGhlIFNERi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgLSB0aGUgY29sb3IgY2hhbm5lbCBpbmRleCAoMC00KSBpbnRvIHdoaWNoIHRoZSBTREYgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyhcbiAgICBzZGZXaWR0aCxcbiAgICBzZGZIZWlnaHQsXG4gICAgcGF0aCxcbiAgICB2aWV3Qm94LFxuICAgIG1heERpc3RhbmNlLFxuICAgIHNkZkV4cG9uZW50LFxuICAgIGNhbnZhcyxcbiAgICB4LFxuICAgIHksXG4gICAgY2hhbm5lbFxuICApIHtcbiAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVJbnRvQ2FudmFzJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMi5hcHBseShqYXZhc2NyaXB0LCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5mb3JFYWNoUGF0aENvbW1hbmQgPSBmb3JFYWNoUGF0aENvbW1hbmQ7XG4gIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgZXhwb3J0cy5nZW5lcmF0ZUludG9DYW52YXMgPSBnZW5lcmF0ZUludG9DYW52YXM7XG4gIGV4cG9ydHMuamF2YXNjcmlwdCA9IGphdmFzY3JpcHQ7XG4gIGV4cG9ydHMucGF0aFRvTGluZVNlZ21lbnRzID0gcGF0aFRvTGluZVNlZ21lbnRzO1xuICBleHBvcnRzLndlYmdsID0gd2ViZ2w7XG4gIGV4cG9ydHMud2ViZ2xVdGlscyA9IHdlYmdsVXRpbHM7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSkpO1xucmV0dXJuIGV4cG9ydHNcbn1cblxuZXhwb3J0IHsgU0RGR2VuZXJhdG9yIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n"));

/***/ })

}]);