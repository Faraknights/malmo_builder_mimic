/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_hls_js_dist_hls_js"],{

/***/ "./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("typeof window !== \"undefined\" &&\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/config.ts\":\n/*!***********************!*\\\n  !*** ./src/config.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_630__) => {\n\n\"use strict\";\n__nested_webpack_require_630__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_630__.d(__nested_webpack_exports__, {\n/* harmony export */   \"enableStreamingMode\": () => (/* binding */ enableStreamingMode),\n/* harmony export */   \"hlsDefaultConfig\": () => (/* binding */ hlsDefaultConfig),\n/* harmony export */   \"mergeConfig\": () => (/* binding */ mergeConfig)\n/* harmony export */ });\n/* harmony import */ var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_630__(/*! ./controller/abr-controller */ \"./src/controller/abr-controller.ts\");\n/* harmony import */ var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_630__(/*! ./controller/audio-stream-controller */ \"./src/controller/audio-stream-controller.ts\");\n/* harmony import */ var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_630__(/*! ./controller/audio-track-controller */ \"./src/controller/audio-track-controller.ts\");\n/* harmony import */ var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_630__(/*! ./controller/subtitle-stream-controller */ \"./src/controller/subtitle-stream-controller.ts\");\n/* harmony import */ var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_630__(/*! ./controller/subtitle-track-controller */ \"./src/controller/subtitle-track-controller.ts\");\n/* harmony import */ var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_630__(/*! ./controller/buffer-controller */ \"./src/controller/buffer-controller.ts\");\n/* harmony import */ var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_630__(/*! ./controller/timeline-controller */ \"./src/controller/timeline-controller.ts\");\n/* harmony import */ var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_630__(/*! ./controller/cap-level-controller */ \"./src/controller/cap-level-controller.ts\");\n/* harmony import */ var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_630__(/*! ./controller/fps-controller */ \"./src/controller/fps-controller.ts\");\n/* harmony import */ var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_630__(/*! ./controller/eme-controller */ \"./src/controller/eme-controller.ts\");\n/* harmony import */ var _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_630__(/*! ./controller/cmcd-controller */ \"./src/controller/cmcd-controller.ts\");\n/* harmony import */ var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_630__(/*! ./utils/xhr-loader */ \"./src/utils/xhr-loader.ts\");\n/* harmony import */ var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_630__(/*! ./utils/fetch-loader */ \"./src/utils/fetch-loader.ts\");\n/* harmony import */ var _utils_cues__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_630__(/*! ./utils/cues */ \"./src/utils/cues.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_630__(/*! ./utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_630__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// If possible, keep hlsDefaultConfig shallow\n// It is cloned whenever a new Hls instance is created, by keeping the config\n// shallow the properties are cloned, and we don't end up manipulating the default\nvar hlsDefaultConfig = _objectSpread(_objectSpread({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by demuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  manifestLoadingTimeOut: 10000,\n  // used by playlist-loader\n  manifestLoadingMaxRetry: 1,\n  // used by playlist-loader\n  manifestLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  manifestLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  startLevel: undefined,\n  // used by level-controller\n  levelLoadingTimeOut: 10000,\n  // used by playlist-loader\n  levelLoadingMaxRetry: 4,\n  // used by playlist-loader\n  levelLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  levelLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  fragLoadingTimeOut: 20000,\n  // used by fragment-loader\n  fragLoadingMaxRetry: 6,\n  // used by fragment-loader\n  fragLoadingRetryDelay: 1000,\n  // used by fragment-loader\n  fragLoadingMaxRetryTimeout: 64000,\n  // used by fragment-loader\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__.requestMediaKeySystemAccess,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true\n}, timelineConfig()), {}, {\n  subtitleStreamController:   true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__.SubtitleStreamController : 0,\n  subtitleTrackController:   true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : 0,\n  timelineController:   true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__.TimelineController : 0,\n  audioStreamController:   true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : 0,\n  audioTrackController:   true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : 0,\n  emeController:   true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__[\"default\"] : 0,\n  cmcdController:   true ? _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"] : 0\n});\nfunction timelineConfig() {\n  return {\n    cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  return _extends({}, defaultConfig, userConfig);\n}\nfunction enableStreamingMode(config) {\n  var currentLoader = config.loader;\n  if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"]) {\n    // If a developer has configured their own loader, respect that choice\n    _utils_logger__WEBPACK_IMPORTED_MODULE_15__.logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    var canStreamProgressively = (0,_utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__.fetchSupported)();\n    if (canStreamProgressively) {\n      config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"];\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_15__.logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/controller/abr-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/abr-controller.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_14694__) => {\n\n\"use strict\";\n__nested_webpack_require_14694__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_14694__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_14694__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_14694__(/*! ../utils/ewma-bandwidth-estimator */ \"./src/utils/ewma-bandwidth-estimator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_14694__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_14694__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_14694__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_14694__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\nvar AbrController = /*#__PURE__*/function () {\n  function AbrController(hls) {\n    this.hls = void 0;\n    this.lastLoadedFragLevel = 0;\n    this._nextAutoLevel = -1;\n    this.timer = void 0;\n    this.onCheck = this._abandonRulesCheck.bind(this);\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    this.hls = hls;\n    var config = hls.config;\n    this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    this.registerListeners();\n  }\n  var _proto = AbrController.prototype;\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.onCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  };\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var frag = data.frag;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN) {\n      if (!this.timer) {\n        var _data$part;\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        this.timer = self.setInterval(this.onCheck, 100);\n      }\n    }\n  };\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var config = this.hls.config;\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n\n  /*\n      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n      quickly enough to prevent underbuffering\n    */;\n  _proto._abandonRulesCheck = function _abandonRulesCheck() {\n    var frag = this.fragCurrent,\n      part = this.partCurrent,\n      hls = this.hls;\n    var autoLevelEnabled = hls.autoLevelEnabled,\n      media = hls.media;\n    if (!frag || !media) {\n      return;\n    }\n    var stats = part ? part.stats : frag.stats;\n    var duration = part ? part.duration : frag.duration;\n    // If frag loading is aborted, complete, or from lowest level, stop timer and return\n    if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {\n      this.clearTimer();\n      // reset forced auto level value so that next level will be selected\n      this._nextAutoLevel = -1;\n      return;\n    }\n\n    // This check only runs if we're in ABR mode and actually playing\n    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n      return;\n    }\n    var bufferInfo = hls.mainForwardBufferInfo;\n    if (bufferInfo === null) {\n      return;\n    }\n    var requestDelay = performance.now() - stats.loading.start;\n    var playbackRate = Math.abs(media.playbackRate);\n    // In order to work with a stable bandwidth, only begin monitoring bandwidth after half of the fragment has been loaded\n    if (requestDelay <= 500 * duration / playbackRate) {\n      return;\n    }\n    var loadedFirstByte = stats.loaded && stats.loading.first;\n    var bwEstimate = this.bwEstimator.getEstimate();\n    var levels = hls.levels,\n      minAutoLevel = hls.minAutoLevel;\n    var level = levels[frag.level];\n    var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n    var loadRate = loadedFirstByte ? stats.loaded * 1000 / requestDelay : 0;\n\n    // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n    var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate;\n\n    // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n    var bufferStarvationDelay = bufferInfo.len / playbackRate;\n\n    // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n    if (fragLoadedDelay <= bufferStarvationDelay) {\n      return;\n    }\n    var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n    var nextLoadLevel;\n    // Iterate through lower level and try to find the largest one that avoids rebuffering\n    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n      // compute time to load next fragment at lower level\n      // 0.8 : consider only 80% of current bw to be conservative\n      // 8 = bits per byte (bps/Bps)\n      var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n      fragLevelNextLoadedDelay = loadRate ? duration * levelNextBitrate / (8 * 0.8 * loadRate) : duration * levelNextBitrate / bwEstimate;\n      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n        break;\n      }\n    }\n    // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n    // to load the current one\n    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n      return;\n    }\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly and will cause an underbuffer; aborting and switching to level \" + nextLoadLevel + \"\\n      Current BW estimate: \" + ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + \" Kb/s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for the next fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\");\n    hls.nextLoadLevel = nextLoadLevel;\n    if (loadedFirstByte) {\n      // If there has been loading progress, sample bandwidth\n      this.bwEstimator.sample(requestDelay, stats.loaded);\n    }\n    this.clearTimer();\n    if (frag.loader || frag.keyLoader) {\n      this.fragCurrent = this.partCurrent = null;\n      frag.abortRequests();\n    }\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n      frag: frag,\n      part: part,\n      stats: stats\n    });\n  };\n  _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n    var frag = _ref.frag,\n      part = _ref.part;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.sn)) {\n      var stats = part ? part.stats : frag.stats;\n      var duration = part ? part.duration : frag.duration;\n      // stop monitoring bw once frag loaded\n      this.clearTimer();\n      // store level id after successful fragment load\n      this.lastLoadedFragLevel = frag.level;\n      // reset forced auto level value so that next level will be selected\n      this._nextAutoLevel = -1;\n\n      // compute level average bitrate\n      if (this.hls.config.abrMaxWithRealBitrate) {\n        var level = this.hls.levels[frag.level];\n        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n        level.loaded = {\n          bytes: loadedBytes,\n          duration: loadedDuration\n        };\n        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n      }\n      if (frag.bitrateTest) {\n        var fragBufferedData = {\n          stats: stats,\n          frag: frag,\n          part: part,\n          id: frag.type\n        };\n        this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, fragBufferedData);\n      }\n    }\n  };\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n      part = data.part;\n    var stats = part ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN || frag.sn === 'initSegment') {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    var processingMs = stats.parsing.end - stats.loading.start;\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.bwEstimator.getEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  };\n  _proto.onError = function onError(event, data) {\n    var _data$frag;\n    // stop timer in case of frag loading error\n    if (((_data$frag = data.frag) === null || _data$frag === void 0 ? void 0 : _data$frag.type) === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN) {\n      if (data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.KEY_SYSTEM_ERROR) {\n        this.clearTimer();\n        return;\n      }\n      switch (data.details) {\n        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.KEY_LOAD_TIMEOUT:\n          this.clearTimer();\n          break;\n        default:\n          break;\n      }\n    }\n  };\n  _proto.clearTimer = function clearTimer() {\n    self.clearInterval(this.timer);\n    this.timer = undefined;\n  }\n\n  // return next auto level\n  ;\n  _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n    var fragCurrent = this.fragCurrent,\n      partCurrent = this.partCurrent,\n      hls = this.hls;\n    var maxAutoLevel = hls.maxAutoLevel,\n      config = hls.config,\n      minAutoLevel = hls.minAutoLevel,\n      media = hls.media;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    var bufferInfo = hls.mainForwardBufferInfo;\n    var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n    if (bestLevel >= 0) {\n      return bestLevel;\n    }\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace((bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", finding optimal quality level\");\n    // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    // if no matching level found, logic will return 0\n    var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    var bwFactor = config.abrBandWidthFactor;\n    var bwUpFactor = config.abrBandWidthUpFactor;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      var bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace(\"bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\");\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n    return Math.max(bestLevel, 0);\n  };\n  _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n    var _level$details;\n    var fragCurrent = this.fragCurrent,\n      partCurrent = this.partCurrent,\n      currentLevel = this.lastLoadedFragLevel;\n    var levels = this.hls.levels;\n    var level = levels[currentLevel];\n    var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);\n    var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var levelInfo = levels[i];\n      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n        continue;\n      }\n      var levelDetails = levelInfo.details;\n      var avgDuration = (partCurrent ? levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      var adjustedbw = void 0;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (i <= currentLevel) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n      var bitrate = levels[i].maxBitrate;\n      var fetchDuration = bitrate * avgDuration / adjustedbw;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + i + \"/\" + Math.round(adjustedbw) + \"/\" + bitrate + \"/\" + avgDuration + \"/\" + maxFetchDuration + \"/\" + fetchDuration);\n      // if adjusted bw is greater than level bitrate AND\n      if (adjustedbw > bitrate && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration === 0 || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  };\n  _createClass(AbrController, [{\n    key: \"nextAutoLevel\",\n    get: function get() {\n      var forcedAutoLevel = this._nextAutoLevel;\n      var bwEstimator = this.bwEstimator;\n      // in case next auto level has been forced, and bw not available or not reliable, return forced value\n      if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {\n        return forcedAutoLevel;\n      }\n\n      // compute next level using ABR logic\n      var nextABRAutoLevel = this.getNextABRAutoLevel();\n      // use forced auto level when ABR selected level has errored\n      if (forcedAutoLevel !== -1 && this.hls.levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n      // if forced auto level has been defined, use it to cap ABR computed quality level\n      if (forcedAutoLevel !== -1) {\n        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n      }\n      return nextABRAutoLevel;\n    },\n    set: function set(nextLevel) {\n      this._nextAutoLevel = nextLevel;\n    }\n  }]);\n  return AbrController;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbrController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-stream-controller.ts\":\n/*!***************************************************!*\\\n  !*** ./src/controller/audio-stream-controller.ts ***!\n  \\***************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_35876__) => {\n\n\"use strict\";\n__nested_webpack_require_35876__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_35876__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_35876__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_35876__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_35876__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_35876__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_35876__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_35876__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_35876__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_35876__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_35876__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_35876__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_35876__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_35876__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_35876__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_35876__(/*! ../errors */ \"./src/errors.ts\");\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\nvar AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(AudioStreamController, _BaseStreamController);\n  function AudioStreamController(hls, fragmentTracker, keyLoader) {\n    var _this;\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[audio-stream-controller]') || this;\n    _this.videoBuffer = null;\n    _this.videoTrackCC = -1;\n    _this.waitingVideoCC = -1;\n    _this.audioSwitch = false;\n    _this.trackId = -1;\n    _this.waitingData = null;\n    _this.mainDetails = null;\n    _this.bufferFlushed = false;\n    _this.cachedTrackLoadedData = null;\n    _this._registerListeners();\n    return _this;\n  }\n  var _proto = AudioStreamController.prototype;\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n  };\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  ;\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var frag = _ref.frag,\n      id = _ref.id,\n      initPTS = _ref.initPTS;\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      var cc = frag.cc;\n      this.initPTS[frag.cc] = initPTS;\n      this.log(\"InitPTS for cc: \" + cc + \" found from main: \" + initPTS);\n      this.videoTrackCC = cc;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  };\n  _proto.startLoad = function startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;\n      return;\n    }\n    var lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL);\n    this.fragLoadError = 0;\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n      startPosition = lastCurrentTime;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  };\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE:\n        this.doTickIdle();\n        break;\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK:\n        {\n          var _levels$trackId;\n          var levels = this.levels,\n            trackId = this.trackId;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          var now = performance.now();\n          var retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded(this.trackId);\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n          }\n          break;\n        }\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          var waitingData = this.waitingData;\n          if (waitingData) {\n            var frag = waitingData.frag,\n              part = waitingData.part,\n              cache = waitingData.cache,\n              complete = waitingData.complete;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING;\n              var payload = cache.flush();\n              var data = {\n                frag: frag,\n                part: part,\n                payload: payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              this.log(\"Waiting fragment cc (\" + frag.cc + \") cancelled because video is at cc \" + this.videoTrackCC);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              var pos = this.getLoadPosition();\n              var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              var waitingFragmentAtPosition = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_11__.fragmentWithinToleranceTest)(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n              if (waitingFragmentAtPosition < 0) {\n                this.log(\"Waiting fragment cc (\" + frag.cc + \") @ \" + frag.start + \" cancelled because another fragment at \" + bufferInfo.end + \" is needed\");\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  };\n  _proto.clearWaitingFragment = function clearWaitingFragment() {\n    var waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    }\n  };\n  _proto.resetLoadingState = function resetLoadingState() {\n    this.clearWaitingFragment();\n    _BaseStreamController.prototype.resetLoadingState.call(this);\n  };\n  _proto.onTickEnd = function onTickEnd() {\n    var media = this.media;\n    if (!media || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  };\n  _proto.doTickIdle = function doTickIdle() {\n    var hls = this.hls,\n      levels = this.levels,\n      media = this.media,\n      trackId = this.trackId;\n    var config = hls.config;\n    if (!levels || !levels[trackId]) {\n      return;\n    }\n\n    // if video not attached AND\n    // start fragment already requested OR start frag prefetch not enabled\n    // exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n    var levelInfo = levels[trackId];\n    var trackDetails = levelInfo.details;\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK;\n      return;\n    }\n    var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);\n    }\n    var bufferInfo = this.getFwdBufferInfo(bufferable, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    var audioSwitch = this.audioSwitch;\n    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED;\n      return;\n    }\n    var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n    var bufferLen = bufferInfo.len;\n    var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len);\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n    if (bufferLen >= maxBufLen && !audioSwitch) {\n      return;\n    }\n    var fragments = trackDetails.fragments;\n    var start = fragments[0].start;\n    var targetBufferTime = bufferInfo.end;\n    if (audioSwitch && media) {\n      var pos = this.getLoadPosition();\n      targetBufferTime = pos;\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n\n    // buffer audio up to one target duration ahead of main buffer\n    if (mainBufferInfo && targetBufferTime > mainBufferInfo.end + trackDetails.targetduration) {\n      return;\n    }\n    // wait for main buffer after buffing some audio\n    if ((!mainBufferInfo || !mainBufferInfo.len) && bufferInfo.len) {\n      return;\n    }\n    var frag = this.getNextFragment(targetBufferTime, trackDetails);\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n    this.loadFragment(frag, trackDetails, targetBufferTime);\n  };\n  _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {\n    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.videoBuffer = null;\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n  _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {\n    var audioTracks = _ref2.audioTracks;\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_5__.Level(mediaPlaylist);\n    });\n  };\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var altAudio = !!data.url;\n    this.trackId = data.id;\n    var fragCurrent = this.fragCurrent;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n    }\n    this.fragCurrent = null;\n    this.clearWaitingFragment();\n    // destroy useless transmuxer when switching audio to main\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL);\n    }\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.audioSwitch = true;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    } else {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;\n    }\n    this.tick();\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = false;\n  };\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    if (this.cachedTrackLoadedData !== null) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n      this.cachedTrackLoadedData = null;\n    }\n  };\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var _track$details;\n    if (this.mainDetails == null) {\n      this.cachedTrackLoadedData = data;\n      return;\n    }\n    var levels = this.levels;\n    var newDetails = data.details,\n      trackId = data.id;\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while loading level \" + trackId);\n      return;\n    }\n    this.log(\"Track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"],duration:\" + newDetails.totalduration);\n    var track = levels[trackId];\n    var sliding = 0;\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        (0,_utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__.alignMediaPlaylistByPDT)(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  };\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    var frag = data.frag,\n      part = data.part,\n      payload = data.payload;\n    var config = this.config,\n      trackId = this.trackId,\n      levels = this.levels;\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n    var track = levels[trackId];\n    console.assert(track, 'Audio track is defined on fragment load progress');\n    var details = track.details;\n    console.assert(details, 'Audio track details are defined on fragment load progress');\n    var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    var transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    var initPTS = this.initPTS[frag.cc];\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      var accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      var partIndex = part ? part.index : -1;\n      var partial = partIndex !== -1;\n      var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(\"Unknown video PTS for cc \" + frag.cc + \", waiting for video PTS before demuxing audio frag \" + frag.sn + \" of [\" + details.startSN + \" ,\" + details.endSN + \"],track \" + trackId);\n      var _this$waitingData = this.waitingData = this.waitingData || {\n          frag: frag,\n          part: part,\n          cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__[\"default\"](),\n          complete: false\n        },\n        cache = _this$waitingData.cache;\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;\n    }\n  };\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);\n  };\n  _proto.onBufferReset = function onBufferReset( /* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  };\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer || null;\n    }\n  };\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n      part = data.part;\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO) {\n      if (!this.loadedmetadata && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {\n        var _ref3;\n        if ((_ref3 = this.videoBuffer || this.media) !== null && _ref3 !== void 0 && _ref3.buffered.length) {\n          this.loadedmetadata = true;\n        }\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state + \", audioSwitch: \" + this.audioSwitch);\n      return;\n    }\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n      if (this.audioSwitch) {\n        this.audioSwitch = false;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHED, {\n          id: this.trackId\n        });\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n  };\n  _proto.onError = function onError(event, data) {\n    if (data.type === _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, data);\n      return;\n    }\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_PARSING_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.KEY_LOAD_TIMEOUT:\n        // TODO: Skip fragments that do not belong to this.fragCurrent audio-group id\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, data);\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED) {\n          // if fatal error, stop processing, otherwise move to IDLE to retry loading\n          this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n          this.warn(data.details + \" while loading frag, switching to \" + this.state + \" state\");\n        }\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'audio' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);\n          // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole audio buffer to recover\n            this.warn('Buffer full error also media.currentTime is not buffered, flush audio buffer');\n            this.fragCurrent = null;\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n          }\n          this.resetLoadingState();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {\n    var type = _ref4.type;\n    if (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO) {\n      this.bufferFlushed = true;\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n      }\n    }\n  };\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    var id = 'audio';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n      chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n    var frag = context.frag,\n      part = context.part,\n      details = context.level.details;\n    var audio = remuxResult.audio,\n      text = remuxResult.text,\n      id3 = remuxResult.id3,\n      initSegment = remuxResult.initSegment;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      return;\n    }\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING;\n    if (this.audioSwitch && audio) {\n      this.completeAudioSwitch();\n    }\n    if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {\n      this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: frag,\n        id: id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n\n    if (audio) {\n      var startPTS = audio.startPTS,\n        endPTS = audio.endPTS,\n        startDTS = audio.startDTS,\n        endDTS = audio.endDTS;\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO] = {\n          startPTS: startPTS,\n          endPTS: endPTS,\n          startDTS: startDTS,\n          endDTS: endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = _extends({\n        id: id,\n        frag: frag,\n        details: details\n      }, id3);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      var emittedText = _extends({\n        id: id,\n        frag: frag,\n        details: details\n      }, text);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n  _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n\n    // include levelCodec in audio and video tracks\n    var track = tracks.audio;\n    if (!track) {\n      return;\n    }\n    track.levelCodec = track.codec;\n    track.id = 'audio';\n    this.log(\"Init audio buffer, container:\" + track.container + \", codecs[parsed]=[\" + track.codec + \"]\");\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CODECS, tracks);\n    var initSegment = track.initSegment;\n    if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n      var segment = {\n        type: 'audio',\n        frag: frag,\n        part: null,\n        chunkMeta: chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tick();\n  };\n  _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__.FragmentState.NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__.FragmentState.PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, trackDetails);\n      } else if (trackDetails.live && !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.initPTS[frag.cc])) {\n        this.log(\"Waiting for video PTS in continuity counter \" + frag.cc + \" of live stream before loading audio fragment \" + frag.sn + \" of level \" + this.trackId);\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;\n      } else {\n        this.startFragRequested = true;\n        _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n  _proto.completeAudioSwitch = function completeAudioSwitch() {\n    var hls = this.hls,\n      media = this.media,\n      trackId = this.trackId;\n    if (media) {\n      this.log('Switching audio track : flushing all audio');\n      _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n    }\n    this.audioSwitch = false;\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHED, {\n      id: trackId\n    });\n  };\n  return AudioStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioStreamController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-track-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/audio-track-controller.ts ***!\n  \\**************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_71759__) => {\n\n\"use strict\";\n__nested_webpack_require_71759__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_71759__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_71759__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_71759__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_71759__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_71759__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(AudioTrackController, _BasePlaylistControll);\n  function AudioTrackController(hls) {\n    var _this;\n    _this = _BasePlaylistControll.call(this, hls, '[audio-track-controller]') || this;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.trackName = '';\n    _this.selectDefaultTrack = true;\n    _this.registerListeners();\n    return _this;\n  }\n  var _proto = AudioTrackController.prototype;\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.trackName = '';\n    this.selectDefaultTrack = true;\n  };\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  };\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var id = data.id,\n      details = data.details;\n    var currentTrack = this.tracksInGroup[id];\n    if (!currentTrack) {\n      this.warn(\"Invalid audio track id \" + id);\n      return;\n    }\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"audioTrack \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {\n      return;\n    }\n    var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];\n    if (this.groupId !== audioGroupId) {\n      this.groupId = audioGroupId;\n      var audioTracks = this.tracks.filter(function (track) {\n        return !audioGroupId || track.groupId === audioGroupId;\n      });\n\n      // Disable selectDefaultTrack if there are no default tracks\n      if (this.selectDefaultTrack && !audioTracks.some(function (track) {\n        return track.default;\n      })) {\n        this.selectDefaultTrack = false;\n      }\n      this.tracksInGroup = audioTracks;\n      var audioTracksUpdated = {\n        audioTracks: audioTracks\n      };\n      this.log(\"Updating audio tracks, \" + audioTracks.length + \" track(s) found in \\\"\" + audioGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      this.selectInitialTrack();\n    }\n  };\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__.PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  };\n  _proto.setAudioTrack = function setAudioTrack(newId) {\n    var tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn('Invalid id passed to audio-track controller');\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    var lastTrack = tracks[this.trackId];\n    this.log(\"Now switching to audio-track index \" + newId);\n    var track = tracks[newId];\n    var id = track.id,\n      _track$groupId = track.groupId,\n      groupId = _track$groupId === void 0 ? '' : _track$groupId,\n      name = track.name,\n      type = track.type,\n      url = track.url;\n    this.trackId = newId;\n    this.trackName = name;\n    this.selectDefaultTrack = false;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_SWITCHING, {\n      id: id,\n      groupId: groupId,\n      name: name,\n      type: type,\n      url: url\n    });\n    // Do not reload track unless live\n    if (track.details && !track.details.live) {\n      return;\n    }\n    var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n    this.loadPlaylist(hlsUrlParameters);\n  };\n  _proto.selectInitialTrack = function selectInitialTrack() {\n    var audioTracks = this.tracksInGroup;\n    console.assert(audioTracks.length, 'Initial audio track should be selected when tracks are known');\n    var currentAudioTrackName = this.trackName;\n    var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();\n    if (trackId !== -1) {\n      this.setAudioTrack(trackId);\n    } else {\n      this.warn(\"No track found for running audio group-ID: \" + this.groupId);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n        fatal: true\n      });\n    }\n  };\n  _proto.findTrackId = function findTrackId(name) {\n    var audioTracks = this.tracksInGroup;\n    for (var i = 0; i < audioTracks.length; i++) {\n      var track = audioTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  };\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    _BasePlaylistControll.prototype.loadPlaylist.call(this);\n    var audioTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadTrack(audioTrack)) {\n      var id = audioTrack.id;\n      var groupId = audioTrack.groupId;\n      var url = audioTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n      // track not retrieved yet, or live playlist we need to (re)load it\n      this.log(\"loading audio-track playlist for id: \" + id);\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n  _createClass(AudioTrackController, [{\n    key: \"audioTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      // If audio track is selected from API then don't choose from the manifest default track\n      this.selectDefaultTrack = false;\n      this.setAudioTrack(newId);\n    }\n  }]);\n  return AudioTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/base-playlist-controller.ts\":\n/*!****************************************************!*\\\n  !*** ./src/controller/base-playlist-controller.ts ***!\n  \\****************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_83047__) => {\n\n\"use strict\";\n__nested_webpack_require_83047__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_83047__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BasePlaylistController)\n/* harmony export */ });\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_83047__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_83047__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_83047__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_83047__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\n\nvar BasePlaylistController = /*#__PURE__*/function () {\n  function BasePlaylistController(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.requestScheduled = -1;\n    this.canLoad = false;\n    this.retryCount = 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, logPrefix + \":\");\n    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, logPrefix + \":\");\n    this.hls = hls;\n  }\n  var _proto = BasePlaylistController.prototype;\n  _proto.destroy = function destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  };\n  _proto.onError = function onError(event, data) {\n    if (data.fatal && (data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.NETWORK_ERROR || data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.KEY_SYSTEM_ERROR)) {\n      this.stopLoad();\n    }\n  };\n  _proto.clearTimer = function clearTimer() {\n    clearTimeout(this.timer);\n    this.timer = -1;\n  };\n  _proto.startLoad = function startLoad() {\n    this.canLoad = true;\n    this.retryCount = 0;\n    this.requestScheduled = -1;\n    this.loadPlaylist();\n  };\n  _proto.stopLoad = function stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  };\n  _proto.switchParams = function switchParams(playlistUri, previous) {\n    var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      for (var i = 0; i < renditionReports.length; i++) {\n        var attr = renditionReports[i];\n        var uri = void 0;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"Could not construct new URL for Rendition Report: \" + error);\n          uri = attr.URI || '';\n        }\n        if (uri === playlistUri.slice(-uri.length)) {\n          var msn = parseInt(attr['LAST-MSN']) || (previous === null || previous === void 0 ? void 0 : previous.lastPartSn);\n          var part = parseInt(attr['LAST-PART']) || (previous === null || previous === void 0 ? void 0 : previous.lastPartIndex);\n          if (this.hls.config.lowLatencyMode) {\n            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n            if (part >= 0 && currentGoal > previous.partTarget) {\n              part += 1;\n            }\n          }\n          return new _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsUrlParameters(msn, part >= 0 ? part : undefined, _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsSkip.No);\n        }\n      }\n    }\n  };\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    if (this.requestScheduled === -1) {\n      this.requestScheduled = self.performance.now();\n    }\n  };\n  _proto.shouldLoadTrack = function shouldLoadTrack(track) {\n    return this.canLoad && track && !!track.url && (!track.details || track.details.live);\n  };\n  _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n    var _this = this;\n    var details = data.details,\n      stats = data.stats;\n\n    // Set last updated date-time\n    var now = self.performance.now();\n    var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails !== null && previousDetails !== void 0 && previousDetails.live) {\n      details.reloaded(previousDetails);\n      if (previousDetails) {\n        this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));\n      }\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        (0,_level_helper__WEBPACK_IMPORTED_MODULE_1__.mergeDetails)(previousDetails, details);\n      }\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      var deliveryDirectives;\n      var msn = undefined;\n      var part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        var lowLatencyMode = this.hls.config.lowLatencyMode;\n        var lastPartSn = details.lastPartSn;\n        var endSn = details.endSN;\n        var lastPartIndex = details.lastPartIndex;\n        var hasParts = lastPartIndex !== -1;\n        var lastPart = lastPartSn === endSn;\n        // When low latency mode is disabled, we'll skip part requests once the last part index is found\n        var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        var lastAdvanced = details.age;\n        var cdnAge = lastAdvanced + details.ageHeader;\n        var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n            currentGoal = 0;\n          } else {\n            var segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      var bufferInfo = this.hls.mainForwardBufferInfo;\n      var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      var distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      var reloadInterval = (0,_level_helper__WEBPACK_IMPORTED_MODULE_1__.computeReloadInterval)(details, distanceToLiveEdgeMs);\n      if (!details.updated) {\n        this.requestScheduled = -1;\n      } else if (now > this.requestScheduled + reloadInterval) {\n        this.requestScheduled = stats.loading.start;\n      }\n      if (msn !== undefined && details.canBlockReload) {\n        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n      } else {\n        this.requestScheduled = (this.requestScheduled === -1 ? now : this.requestScheduled) + reloadInterval;\n      }\n      var estimatedTimeUntilUpdate = this.requestScheduled - now;\n      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n      this.log(\"reload live playlist \" + index + \" in \" + Math.round(estimatedTimeUntilUpdate) + \" ms\");\n      //     this.log(\n      //       `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n      // reload in ${estimatedTimeUntilUpdate / 1000}\n      // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n      // diff ${\n      //   (reloadInterval -\n      //     (estimatedTimeUntilUpdate + stats.loading.end - stats.loading.start)) /\n      //   1000\n      // }\n      // reload interval ${reloadInterval / 1000}\n      // target duration ${details.targetduration}\n      // distance to edge ${distanceToLiveEdgeMs / 1000}`\n      //     );\n\n      this.timer = self.setTimeout(function () {\n        return _this.loadPlaylist(deliveryDirectives);\n      }, estimatedTimeUntilUpdate);\n    } else {\n      this.clearTimer();\n    }\n  };\n  _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    var skip = (0,_types_level__WEBPACK_IMPORTED_MODULE_0__.getSkipValue)(details, msn);\n    if (previousDeliveryDirectives !== null && previousDeliveryDirectives !== void 0 && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsSkip.No;\n    }\n    return new _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsUrlParameters(msn, part, skip);\n  };\n  _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {\n    var _this2 = this;\n    var config = this.hls.config;\n    var retry = this.retryCount < config.levelLoadingMaxRetry;\n    if (retry) {\n      var _errorEvent$context;\n      this.requestScheduled = -1;\n      this.retryCount++;\n      if (errorEvent.details.indexOf('LoadTimeOut') > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" after \\\"\" + errorEvent.details + \"\\\"\");\n        this.loadPlaylist();\n      } else {\n        // exponential backoff capped to max retry timeout\n        var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);\n        // Schedule level/track reload\n        this.timer = self.setTimeout(function () {\n          return _this2.loadPlaylist();\n        }, delay);\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" in \" + delay + \" ms after \\\"\" + errorEvent.details + \"\\\"\");\n      }\n    } else {\n      this.warn(\"cannot recover from error \\\"\" + errorEvent.details + \"\\\"\");\n      // stopping live reloading timer if any\n      this.clearTimer();\n      // switch error to fatal\n      errorEvent.fatal = true;\n    }\n    return retry;\n  };\n  return BasePlaylistController;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/base-stream-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/base-stream-controller.ts ***!\n  \\**************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_94870__) => {\n\n\"use strict\";\n__nested_webpack_require_94870__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_94870__.d(__nested_webpack_exports__, {\n/* harmony export */   \"State\": () => (/* binding */ State),\n/* harmony export */   \"default\": () => (/* binding */ BaseStreamController)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_94870__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_94870__(/*! ../task-loop */ \"./src/task-loop.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_94870__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_94870__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_94870__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_94870__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_94870__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_94870__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_94870__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_94870__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_94870__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_94870__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_94870__(/*! ../loader/fragment-loader */ \"./src/loader/fragment-loader.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_94870__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_94870__(/*! ../utils/time-ranges */ \"./src/utils/time-ranges.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_94870__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nvar BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n  _inheritsLoose(BaseStreamController, _TaskLoop);\n  function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix) {\n    var _this;\n    _this = _TaskLoop.call(this) || this;\n    _this.hls = void 0;\n    _this.fragPrevious = null;\n    _this.fragCurrent = null;\n    _this.fragmentTracker = void 0;\n    _this.transmuxer = null;\n    _this._state = State.STOPPED;\n    _this.media = null;\n    _this.mediaBuffer = null;\n    _this.config = void 0;\n    _this.bitrateTest = false;\n    _this.lastCurrentTime = 0;\n    _this.nextLoadPosition = 0;\n    _this.startPosition = 0;\n    _this.loadedmetadata = false;\n    _this.fragLoadError = 0;\n    _this.retryDate = 0;\n    _this.levels = null;\n    _this.fragmentLoader = void 0;\n    _this.keyLoader = void 0;\n    _this.levelLastLoaded = null;\n    _this.startFragRequested = false;\n    _this.decrypter = void 0;\n    _this.initPTS = [];\n    _this.onvseeking = null;\n    _this.onvended = null;\n    _this.logPrefix = '';\n    _this.log = void 0;\n    _this.warn = void 0;\n    _this.logPrefix = logPrefix;\n    _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger, logPrefix + \":\");\n    _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger, logPrefix + \":\");\n    _this.hls = hls;\n    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"](hls.config);\n    _this.keyLoader = keyLoader;\n    _this.fragmentTracker = fragmentTracker;\n    _this.config = hls.config;\n    _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__[\"default\"](hls.config);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_SWITCHING, _this.onLevelSwitching, _assertThisInitialized(_this));\n    return _this;\n  }\n  var _proto = BaseStreamController.prototype;\n  _proto.doTick = function doTick() {\n    this.onTickEnd();\n  };\n  _proto.onTickEnd = function onTickEnd() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n  _proto.startLoad = function startLoad(startPosition) {};\n  _proto.stopLoad = function stopLoad() {\n    this.fragmentLoader.abort();\n    this.keyLoader.abort();\n    var frag = this.fragCurrent;\n    if (frag) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  };\n  _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n    // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n    // of nothing loading/loaded return false\n    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n      return false;\n    }\n    var partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList !== null && partList !== void 0 && partList.length) {\n      var lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      var lastPartBuffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  };\n  _proto.getLevelDetails = function getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levels$this$lev;\n      return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) === null || _this$levels$this$lev === void 0 ? void 0 : _this$levels$this$lev.details;\n    }\n  };\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    var media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    var config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n    if (media !== null && media !== void 0 && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    if (media && this.onvseeking && this.onvended) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n    if (this.keyLoader) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  };\n  _proto.onMediaSeeking = function onMediaSeeking() {\n    var config = this.config,\n      fragCurrent = this.fragCurrent,\n      media = this.media,\n      mediaBuffer = this.mediaBuffer,\n      state = this.state;\n    var currentTime = media ? media.currentTime : 0;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n    this.log(\"media seeking to \" + ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent) {\n      // Seeking while frag load is in progress\n      var tolerance = config.maxFragLookUpTolerance;\n      var fragStartOffset = fragCurrent.start - tolerance;\n      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      // if seeking out of buffered range or into new one\n      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n        var pastFragment = currentTime > fragEndOffset;\n        // if the seek position is outside the current fragment range\n        if (currentTime < fragStartOffset || pastFragment) {\n          if (pastFragment && fragCurrent.loader) {\n            this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n            fragCurrent.abortRequests();\n          }\n          this.resetLoadingState();\n        }\n      }\n    }\n    if (media) {\n      this.lastCurrentTime = currentTime;\n    }\n\n    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    }\n\n    // Async tick to speed up processing\n    this.tickImmediate();\n  };\n  _proto.onMediaEnded = function onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  };\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.fragLoadError = 0;\n  };\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this.stopLoad();\n    _TaskLoop.prototype.onHandlerDestroying.call(this);\n  };\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    _TaskLoop.prototype.onHandlerDestroyed.call(this);\n  };\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this._loadFragForPlayback(frag, levelDetails, targetBufferTime);\n  };\n  _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {\n    var _this2 = this;\n    var progressCallback = function progressCallback(data) {\n      if (_this2.fragContextChanged(frag)) {\n        _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n        _this2.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      _this2._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback).then(function (data) {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      _this2.fragLoadError = 0;\n      var state = _this2.state;\n      if (_this2.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {\n          _this2.fragmentTracker.removeFragment(frag);\n          _this2.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n        _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      _this2._handleFragmentLoadComplete(data);\n    }).catch(function (reason) {\n      if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {\n        return;\n      }\n      _this2.warn(reason);\n      _this2.resetFragmentLoading(frag);\n    });\n  };\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n    if (type === void 0) {\n      type = null;\n    }\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    var flushScope = {\n      startOffset: startOffset,\n      endOffset: endOffset,\n      type: type\n    };\n    // Reset load errors on flush\n    this.fragLoadError = 0;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.BUFFER_FLUSHING, flushScope);\n  };\n  _proto._loadInitSegment = function _loadInitSegment(frag, details) {\n    var _this3 = this;\n    this._doFragLoad(frag, details).then(function (data) {\n      if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(function (data) {\n      var hls = _this3.hls;\n      var payload = data.payload;\n      var decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        var startTime = self.performance.now();\n        // decrypt the subtitles\n        return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n          var endTime = self.performance.now();\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_DECRYPTED, {\n            frag: frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return data;\n        });\n      }\n      return data;\n    }).then(function (data) {\n      var fragCurrent = _this3.fragCurrent,\n        hls = _this3.hls,\n        levels = _this3.levels;\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n      var details = levels[frag.level].details;\n      console.assert(details, 'Level details are defined when init segment is loaded');\n      var stats = frag.stats;\n      _this3.state = State.IDLE;\n      _this3.fragLoadError = 0;\n      frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now();\n\n      // Silence FRAG_BUFFERED event if fragCurrent is null\n      if (data.frag === fragCurrent) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_BUFFERED, {\n          stats: stats,\n          frag: fragCurrent,\n          part: null,\n          id: frag.type\n        });\n      }\n      _this3.tick();\n    }).catch(function (reason) {\n      if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n        return;\n      }\n      _this3.warn(reason);\n      _this3.resetFragmentLoading(frag);\n    });\n  };\n  _proto.fragContextChanged = function fragContextChanged(frag) {\n    var fragCurrent = this.fragCurrent;\n    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n  };\n  _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n    var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level + \" (frag:[\" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + \"-\" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + \"] > buffer:\" + (media ? _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__[\"default\"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.getBuffered(media)) : '(detached)') + \")\");\n    this.state = State.IDLE;\n    if (!media) {\n      return;\n    }\n    if (!this.loadedmetadata && frag.type == _types_loader__WEBPACK_IMPORTED_MODULE_15__.PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) === null || _this$fragCurrent === void 0 ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) === null || _this$fragPrevious === void 0 ? void 0 : _this$fragPrevious.sn)) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    }\n    this.tick();\n  };\n  _proto.seekToStartPos = function seekToStartPos() {};\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n    var transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      return;\n    }\n    var frag = fragLoadedEndData.frag,\n      part = fragLoadedEndData.part,\n      partsLoaded = fragLoadedEndData.partsLoaded;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n      return !fragLoaded;\n    });\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n  _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {\n    var _frag$decryptdata,\n      _this4 = this;\n    if (targetBufferTime === void 0) {\n      targetBufferTime = null;\n    }\n    if (!this.levels) {\n      throw new Error('frag load aborted, missing levels');\n    }\n    var keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) !== null && _frag$decryptdata !== void 0 && _frag$decryptdata.key)) {\n      this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {\n        if (!_this4.fragContextChanged(keyLoadedData.frag)) {\n          _this4.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_LOADED, keyLoadedData);\n          if (_this4.state === State.KEY_LOADING) {\n            _this4.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_LOADING, {\n        frag: frag\n      });\n      this.throwIfFragContextChanged('KEY_LOADING');\n    } else if (!frag.encrypted && details.encryptedFragments.length) {\n      this.keyLoader.loadClear(frag, details.encryptedFragments);\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.config.lowLatencyMode && details) {\n      var partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          var part = partList[partIndex];\n          this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADING, {\n            frag: frag,\n            part: partList[partIndex],\n            targetBufferTime: targetBufferTime\n          });\n          this.throwIfFragContextChanged('FRAG_LOADING parts');\n          if (keyLoadingPromise) {\n            return keyLoadingPromise.then(function (keyLoadedData) {\n              if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return _this4.doFragPartsLoad(frag, partList, partIndex, progressCallback);\n            }).catch(function (error) {\n              return _this4.handleFragLoadError(error);\n            });\n          }\n          return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADING, {\n      frag: frag,\n      targetBufferTime: targetBufferTime\n    });\n    this.throwIfFragContextChanged('FRAG_LOADING');\n\n    // Load key before streaming fragment data\n    var dataOnProgress = this.config.progressive;\n    if (dataOnProgress && keyLoadingPromise) {\n      return keyLoadingPromise.then(function (keyLoadedData) {\n        if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData === null || keyLoadedData === void 0 ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return _this4.fragmentLoader.load(frag, progressCallback);\n      }).catch(function (error) {\n        return _this4.handleFragLoadError(error);\n      });\n    }\n\n    // load unencrypted fragment data with progress event,\n    // or handle fragment result after key and fragment are finished loading\n    return Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {\n      var fragLoadedData = _ref[0];\n      if (!dataOnProgress && fragLoadedData && progressCallback) {\n        progressCallback(fragLoadedData);\n      }\n      return fragLoadedData;\n    }).catch(function (error) {\n      return _this4.handleFragLoadError(error);\n    });\n  };\n  _proto.throwIfFragContextChanged = function throwIfFragContextChanged(context) {\n    // exit if context changed during event loop\n    if (this.fragCurrent === null) {\n      throw new Error(\"frag load aborted, context changed in \" + context);\n    }\n  };\n  _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {\n    var _this5 = this;\n    return new Promise(function (resolve, reject) {\n      var partsLoaded = [];\n      var loadPartIndex = function loadPartIndex(index) {\n        var part = partList[index];\n        _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n          partsLoaded[part.index] = partLoadedData;\n          var loadedPart = partLoadedData.part;\n          _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADED, partLoadedData);\n          var nextPart = partList[index + 1];\n          if (nextPart && nextPart.fragment === frag) {\n            loadPartIndex(index + 1);\n          } else {\n            return resolve({\n              frag: frag,\n              part: loadedPart,\n              partsLoaded: partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPartIndex(partIndex);\n    });\n  };\n  _proto.handleFragLoadError = function handleFragLoadError(error) {\n    if ('data' in error) {\n      var data = error.data;\n      if (error.data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorTypes.OTHER_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        fatal: true\n      });\n    }\n    return null;\n  };\n  _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n    var context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    var frag = context.frag,\n      part = context.part,\n      level = context.level;\n    var now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  };\n  _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n    var levels = this.levels;\n    var levelIndex = chunkMeta.level,\n      sn = chunkMeta.sn,\n      partIndex = chunkMeta.part;\n    if (!levels || !levels[levelIndex]) {\n      this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n      return null;\n    }\n    var level = levels[levelIndex];\n    var part = partIndex > -1 ? (0,_level_helper__WEBPACK_IMPORTED_MODULE_11__.getPartWith)(level, sn, partIndex) : null;\n    var frag = part ? part.fragment : (0,_level_helper__WEBPACK_IMPORTED_MODULE_11__.getFragmentWithSN)(level, sn, this.fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    return {\n      frag: frag,\n      part: part,\n      level: level\n    };\n  };\n  _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    var data1 = data.data1,\n      data2 = data.data2;\n    var buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.appendUint8Array)(data1, data2);\n    }\n    if (!buffer || !buffer.length) {\n      return;\n    }\n    var segment = {\n      type: data.type,\n      frag: frag,\n      part: part,\n      chunkMeta: chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  };\n  _proto.flushBufferGap = function flushBufferGap(frag) {\n    var media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    var currentTime = media.currentTime;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(media, currentTime, 0);\n    var fragDuration = frag.duration;\n    var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  };\n  _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n    var config = this.config;\n    var pos = this.getLoadPosition();\n    if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(pos)) {\n      return null;\n    }\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(bufferable, pos, config.maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, config.maxBufferHole));\n      }\n    }\n    return bufferInfo;\n  };\n  _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n    var config = this.config;\n    var maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  };\n  _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {\n    var config = this.config;\n    var minLength = threshold || config.maxBufferLength;\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(\"Reduce max buffer length to \" + config.maxMaxBufferLength + \"s\");\n      return true;\n    }\n    return false;\n  };\n  _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n    var fragments = levelDetails.fragments;\n    var fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    var config = this.config;\n    var start = fragments[0].start;\n    var frag;\n    if (levelDetails.live) {\n      var initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(frag);\n  };\n  _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag !== null && frag !== void 0 && frag.initSegment && !(frag !== null && frag !== void 0 && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  };\n  _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n    var nextPart = -1;\n    var contiguous = false;\n    var independentAttrOmitted = true;\n    for (var i = 0, len = partList.length; i < len; i++) {\n      var part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      var loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  };\n  _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n    var lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */;\n  _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n    var fragPrevious = this.fragPrevious;\n    var frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n        frag = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        var targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          var fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragWithCC)(fragments, fragPrevious.cc);\n          if (frag) {\n            this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      var liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */;\n  _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    var config = this.config;\n    var fragPrevious = this.fragPrevious;\n    var fragments = levelDetails.fragments,\n      endSN = levelDetails.endSN;\n    var fragmentHint = levelDetails.fragmentHint;\n    var tolerance = config.maxFragLookUpTolerance;\n    var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    var frag;\n    if (bufferEnd < end) {\n      var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      var curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      if (this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__.FragmentState.OK) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          var nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__.FragmentState.OK) {\n            this.log(\"SN \" + frag.sn + \" just loaded, load next one: \" + nextFrag.sn);\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  };\n  _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n    var config = this.config,\n      media = this.media;\n    if (!media) {\n      return;\n    }\n    var liveSyncPosition = this.hls.liveSyncPosition;\n    var currentTime = media.currentTime;\n    var start = levelDetails.fragments[0].start;\n    var end = levelDetails.edge;\n    var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  };\n  _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {\n    var levels = this.levels,\n      levelLastLoaded = this.levelLastLoaded,\n      fragPrevious = this.fragPrevious;\n    var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;\n\n    // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    var length = details.fragments.length;\n    if (!length) {\n      this.warn(\"No fragments in live playlist\");\n      return 0;\n    }\n    var slidingStart = details.fragments[0].start;\n    var firstLevelLoad = !previousDetails;\n    var aligned = details.alignedSliding && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      (0,_utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__.alignStream)(fragPrevious, lastLevel, details);\n      var alignedSlidingStart = details.fragments[0].start;\n      this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  };\n  _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    var advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  };\n  _proto.setStartPosition = function setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    var startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // first, check if start time offset has been set in playlist, if yes, use this value\n      var startTimeOffset = details.startTimeOffset;\n      if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(\"Start time offset \" + startTimeOffset + \" found in playlist, adjust startPosition to \" + startPosition);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition;\n    }\n    this.nextLoadPosition = startPosition;\n  };\n  _proto.getLoadPosition = function getLoadPosition() {\n    var media = this.media;\n    // if we have not yet loaded any fragment, start loading from start position\n    var pos = 0;\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  };\n  _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(\"Fragment \" + frag.sn + (part ? ' part' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n      this.resetFragmentLoading(frag);\n    }\n  };\n  _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  };\n  _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n    if (data.fatal) {\n      this.stopLoad();\n      this.state = State.ERROR;\n      return;\n    }\n    var config = this.config;\n    if (data.chunkMeta) {\n      // Parsing Error: no retries\n      var context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n        data.levelRetry = true;\n        this.fragLoadError = config.fragLoadingMaxRetry;\n      }\n    }\n    var frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType) {\n      return;\n    }\n    var fragCurrent = this.fragCurrent;\n    console.assert(fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level && frag.urlId === fragCurrent.urlId, 'Frag load error must match current frag to retry');\n    // keep retrying until the limit will be reached\n    if (this.fragLoadError + 1 <= config.fragLoadingMaxRetry) {\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n        this.nextLoadPosition = this.startPosition;\n      }\n      // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n      var delay = Math.min(Math.pow(2, this.fragLoadError) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n      this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" failed to load, retrying in \" + delay + \"ms\");\n      this.retryDate = self.performance.now() + delay;\n      this.fragLoadError++;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (data.levelRetry) {\n      if (filterType === _types_loader__WEBPACK_IMPORTED_MODULE_15__.PlaylistLevelType.AUDIO) {\n        // Reset current fragment since audio track audio is essential and may not have a fail-over track\n        this.fragCurrent = null;\n      }\n      // Fragment errors that result in a level switch or redundant fail-over\n      // should reset the stream controller state to idle\n      this.fragLoadError = 0;\n      this.state = State.IDLE;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.error(data.details + \" reaches max retry, redispatch as fatal ...\");\n      // switch error to fatal\n      data.fatal = true;\n      this.hls.stopLoad();\n      this.state = State.ERROR;\n    }\n  };\n  _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    var bufferedTimeRanges = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  };\n  _proto.resetLoadingState = function resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  };\n  _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      var details = this.levels ? this.levels[level].details : null;\n      if (details !== null && details !== void 0 && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  };\n  _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n    var _this6 = this;\n    var details = level.details;\n    console.assert(!!details, 'level.details must be defined');\n    var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n      var info = frag.elementaryStreams[type];\n      if (info) {\n        var parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n          return result || false;\n        }\n        var drift = partial ? 0 : (0,_level_helper__WEBPACK_IMPORTED_MODULE_11__.updateFragPTSDTS)(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_PTS_UPDATED, {\n          details: details,\n          level: level,\n          drift: drift,\n          type: type,\n          frag: frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (!parsed) {\n      this.warn(\"Found no media in fragment \" + frag.sn + \" of level \" + level.id + \" resetting transmuxer to fallback to playlist timing\");\n      this.resetTransmuxer();\n    }\n    this.state = State.PARSED;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_PARSED, {\n      frag: frag,\n      part: part\n    });\n  };\n  _proto.resetTransmuxer = function resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  };\n  _createClass(BaseStreamController, [{\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    },\n    set: function set(nextState) {\n      var previousState = this._state;\n      if (previousState !== nextState) {\n        this._state = nextState;\n        this.log(previousState + \"->\" + nextState);\n      }\n    }\n  }]);\n  return BaseStreamController;\n}(_task_loop__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/buffer-controller.ts ***!\n  \\*********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_148137__) => {\n\n\"use strict\";\n__nested_webpack_require_148137__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_148137__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BufferController)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_148137__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_148137__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_148137__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_148137__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_148137__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_148137__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_148137__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_148137__(/*! ./buffer-operation-queue */ \"./src/controller/buffer-operation-queue.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar MediaSource = (0,_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__.getMediaSource)();\nvar VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\nvar BufferController = /*#__PURE__*/function () {\n  // The level details used to determine duration, target-duration and live\n\n  // cache the self generated object url to detect hijack of video tag\n\n  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n\n  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n\n  // The number of BUFFER_CODEC events received before any sourceBuffers are created\n\n  // The total number of BUFFER_CODEC events received\n\n  // A reference to the attached media element\n\n  // A reference to the active media source\n\n  // Last MP3 audio chunk appended\n\n  // counters\n\n  function BufferController(hls) {\n    var _this = this;\n    this.details = null;\n    this._objectUrl = null;\n    this.operationQueue = void 0;\n    this.listeners = void 0;\n    this.hls = void 0;\n    this.bufferCodecEventsExpected = 0;\n    this._bufferCodecEventsTotal = 0;\n    this.media = null;\n    this.mediaSource = null;\n    this.lastMpegAudioChunk = null;\n    this.appendError = 0;\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n    this._onMediaSourceOpen = function () {\n      var media = _this.media,\n        mediaSource = _this.mediaSource;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: Media source opened');\n      if (media) {\n        media.removeEventListener('emptied', _this._onMediaEmptied);\n        _this.updateMediaElementDuration();\n        _this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, {\n          media: media\n        });\n      }\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n      }\n      _this.checkPendingTracks();\n    };\n    this._onMediaSourceClose = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: Media source closed');\n    };\n    this._onMediaSourceEnded = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: Media source ended');\n    };\n    this._onMediaEmptied = function () {\n      var media = _this.media,\n        _objectUrl = _this._objectUrl;\n      if (media && media.src !== _objectUrl) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(\"Media element src was set while attaching MediaSource (\" + _objectUrl + \" > \" + media.src + \")\");\n      }\n    };\n    this.hls = hls;\n    this._initSourceBuffer();\n    this.registerListeners();\n  }\n  var _proto = BufferController.prototype;\n  _proto.hasSourceTypes = function hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = null;\n  };\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_CHANGED, this.onFragChanged, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_CHANGED, this.onFragChanged, this);\n  };\n  _proto._initSourceBuffer = function _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n    this.lastMpegAudioChunk = null;\n  };\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    var codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    this.details = null;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n  };\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var media = this.media = data.media;\n    if (media && MediaSource) {\n      var ms = this.mediaSource = new MediaSource();\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      // link video and media Source\n      media.src = self.URL.createObjectURL(ms);\n      // cache the locally generated object url\n      this._objectUrl = media.src;\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media,\n      mediaSource = this.mediaSource,\n      _objectUrl = this._objectUrl;\n    if (mediaSource) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: media source detaching');\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n        }\n      }\n      // Clean up the SourceBuffers by invoking onBufferReset\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (media.src === _objectUrl) {\n          media.removeAttribute('src');\n          media.load();\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHED, undefined);\n  };\n  _proto.onBufferReset = function onBufferReset() {\n    var _this2 = this;\n    this.getSourceBufferTypes().forEach(function (type) {\n      var sb = _this2.sourceBuffer[type];\n      try {\n        if (sb) {\n          _this2.removeBufferListeners(type);\n          if (_this2.mediaSource) {\n            _this2.mediaSource.removeSourceBuffer(sb);\n          }\n          // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n          _this2.sourceBuffer[type] = undefined;\n        }\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: Failed to reset the \" + type + \" buffer\", err);\n      }\n    });\n    this._initSourceBuffer();\n  };\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var _this3 = this;\n    var sourceBufferCount = this.getSourceBufferTypes().length;\n    Object.keys(data).forEach(function (trackName) {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        var track = _this3.tracks[trackName];\n        if (track && typeof track.buffer.changeType === 'function') {\n          var _data$trackName = data[trackName],\n            id = _data$trackName.id,\n            codec = _data$trackName.codec,\n            levelCodec = _data$trackName.levelCodec,\n            container = _data$trackName.container,\n            metadata = _data$trackName.metadata;\n          var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          if (currentCodec !== nextCodec) {\n            var mimeType = container + \";codecs=\" + (levelCodec || codec);\n            _this3.appendChangeType(trackName, mimeType);\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: switching codec \" + currentCodec + \" to \" + nextCodec);\n            _this3.tracks[trackName] = {\n              buffer: track.buffer,\n              codec: codec,\n              container: container,\n              levelCodec: levelCodec,\n              metadata: metadata,\n              id: id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        _this3.pendingTracks[trackName] = data[trackName];\n      }\n    });\n\n    // if sourcebuffers already created, do nothing ...\n    if (sourceBufferCount) {\n      return;\n    }\n    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  };\n  _proto.appendChangeType = function appendChangeType(type, mimeType) {\n    var _this4 = this;\n    var operationQueue = this.operationQueue;\n    var operation = {\n      execute: function execute() {\n        var sb = _this4.sourceBuffer[type];\n        if (sb) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: changing \" + type + \" sourceBuffer type to \" + mimeType);\n          sb.changeType(mimeType);\n        }\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError(e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: Failed to change \" + type + \" SourceBuffer type\", e);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n  _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n    var _this5 = this;\n    var hls = this.hls,\n      operationQueue = this.operationQueue,\n      tracks = this.tracks;\n    var data = eventData.data,\n      type = eventData.type,\n      frag = eventData.frag,\n      part = eventData.part,\n      chunkMeta = eventData.chunkMeta;\n    var chunkStats = chunkMeta.buffering[type];\n    var bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    var fragBuffering = frag.stats.buffering;\n    var partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    var audioTrack = tracks.audio;\n    var checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n    var fragStart = frag.start;\n    var operation = {\n      execute: function execute() {\n        chunkStats.executeStart = self.performance.now();\n        if (checkTimestampOffset) {\n          var sb = _this5.sourceBuffer[type];\n          if (sb) {\n            var delta = fragStart - sb.timestampOffset;\n            if (Math.abs(delta) >= 0.1) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + fragStart + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n              sb.timestampOffset = fragStart;\n            }\n          }\n        }\n        _this5.appendExecutor(data, type);\n      },\n      onStart: function onStart() {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: function onComplete() {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        var end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        var sourceBuffer = _this5.sourceBuffer;\n        var timeRanges = {};\n        for (var _type in sourceBuffer) {\n          timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(sourceBuffer[_type]);\n        }\n        _this5.appendError = 0;\n        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDED, {\n          type: type,\n          frag: frag,\n          part: part,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          timeRanges: timeRanges\n        });\n      },\n      onError: function onError(err) {\n        // in case any error occured while appending, put back segment in segments table\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(\"[buffer-controller]: Error encountered while trying to append to the \" + type + \" SourceBuffer\", err);\n        var event = {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPEND_ERROR,\n          err: err,\n          fatal: false\n        };\n        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_FULL_ERROR;\n        } else {\n          _this5.appendError++;\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          if (_this5.appendError > hls.config.appendErrorMaxRetry) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(\"[buffer-controller]: Failed \" + hls.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\");\n            event.fatal = true;\n            hls.stopLoad();\n          }\n        }\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var _this6 = this;\n    var operationQueue = this.operationQueue;\n    var flushOperation = function flushOperation(type) {\n      return {\n        execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n        onStart: function onStart() {\n          // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n          _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHED, {\n            type: type\n          });\n        },\n        onError: function onError(e) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: Failed to remove from \" + type + \" SourceBuffer\", e);\n        }\n      };\n    };\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(function (type) {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  };\n  _proto.onFragParsed = function onFragParsed(event, data) {\n    var _this7 = this;\n    var frag = data.frag,\n      part = data.part;\n    var buffersAppendedTo = [];\n    var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    var onUnblocked = function onUnblocked() {\n      var now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      var stats = part ? part.stats : frag.stats;\n      _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_BUFFERED, {\n        frag: frag,\n        part: part,\n        stats: stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  };\n  _proto.onFragChanged = function onFragChanged(event, data) {\n    this.flushBackBuffer();\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  ;\n  _proto.onBufferEos = function onBufferEos(event, data) {\n    var _this8 = this;\n    var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n      var sb = _this8.sourceBuffer[type];\n      if (sb && (!data.type || data.type === type)) {\n        sb.ending = true;\n        if (!sb.ended) {\n          sb.ended = true;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: \" + type + \" sourceBuffer now EOS\");\n        }\n      }\n      return acc && !!(!sb || sb.ended);\n    }, true);\n    if (ended) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: Queueing mediaSource.endOfStream()\");\n      this.blockBuffers(function () {\n        _this8.getSourceBufferTypes().forEach(function (type) {\n          var sb = _this8.sourceBuffer[type];\n          if (sb) {\n            sb.ending = false;\n          }\n        });\n        var mediaSource = _this8.mediaSource;\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          if (mediaSource) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.info(\"[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + mediaSource.readyState);\n          }\n          return;\n        }\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: Calling mediaSource.endOfStream()\");\n        // Allow this to throw and be caught by the enqueueing function\n        mediaSource.endOfStream();\n      });\n    }\n  };\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  };\n  _proto.flushBackBuffer = function flushBackBuffer() {\n    var hls = this.hls,\n      details = this.details,\n      media = this.media,\n      sourceBuffer = this.sourceBuffer;\n    if (!media || details === null) {\n      return;\n    }\n    var sourceBufferTypes = this.getSourceBufferTypes();\n    if (!sourceBufferTypes.length) {\n      return;\n    }\n\n    // Support for deprecated liveBackBufferLength\n    var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n    if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(backBufferLength) || backBufferLength < 0) {\n      return;\n    }\n    var currentTime = media.currentTime;\n    var targetDuration = details.levelTargetDuration;\n    var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n    var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n    sourceBufferTypes.forEach(function (type) {\n      var sb = sourceBuffer[type];\n      if (sb) {\n        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          if (details.live) {\n            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.info(\"[buffer-controller]: Cannot flush \" + type + \" back buffer while SourceBuffer is in ended state\");\n            return;\n          }\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type: type\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */;\n  _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    var details = this.details,\n      hls = this.hls,\n      media = this.media,\n      mediaSource = this.mediaSource;\n    var levelDuration = details.fragments[0].start + details.totalduration;\n    var mediaDuration = media.duration;\n    var msDuration = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaSource.duration) ? mediaSource.duration : 0;\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: Media Source duration is set to Infinity');\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: Updating Media Source duration to \" + levelDuration.toFixed(3));\n      mediaSource.duration = levelDuration;\n    }\n  };\n  _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n    var mediaSource = this.mediaSource;\n    var fragments = levelDetails.fragments;\n    var len = fragments.length;\n    if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {\n      var start = Math.max(0, fragments[0].start);\n      var end = Math.max(start, start + levelDetails.totalduration);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  };\n  _proto.checkPendingTracks = function checkPendingTracks() {\n    var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n      operationQueue = this.operationQueue,\n      pendingTracks = this.pendingTracks;\n\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    var pendingTracksCount = Object.keys(pendingTracks).length;\n    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {};\n      // append any pending segments now !\n      var buffers = this.getSourceBufferTypes();\n      if (buffers.length === 0) {\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          reason: 'could not create source buffer for media codec(s)'\n        });\n        return;\n      }\n      buffers.forEach(function (type) {\n        operationQueue.executeNext(type);\n      });\n    }\n  };\n  _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n    var sourceBuffer = this.sourceBuffer,\n      mediaSource = this.mediaSource;\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n    var tracksCreated = 0;\n    for (var trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        var track = tracks[trackName];\n        if (!track) {\n          throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n        }\n        // use levelCodec as first priority\n        var codec = track.levelCodec || track.codec;\n        var mimeType = track.container + \";codecs=\" + codec;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: creating sourceBuffer(\" + mimeType + \")\");\n        try {\n          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          var sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n          tracksCreated++;\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + err.message);\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n    if (tracksCreated) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CREATED, {\n        tracks: this.tracks\n      });\n    }\n  }\n\n  // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n  ;\n  _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onStart();\n  };\n  _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  };\n  _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(\"[buffer-controller]: \" + type + \" SourceBuffer error\", event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPENDING_ERROR,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    var operation = this.operationQueue.current(type);\n    if (operation) {\n      operation.onError(event);\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  ;\n  _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n    var media = this.media,\n      mediaSource = this.mediaSource,\n      operationQueue = this.operationQueue,\n      sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n    if (!media || !mediaSource || !sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    var mediaDuration = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(media.duration) ? media.duration : Infinity;\n    var msDuration = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaSource.duration) ? mediaSource.duration : Infinity;\n    var removeStart = Math.max(0, startOffset);\n    var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && !sb.ending) {\n      sb.ended = false;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(\"[buffer-controller]: Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n      console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  ;\n  _proto.appendExecutor = function appendExecutor(data, type) {\n    var operationQueue = this.operationQueue,\n      sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n    if (!sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"[buffer-controller]: Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    sb.ended = false;\n    console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n    sb.appendBuffer(data);\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  ;\n  _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n    var _this9 = this;\n    if (buffers === void 0) {\n      buffers = this.getSourceBufferTypes();\n    }\n    if (!buffers.length) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n    var operationQueue = this.operationQueue;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    var blockingOperations = buffers.map(function (type) {\n      return operationQueue.appendBlocker(type);\n    });\n    Promise.all(blockingOperations).then(function () {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(function (type) {\n        var sb = _this9.sourceBuffer[type];\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!sb || !sb.updating) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  };\n  _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  };\n  _proto.addBufferListener = function addBufferListener(type, event, fn) {\n    var buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    var listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event: event,\n      listener: listener\n    });\n    buffer.addEventListener(event, listener);\n  };\n  _proto.removeBufferListeners = function removeBufferListeners(type) {\n    var buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    this.listeners[type].forEach(function (l) {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  };\n  return BufferController;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-operation-queue.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/buffer-operation-queue.ts ***!\n  \\**************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_187498__) => {\n\n\"use strict\";\n__nested_webpack_require_187498__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_187498__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BufferOperationQueue)\n/* harmony export */ });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_187498__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\nvar BufferOperationQueue = /*#__PURE__*/function () {\n  function BufferOperationQueue(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n  var _proto = BufferOperationQueue.prototype;\n  _proto.append = function append(operation, type) {\n    var queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && this.buffers[type]) {\n      this.executeNext(type);\n    }\n  };\n  _proto.insertAbort = function insertAbort(operation, type) {\n    var queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  };\n  _proto.appendBlocker = function appendBlocker(type) {\n    var execute;\n    var promise = new Promise(function (resolve) {\n      execute = resolve;\n    });\n    var operation = {\n      execute: execute,\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError() {}\n    };\n    this.append(operation, type);\n    return promise;\n  };\n  _proto.executeNext = function executeNext(type) {\n    var buffers = this.buffers,\n      queues = this.queues;\n    var sb = buffers[type];\n    var queue = queues[type];\n    if (queue.length) {\n      var operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n        operation.onError(e);\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        if (!sb || !sb.updating) {\n          queue.shift();\n          this.executeNext(type);\n        }\n      }\n    }\n  };\n  _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  };\n  _proto.current = function current(type) {\n    return this.queues[type][0];\n  };\n  return BufferOperationQueue;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/cap-level-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/cap-level-controller.ts ***!\n  \\************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_190376__) => {\n\n\"use strict\";\n__nested_webpack_require_190376__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_190376__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_190376__(/*! ../events */ \"./src/events.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * cap stream level to media size dimension controller\n */\n\n\nvar CapLevelController = /*#__PURE__*/function () {\n  function CapLevelController(hls) {\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.hls = void 0;\n    this.streamController = void 0;\n    this.clientRect = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  var _proto = CapLevelController.prototype;\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListener();\n    if (this.hls.config.capLevelToPlayerSize) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  };\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n  _proto.unregisterListener = function unregisterListener() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n  _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {\n      this.restrictedLevels.push(data.droppedLevel);\n    }\n  };\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n  };\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  ;\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.stopCapping();\n  };\n  _proto.detectPlayerSize = function detectPlayerSize() {\n    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n      var levels = this.hls.levels;\n      if (levels.length) {\n        var hls = this.hls;\n        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */;\n  _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n    var _this = this;\n    var levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    var validLevels = levels.filter(function (level, index) {\n      return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;\n    });\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  };\n  _proto.startCapping = function startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  };\n  _proto.stopCapping = function stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  };\n  _proto.getDimensions = function getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    var media = this.media;\n    var boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      var clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  };\n  CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {\n    if (restrictedLevels === void 0) {\n      restrictedLevels = [];\n    }\n    return restrictedLevels.indexOf(level) === -1;\n  };\n  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n    if (!levels || !levels.length) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    var maxLevelIndex = levels.length - 1;\n    for (var i = 0; i < levels.length; i += 1) {\n      var level = levels[i];\n      if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  };\n  _createClass(CapLevelController, [{\n    key: \"mediaWidth\",\n    get: function get() {\n      return this.getDimensions().width * this.contentScaleFactor;\n    }\n  }, {\n    key: \"mediaHeight\",\n    get: function get() {\n      return this.getDimensions().height * this.contentScaleFactor;\n    }\n  }, {\n    key: \"contentScaleFactor\",\n    get: function get() {\n      var pixelRatio = 1;\n      if (!this.hls.config.ignoreDevicePixelRatio) {\n        try {\n          pixelRatio = self.devicePixelRatio;\n        } catch (e) {\n          /* no-op */\n        }\n      }\n      return pixelRatio;\n    }\n  }]);\n  return CapLevelController;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CapLevelController);\n\n/***/ }),\n\n/***/ \"./src/controller/cmcd-controller.ts\":\n/*!*******************************************!*\\\n  !*** ./src/controller/cmcd-controller.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_200623__) => {\n\n\"use strict\";\n__nested_webpack_require_200623__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_200623__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CMCDController)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_200623__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_cmcd__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_200623__(/*! ../types/cmcd */ \"./src/types/cmcd.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_200623__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_200623__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nvar CMCDController = /*#__PURE__*/function () {\n  // eslint-disable-line no-restricted-globals\n  // eslint-disable-line no-restricted-globals\n\n  function CMCDController(hls) {\n    var _this = this;\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n    this.onWaiting = function () {\n      if (_this.initialized) {\n        _this.starved = true;\n      }\n      _this.buffering = true;\n    };\n    this.onPlaying = function () {\n      if (!_this.initialized) {\n        _this.initialized = true;\n      }\n      _this.buffering = false;\n    };\n    this.applyPlaylistData = function (context) {\n      try {\n        _this.apply(context, {\n          ot: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MANIFEST,\n          su: !_this.initialized\n        });\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    this.applyFragmentData = function (context) {\n      try {\n        var fragment = context.frag;\n        var level = _this.hls.levels[fragment.level];\n        var ot = _this.getObjectType(fragment);\n        var data = {\n          d: fragment.duration * 1000,\n          ot: ot\n        };\n        if (ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO || ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO || ot == _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = _this.getTopBandwidth(ot) / 1000;\n          data.bl = _this.getBufferLength(ot);\n        }\n        _this.apply(context, data);\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    var config = this.config = hls.config;\n    var cmcd = config.cmcd;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || CMCDController.uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.registerListeners();\n    }\n  }\n  var _proto = CMCDController.prototype;\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n    this.onMediaDetached();\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n  };\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  };\n  _proto.onMediaDetached = function onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  };\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) === null || _data$tracks$audio === void 0 ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) === null || _data$tracks$video === void 0 ? void 0 : _data$tracks$video.buffer;\n  };\n  /**\n   * Create baseline CMCD data\n   */\n  _proto.createData = function createData() {\n    var _this$media;\n    return {\n      v: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDVersion,\n      sf: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDStreamingFormat.HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */;\n  _proto.apply = function apply(context, data) {\n    if (data === void 0) {\n      data = {};\n    }\n    // apply baseline data\n    _extends(data, this.createData());\n    var isVideo = data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.INIT || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    if (this.useHeaders) {\n      var headers = CMCDController.toHeaders(data);\n      if (!Object.keys(headers).length) {\n        return;\n      }\n      if (!context.headers) {\n        context.headers = {};\n      }\n      _extends(context.headers, headers);\n    } else {\n      var query = CMCDController.toQuery(data);\n      if (!query) {\n        return;\n      }\n      context.url = CMCDController.appendQueryToUri(context.url, query);\n    }\n  }\n\n  /**\n   * Apply CMCD data to a manifest request.\n   */;\n  /**\n   * The CMCD object type.\n   */\n  _proto.getObjectType = function getObjectType(fragment) {\n    var type = fragment.type;\n    if (type === 'subtitle') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED;\n      }\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */;\n  _proto.getTopBandwidth = function getTopBandwidth(type) {\n    var bitrate = 0;\n    var levels;\n    var hls = this.hls;\n    if (type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      var max = hls.maxAutoLevel;\n      var len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done;) {\n      var level = _step.value;\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */;\n  _proto.getBufferLength = function getBufferLength(type) {\n    var media = this.hls.media;\n    var buffer = type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    var info = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__.BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */;\n  _proto.createPlaylistLoader = function createPlaylistLoader() {\n    var pLoader = this.config.pLoader;\n    var apply = this.applyPlaylistData;\n    var Ctor = pLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdPlaylistLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      var _proto2 = CmcdPlaylistLoader.prototype;\n      _proto2.destroy = function destroy() {\n        this.loader.destroy();\n      };\n      _proto2.abort = function abort() {\n        this.loader.abort();\n      };\n      _proto2.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n      _createClass(CmcdPlaylistLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n      return CmcdPlaylistLoader;\n    }();\n  }\n\n  /**\n   * Create a playlist loader\n   */;\n  _proto.createFragmentLoader = function createFragmentLoader() {\n    var fLoader = this.config.fLoader;\n    var apply = this.applyFragmentData;\n    var Ctor = fLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdFragmentLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      var _proto3 = CmcdFragmentLoader.prototype;\n      _proto3.destroy = function destroy() {\n        this.loader.destroy();\n      };\n      _proto3.abort = function abort() {\n        this.loader.abort();\n      };\n      _proto3.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n      _createClass(CmcdFragmentLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n      return CmcdFragmentLoader;\n    }();\n  }\n\n  /**\n   * Generate a random v4 UUI\n   *\n   * @returns {string}\n   */;\n  CMCDController.uuid = function uuid() {\n    var url = URL.createObjectURL(new Blob());\n    var uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.slice(uuid.lastIndexOf('/') + 1);\n  }\n\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */;\n  CMCDController.serialize = function serialize(data) {\n    var results = [];\n    var isValid = function isValid(value) {\n      return !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    };\n    var toRounded = function toRounded(value) {\n      return Math.round(value);\n    };\n    var toHundred = function toHundred(value) {\n      return toRounded(value / 100) * 100;\n    };\n    var toUrlSafe = function toUrlSafe(value) {\n      return encodeURIComponent(value);\n    };\n    var formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded\n    };\n    var keys = Object.keys(data || {}).sort();\n    for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done;) {\n      var key = _step2.value;\n      var value = data[key];\n\n      // ignore invalid values\n      if (!isValid(value)) {\n        continue;\n      }\n\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        continue;\n      }\n\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        continue;\n      }\n\n      // Certain values require special formatting\n      var formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value);\n      }\n\n      // Serialize the key/value pair\n      var type = typeof value;\n      var result = void 0;\n      if (key === 'ot' || key === 'sf' || key === 'st') {\n        result = key + \"=\" + value;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'number') {\n        result = key + \"=\" + value;\n      } else {\n        result = key + \"=\" + JSON.stringify(value);\n      }\n      results.push(result);\n    }\n    return results.join(',');\n  }\n\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */;\n  CMCDController.toHeaders = function toHeaders(data) {\n    var keys = Object.keys(data);\n    var headers = {};\n    var headerNames = ['Object', 'Request', 'Session', 'Status'];\n    var headerGroups = [{}, {}, {}, {}];\n    var headerMap = {\n      br: 0,\n      d: 0,\n      ot: 0,\n      tb: 0,\n      bl: 1,\n      dl: 1,\n      mtp: 1,\n      nor: 1,\n      nrr: 1,\n      su: 1,\n      cid: 2,\n      pr: 2,\n      sf: 2,\n      sid: 2,\n      st: 2,\n      v: 2,\n      bs: 3,\n      rtp: 3\n    };\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var key = _keys[_i];\n      // Unmapped fields are mapped to the Request header\n      var index = headerMap[key] != null ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n    for (var i = 0; i < headerGroups.length; i++) {\n      var value = CMCDController.serialize(headerGroups[i]);\n      if (value) {\n        headers[\"CMCD-\" + headerNames[i]] = value;\n      }\n    }\n    return headers;\n  }\n\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */;\n  CMCDController.toQuery = function toQuery(data) {\n    return \"CMCD=\" + encodeURIComponent(CMCDController.serialize(data));\n  }\n\n  /**\n   * Append query args to a uri.\n   */;\n  CMCDController.appendQueryToUri = function appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n    var separator = uri.includes('?') ? '&' : '?';\n    return \"\" + uri + separator + query;\n  };\n  return CMCDController;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/eme-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/eme-controller.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_218787__) => {\n\n\"use strict\";\n__nested_webpack_require_218787__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_218787__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_218787__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_218787__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_218787__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_218787__(/*! ../utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\n/* harmony import */ var _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_218787__(/*! ../utils/keysystem-util */ \"./src/utils/keysystem-util.ts\");\n/* harmony import */ var _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_218787__(/*! ../utils/numeric-encoding-utils */ \"./src/utils/numeric-encoding-utils.ts\");\n/* harmony import */ var _loader_level_key__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_218787__(/*! ../loader/level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _utils_hex__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_218787__(/*! ../utils/hex */ \"./src/utils/hex.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_218787__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_218787__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__nested_webpack_require_218787__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_9__);\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n/**\n * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>\n *\n * DRM support for Hls.js\n */\n\n\n\n\n\n\n\n\n\n\n\nvar MAX_LICENSE_REQUEST_FAILURES = 3;\nvar LOGGER_PREFIX = '[eme]';\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nvar EMEController = /*#__PURE__*/function () {\n  function EMEController(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n    this.onWaitingForKey = this._onWaitingForKey.bind(this);\n    this.debug = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.debug.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);\n    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);\n    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);\n    this.error = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  var _proto = EMEController.prototype;\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n    // @ts-ignore\n    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n  };\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  };\n  _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {\n    var _this$config = this.config,\n      drmSystems = _this$config.drmSystems,\n      widevineLicenseUrl = _this$config.widevineLicenseUrl;\n    var keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n    throw new Error(\"no license server URL configured for key-system \\\"\" + keySystem + \"\\\"\");\n  };\n  _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {\n    var drmSystems = this.config.drmSystems;\n    var keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(\"No Server Certificate in config.drmSystems[\\\"\" + keySystem + \"\\\"]\");\n    }\n  };\n  _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {\n    var _this = this;\n    var levels = this.hls.levels;\n    var uniqueCodec = function uniqueCodec(value, i, a) {\n      return !!value && a.indexOf(value) === i;\n    };\n    var audioCodecs = levels.map(function (level) {\n      return level.audioCodec;\n    }).filter(uniqueCodec);\n    var videoCodecs = levels.map(function (level) {\n      return level.videoCodec;\n    }).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise(function (resolve, reject) {\n      var attempt = function attempt(keySystems) {\n        var keySystem = keySystems.shift();\n        _this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function (mediaKeys) {\n          return resolve({\n            keySystem: keySystem,\n            mediaKeys: mediaKeys\n          });\n        }).catch(function (error) {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error: error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  };\n  _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      var errMessage = \"Configured requestMediaKeySystemAccess is not a function \" + requestMediaKeySystemAccessFunc;\n      if (_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = \"navigator.requestMediaKeySystemAccess is not available over insecure protocol \" + location.protocol;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  };\n  _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    var _this2 = this;\n    // This can throw, but is caught in event handler callpath\n    var mediaKeySystemConfigs = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getSupportedMediaKeySystemConfigurations)(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    var keySystemAccess = keySystemAccessPromises === null || keySystemAccessPromises === void 0 ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(\"Requesting encrypted media \\\"\" + keySystem + \"\\\" key-system access with config: \" + JSON.stringify(mediaKeySystemConfigs));\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      var _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess: keySystemAccess\n      };\n      keySystemAccess.catch(function (error) {\n        _this2.log(\"Failed to obtain access to key-system \\\"\" + keySystem + \"\\\": \" + error);\n      });\n      return keySystemAccess.then(function (mediaKeySystemAccess) {\n        _this2.log(\"Access for key-system \\\"\" + mediaKeySystemAccess.keySystem + \"\\\" obtained\");\n        var certificateRequest = _this2.fetchServerCertificate(keySystem);\n        _this2.log(\"Create media-keys for \\\"\" + keySystem + \"\\\"\");\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {\n          _this2.log(\"Media-keys created for \\\"\" + keySystem + \"\\\"\");\n          return certificateRequest.then(function (certificate) {\n            if (certificate) {\n              return _this2.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(function (error) {\n          _this2.error(\"Failed to create media-keys for \\\"\" + keySystem + \"\\\"}: \" + error);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(function () {\n      return keySystemAccessPromises.mediaKeys;\n    });\n  };\n  _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {\n    var decryptdata = _ref.decryptdata,\n      keySystem = _ref.keySystem,\n      mediaKeys = _ref.mediaKeys;\n    console.assert(!!mediaKeys, 'mediaKeys is defined');\n    this.log(\"Creating key-system session \\\"\" + keySystem + \"\\\" keyId: \" + _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(decryptdata.keyId || []));\n    var mediaKeysSession = mediaKeys.createSession();\n    var mediaKeySessionContext = {\n      decryptdata: decryptdata,\n      keySystem: keySystem,\n      mediaKeys: mediaKeys,\n      mediaKeysSession: mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  };\n  _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {\n    var decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      var _keyId = this.getKeyIdString(decryptdata);\n      var scheme = 'cenc';\n      this.keyIdToKeySessionPromise[_keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');\n    } else {\n      this.warn(\"Could not renew expired session. Missing pssh initData.\");\n    }\n    this.removeSession(mediaKeySessionContext);\n  };\n  _proto.getKeyIdString = function getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(decryptdata.keyId);\n  };\n  _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    var keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(\"Updating key-session \\\"\" + keySession.sessionId + \"\\\" for keyID \" + _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) === null || _mediaKeySessionConte === void 0 ? void 0 : _mediaKeySessionConte.keyId) || []) + \"\\n      } (data length: \" + (data ? data.byteLength : data) + \")\");\n    return keySession.update(data);\n  };\n  _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {\n    var keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(\"Selecting key-system from fragment (sn: \" + frag.sn + \" \" + frag.type + \": \" + frag.level + \") key formats \" + keyFormats.join(', '));\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  };\n  _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {\n    var _this3 = this;\n    return new Promise(function (resolve, reject) {\n      var keySystemsInConfig = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(_this3.config);\n      var keySystemsToAttempt = keyFormats.map(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemFormatToKeySystemDomain).filter(function (value) {\n        return !!value && keySystemsInConfig.indexOf(value) !== -1;\n      });\n      return _this3.getKeySystemSelectionPromise(keySystemsToAttempt).then(function (_ref2) {\n        var keySystem = _ref2.keySystem;\n        var keySystemFormat = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemDomainToKeySystemFormat)(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(\"Unable to find format for key-system \\\"\" + keySystem + \"\\\"\"));\n        }\n      }).catch(reject);\n    });\n  };\n  _proto.loadKey = function loadKey(data) {\n    var _this4 = this;\n    var decryptdata = data.keyInfo.decryptdata;\n    var keyId = this.getKeyIdString(decryptdata);\n    var keyDetails = \"(keyId: \" + keyId + \" format: \\\"\" + decryptdata.keyFormat + \"\\\" method: \" + decryptdata.method + \" uri: \" + decryptdata.uri + \")\";\n    this.log(\"Starting session for key \" + keyDetails);\n    var keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keySessionContextPromise) {\n      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(function (_ref3) {\n        var keySystem = _ref3.keySystem,\n          mediaKeys = _ref3.mediaKeys;\n        _this4.throwIfDestroyed();\n        _this4.log(\"Handle encrypted media sn: \" + data.frag.sn + \" \" + data.frag.type + \": \" + data.frag.level + \" using key \" + keyDetails);\n        return _this4.attemptSetMediaKeys(keySystem, mediaKeys).then(function () {\n          _this4.throwIfDestroyed();\n          var keySessionContext = _this4.createMediaKeySessionContext({\n            keySystem: keySystem,\n            mediaKeys: mediaKeys,\n            decryptdata: decryptdata\n          });\n          var scheme = 'cenc';\n          return _this4.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');\n        });\n      });\n      keySessionContextPromise.catch(function (error) {\n        return _this4.handleError(error);\n      });\n    }\n    return keySessionContextPromise;\n  };\n  _proto.throwIfDestroyed = function throwIfDestroyed(message) {\n    if (message === void 0) {\n      message = 'Invalid state';\n    }\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  };\n  _proto.handleError = function handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error: error,\n        fatal: true\n      });\n    }\n  };\n  _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {\n    var keyId = this.getKeyIdString(decryptdata);\n    var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      var keySystem = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemFormatToKeySystemDomain)(decryptdata.keyFormat);\n      var keySystemsToAttempt = keySystem ? [keySystem] : (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  };\n  _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, \"Missing key-system license configuration options \" + JSON.stringify({\n        drmSystems: this.config.drmSystems\n      }));\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  };\n  _proto._onMediaEncrypted = function _onMediaEncrypted(event) {\n    var _this5 = this;\n    var initDataType = event.initDataType,\n      initData = event.initData;\n    this.debug(\"\\\"\" + event.type + \"\\\" event: init data type: \\\"\" + initDataType + \"\\\"\");\n\n    // Ignore event when initData is null\n    if (initData === null) {\n      return;\n    }\n    var keyId;\n    var keySystemDomain;\n    if (initDataType === 'sinf' && this.config.drmSystems[_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY]) {\n      // Match sinf keyId to playlist skd://keyId=\n      var json = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.bin2str)(new Uint8Array(initData));\n      try {\n        var sinf = (0,_utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_5__.base64Decode)(JSON.parse(json).sinf);\n        var tenc = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.parseSinf)(new Uint8Array(sinf));\n        if (!tenc) {\n          return;\n        }\n        keyId = tenc.subarray(8, 24);\n        keySystemDomain = _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY;\n      } catch (error) {\n        this.warn('Failed to parse sinf \"encrypted\" event message initData');\n        return;\n      }\n    } else {\n      // Support clear-lead key-session creation (otherwise depend on playlist keys)\n      var psshInfo = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.parsePssh)(initData);\n      if (psshInfo === null) {\n        return;\n      }\n      if (psshInfo.version === 0 && psshInfo.systemId === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystemIds.WIDEVINE && psshInfo.data) {\n        keyId = psshInfo.data.subarray(8, 24);\n      }\n      keySystemDomain = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemIdToKeySystemDomain)(psshInfo.systemId);\n    }\n    if (!keySystemDomain || !keyId) {\n      return;\n    }\n    var keyIdHex = _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(keyId);\n    var keyIdToKeySessionPromise = this.keyIdToKeySessionPromise,\n      mediaKeySessions = this.mediaKeySessions;\n    var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n    var _loop = function _loop(i) {\n      // Match playlist key\n      var keyContext = mediaKeySessions[i];\n      var decryptdata = keyContext.decryptdata;\n      if (decryptdata.pssh || !decryptdata.keyId) {\n        return \"continue\";\n      }\n      var oldKeyIdHex = _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(decryptdata.keyId);\n      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n        delete keyIdToKeySessionPromise[oldKeyIdHex];\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function () {\n          return _this5.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n        });\n        return \"break\";\n      }\n    };\n    for (var i = 0; i < mediaKeySessions.length; i++) {\n      var _ret = _loop(i);\n      if (_ret === \"continue\") continue;\n      if (_ret === \"break\") break;\n    }\n    if (!keySessionContextPromise) {\n      // Clear-lead key (not encountered in playlist)\n      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(function (_ref4) {\n        var _keySystemToKeySystem;\n        var keySystem = _ref4.keySystem,\n          mediaKeys = _ref4.mediaKeys;\n        _this5.throwIfDestroyed();\n        var decryptdata = new _loader_level_key__WEBPACK_IMPORTED_MODULE_6__.LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = (0,_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemDomainToKeySystemFormat)(keySystem)) != null ? _keySystemToKeySystem : '');\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        return _this5.attemptSetMediaKeys(keySystem, mediaKeys).then(function () {\n          _this5.throwIfDestroyed();\n          var keySessionContext = _this5.createMediaKeySessionContext({\n            decryptdata: decryptdata,\n            keySystem: keySystem,\n            mediaKeys: mediaKeys\n          });\n          return _this5.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');\n        });\n      });\n    }\n    keySessionContextPromise.catch(function (error) {\n      return _this5.handleError(error);\n    });\n  };\n  _proto._onWaitingForKey = function _onWaitingForKey(event) {\n    this.log(\"\\\"\" + event.type + \"\\\" event\");\n  };\n  _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {\n    var _this6 = this;\n    var queue = this.setMediaKeysQueue.slice();\n    this.log(\"Setting media-keys for \\\"\" + keySystem + \"\\\"\");\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    var setMediaKeysPromise = Promise.all(queue).then(function () {\n      if (!_this6.media) {\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return _this6.media.setMediaKeys(mediaKeys);\n    });\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(function () {\n      _this6.log(\"Media-keys set for \\\"\" + keySystem + \"\\\"\");\n      queue.push(setMediaKeysPromise);\n      _this6.setMediaKeysQueue = _this6.setMediaKeysQueue.filter(function (p) {\n        return queue.indexOf(p) === -1;\n      });\n    });\n  };\n  _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste,\n      _this$config$drmSyste2,\n      _this7 = this;\n    var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) === null || _this$config$drmSyste === void 0 ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) === null || _this$config$drmSyste2 === void 0 ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) !== null && _this$hls !== void 0 && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(\"Skipping key-session request for \\\"\" + reason + \"\\\" (no initData)\");\n      return Promise.resolve(context);\n    }\n    var keyId = this.getKeyIdString(context.decryptdata);\n    this.log(\"Generating key-session request for \\\"\" + reason + \"\\\": \" + keyId + \" (init data type: \" + initDataType + \" length: \" + (initData ? initData.byteLength : null) + \")\");\n    var licenseStatus = new (eventemitter3__WEBPACK_IMPORTED_MODULE_9___default())();\n    context.mediaKeysSession.onmessage = function (event) {\n      var keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      var messageType = event.messageType,\n        message = event.message;\n      _this7.log(\"\\\"\" + messageType + \"\\\" message event for session \\\"\" + keySession.sessionId + \"\\\" message size: \" + message.byteLength);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        _this7.renewLicense(context, message).catch(function (error) {\n          _this7.handleError(error);\n          licenseStatus.emit('error', error);\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY) {\n          _this7.updateKeySession(context, (0,_utils_keysystem_util__WEBPACK_IMPORTED_MODULE_4__.strToUtf8array)('acknowledged'));\n          _this7.removeSession(context);\n        }\n      } else {\n        _this7.warn(\"unhandled media key message type \\\"\" + messageType + \"\\\"\");\n      }\n    };\n    context.mediaKeysSession.onkeystatuseschange = function (event) {\n      var keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      _this7.onKeyStatusChange(context);\n      var keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        _this7.warn(context.keySystem + \" expired for key \" + keyId);\n        _this7.renewKeySession(context);\n      }\n    };\n    var keyUsablePromise = new Promise(function (resolve, reject) {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', function (keyStatus) {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, \"key status changed to \\\"\" + keyStatus + \"\\\"\"));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          _this7.warn(\"unhandled key status change \\\"\" + keyStatus + \"\\\"\");\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(function () {\n      var _context$mediaKeysSes;\n      _this7.log(\"Request generated for key-session \\\"\" + ((_context$mediaKeysSes = context.mediaKeysSession) === null || _context$mediaKeysSes === void 0 ? void 0 : _context$mediaKeysSes.sessionId) + \"\\\" keyId: \" + keyId);\n    }).catch(function (error) {\n      throw new EMEKeyError({\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error: error,\n        fatal: false\n      }, \"Error generating key-session request: \" + error);\n    }).then(function () {\n      return keyUsablePromise;\n    }).catch(function (error) {\n      licenseStatus.removeAllListeners();\n      _this7.removeSession(context);\n      throw error;\n    }).then(function () {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  };\n  _proto.onKeyStatusChange = function onKeyStatusChange(mediaKeySessionContext) {\n    var _this8 = this;\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function (status, keyId) {\n      _this8.log(\"key status change \\\"\" + status + \"\\\" for keyStatuses keyId: \" + _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId)) + \" session keyId: \" + _utils_hex__WEBPACK_IMPORTED_MODULE_7__[\"default\"].hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || [])) + \" uri: \" + mediaKeySessionContext.decryptdata.uri);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  };\n  _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {\n    var _this9 = this;\n    return new Promise(function (resolve, reject) {\n      var url = _this9.getServerCertificateUrl(keySystem);\n      if (!url) {\n        return resolve();\n      }\n      _this9.log(\"Fetching serverCertificate for \\\"\" + keySystem + \"\\\"\");\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          if (xhr.status === 200) {\n            resolve(xhr.response);\n          } else {\n            reject(new EMEKeyError({\n              type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n              fatal: true,\n              networkDetails: xhr\n            }, \"\\\"\" + keySystem + \"\\\" certificate request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\"));\n          }\n        }\n      };\n      xhr.send();\n    });\n  };\n  _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    var _this10 = this;\n    return new Promise(function (resolve, reject) {\n      mediaKeys.setServerCertificate(cert).then(function (success) {\n        _this10.log(\"setServerCertificate \" + (success ? 'success' : 'not supported by CDM') + \" (\" + (cert === null || cert === void 0 ? void 0 : cert.byteLength) + \") on \\\"\" + keySystem + \"\\\"\");\n        resolve(mediaKeys);\n      }).catch(function (error) {\n        reject(new EMEKeyError({\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error: error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  };\n  _proto.renewLicense = function renewLicense(context, keyMessage) {\n    var _this11 = this;\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(function (data) {\n      return _this11.updateKeySession(context, new Uint8Array(data)).catch(function (error) {\n        throw new EMEKeyError({\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error: error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  };\n  _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    var _this12 = this;\n    var licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr: xhr,\n        licenseChallenge: licenseChallenge\n      });\n    }\n    return Promise.resolve().then(function () {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(function (error) {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(function (licenseXhrSetupResult) {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr: xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  };\n  _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {\n    var _this13 = this;\n    return new Promise(function (resolve, reject) {\n      var url = _this13.getLicenseServerUrl(keySessionContext.keySystem);\n      _this13.log(\"Sending license request to URL: \" + url);\n      var xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = function () {\n        if (!_this13.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            _this13._requestLicenseFailureCount = 0;\n            var data = xhr.response;\n            _this13.log(\"License received \" + (data instanceof ArrayBuffer ? data.byteLength : data));\n            var licenseResponseCallback = _this13.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(_this13.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                _this13.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            _this13._requestLicenseFailureCount++;\n            if (_this13._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,\n                details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr\n              }, \"License Request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\"));\n            } else {\n              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - _this13._requestLicenseFailureCount + 1;\n              _this13.warn(\"Retrying license request, \" + attemptsLeft + \" attempts left\");\n              _this13.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      _this13.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(function (_ref5) {\n        var xhr = _ref5.xhr,\n          licenseChallenge = _ref5.licenseChallenge;\n        xhr.send(licenseChallenge);\n      });\n    });\n  };\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    var media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    media.addEventListener('encrypted', this.onMediaEncrypted);\n    media.addEventListener('waitingforkey', this.onWaitingForKey);\n  };\n  _proto.onMediaDetached = function onMediaDetached() {\n    var _this14 = this;\n    var media = this.media;\n    var mediaKeysList = this.mediaKeySessions;\n    if (media) {\n      media.removeEventListener('encrypted', this.onMediaEncrypted);\n      media.removeEventListener('waitingforkey', this.onWaitingForKey);\n      this.media = null;\n    }\n    this._requestLicenseFailureCount = 0;\n    this.setMediaKeysQueue = [];\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    _loader_level_key__WEBPACK_IMPORTED_MODULE_6__.LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    var keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(function (mediaKeySessionContext) {\n      return _this14.removeSession(mediaKeySessionContext);\n    }).concat(media === null || media === void 0 ? void 0 : media.setMediaKeys(null).catch(function (error) {\n      _this14.log(\"Could not clear media keys: \" + error + \". media.src: \" + (media === null || media === void 0 ? void 0 : media.src));\n    }))).then(function () {\n      if (keySessionCount) {\n        _this14.log('finished closing key sessions and clearing media keys');\n        mediaKeysList.length = 0;\n      }\n    }).catch(function (error) {\n      _this14.log(\"Could not close sessions and clear media keys: \" + error + \". media.src: \" + (media === null || media === void 0 ? void 0 : media.src));\n    });\n  };\n  _proto.onManifestLoaded = function onManifestLoaded(event, _ref6) {\n    var sessionKeys = _ref6.sessionKeys;\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      var keyFormats = sessionKeys.reduce(function (formats, sessionKey) {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(\"Selecting key-system from session-keys \" + keyFormats.join(', '));\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  };\n  _proto.removeSession = function removeSession(mediaKeySessionContext) {\n    var _this15 = this;\n    var mediaKeysSession = mediaKeySessionContext.mediaKeysSession,\n      licenseXhr = mediaKeySessionContext.licenseXhr;\n    if (mediaKeysSession) {\n      this.log(\"Remove licenses and keys and close session \" + mediaKeysSession.sessionId);\n      mediaKeysSession.onmessage = null;\n      mediaKeysSession.onkeystatuseschange = null;\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      return mediaKeysSession.remove().catch(function (error) {\n        _this15.log(\"Could not remove session: \" + error);\n      }).then(function () {\n        return mediaKeysSession.close();\n      }).catch(function (error) {\n        _this15.log(\"Could not close session: \" + error);\n      });\n    }\n  };\n  return EMEController;\n}();\nEMEController.CDMCleanupPromise = void 0;\nvar EMEKeyError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(EMEKeyError, _Error);\n  function EMEKeyError(data, message) {\n    var _this16;\n    _this16 = _Error.call(this, message) || this;\n    _this16.data = void 0;\n    _this16.data = data;\n    data.err = data.error;\n    return _this16;\n  }\n  return EMEKeyError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EMEController);\n\n/***/ }),\n\n/***/ \"./src/controller/fps-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/fps-controller.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_261286__) => {\n\n\"use strict\";\n__nested_webpack_require_261286__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_261286__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_261286__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_261286__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\nvar FPSController = /*#__PURE__*/function () {\n  // stream controller must be provided as a dependency!\n\n  function FPSController(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  var _proto = FPSController.prototype;\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching);\n  };\n  _proto.destroy = function destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  };\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  };\n  _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n    var currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        var currentPeriod = currentTime - this.lastTime;\n        var currentDropped = droppedFrames - this.lastDroppedFrames;\n        var currentDecoded = decodedFrames - this.lastDecodedFrames;\n        var droppedFPS = 1000 * currentDropped / currentPeriod;\n        var hls = this.hls;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            var currentLevel = hls.currentLevel;\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  };\n  _proto.checkFPSInterval = function checkFPSInterval() {\n    var video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        var videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  };\n  return FPSController;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FPSController);\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-finders.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-finders.ts ***!\n  \\********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_266137__) => {\n\n\"use strict\";\n__nested_webpack_require_266137__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_266137__.d(__nested_webpack_exports__, {\n/* harmony export */   \"findFragWithCC\": () => (/* binding */ findFragWithCC),\n/* harmony export */   \"findFragmentByPDT\": () => (/* binding */ findFragmentByPDT),\n/* harmony export */   \"findFragmentByPTS\": () => (/* binding */ findFragmentByPTS),\n/* harmony export */   \"fragmentWithinToleranceTest\": () => (/* binding */ fragmentWithinToleranceTest),\n/* harmony export */   \"pdtWithinToleranceTest\": () => (/* binding */ pdtWithinToleranceTest)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_266137__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_266137__(/*! ../utils/binary-search */ \"./src/utils/binary-search.ts\");\n\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT.\n * @param {Array<Fragment>} fragments - The array of candidate fragments\n * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*|null} fragment - The best matching fragment\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  var startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n  for (var seg = 0; seg < fragments.length; ++seg) {\n    var frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param {*} fragPrevious - The last frag successfully appended\n * @param {Array} fragments - The array of candidate fragments\n * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within\n * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*} foundFrag - The best matching fragment\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n  var fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param {*} candidate - The fragment to test\n * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {number} - 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[Ø] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param {*} candidate - The fragment to test\n * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {boolean} True if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  var endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, function (candidate) {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-tracker.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-tracker.ts ***!\n  \\********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_273992__) => {\n\n\"use strict\";\n__nested_webpack_require_273992__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_273992__.d(__nested_webpack_exports__, {\n/* harmony export */   \"FragmentState\": () => (/* binding */ FragmentState),\n/* harmony export */   \"FragmentTracker\": () => (/* binding */ FragmentTracker)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_273992__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_273992__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\nvar FragmentState;\n(function (FragmentState) {\n  FragmentState[\"NOT_LOADED\"] = \"NOT_LOADED\";\n  FragmentState[\"APPENDING\"] = \"APPENDING\";\n  FragmentState[\"PARTIAL\"] = \"PARTIAL\";\n  FragmentState[\"OK\"] = \"OK\";\n})(FragmentState || (FragmentState = {}));\nvar FragmentTracker = /*#__PURE__*/function () {\n  function FragmentTracker(hls) {\n    this.activeFragment = null;\n    this.activeParts = null;\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  var _proto = FragmentTracker.prototype;\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_LOADED, this.onFragLoaded, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_LOADED, this.onFragLoaded, this);\n  };\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = this.activeFragment = this.activeParts = null;\n  }\n\n  /**\n   * Return a Fragment with an appended range that matches the position and levelType.\n   * If not found any Fragment, return null\n   */;\n  _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n    if (levelType === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {\n      var activeFragment = this.activeFragment,\n        activeParts = this.activeParts;\n      if (!activeFragment) {\n        return null;\n      }\n      if (activeParts) {\n        for (var i = activeParts.length; i--;) {\n          var activePart = activeParts[i];\n          var appendedPTS = activePart ? activePart.end : activeFragment.appendedPTS;\n          if (activePart.start <= position && appendedPTS !== undefined && position <= appendedPTS) {\n            // 9 is a magic number. remove parts from lookup after a match but keep some short seeks back.\n            if (i > 9) {\n              this.activeParts = activeParts.slice(i - 9);\n            }\n            return activePart;\n          }\n        }\n      } else if (activeFragment.start <= position && activeFragment.appendedPTS !== undefined && position <= activeFragment.appendedPTS) {\n        return activeFragment;\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */;\n  _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n    var fragments = this.fragments;\n    var keys = Object.keys(fragments);\n    for (var i = keys.length; i--;) {\n      var fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */;\n  _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType) {\n    var _this = this;\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n        if (fragmentEntity.body.type === playlistType) {\n          _this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      var esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      esData.time.some(function (time) {\n        var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          _this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */;\n  _proto.detectPartialFragments = function detectPartialFragments(data) {\n    var _this2 = this;\n    var timeRanges = this.timeRanges;\n    var frag = data.frag,\n      part = data.part;\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity) {\n      return;\n    }\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      var timeRange = timeRanges[elementaryStream];\n      var partial = part !== null || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      if (fragmentEntity.body.endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  };\n  _proto.fragBuffered = function fragBuffered(frag) {\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  };\n  _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n    var buffered = {\n      time: [],\n      partial: partial\n    };\n    var startPTS = part ? part.start : fragment.start;\n    var endPTS = part ? part.end : fragment.end;\n    var minEndPTS = fragment.minEndPTS || endPTS;\n    var maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (var i = 0; i < timeRange.length; i++) {\n      var startTime = timeRange.start(i) - this.bufferPadding;\n      var endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        buffered.partial = true;\n        // Check for intersection with buffer\n        // Get playable sections of the fragment\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */;\n  _proto.getPartialFragment = function getPartialFragment(time) {\n    var bestFragment = null;\n    var timePadding;\n    var startTime;\n    var endTime;\n    var bestOverlap = 0;\n    var bufferPadding = this.bufferPadding,\n      fragments = this.fragments;\n    Object.keys(fragments).forEach(function (key) {\n      var fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  };\n  _proto.isEndListAppended = function isEndListAppended(type) {\n    var lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  };\n  _proto.getState = function getState(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    var fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  };\n  _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n    var startTime;\n    var endTime;\n    for (var i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  };\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n      part = data.part;\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    // don't track parts for memory efficiency\n    if (frag.sn === 'initSegment' || frag.bitrateTest || part) {\n      return;\n    }\n    var fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      loaded: data,\n      buffered: false,\n      range: Object.create(null)\n    };\n  };\n  _proto.onBufferAppended = function onBufferAppended(event, data) {\n    var _this3 = this;\n    var frag = data.frag,\n      part = data.part,\n      timeRanges = data.timeRanges;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {\n      if (this.activeFragment !== frag) {\n        this.activeFragment = frag;\n        frag.appendedPTS = undefined;\n      }\n      if (part) {\n        var activeParts = this.activeParts;\n        if (!activeParts) {\n          this.activeParts = activeParts = [];\n        }\n        activeParts.push(part);\n      } else {\n        this.activeParts = null;\n      }\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var timeRange = timeRanges[elementaryStream];\n      _this3.detectEvictedFragments(elementaryStream, timeRange);\n      if (!part && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {\n        var streamInfo = frag.elementaryStreams[elementaryStream];\n        if (!streamInfo) {\n          return;\n        }\n        for (var i = 0; i < timeRange.length; i++) {\n          var rangeEnd = timeRange.end(i);\n          if (rangeEnd <= streamInfo.endPTS && rangeEnd > streamInfo.startPTS) {\n            frag.appendedPTS = Math.max(rangeEnd, frag.appendedPTS || 0);\n          } else {\n            frag.appendedPTS = streamInfo.endPTS;\n          }\n        }\n      }\n    });\n  };\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  };\n  _proto.hasFragment = function hasFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  };\n  _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType) {\n    var _this4 = this;\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this4.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n        if (frag.type === playlistType && frag.start < end && frag.end > start) {\n          _this4.removeFragment(frag);\n        }\n      }\n    });\n  };\n  _proto.removeFragment = function removeFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    fragment.appendedPTS = undefined;\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  };\n  _proto.removeAllFragments = function removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activeFragment = null;\n    this.activeParts = null;\n  };\n  return FragmentTracker;\n}();\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2;\n  return fragmentEntity.buffered && (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial));\n}\nfunction getFragmentKey(fragment) {\n  return fragment.type + \"_\" + fragment.level + \"_\" + fragment.urlId + \"_\" + fragment.sn;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/gap-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/gap-controller.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_289208__) => {\n\n\"use strict\";\n__nested_webpack_require_289208__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_289208__.d(__nested_webpack_exports__, {\n/* harmony export */   \"MAX_START_GAP_JUMP\": () => (/* binding */ MAX_START_GAP_JUMP),\n/* harmony export */   \"SKIP_BUFFER_HOLE_STEP_SECONDS\": () => (/* binding */ SKIP_BUFFER_HOLE_STEP_SECONDS),\n/* harmony export */   \"SKIP_BUFFER_RANGE_START\": () => (/* binding */ SKIP_BUFFER_RANGE_START),\n/* harmony export */   \"STALL_MINIMUM_DURATION_MS\": () => (/* binding */ STALL_MINIMUM_DURATION_MS),\n/* harmony export */   \"default\": () => (/* binding */ GapController)\n/* harmony export */ });\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_289208__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_289208__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_289208__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_289208__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\nvar STALL_MINIMUM_DURATION_MS = 250;\nvar MAX_START_GAP_JUMP = 2.0;\nvar SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nvar SKIP_BUFFER_RANGE_START = 0.05;\nvar GapController = /*#__PURE__*/function () {\n  function GapController(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n  var _proto = GapController.prototype;\n  _proto.destroy = function destroy() {\n    this.media = null;\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param {number} lastCurrentTime Previously read playhead position\n   */;\n  _proto.poll = function poll(lastCurrentTime, activeFrag) {\n    var config = this.config,\n      media = this.media,\n      stalled = this.stalled;\n    if (media === null) {\n      return;\n    }\n    var currentTime = media.currentTime,\n      seeking = media.seeking;\n    var seeked = this.seeking && !seeking;\n    var beginSeek = !this.seeking && seeking;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          var _stalledDuration = self.performance.now() - stalled;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n          this.stallReported = false;\n        }\n        this.stalled = null;\n        this.nudgeRetry = 0;\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      this.stalled = null;\n    }\n\n    // The playhead should not be moving\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.getBuffered(media).length) {\n      return;\n    }\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.bufferInfo(media, currentTime, 0);\n    var isBuffered = bufferInfo.len > 0;\n    var nextStart = bufferInfo.nextStart || 0;\n\n    // There is no playable buffer (seeked, waiting for buffer)\n    if (!isBuffered && !nextStart) {\n      return;\n    }\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n      // Jump start gaps within jump threshold\n      var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;\n      var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n      if (startJump > 0 && startJump <= maxStartGapJump) {\n        this._trySkipBufferHole(null);\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    var tnow = self.performance.now();\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n    var stalledDuration = tnow - stalled;\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media) {\n        return;\n      }\n    }\n    var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */;\n  _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    var config = this.config,\n      fragmentTracker = this.fragmentTracker,\n      media = this.media;\n    if (media === null) {\n      return;\n    }\n    var currentTime = media.currentTime;\n    var partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      var targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we don't handle a partial fragment\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n      this.stalled = null;\n      this._tryNudgeBuffer();\n    }\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */;\n  _proto._reportStall = function _reportStall(bufferInfo) {\n    var hls = this.hls,\n      media = this.media,\n      stallReported = this.stallReported;\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + JSON.stringify(bufferInfo) + \")\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */;\n  _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n    var config = this.config,\n      hls = this.hls,\n      media = this.media;\n    if (media === null) {\n      return 0;\n    }\n    var currentTime = media.currentTime;\n    var lastEndTime = 0;\n    // Check if currentTime is between unbuffered regions of partial fragments\n    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.getBuffered(media);\n    for (var i = 0; i < buffered.length; i++) {\n      var startTime = buffered.start(i);\n      if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {\n        var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n        if (partial) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            reason: \"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime,\n            frag: partial\n          });\n        }\n        return targetTime;\n      }\n      lastEndTime = buffered.end(i);\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */;\n  _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n    var config = this.config,\n      hls = this.hls,\n      media = this.media,\n      nudgeRetry = this.nudgeRetry;\n    if (media === null) {\n      return;\n    }\n    var currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n      media.currentTime = targetTime;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        fatal: false\n      });\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: true\n      });\n    }\n  };\n  return GapController;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/id3-track-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/id3-track-controller.ts ***!\n  \\************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_301819__) => {\n\n\"use strict\";\n__nested_webpack_require_301819__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_301819__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_301819__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_301819__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_301819__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_301819__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _loader_date_range__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_301819__(/*! ../loader/date-range */ \"./src/loader/date-range.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_301819__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n\n\n\n\n\n\nvar MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  // Attempt to recreate Safari functionality by creating\n  // WebKitDataCue objects when available and store the decoded\n  // ID3 data in the value property of the cue\n  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nvar MAX_CUE_ENDTIME = function () {\n  var Cue = getCueClass();\n  try {\n    new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n}();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\nvar ID3TrackController = /*#__PURE__*/function () {\n  function ID3TrackController(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n    this._registerListeners();\n  }\n  var _proto = ID3TrackController.prototype;\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = null;\n  };\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n\n  // Add ID3 metatadata text track.\n  ;\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n    (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.clearCurrentCues)(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  };\n  _proto.createTrack = function createTrack(media) {\n    var track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  };\n  _proto.getID3Track = function getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (var i = 0; i < textTracks.length; i++) {\n      var textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.sendAddTrackEvent)(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  };\n  _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    var _this$hls$config = this.hls.config,\n      enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n      enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    var samples = data.samples;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    var Cue = getCueClass();\n    for (var i = 0; i < samples.length; i++) {\n      var type = samples[i].type;\n      if (type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_3__.getID3Frames(samples[i].data);\n      if (frames) {\n        var startTime = samples[i].pts;\n        var endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        var timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (var j = 0; j < frames.length; j++) {\n          var frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!_demux_id3__WEBPACK_IMPORTED_MODULE_3__.isTimeStampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime);\n            var cue = new Cue(startTime, endTime, '');\n            cue.value = frame;\n            if (type) {\n              cue.type = type;\n            }\n            this.id3Track.addCue(cue);\n          }\n        }\n      }\n    }\n  };\n  _proto.updateId3CueEnds = function updateId3CueEnds(startTime) {\n    var _this$id3Track;\n    var cues = (_this$id3Track = this.id3Track) === null || _this$id3Track === void 0 ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (var i = cues.length; i--;) {\n        var cue = cues[i];\n        if (cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  };\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n    var startOffset = _ref.startOffset,\n      endOffset = _ref.endOffset,\n      type = _ref.type;\n    var id3Track = this.id3Track,\n      hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    var _hls$config = hls.config,\n      enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n      enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      var predicate;\n      if (type === 'audio') {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.audioId3 && enableID3MetadataCues;\n        };\n      } else if (type === 'video') {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && enableEmsgMetadataCues;\n        };\n      } else {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && enableEmsgMetadataCues;\n        };\n      }\n      (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.removeCuesInRange)(id3Track, startOffset, endOffset, predicate);\n    }\n  };\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n    var _this = this;\n    var details = _ref2.details;\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    var dateRangeCuesAppended = this.dateRangeCuesAppended,\n      id3Track = this.id3Track;\n    var dateRanges = details.dateRanges;\n    var ids = Object.keys(dateRanges);\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track) {\n      var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n        return !ids.includes(id);\n      });\n      var _loop = function _loop(i) {\n        var id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      };\n      for (var i = idsToRemove.length; i--;) {\n        _loop(i);\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    var lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(lastFragment === null || lastFragment === void 0 ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    var Cue = getCueClass();\n    var _loop2 = function _loop2(_i) {\n      var id = ids[_i];\n      var dateRange = dateRanges[id];\n      var appendedDateRangeCues = dateRangeCuesAppended[id];\n      var cues = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.cues) || {};\n      var durationKnown = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n      var endTime = MAX_CUE_ENDTIME;\n      var endDate = dateRange.endDate;\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        var nextDateRangeWithSameClass = ids.reduce(function (filterMapArray, id) {\n          var candidate = dateRanges[id];\n          if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n            filterMapArray.push(candidate);\n          }\n          return filterMapArray;\n        }, []).sort(function (a, b) {\n          return a.startDate.getTime() - b.startDate.getTime();\n        })[0];\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n      var attributes = Object.keys(dateRange.attr);\n      for (var j = 0; j < attributes.length; j++) {\n        var key = attributes[j];\n        if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.ID || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.CLASS || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.START_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.DURATION || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.END_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.END_ON_NEXT) {\n          continue;\n        }\n        var cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else {\n          var data = dateRange.attr[key];\n          cue = new Cue(startTime, endTime, '');\n          if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.SCTE35_OUT || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.SCTE35_IN) {\n            data = hexToArrayBuffer(data);\n          }\n          cue.value = {\n            key: key,\n            data: data\n          };\n          cue.type = _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.dateRange;\n          _this.id3Track.addCue(cue);\n          cues[key] = cue;\n        }\n      }\n      dateRangeCuesAppended[id] = {\n        cues: cues,\n        dateRange: dateRange,\n        durationKnown: durationKnown\n      };\n    };\n    for (var _i = 0; _i < ids.length; _i++) {\n      _loop2(_i);\n    }\n  };\n  return ID3TrackController;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ID3TrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/latency-controller.ts\":\n/*!**********************************************!*\\\n  !*** ./src/controller/latency-controller.ts ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_315744__) => {\n\n\"use strict\";\n__nested_webpack_require_315744__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_315744__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LatencyController)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_315744__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_315744__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_315744__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar LatencyController = /*#__PURE__*/function () {\n  function LatencyController(hls) {\n    var _this = this;\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this.timeupdateHandler = function () {\n      return _this.timeupdate();\n    };\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  var _proto = LatencyController.prototype;\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null;\n    // @ts-ignore\n    this.hls = this.timeupdateHandler = null;\n  };\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError);\n  };\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  };\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n    this.levelDetails = details;\n    if (details.advanced) {\n      this.timeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  };\n  _proto.onError = function onError(event, data) {\n    if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n  };\n  _proto.timeupdate = function timeupdate() {\n    var media = this.media,\n      levelDetails = this.levelDetails;\n    if (!media || !levelDetails) {\n      return;\n    }\n    this.currentTime = media.currentTime;\n    var latency = this.computeLatency();\n    if (latency === null) {\n      return;\n    }\n    this._latency = latency;\n\n    // Adapt playbackRate to meet target latency in low-latency mode\n    var _this$config = this.config,\n      lowLatencyMode = _this$config.lowLatencyMode,\n      maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n      return;\n    }\n    var targetLatency = this.targetLatency;\n    if (targetLatency === null) {\n      return;\n    }\n    var distanceFromTarget = latency - targetLatency;\n    // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n    var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  };\n  _proto.estimateLiveEdge = function estimateLiveEdge() {\n    var levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  };\n  _proto.computeLatency = function computeLatency() {\n    var liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  };\n  _createClass(LatencyController, [{\n    key: \"latency\",\n    get: function get() {\n      return this._latency || 0;\n    }\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      var config = this.config,\n        levelDetails = this.levelDetails;\n      if (config.liveMaxLatencyDuration !== undefined) {\n        return config.liveMaxLatencyDuration;\n      }\n      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n    }\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n      if (levelDetails === null) {\n        return null;\n      }\n      var holdBack = levelDetails.holdBack,\n        partHoldBack = levelDetails.partHoldBack,\n        targetduration = levelDetails.targetduration;\n      var _this$config2 = this.config,\n        liveSyncDuration = _this$config2.liveSyncDuration,\n        liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n        lowLatencyMode = _this$config2.lowLatencyMode;\n      var userConfig = this.hls.userConfig;\n      var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n        targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n      }\n      var maxLiveSyncOnStallIncrease = targetduration;\n      var liveSyncOnStallIncrease = 1.0;\n      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n    }\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      var liveEdge = this.estimateLiveEdge();\n      var targetLatency = this.targetLatency;\n      var levelDetails = this.levelDetails;\n      if (liveEdge === null || targetLatency === null || levelDetails === null) {\n        return null;\n      }\n      var edge = levelDetails.edge;\n      var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n      var min = edge - levelDetails.totalduration;\n      var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n      return Math.min(Math.max(min, syncPosition), max);\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n      if (levelDetails === null) {\n        return 1;\n      }\n      return levelDetails.drift;\n    }\n  }, {\n    key: \"edgeStalled\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n      if (levelDetails === null) {\n        return 0;\n      }\n      var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n    }\n  }, {\n    key: \"forwardBufferLength\",\n    get: function get() {\n      var media = this.media,\n        levelDetails = this.levelDetails;\n      if (!media || !levelDetails) {\n        return 0;\n      }\n      var bufferedRanges = media.buffered.length;\n      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n    }\n  }]);\n  return LatencyController;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-controller.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/level-controller.ts ***!\n  \\********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_325960__) => {\n\n\"use strict\";\n__nested_webpack_require_325960__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_325960__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LevelController)\n/* harmony export */ });\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_325960__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_325960__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_325960__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_325960__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_325960__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_325960__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_325960__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n/*\n * Level Controller\n */\n\n\n\n\n\n\n\n\nvar chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());\nvar LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(LevelController, _BasePlaylistControll);\n  function LevelController(hls) {\n    var _this;\n    _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n    _this._levels = [];\n    _this._firstLevel = -1;\n    _this._startLevel = void 0;\n    _this.currentLevelIndex = -1;\n    _this.manualLevelIndex = -1;\n    _this.onParsedComplete = void 0;\n    _this._registerListeners();\n    return _this;\n  }\n  var _proto = LevelController.prototype;\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);\n  };\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n    this.manualLevelIndex = -1;\n    this._levels.length = 0;\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n  _proto.startLoad = function startLoad() {\n    var levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(function (level) {\n      level.loadError = 0;\n    });\n    _BasePlaylistControll.prototype.startLoad.call(this);\n  };\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var levels = [];\n    var audioTracks = [];\n    var subtitleTracks = [];\n    var bitrateStart;\n    var levelSet = {};\n    var levelFromSet;\n    var resolutionFound = false;\n    var videoCodecFound = false;\n    var audioCodecFound = false;\n\n    // regroup redundant levels together\n    data.levels.forEach(function (levelParsed) {\n      var attributes = levelParsed.attrs;\n      resolutionFound = resolutionFound || !!(levelParsed.width && levelParsed.height);\n      videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;\n      audioCodecFound = audioCodecFound || !!levelParsed.audioCodec;\n\n      // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n      if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf('mp4a.40.34') !== -1) {\n        levelParsed.audioCodec = undefined;\n      }\n      var levelKey = levelParsed.bitrate + \"-\" + levelParsed.attrs.RESOLUTION + \"-\" + levelParsed.attrs.CODECS;\n      levelFromSet = levelSet[levelKey];\n      if (!levelFromSet) {\n        levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__.Level(levelParsed);\n        levelSet[levelKey] = levelFromSet;\n        levels.push(levelFromSet);\n      } else {\n        levelFromSet.url.push(levelParsed.url);\n      }\n      if (attributes) {\n        if (attributes.AUDIO) {\n          (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.addGroupId)(levelFromSet, 'audio', attributes.AUDIO);\n        }\n        if (attributes.SUBTITLES) {\n          (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.addGroupId)(levelFromSet, 'text', attributes.SUBTITLES);\n        }\n      }\n    });\n\n    // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(function (_ref) {\n        var videoCodec = _ref.videoCodec,\n          width = _ref.width,\n          height = _ref.height;\n        return !!videoCodec || !!(width && height);\n      });\n    }\n\n    // only keep levels with supported audio/video codecs\n    levels = levels.filter(function (_ref2) {\n      var audioCodec = _ref2.audioCodec,\n        videoCodec = _ref2.videoCodec;\n      return (!audioCodec || (0,_utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(audioCodec, 'audio')) && (!videoCodec || (0,_utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(videoCodec, 'video'));\n    });\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(function (track) {\n        return !track.audioCodec || (0,_utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(track.audioCodec, 'audio');\n      });\n      // Assign ids after filtering as array indices by group-id\n      (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.assignTrackIdsByGroup)(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.assignTrackIdsByGroup)(subtitleTracks);\n    }\n    if (levels.length > 0) {\n      // start bitrate is the first bitrate of the manifest\n      bitrateStart = levels[0].bitrate;\n      // sort levels from lowest to highest\n      levels.sort(function (a, b) {\n        if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n          return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n        }\n        if (a.bitrate !== b.bitrate) {\n          return a.bitrate - b.bitrate;\n        }\n        if (a.attrs.SCORE !== b.attrs.SCORE) {\n          return a.attrs.decimalFloatingPoint('SCORE') - b.attrs.decimalFloatingPoint('SCORE');\n        }\n        if (resolutionFound && a.height !== b.height) {\n          return a.height - b.height;\n        }\n        return 0;\n      });\n      this._levels = levels;\n      // find index of first level in sorted levels\n      for (var i = 0; i < levels.length; i++) {\n        if (levels[i].bitrate === bitrateStart) {\n          this._firstLevel = i;\n          this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + bitrateStart);\n          break;\n        }\n      }\n\n      // Audio is only alternate if manifest include a URI along with the audio group tag,\n      // and this is not an audio-only stream where levels contain audio-only\n      var audioOnly = audioCodecFound && !videoCodecFound;\n      var edata = {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitleTracks: subtitleTracks,\n        sessionData: data.sessionData,\n        sessionKeys: data.sessionKeys,\n        firstLevel: this._firstLevel,\n        stats: data.stats,\n        audio: audioCodecFound,\n        video: videoCodecFound,\n        altAudio: !audioOnly && audioTracks.some(function (t) {\n          return !!t.url;\n        })\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, edata);\n\n      // Initiate loading after all controllers have received MANIFEST_PARSED\n      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n        this.hls.startLoad(this.hls.config.startPosition);\n      }\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n        fatal: true,\n        url: data.url,\n        reason: 'no level with compatible codecs found in manifest'\n      });\n    }\n  };\n  _proto.onError = function onError(event, data) {\n    var _data$frag, _data$level;\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n    if (data.fatal) {\n      return;\n    }\n\n    // Switch to redundant level when track fails to load\n    var context = data.context;\n    var level = this._levels[this.currentLevelIndex];\n    if (context && (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistContextType.AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId] || context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistContextType.SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId])) {\n      this.redundantFailover(this.currentLevelIndex);\n      return;\n    }\n    var levelError = false;\n    var levelSwitch = true;\n    var levelIndex;\n\n    // try to recover not fatal errors\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_LOAD_TIMEOUT:\n        if (data.frag) {\n          // Share fragment error count accross media options (main, audio, subs)\n          // This allows for level based rendition switching when media option assets fail\n          var variantLevelIndex = data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN ? data.frag.level : this.currentLevelIndex;\n          var _level = this._levels[variantLevelIndex];\n          // Set levelIndex when we're out of fragment retries\n          if (_level) {\n            _level.fragmentError++;\n            if (_level.fragmentError > this.hls.config.fragLoadingMaxRetry) {\n              levelIndex = variantLevelIndex;\n            }\n          } else {\n            levelIndex = variantLevelIndex;\n          }\n        }\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          var restrictedHdcpLevel = level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            this.hls.maxHdcpLevel = _types_level__WEBPACK_IMPORTED_MODULE_0__.HdcpLevels[_types_level__WEBPACK_IMPORTED_MODULE_0__.HdcpLevels.indexOf(restrictedHdcpLevel) - 1];\n            this.warn(\"Restricting playback to HDCP-LEVEL of \\\"\" + this.hls.maxHdcpLevel + \"\\\" or lower\");\n          }\n        }\n      // eslint-disable-next-line no-fallthrough\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_PARSING_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_SYSTEM_NO_SESSION:\n        levelIndex = ((_data$frag = data.frag) === null || _data$frag === void 0 ? void 0 : _data$frag.type) === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN ? data.frag.level : this.currentLevelIndex;\n        // Do not retry level. Escalate to fatal if switching levels fails.\n        data.levelRetry = false;\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        // Do not perform level switch if an error occurred using delivery directives\n        // Attempt to reload level without directives first\n        if (context) {\n          if (context.deliveryDirectives) {\n            levelSwitch = false;\n          }\n          levelIndex = context.level;\n        }\n        levelError = true;\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.REMUX_ALLOC_ERROR:\n        levelIndex = (_data$level = data.level) != null ? _data$level : this.currentLevelIndex;\n        levelError = true;\n        break;\n    }\n    if (levelIndex !== undefined) {\n      this.recoverLevel(data, levelIndex, levelError, levelSwitch);\n    }\n  }\n\n  /**\n   * Switch to a redundant stream if any available.\n   * If redundant stream is not available, emergency switch down if ABR mode is enabled.\n   */;\n  _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, levelSwitch) {\n    var errorDetails = errorEvent.details;\n    var level = this._levels[levelIndex];\n    level.loadError++;\n    if (levelError) {\n      var retrying = this.retryLoadingOrFail(errorEvent);\n      if (retrying) {\n        // boolean used to inform stream controller not to switch back to IDLE on non fatal error\n        errorEvent.levelRetry = true;\n      } else {\n        this.currentLevelIndex = -1;\n        return;\n      }\n    }\n    if (levelSwitch) {\n      var redundantLevels = level.url.length;\n      // Try redundant fail-over until level.loadError reaches redundantLevels\n      if (redundantLevels > 1 && level.loadError < redundantLevels) {\n        errorEvent.levelRetry = true;\n        this.redundantFailover(levelIndex);\n      } else if (this.manualLevelIndex === -1) {\n        // Search for next level to retry\n        var nextLevel = -1;\n        var levels = this._levels;\n        for (var i = levels.length; i--;) {\n          var candidate = (i + this.currentLevelIndex) % levels.length;\n          if (candidate !== this.currentLevelIndex && levels[candidate].loadError === 0) {\n            nextLevel = candidate;\n            break;\n          }\n        }\n        if (nextLevel > -1 && this.currentLevelIndex !== nextLevel) {\n          this.warn(errorDetails + \": switch to \" + nextLevel);\n          errorEvent.levelRetry = true;\n          this.hls.nextAutoLevel = nextLevel;\n        } else if (errorEvent.levelRetry === false) {\n          // No levels to switch to and no more retries\n          errorEvent.fatal = true;\n        }\n      }\n    }\n  };\n  _proto.redundantFailover = function redundantFailover(levelIndex) {\n    var level = this._levels[levelIndex];\n    var redundantLevels = level.url.length;\n    if (redundantLevels > 1) {\n      // Update the url id of all levels so that we stay on the same set of variants when level switching\n      var newUrlId = (level.urlId + 1) % redundantLevels;\n      this.warn(\"Switching to redundant URL-id \" + newUrlId);\n      this._levels.forEach(function (level) {\n        level.urlId = newUrlId;\n      });\n      this.level = levelIndex;\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  ;\n  _proto.onFragLoaded = function onFragLoaded(event, _ref3) {\n    var frag = _ref3.frag;\n    if (frag !== undefined && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {\n      var level = this._levels[frag.level];\n      if (level !== undefined) {\n        level.fragmentError = 0;\n        level.loadError = 0;\n      }\n    }\n  };\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    var level = data.level,\n      details = data.details;\n    var curLevel = this._levels[level];\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(\"Invalid level index \" + level);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n        this.retryCount = 0;\n      }\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  };\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var currentLevel = this.hls.levels[this.currentLevelIndex];\n    if (!currentLevel) {\n      return;\n    }\n    if (currentLevel.audioGroupIds) {\n      var urlId = -1;\n      var audioGroupId = this.hls.audioTracks[data.id].groupId;\n      for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {\n        if (currentLevel.audioGroupIds[i] === audioGroupId) {\n          urlId = i;\n          break;\n        }\n      }\n      if (urlId !== currentLevel.urlId) {\n        currentLevel.urlId = urlId;\n        this.startLoad();\n      }\n    }\n  };\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    _BasePlaylistControll.prototype.loadPlaylist.call(this);\n    var level = this.currentLevelIndex;\n    var currentLevel = this._levels[level];\n    if (this.canLoad && currentLevel && currentLevel.url.length > 0) {\n      var id = currentLevel.urlId;\n      var url = currentLevel.url[id];\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n      this.log(\"Attempt loading level index \" + level + ((hlsUrlParameters === null || hlsUrlParameters === void 0 ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with URL-id \" + id + \" \" + url);\n\n      // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, {\n        url: url,\n        level: level,\n        id: id,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {\n      return id !== urlId;\n    };\n    var levels = this._levels.filter(function (level, index) {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (level.url.length > 1 && urlId !== undefined) {\n        level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n        if (level.audioGroupIds) {\n          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        if (level.textGroupIds) {\n          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        level.urlId = 0;\n        return true;\n      }\n      return false;\n    }).map(function (level, index) {\n      var details = level.details;\n      if (details !== null && details !== void 0 && details.fragments) {\n        details.fragments.forEach(function (fragment) {\n          fragment.level = index;\n        });\n      }\n      return level;\n    });\n    this._levels = levels;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVELS_UPDATED, {\n      levels: levels\n    });\n  };\n  _createClass(LevelController, [{\n    key: \"levels\",\n    get: function get() {\n      if (this._levels.length === 0) {\n        return null;\n      }\n      return this._levels;\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this.currentLevelIndex;\n    },\n    set: function set(newLevel) {\n      var _levels$newLevel;\n      var levels = this._levels;\n      if (levels.length === 0) {\n        return;\n      }\n      if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {\n        return;\n      }\n      // check if level idx is valid\n      if (newLevel < 0 || newLevel >= levels.length) {\n        // invalid level id given, trigger error\n        var fatal = newLevel < 0;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_SWITCH_ERROR,\n          level: newLevel,\n          fatal: fatal,\n          reason: 'invalid level idx'\n        });\n        if (fatal) {\n          return;\n        }\n        newLevel = Math.min(newLevel, levels.length - 1);\n      }\n\n      // stopping live reloading timer if any\n      this.clearTimer();\n      var lastLevelIndex = this.currentLevelIndex;\n      var lastLevel = levels[lastLevelIndex];\n      var level = levels[newLevel];\n      this.log(\"switching to level \" + newLevel + \" from \" + lastLevelIndex);\n      this.currentLevelIndex = newLevel;\n      var levelSwitchingData = _extends({}, level, {\n        level: newLevel,\n        maxBitrate: level.maxBitrate,\n        uri: level.uri,\n        urlId: level.urlId\n      });\n      // @ts-ignore\n      delete levelSwitchingData._urlId;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_SWITCHING, levelSwitchingData);\n      // check if we need to load playlist for this level\n      var levelDetails = level.details;\n      if (!levelDetails || levelDetails.live) {\n        // level not retrieved yet, or live playlist we need to (re)load it\n        var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);\n        this.loadPlaylist(hlsUrlParameters);\n      }\n    }\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.manualLevelIndex;\n    },\n    set: function set(newLevel) {\n      this.manualLevelIndex = newLevel;\n      if (this._startLevel === undefined) {\n        this._startLevel = newLevel;\n      }\n      if (newLevel !== -1) {\n        this.level = newLevel;\n      }\n    }\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return this._firstLevel;\n    },\n    set: function set(newLevel) {\n      this._firstLevel = newLevel;\n    }\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      // hls.startLevel takes precedence over config.startLevel\n      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n      if (this._startLevel === undefined) {\n        var configStartLevel = this.hls.config.startLevel;\n        if (configStartLevel !== undefined) {\n          return configStartLevel;\n        } else {\n          return this._firstLevel;\n        }\n      } else {\n        return this._startLevel;\n      }\n    },\n    set: function set(newLevel) {\n      this._startLevel = newLevel;\n    }\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      if (this.manualLevelIndex !== -1) {\n        return this.manualLevelIndex;\n      } else {\n        return this.hls.nextAutoLevel;\n      }\n    },\n    set: function set(nextLevel) {\n      this.level = nextLevel;\n      if (this.manualLevelIndex === -1) {\n        this.hls.nextAutoLevel = nextLevel;\n      }\n    }\n  }]);\n  return LevelController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-helper.ts\":\n/*!****************************************!*\\\n  !*** ./src/controller/level-helper.ts ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_352119__) => {\n\n\"use strict\";\n__nested_webpack_require_352119__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_352119__.d(__nested_webpack_exports__, {\n/* harmony export */   \"addGroupId\": () => (/* binding */ addGroupId),\n/* harmony export */   \"addSliding\": () => (/* binding */ addSliding),\n/* harmony export */   \"adjustSliding\": () => (/* binding */ adjustSliding),\n/* harmony export */   \"assignTrackIdsByGroup\": () => (/* binding */ assignTrackIdsByGroup),\n/* harmony export */   \"computeReloadInterval\": () => (/* binding */ computeReloadInterval),\n/* harmony export */   \"getFragmentWithSN\": () => (/* binding */ getFragmentWithSN),\n/* harmony export */   \"getPartWith\": () => (/* binding */ getPartWith),\n/* harmony export */   \"mapFragmentIntersection\": () => (/* binding */ mapFragmentIntersection),\n/* harmony export */   \"mapPartIntersection\": () => (/* binding */ mapPartIntersection),\n/* harmony export */   \"mergeDetails\": () => (/* binding */ mergeDetails),\n/* harmony export */   \"updateFragPTSDTS\": () => (/* binding */ updateFragPTSDTS),\n/* harmony export */   \"updatePTS\": () => (/* binding */ updatePTS)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_352119__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_352119__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _loader_date_range__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_352119__(/*! ../loader/date-range */ \"./src/loader/date-range.ts\");\n\n\n\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n/**\n * @module LevelHelper\n * Providing methods dealing with playlist sliding and drift\n * */\n\n\n\nfunction addGroupId(level, type, id) {\n  switch (type) {\n    case 'audio':\n      if (!level.audioGroupIds) {\n        level.audioGroupIds = [];\n      }\n      level.audioGroupIds.push(id);\n      break;\n    case 'text':\n      if (!level.textGroupIds) {\n        level.textGroupIds = [];\n      }\n      level.textGroupIds.push(id);\n      break;\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  var groups = {};\n  tracks.forEach(function (track) {\n    var groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\nfunction updatePTS(fragments, fromIdx, toIdx) {\n  var fragFrom = fragments[fromIdx];\n  var fragTo = fragments[toIdx];\n  updateFromToPTS(fragFrom, fragTo);\n}\nfunction updateFromToPTS(fragFrom, fragTo) {\n  var fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    var duration = 0;\n    var frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    // TODO? Drift can go either way, or the playlist could be completely accurate\n    // console.assert(duration > 0,\n    //   `duration of ${duration} computed for frag ${frag.sn}, level ${frag.level}, there should be some duration drift between playlist and fragment!`);\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    var contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  var parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  var maxStartPTS = startPTS;\n  var minEndPTS = endPTS;\n  var fragStartPts = frag.startPTS;\n  var fragEndPts = frag.endPTS;\n  if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fragStartPts)) {\n    // delta PTS between audio and video\n    var deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  frag.duration = endPTS - startPTS;\n  var drift = startPTS - frag.start;\n  frag.start = frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  var sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  var i;\n  var fragIdx = sn - details.startSN;\n  var fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  var currentInitSegment = null;\n  var oldFragments = oldDetails.fragments;\n  for (var i = oldFragments.length - 1; i >= 0; i--) {\n    var oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n  var ccOffset = 0;\n  var PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n    if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(oldFrag.startPTS) && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.appendedPTS = oldFrag.appendedPTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    newFrag.urlId = oldFrag.urlId;\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  if (currentInitSegment) {\n    var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(function (frag) {\n      var _currentInitSegment;\n      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) === null || _currentInitSegment === void 0 ? void 0 : _currentInitSegment.relurl)) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n      return !frag;\n    });\n    if (newDetails.deltaUpdateFailed) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (var _i = newDetails.skippedSegments; _i--;) {\n        newDetails.fragments.shift();\n      }\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n  var newFragments = newDetails.fragments;\n  if (ccOffset) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn('discontinuity sliding from playlist, take drift into account');\n    for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n      newFragments[_i2].cc += ccOffset;\n    }\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  var advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    var edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  var dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(function (id) {\n      delete dateRanges[id];\n    });\n  }\n  Object.keys(deltaDateRanges).forEach(function (id) {\n    var dateRange = new _loader_date_range__WEBPACK_IMPORTED_MODULE_2__.DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + JSON.stringify(deltaDateRanges[id].attr) + \"\\\"\");\n    }\n  });\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    var delta = 0;\n    for (var i = 0, len = oldParts.length; i <= len; i++) {\n      var _oldPart = oldParts[i];\n      var _newPart = newParts[i + delta];\n      if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n        intersectionFn(_oldPart, _newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  var skippedSegments = newDetails.skippedSegments;\n  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  var delta = newDetails.startSN - oldDetails.startSN;\n  var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (var i = start; i <= end; i++) {\n    var _oldFrag = oldFrags[delta + i];\n    var _newFrag = newFrags[i];\n    if (skippedSegments && !_newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      _newFrag = newDetails.fragments[i] = _oldFrag;\n    }\n    if (_oldFrag && _newFrag) {\n      intersectionFn(_oldFrag, _newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  var oldFragments = oldDetails.fragments;\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    var fragments = details.fragments;\n    for (var i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs) {\n  if (distanceToLiveEdgeMs === void 0) {\n    distanceToLiveEdgeMs = Infinity;\n  }\n  var reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    var fragments = newDetails.fragments;\n    var liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!level || !level.details) {\n    return null;\n  }\n  var levelDetails = level.details;\n  var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = levelDetails.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  if (!level || !level.details) {\n    return null;\n  }\n  var partList = level.details.partList;\n  if (partList) {\n    for (var i = partList.length; i--;) {\n      var part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/stream-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/stream-controller.ts ***!\n  \\*********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_369194__) => {\n\n\"use strict\";\n__nested_webpack_require_369194__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_369194__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StreamController)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_369194__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_369194__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_369194__(/*! ../is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_369194__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_369194__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_369194__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_369194__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_369194__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_369194__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_369194__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _gap_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_369194__(/*! ./gap-controller */ \"./src/controller/gap-controller.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_369194__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\nvar StreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(StreamController, _BaseStreamController);\n  function StreamController(hls, fragmentTracker, keyLoader) {\n    var _this;\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[stream-controller]') || this;\n    _this.audioCodecSwap = false;\n    _this.gapController = null;\n    _this.level = -1;\n    _this._forceStartLoad = false;\n    _this.altAudio = false;\n    _this.audioOnly = false;\n    _this.fragPlaying = null;\n    _this.onvplaying = null;\n    _this.onvseeked = null;\n    _this.fragLastKbps = 0;\n    _this.couldBacktrack = false;\n    _this.backtrackFragment = null;\n    _this.audioCodecSwitch = false;\n    _this.videoBuffer = null;\n    _this._registerListeners();\n    return _this;\n  }\n  var _proto = StreamController.prototype;\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n    this.onMediaDetaching();\n  };\n  _proto.startLoad = function startLoad(startPosition) {\n    if (this.levels) {\n      var lastCurrentTime = this.lastCurrentTime,\n        hls = this.hls;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      this.fragLoadError = 0;\n      if (!this.startFragRequested) {\n        // determine load level\n        var startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.nextAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n        startPosition = lastCurrentTime;\n      }\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;\n    }\n  };\n  _proto.stopLoad = function stopLoad() {\n    this._forceStartLoad = false;\n    _BaseStreamController.prototype.stopLoad.call(this);\n  };\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE:\n        this.doTickIdle();\n        break;\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL:\n        {\n          var _levels$level;\n          var levels = this.levels,\n            level = this.level;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;\n          if (details && (!details.live || this.levelLastLoaded === this.level)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n            break;\n          }\n          break;\n        }\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          var now = self.performance.now();\n          var retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('retryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded(this.level);\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n    // check buffer\n    // check/update current fragment\n    this.onTickEnd();\n  };\n  _proto.onTickEnd = function onTickEnd() {\n    _BaseStreamController.prototype.onTickEnd.call(this);\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  };\n  _proto.doTickIdle = function doTickIdle() {\n    var hls = this.hls,\n      levelLastLoaded = this.levelLastLoaded,\n      levels = this.levels,\n      media = this.media;\n    var config = hls.config,\n      level = hls.nextLoadLevel;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    if (!levels || !levels[level]) {\n      return;\n    }\n    var levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    var bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    var lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      var data = {};\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_EOS, data);\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED;\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    this.level = hls.nextLoadLevel = level;\n    var levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n      this.level = level;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL;\n      return;\n    }\n    var bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    var frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.OK) {\n      var _this$backtrackFragme;\n      var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      var fragIdx = backtrackSn - levelDetails.startSN;\n      var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking\n    if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.OK && this.nextLoadPosition > targetBufferTime) {\n      // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n      var type = this.audioOnly && !this.altAudio ? _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO : _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO;\n      var mediaBuffer = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n      }\n      frag = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelDetails, targetBufferTime);\n  };\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    var _this$media2;\n    // Check if fragment is not loaded\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.NOT_LOADED) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, levelDetails);\n      } else if (this.bitrateTest) {\n        this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n        this._loadBitrateTestFrag(frag, levelDetails);\n      } else {\n        this.startFragRequested = true;\n        _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n      }\n    } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.APPENDING) {\n      // Lower the buffer size and try again\n      if (this.reduceMaxBufferLength(frag.duration)) {\n        this.fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      this.fragmentTracker.removeAllFragments();\n    }\n  };\n  _proto.getAppendedFrag = function getAppendedFrag(position) {\n    var fragOrPart = this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  };\n  _proto.getBufferedFrag = function getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n  };\n  _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */;\n  _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */;\n  _proto.nextLevelSwitch = function nextLevelSwitch() {\n    var levels = this.levels,\n      media = this.media;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media !== null && media !== void 0 && media.readyState) {\n      var fetchdelay;\n      var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        var nextLevelId = this.hls.nextLoadLevel;\n        var nextLevel = levels[nextLevelId];\n        var fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          var fragDuration = nextBufferedFrag.duration;\n          var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  };\n  _proto.abortCurrentFrag = function abortCurrentFrag() {\n    var fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n    }\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.KEY_LOADING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED:\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  };\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n    _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n  };\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n    var media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"](this.config, media, this.fragmentTracker, this.hls);\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n    if (media && this.onvplaying && this.onvseeked) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n    this.fragPlaying = null;\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n  _proto.onMediaPlaying = function onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  };\n  _proto.onMediaSeeked = function onMediaSeeked() {\n    var media = this.media;\n    var currentTime = media ? media.currentTime : null;\n    if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime)) {\n      this.log(\"Media seeked to \" + currentTime.toFixed(3));\n    }\n\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = false;\n    this.startPosition = this.lastCurrentTime = 0;\n    this.fragPlaying = null;\n    this.backtrackFragment = null;\n  };\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var aac = false;\n    var heaac = false;\n    var codec;\n    data.levels.forEach(function (level) {\n      // detect if we have different kind of audio codecs used amongst playlists\n      codec = level.audioCodec;\n      if (codec) {\n        if (codec.indexOf('mp4a.40.2') !== -1) {\n          aac = true;\n        }\n        if (codec.indexOf('mp4a.40.5') !== -1) {\n          heaac = true;\n        }\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !(0,_is_supported__WEBPACK_IMPORTED_MODULE_2__.changeTypeSupported)();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  };\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var levels = this.levels;\n    if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE) {\n      return;\n    }\n    var level = levels[data.level];\n    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL;\n    }\n  };\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _curLevel$details;\n    var levels = this.levels;\n    var newLevelId = data.level;\n    var newDetails = data.details;\n    var duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(\"Levels were reset while loading level \" + newLevelId);\n      return;\n    }\n    this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"], cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n    var fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n        this.backtrackFragment = null;\n        fragCurrent.abortRequests();\n      }\n    }\n    var curLevel = levels[newLevelId];\n    var sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live) {\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = newLevelId;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    }\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  };\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    var frag = data.frag,\n      part = data.part,\n      payload = data.payload;\n    var levels = this.levels;\n    if (!levels) {\n      this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n    var currentLevel = levels[frag.level];\n    var details = currentLevel.details;\n    if (!details) {\n      this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n      return;\n    }\n    var videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    var accurateTimeOffset = details.PTSKnown || !details.live;\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n    var audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    var transmuxer = this.transmuxer = this.transmuxer || new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    var partIndex = part ? part.index : -1;\n    var partial = partIndex !== -1;\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    var initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  };\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var fromAltAudio = this.altAudio;\n    var altAudio = !!data.url;\n    var trackId = data.id;\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        var fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      var hls = this.hls;\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: 'audio'\n        });\n      }\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, {\n        id: trackId\n      });\n    }\n  };\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var trackId = data.id;\n    var altAudio = !!this.hls.audioTracks[trackId].url;\n    if (altAudio) {\n      var videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio;\n    this.tick();\n  };\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var tracks = data.tracks;\n    var mediaTrack;\n    var name;\n    var alternate = false;\n    for (var type in tracks) {\n      var track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          var videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  };\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n      part = data.part;\n    if (frag && frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n      }\n      return;\n    }\n    var stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n    this.fragBufferedComplete(frag, part);\n  };\n  _proto.onError = function onError(event, data) {\n    if (data.type === _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, data);\n      return;\n    }\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_PARSING_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, data);\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR) {\n          if (data.fatal) {\n            // if fatal error, stop processing\n            this.warn(\"\" + data.details);\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR;\n          } else {\n            // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE\n            if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL) {\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n            }\n          }\n        }\n        break;\n      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'main' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n          // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole buffer to recover\n            this.warn('buffer full error also media.currentTime is not buffered, flush main');\n            // flush main buffer\n            this.immediateLevelSwitch();\n          }\n          this.resetLoadingState();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Checks the health of the buffer and attempts to resolve playback stalls.\n  ;\n  _proto.checkBuffer = function checkBuffer() {\n    var media = this.media,\n      gapController = this.gapController;\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    if (this.loadedmetadata || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(media).length) {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      var activeFrag = this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n    this.lastCurrentTime = media.currentTime;\n  };\n  _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n    this.tickImmediate();\n  };\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n    var type = _ref.type;\n    if (type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n      var mediaBuffer = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(mediaBuffer, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n    }\n  };\n  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n    this.levels = data.levels;\n  };\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */;\n  _proto.seekToStartPos = function seekToStartPos() {\n    var media = this.media;\n    if (!media) {\n      return;\n    }\n    var currentTime = media.currentTime;\n    var startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n        return;\n      }\n      var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(media);\n      var bufferStart = buffered.length ? buffered.start(0) : 0;\n      var delta = bufferStart - startPosition;\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        this.log(\"adjusting start position by \" + delta + \" to match buffer start\");\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n      media.currentTime = startPosition;\n    }\n  };\n  _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n    var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  };\n  _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, levelDetails) {\n    var _this2 = this;\n    frag.bitrateTest = true;\n    this._doFragLoad(frag, levelDetails).then(function (data) {\n      var hls = _this2.hls;\n      if (!data || _this2.fragContextChanged(frag)) {\n        return;\n      }\n      _this2.fragLoadError = 0;\n      _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n      _this2.startFragRequested = false;\n      _this2.bitrateTest = false;\n      var stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  };\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    var id = 'main';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n      chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n    var frag = context.frag,\n      part = context.part,\n      level = context.level;\n    var video = remuxResult.video,\n      text = remuxResult.text,\n      id3 = remuxResult.id3,\n      initSegment = remuxResult.initSegment;\n    var details = level.details;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    var audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING;\n    if (initSegment) {\n      if (initSegment.tracks) {\n        this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: frag,\n          id: id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      var initPTS = initSegment.initPTS;\n      var timescale = initSegment.timescale;\n      if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS)) {\n        this.initPTS[frag.cc] = initPTS;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.INIT_PTS_FOUND, {\n          frag: frag,\n          id: id,\n          initPTS: initPTS,\n          timescale: timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && remuxResult.independent !== false) {\n      if (details) {\n        var startPTS = video.startPTS,\n          endPTS = video.endPTS,\n          startDTS = video.startDTS,\n          endDTS = video.endDTS;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            var bufferInfo = this.getMainFwdBufferInfo();\n            var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (targetBufferTime < startTime - this.config.maxBufferHole) {\n              this.backtrack(frag);\n              return;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta);\n      }\n    } else if (remuxResult.independent === false) {\n      this.backtrack(frag);\n      return;\n    }\n    if (audio) {\n      var _startPTS = audio.startPTS,\n        _endPTS = audio.endPTS,\n        _startDTS = audio.startDTS,\n        _endDTS = audio.endDTS;\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO] = {\n          startPTS: _startPTS,\n          endPTS: _endPTS,\n          startDTS: _startDTS,\n          endDTS: _endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = {\n        id: id,\n        frag: frag,\n        details: details,\n        samples: id3.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      var emittedText = {\n        id: id,\n        frag: frag,\n        details: details,\n        samples: text.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n  _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    var _this3 = this;\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    }\n    // include levelCodec in audio and video tracks\n    var audio = tracks.audio,\n      video = tracks.video,\n      audiovideo = tracks.audiovideo;\n    if (audio) {\n      var audioCodec = currentLevel.audioCodec;\n      var ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(\"Android: force audio codec to \" + audioCodec);\n      }\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n    }\n    if (audiovideo) {\n      this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + (currentLevel.attrs.CODECS || '') + \"/\" + audiovideo.codec + \"]\");\n    }\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CODECS, tracks);\n    // loop through tracks that are going to be provided to bufferController\n    Object.keys(tracks).forEach(function (trackName) {\n      var track = tracks[trackName];\n      var initSegment = track.initSegment;\n      if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n        _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag: frag,\n          part: null,\n          chunkMeta: chunkMeta,\n          parent: frag.type\n        });\n      }\n    });\n    // trigger handler right now\n    this.tick();\n  };\n  _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);\n  };\n  _proto.backtrack = function backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;\n  };\n  _proto.checkFragmentChanged = function checkFragmentChanged() {\n    var video = this.media;\n    var fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      var currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        var fragPlaying = this.fragPlaying;\n        var fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  };\n  _createClass(StreamController, [{\n    key: \"nextLevel\",\n    get: function get() {\n      var frag = this.nextBufferedFrag;\n      if (frag) {\n        return frag.level;\n      }\n      return -1;\n    }\n  }, {\n    key: \"currentFrag\",\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n      }\n      return null;\n    }\n  }, {\n    key: \"currentProgramDateTime\",\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        var currentTime = media.currentTime;\n        var frag = this.currentFrag;\n        if (frag && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime) && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.programDateTime)) {\n          var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n          return new Date(epocMs);\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      var frag = this.currentFrag;\n      if (frag) {\n        return frag.level;\n      }\n      return -1;\n    }\n  }, {\n    key: \"nextBufferedFrag\",\n    get: function get() {\n      var frag = this.currentFrag;\n      if (frag) {\n        return this.followingBufferedFrag(frag);\n      }\n      return null;\n    }\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this._forceStartLoad;\n    }\n  }]);\n  return StreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-stream-controller.ts\":\n/*!******************************************************!*\\\n  !*** ./src/controller/subtitle-stream-controller.ts ***!\n  \\******************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_424349__) => {\n\n\"use strict\";\n__nested_webpack_require_424349__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_424349__.d(__nested_webpack_exports__, {\n/* harmony export */   \"SubtitleStreamController\": () => (/* binding */ SubtitleStreamController)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_424349__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_424349__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_424349__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_424349__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_424349__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_424349__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_424349__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_424349__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_424349__(/*! ../types/level */ \"./src/types/level.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 500; // how often to tick in ms\n\nvar SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(SubtitleStreamController, _BaseStreamController);\n  function SubtitleStreamController(hls, fragmentTracker, keyLoader) {\n    var _this;\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]') || this;\n    _this.levels = [];\n    _this.currentTrackId = -1;\n    _this.tracksBuffered = [];\n    _this.mainDetails = null;\n    _this._registerListeners();\n    return _this;\n  }\n  var _proto = SubtitleStreamController.prototype;\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n  };\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n  _proto.startLoad = function startLoad(startPosition) {\n    this.stopLoad();\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;\n    this.setInterval(TICK_INTERVAL);\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  };\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  };\n  _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {\n    var frag = data.frag,\n      success = data.success;\n    this.fragPrevious = frag;\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;\n    if (!success) {\n      return;\n    }\n    var buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    var timeRange;\n    var fragStart = frag.start;\n    for (var i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    var fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n  };\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var startOffset = data.startOffset,\n      endOffset = data.endOffset;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      }\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var endOffsetSubtitles = endOffset - targetDuration;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(function (buffered) {\n        for (var i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.SUBTITLE);\n    }\n  };\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    if (!this.loadedmetadata && data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.MAIN) {\n      var _this$media;\n      if ((_this$media = this.media) !== null && _this$media !== void 0 && _this$media.buffered.length) {\n        this.loadedmetadata = true;\n      }\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  ;\n  _proto.onError = function onError(event, data) {\n    var frag = data.frag;\n    // don't handle error not related to subtitle fragment\n    if (!frag || frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.SUBTITLE) {\n      return;\n    }\n    if (this.fragCurrent) {\n      this.fragCurrent.abortRequests();\n    }\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;\n  }\n\n  // Got all new subtitle levels.\n  ;\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {\n    var _this2 = this;\n    var subtitleTracks = _ref.subtitleTracks;\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_8__.Level(mediaPlaylist);\n    });\n    this.fragmentTracker.removeAllFragments();\n    this.fragPrevious = null;\n    this.levels.forEach(function (level) {\n      _this2.tracksBuffered[level.id] = [];\n    });\n    this.mediaBuffer = null;\n  };\n  _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n    this.currentTrackId = data.id;\n    if (!this.levels.length || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    var currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  ;\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    var newDetails = data.details,\n      trackId = data.id;\n    var currentTrackId = this.currentTrackId,\n      levels = this.levels;\n    if (!levels.length) {\n      return;\n    }\n    var track = levels[currentTrackId];\n    if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n      return;\n    }\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    var sliding = 0;\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      var mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          (0,_utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__.alignMediaPlaylistByPDT)(newDetails, mainDetails);\n          sliding = newDetails.fragments[0].start;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.addSliding)(newDetails, sliding);\n        }\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          (0,_level_helper__WEBPACK_IMPORTED_MODULE_4__.addSliding)(newDetails, sliding);\n        }\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE) {\n      var foundFrag = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_2__.findFragmentByPTS)(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  };\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    var _this3 = this;\n    var frag = fragLoadedData.frag,\n      payload = fragLoadedData.payload;\n    var decryptData = frag.decryptdata;\n    var hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      var startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n        var endTime = performance.now();\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_DECRYPTED, {\n          frag: frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(function (err) {\n        _this3.warn(err.name + \": \" + err.message);\n        _this3.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;\n      });\n    }\n  };\n  _proto.doTick = function doTick() {\n    if (!this.media) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;\n      return;\n    }\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE) {\n      var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      }\n\n      // Expand range of subs loaded by one target-duration in either direction to make up for misaligned playlists\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var config = this.config;\n      var currentTime = this.getLoadPosition();\n      var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__.BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime - targetDuration, config.maxBufferHole);\n      var targetBufferTime = bufferedInfo.end,\n        bufferLen = bufferedInfo.len;\n      var mainBufferInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.MAIN);\n      var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len) + targetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      console.assert(trackDetails, 'Subtitle track details are defined on idle subtitle stream controller tick');\n      var fragments = trackDetails.fragments;\n      var fragLen = fragments.length;\n      var end = trackDetails.edge;\n      var foundFrag = null;\n      var fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n        foundFrag = (0,_fragment_finders__WEBPACK_IMPORTED_MODULE_2__.findFragmentByPTS)(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), maxFragLookUpTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (!foundFrag) {\n        return;\n      }\n      foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n      if (this.fragmentTracker.getState(foundFrag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n  _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {\n    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  };\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this.fragCurrent = frag;\n    if (frag.sn === 'initSegment') {\n      this._loadInitSegment(frag, levelDetails);\n    } else {\n      this.startFragRequested = true;\n      _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n    }\n  };\n  _createClass(SubtitleStreamController, [{\n    key: \"mediaBufferTimeRanges\",\n    get: function get() {\n      return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n    }\n  }]);\n  return SubtitleStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\nvar BufferableInstance = function BufferableInstance(timeranges) {\n  this.buffered = void 0;\n  var getRange = function getRange(name, index, length) {\n    index = index >>> 0;\n    if (index > length - 1) {\n      throw new DOMException(\"Failed to execute '\" + name + \"' on 'TimeRanges': The index provided (\" + index + \") is greater than the maximum bound (\" + length + \")\");\n    }\n    return timeranges[index][name];\n  };\n  this.buffered = {\n    get length() {\n      return timeranges.length;\n    },\n    end: function end(index) {\n      return getRange('end', index, timeranges.length);\n    },\n    start: function start(index) {\n      return getRange('start', index, timeranges.length);\n    }\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-track-controller.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/controller/subtitle-track-controller.ts ***!\n  \\*****************************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_444008__) => {\n\n\"use strict\";\n__nested_webpack_require_444008__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_444008__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_444008__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_444008__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_444008__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_444008__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);\n  function SubtitleTrackController(hls) {\n    var _this;\n    _this = _BasePlaylistControll.call(this, hls, '[subtitle-track-controller]') || this;\n    _this.media = null;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.selectDefaultTrack = true;\n    _this.queuedDefaultTrack = -1;\n    _this.trackChangeListener = function () {\n      return _this.onTextTracksChanged();\n    };\n    _this.asyncPollTrackChange = function () {\n      return _this.pollTrackChange(0);\n    };\n    _this.useTextTrackPolling = false;\n    _this.subtitlePollingInterval = -1;\n    _this._subtitleDisplay = true;\n    _this.registerListeners();\n    return _this;\n  }\n  var _proto = SubtitleTrackController.prototype;\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.trackChangeListener = this.asyncPollTrackChange = null;\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  ;\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  };\n  _proto.pollTrackChange = function pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n    var textTracks = filterSubtitleTracks(this.media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(function (track) {\n      (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__.clearCurrentCues)(track);\n    });\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  ;\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  };\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var id = data.id,\n      details = data.details;\n    var trackId = this.trackId;\n    var currentTrack = this.tracksInGroup[trackId];\n    if (!currentTrack) {\n      this.warn(\"Invalid subtitle track id \" + id);\n      return;\n    }\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"subtitle track \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {\n      return;\n    }\n    var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];\n    if (this.groupId !== textGroupId) {\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      var subtitleTracks = this.tracks.filter(function (track) {\n        return !textGroupId || track.groupId === textGroupId;\n      });\n      this.tracksInGroup = subtitleTracks;\n      var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();\n      this.groupId = textGroupId;\n      var subtitleTracksUpdated = {\n        subtitleTracks: subtitleTracks\n      };\n      this.log(\"Updating subtitle tracks, \" + subtitleTracks.length + \" track(s) found in \\\"\" + textGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (initialTrackId !== -1) {\n        this.setSubtitleTrack(initialTrackId, lastTrack);\n      }\n    }\n  };\n  _proto.findTrackId = function findTrackId(name) {\n    var textTracks = this.tracksInGroup;\n    for (var i = 0; i < textTracks.length; i++) {\n      var track = textTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  };\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__.PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  }\n\n  /** get alternate subtitle tracks list from playlist **/;\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    _BasePlaylistControll.prototype.loadPlaylist.call(this);\n    var currentTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadTrack(currentTrack)) {\n      var id = currentTrack.id;\n      var groupId = currentTrack.groupId;\n      var url = currentTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n      this.log(\"Loading subtitle playlist for id \" + id);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */;\n  _proto.toggleTrackModes = function toggleTrackModes(newId) {\n    var _this2 = this;\n    var media = this.media,\n      trackId = this.trackId;\n    if (!media) {\n      return;\n    }\n    var textTracks = filterSubtitleTracks(media.textTracks);\n    var groupTracks = textTracks.filter(function (track) {\n      return track.groupId === _this2.groupId;\n    });\n    if (newId === -1) {\n      [].slice.call(textTracks).forEach(function (track) {\n        track.mode = 'disabled';\n      });\n    } else {\n      var oldTrack = groupTracks[trackId];\n      if (oldTrack) {\n        oldTrack.mode = 'disabled';\n      }\n    }\n    var nextTrack = groupTracks[newId];\n    if (nextTrack) {\n      nextTrack.mode = this.subtitleDisplay ? 'showing' : 'hidden';\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */;\n  _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {\n    var _tracks$newId;\n    var tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n    if (this.trackId !== newId) {\n      this.toggleTrackModes(newId);\n    }\n\n    // exit if track id as already set or invalid\n    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    var track = tracks[newId];\n    this.log(\"Switching to subtitle track \" + newId);\n    this.trackId = newId;\n    if (track) {\n      var id = track.id,\n        _track$groupId = track.groupId,\n        groupId = _track$groupId === void 0 ? '' : _track$groupId,\n        name = track.name,\n        type = track.type,\n        url = track.url;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, {\n        id: id,\n        groupId: groupId,\n        name: name,\n        type: type,\n        url: url\n      });\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n      this.loadPlaylist(hlsUrlParameters);\n    } else {\n      // switch to -1\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n    }\n  };\n  _proto.onTextTracksChanged = function onTextTracksChanged() {\n    if (!this.useTextTrackPolling) {\n      self.clearInterval(this.subtitlePollingInterval);\n    }\n    // Media is undefined when switching streams via loadSource()\n    if (!this.media || !this.hls.config.renderTextTracksNatively) {\n      return;\n    }\n    var trackId = -1;\n    var tracks = filterSubtitleTracks(this.media.textTracks);\n    for (var id = 0; id < tracks.length; id++) {\n      if (tracks[id].mode === 'hidden') {\n        // Do not break in case there is a following track with showing.\n        trackId = id;\n      } else if (tracks[id].mode === 'showing') {\n        trackId = id;\n        break;\n      }\n    }\n\n    // Setting current subtitleTrack will invoke code.\n    if (this.subtitleTrack !== trackId) {\n      this.subtitleTrack = trackId;\n    }\n  };\n  _createClass(SubtitleTrackController, [{\n    key: \"subtitleDisplay\",\n    get: function get() {\n      return this._subtitleDisplay;\n    },\n    set: function set(value) {\n      this._subtitleDisplay = value;\n      if (this.trackId > -1) {\n        this.toggleTrackModes(this.trackId);\n      }\n    }\n  }, {\n    key: \"subtitleTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n\n    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      this.selectDefaultTrack = false;\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      this.setSubtitleTrack(newId, lastTrack);\n    }\n  }]);\n  return SubtitleTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nfunction filterSubtitleTracks(textTrackList) {\n  var tracks = [];\n  for (var i = 0; i < textTrackList.length; i++) {\n    var track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SubtitleTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/timeline-controller.ts\":\n/*!***********************************************!*\\\n  !*** ./src/controller/timeline-controller.ts ***!\n  \\***********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_460416__) => {\n\n\"use strict\";\n__nested_webpack_require_460416__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_460416__.d(__nested_webpack_exports__, {\n/* harmony export */   \"TimelineController\": () => (/* binding */ TimelineController)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_460416__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_460416__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_460416__(/*! ../utils/cea-608-parser */ \"./src/utils/cea-608-parser.ts\");\n/* harmony import */ var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_460416__(/*! ../utils/output-filter */ \"./src/utils/output-filter.ts\");\n/* harmony import */ var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_460416__(/*! ../utils/webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_460416__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_460416__(/*! ../utils/imsc1-ttml-parser */ \"./src/utils/imsc1-ttml-parser.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_460416__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_460416__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_460416__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\n\nvar TimelineController = /*#__PURE__*/function () {\n  function TimelineController(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.timescale = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    if (this.config.enableCEA708Captions) {\n      var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack1');\n      var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack2');\n      var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack3');\n      var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack4');\n      this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, channel1, channel2);\n      this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](3, channel3, channel4);\n    }\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  var _proto = TimelineController.prototype;\n  _proto.destroy = function destroy() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;\n  };\n  _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    var merged = false;\n    for (var i = cueRanges.length; i--;) {\n      var cueRange = cueRanges[i];\n      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      var track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      var cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.CUES_PARSED, {\n        type: 'captions',\n        cues: cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  ;\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var _this = this;\n    var frag = _ref.frag,\n      id = _ref.id,\n      initPTS = _ref.initPTS,\n      timescale = _ref.timescale;\n    var unparsedVttFrags = this.unparsedVttFrags;\n    if (id === 'main') {\n      this.initPTS[frag.cc] = initPTS;\n      this.timescale[frag.cc] = timescale;\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(function (frag) {\n        _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, frag);\n      });\n    }\n  };\n  _proto.getExistingTrack = function getExistingTrack(trackName) {\n    var media = this.media;\n    if (media) {\n      for (var i = 0; i < media.textTracks.length; i++) {\n        var textTrack = media.textTracks[i];\n        if (textTrack[trackName]) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  };\n  _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  };\n  _proto.createNativeTrack = function createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    var captionsProperties = this.captionsProperties,\n      captionsTracks = this.captionsTracks,\n      media = this.media;\n    var _captionsProperties$t = captionsProperties[trackName],\n      label = _captionsProperties$t.label,\n      languageCode = _captionsProperties$t.languageCode;\n    // Enable reuse of existing text track.\n    var existingTrack = this.getExistingTrack(trackName);\n    if (!existingTrack) {\n      var textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(captionsTracks[trackName]);\n      (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.sendAddTrackEvent)(captionsTracks[trackName], media);\n    }\n  };\n  _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    var trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    var label = trackProperties.label;\n    var track = {\n      _id: trackName,\n      label: label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  };\n  _proto.createTextTrack = function createTextTrack(kind, label, lang) {\n    var media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  };\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media;\n    this._cleanTracks();\n  };\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var captionsTracks = this.captionsTracks;\n    Object.keys(captionsTracks).forEach(function (trackName) {\n      (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  };\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.lastSn = -1; // Detect discontinuity in fragment parsing\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = this.unparsedVttFrags || [];\n    this.initPTS = [];\n    this.timescale = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  };\n  _proto._cleanTracks = function _cleanTracks() {\n    // clear outdated subtitles\n    var media = this.media;\n    if (!media) {\n      return;\n    }\n    var textTracks = media.textTracks;\n    if (textTracks) {\n      for (var i = 0; i < textTracks.length; i++) {\n        (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(textTracks[i]);\n      }\n    }\n  };\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {\n    var _this2 = this;\n    this.textTracks = [];\n    var tracks = data.subtitleTracks || [];\n    var hasIMSC1 = tracks.some(function (track) {\n      return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC;\n    });\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;\n      this.tracks = tracks || [];\n      if (this.config.renderTextTracksNatively) {\n        var inUseTracks = this.media ? this.media.textTracks : [];\n        this.tracks.forEach(function (track, index) {\n          var textTrack;\n          if (index < inUseTracks.length) {\n            var inUseTrack = null;\n            for (var i = 0; i < inUseTracks.length; i++) {\n              if (canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                break;\n              }\n            }\n\n            // Reuse tracks with the same label, but do not reuse 608/708 tracks\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(textTrack);\n          } else {\n            var textTrackKind = _this2._captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            textTrack.groupId = track.groupId;\n            _this2.textTracks.push(textTrack);\n          }\n        });\n      } else if (!sameTracks && this.tracks && this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        var tracksList = this.tracks.map(function (track) {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  };\n  _proto._captionsOrSubtitlesFromCharacteristics = function _captionsOrSubtitlesFromCharacteristics(track) {\n    var _track$attrs;\n    if ((_track$attrs = track.attrs) !== null && _track$attrs !== void 0 && _track$attrs.CHARACTERISTICS) {\n      var transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);\n      var describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);\n      if (transcribesSpokenDialog && describesMusicAndSound) {\n        return 'captions';\n      }\n    }\n    return 'subtitles';\n  };\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var _this3 = this;\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(function (captionsTrack) {\n        var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        var trackName = \"textTrack\" + instreamIdMatch[1];\n        var trackProperties = _this3.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  };\n  _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {\n    var level = this.hls.levels[frag.level];\n    return level === null || level === void 0 ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  };\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n      cea608Parser2 = this.cea608Parser2,\n      lastSn = this.lastSn,\n      lastPartIndex = this.lastPartIndex;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      var sn = data.frag.sn;\n      var partIndex = (_data$part$index = data === null || data === void 0 ? void 0 : (_data$part = data.part) === null || _data$part === void 0 ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {\n        cea608Parser1.reset();\n        cea608Parser2.reset();\n      }\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  };\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n      payload = data.payload;\n    var initPTS = this.initPTS,\n      unparsedVttFrags = this.unparsedVttFrags;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        // We need an initial synchronisation PTS. Store fragments as long as none has arrived.\n        if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS[frag.cc])) {\n          unparsedVttFrags.push(data);\n          if (initPTS.length) {\n            // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n              success: false,\n              frag: frag,\n              error: new Error('Missing initial subtitle PTS')\n            });\n          }\n          return;\n        }\n        var decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        var decrypted = ('stats' in data);\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          var trackPlaylistMedia = this.tracks[frag.level];\n          var vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(frag, payload, vttCCs);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  };\n  _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {\n    var _this4 = this;\n    var hls = this.hls;\n    (0,_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.parseIMSC1)(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function (cues) {\n      _this4._appendCues(cues, frag.level);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"Failed to parse IMSC1: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n  _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {\n    var _frag$initSegment,\n      _this5 = this;\n    var hls = this.hls;\n    // Parse the WebVTT file contents.\n    var payloadWebVTT = (_frag$initSegment = frag.initSegment) !== null && _frag$initSegment !== void 0 && _frag$initSegment.data ? (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__.appendUint8Array)(frag.initSegment.data, new Uint8Array(payload)) : payload;\n    (0,_utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__.parseWebVTT)(payloadWebVTT, this.initPTS[frag.cc], this.timescale[frag.cc], vttCCs, frag.cc, frag.start, function (cues) {\n      _this5._appendCues(cues, frag.level);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _this5._fallbackToIMSC1(frag, payload);\n      // Something went wrong while parsing. Trigger event with success false.\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"Failed to parse VTT cue: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n  _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {\n    var _this6 = this;\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    var trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      (0,_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.parseIMSC1)(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function () {\n        trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC;\n        _this6._parseIMSC1(frag, payload);\n      }, function () {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  };\n  _proto._appendCues = function _appendCues(cues, fragLevel) {\n    var hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      var textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(function (cue) {\n        return (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.addCueToTrack)(textTrack, cue);\n      });\n    } else {\n      var currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues: cues,\n        track: track\n      });\n    }\n  };\n  _proto.onFragDecrypted = function onFragDecrypted(event, data) {\n    var frag = data.frag;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.SUBTITLE) {\n      if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.initPTS[frag.cc])) {\n        this.unparsedVttFrags.push(data);\n        return;\n      }\n      this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, data);\n    }\n  };\n  _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  };\n  _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n      cea608Parser2 = this.cea608Parser2;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    var frag = data.frag,\n      samples = data.samples;\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (var i = 0; i < samples.length; i++) {\n      var ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        var ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  };\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {\n    var startOffset = _ref2.startOffset,\n      endOffset = _ref2.endOffset,\n      endOffsetSubtitles = _ref2.endOffsetSubtitles,\n      type = _ref2.type;\n    var media = this.media;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      var captionsTracks = this.captionsTracks;\n      Object.keys(captionsTracks).forEach(function (trackName) {\n        return (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.removeCuesInRange)(captionsTracks[trackName], startOffset, endOffset);\n      });\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        var textTracks = this.textTracks;\n        Object.keys(textTracks).forEach(function (trackName) {\n          return (0,_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.removeCuesInRange)(textTracks[trackName], startOffset, endOffsetSubtitles);\n        });\n      }\n    }\n  };\n  _proto.extractCea608Data = function extractCea608Data(byteArray) {\n    var actualCCBytes = [[], []];\n    var count = byteArray[0] & 0x1f;\n    var position = 2;\n    for (var j = 0; j < count; j++) {\n      var tmpByte = byteArray[position++];\n      var ccbyte1 = 0x7f & byteArray[position++];\n      var ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      var ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        var ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  };\n  return TimelineController;\n}();\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-crypto.ts\":\n/*!*********************************!*\\\n  !*** ./src/crypt/aes-crypto.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_488439__) => {\n\n\"use strict\";\n__nested_webpack_require_488439__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_488439__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AESCrypto)\n/* harmony export */ });\nvar AESCrypto = /*#__PURE__*/function () {\n  function AESCrypto(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n  var _proto = AESCrypto.prototype;\n  _proto.decrypt = function decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  };\n  return AESCrypto;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-decryptor.ts\":\n/*!************************************!*\\\n  !*** ./src/crypt/aes-decryptor.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_489302__) => {\n\n\"use strict\";\n__nested_webpack_require_489302__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_489302__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AESDecryptor),\n/* harmony export */   \"removePadding\": () => (/* binding */ removePadding)\n/* harmony export */ });\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_489302__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n// PKCS7\nfunction removePadding(array) {\n  var outputBytes = array.byteLength;\n  var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return (0,_utils_typed_array__WEBPACK_IMPORTED_MODULE_0__.sliceUint8)(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nvar AESDecryptor = /*#__PURE__*/function () {\n  function AESDecryptor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  var _proto = AESDecryptor.prototype;\n  _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n    var view = new DataView(arrayBuffer);\n    var newArray = new Uint32Array(4);\n    for (var i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  };\n  _proto.initTable = function initTable() {\n    var sBox = this.sBox;\n    var invSBox = this.invSBox;\n    var subMix = this.subMix;\n    var subMix0 = subMix[0];\n    var subMix1 = subMix[1];\n    var subMix2 = subMix[2];\n    var subMix3 = subMix[3];\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var d = new Uint32Array(256);\n    var x = 0;\n    var xi = 0;\n    var i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      var x2 = d[x];\n      var x4 = d[x2];\n      var x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      var t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  };\n  _proto.expandKey = function expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    var key = this.uint8ArrayToUint32Array_(keyBuffer);\n    var sameKey = true;\n    var offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    var keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    var ksRow;\n    var invKsRow;\n    var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    var sbox = this.sBox;\n    var rcon = this.rcon;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var prev;\n    var t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  ;\n  _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  };\n  _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n    var nRounds = this.keySize + 6;\n    var invKeySchedule = this.invKeySchedule;\n    var invSBOX = this.invSBox;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var initVector = this.uint8ArrayToUint32Array_(aesIV);\n    var initVector0 = initVector[0];\n    var initVector1 = initVector[1];\n    var initVector2 = initVector[2];\n    var initVector3 = initVector[3];\n    var inputInt32 = new Int32Array(inputArrayBuffer);\n    var outputInt32 = new Int32Array(inputInt32.length);\n    var t0, t1, t2, t3;\n    var s0, s1, s2, s3;\n    var inputWords0, inputWords1, inputWords2, inputWords3;\n    var ksRow, i;\n    var swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  };\n  return AESDecryptor;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/crypt/decrypter.ts\":\n/*!********************************!*\\\n  !*** ./src/crypt/decrypter.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_498686__) => {\n\n\"use strict\";\n__nested_webpack_require_498686__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_498686__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Decrypter)\n/* harmony export */ });\n/* harmony import */ var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_498686__(/*! ./aes-crypto */ \"./src/crypt/aes-crypto.ts\");\n/* harmony import */ var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_498686__(/*! ./fast-aes-key */ \"./src/crypt/fast-aes-key.ts\");\n/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_498686__(/*! ./aes-decryptor */ \"./src/crypt/aes-decryptor.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_498686__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_498686__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_498686__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\nvar CHUNK_SIZE = 16; // 16 bytes, 128 bits\nvar Decrypter = /*#__PURE__*/function () {\n  function Decrypter(config, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n      removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        var browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    if (this.subtle === null) {\n      this.useSoftware = true;\n    }\n  }\n  var _proto = Decrypter.prototype;\n  _proto.destroy = function destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  };\n  _proto.isSync = function isSync() {\n    return this.useSoftware;\n  };\n  _proto.flush = function flush() {\n    var currentResult = this.currentResult,\n      remainderData = this.remainderData;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    var data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return (0,_aes_decryptor__WEBPACK_IMPORTED_MODULE_2__.removePadding)(data);\n    }\n    return data;\n  };\n  _proto.reset = function reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  };\n  _proto.decrypt = function decrypt(data, key, iv) {\n    var _this = this;\n    if (this.useSoftware) {\n      return new Promise(function (resolve, reject) {\n        _this.softwareDecrypt(new Uint8Array(data), key, iv);\n        var decryptResult = _this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  ;\n  _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n    var currentIV = this.currentIV,\n      currentResult = this.currentResult,\n      remainderData = this.remainderData;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    var currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    var softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    }\n    softwareDecrypter.expandKey(key);\n    var result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = (0,_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(currentChunk, -16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  };\n  _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n    var _this2 = this;\n    var subtle = this.subtle;\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__[\"default\"](subtle, key);\n    }\n    return this.fastAesKey.expandKey().then(function (aesKey) {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      _this2.logOnce('WebCrypto AES decrypt');\n      var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__[\"default\"](subtle, new Uint8Array(iv));\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + err.name + \": \" + err.message);\n      return _this2.onWebCryptoError(data, key, iv);\n    });\n  };\n  _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    var decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  };\n  _proto.getValidChunk = function getValidChunk(data) {\n    var currentChunk = data;\n    var splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = (0,_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, 0, splitPoint);\n      this.remainderData = (0,_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, splitPoint);\n    }\n    return currentChunk;\n  };\n  _proto.logOnce = function logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"[decrypter]: \" + msg);\n    this.logEnabled = false;\n  };\n  return Decrypter;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/crypt/fast-aes-key.ts\":\n/*!***********************************!*\\\n  !*** ./src/crypt/fast-aes-key.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_506288__) => {\n\n\"use strict\";\n__nested_webpack_require_506288__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_506288__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FastAESKey)\n/* harmony export */ });\nvar FastAESKey = /*#__PURE__*/function () {\n  function FastAESKey(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n  var _proto = FastAESKey.prototype;\n  _proto.expandKey = function expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  };\n  return FastAESKey;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/demux/aacdemuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/aacdemuxer.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_507154__) => {\n\n\"use strict\";\n__nested_webpack_require_507154__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_507154__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_507154__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_507154__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_507154__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_507154__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n/**\n * AAC demuxer\n */\n\n\n\n\nvar AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n  function AACDemuxer(observer, config) {\n    var _this;\n    _this = _BaseAudioDemuxer.call(this) || this;\n    _this.observer = void 0;\n    _this.config = void 0;\n    _this.observer = observer;\n    _this.config = config;\n    return _this;\n  }\n  var _proto = AACDemuxer.prototype;\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  ;\n  AACDemuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__.getID3Data(data, 0) || [];\n    var offset = id3Data.length;\n    for (var length = data.length; offset < length; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_1__.probe(data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  };\n  _proto.canParse = function canParse(data, offset) {\n    return _adts__WEBPACK_IMPORTED_MODULE_1__.canParse(data, offset);\n  };\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    _adts__WEBPACK_IMPORTED_MODULE_1__.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    var frame = _adts__WEBPACK_IMPORTED_MODULE_1__.appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  };\n  return AACDemuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AACDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/adts.ts\":\n/*!***************************!*\\\n  !*** ./src/demux/adts.ts ***!\n  \\***************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_510956__) => {\n\n\"use strict\";\n__nested_webpack_require_510956__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_510956__.d(__nested_webpack_exports__, {\n/* harmony export */   \"appendFrame\": () => (/* binding */ appendFrame),\n/* harmony export */   \"canGetFrameLength\": () => (/* binding */ canGetFrameLength),\n/* harmony export */   \"canParse\": () => (/* binding */ canParse),\n/* harmony export */   \"getAudioConfig\": () => (/* binding */ getAudioConfig),\n/* harmony export */   \"getFrameDuration\": () => (/* binding */ getFrameDuration),\n/* harmony export */   \"getFullFrameLength\": () => (/* binding */ getFullFrameLength),\n/* harmony export */   \"getHeaderLength\": () => (/* binding */ getHeaderLength),\n/* harmony export */   \"initTrackConfig\": () => (/* binding */ initTrackConfig),\n/* harmony export */   \"isHeader\": () => (/* binding */ isHeader),\n/* harmony export */   \"isHeaderPattern\": () => (/* binding */ isHeaderPattern),\n/* harmony export */   \"parseFrameHeader\": () => (/* binding */ parseFrameHeader),\n/* harmony export */   \"probe\": () => (/* binding */ probe)\n/* harmony export */ });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_510956__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_510956__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_510956__(/*! ../events */ \"./src/events.ts\");\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\n\n\n\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  var adtsObjectType;\n  var adtsExtensionSamplingIndex;\n  var adtsChannelConfig;\n  var config;\n  var userAgent = navigator.userAgent.toLowerCase();\n  var manifestCodec = audioCodec;\n  var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n    observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      reason: \"invalid ADTS sampling index:\" + adtsSamplingIndex\n    });\n    return;\n  }\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n  // byte 3\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChannelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSamplingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return {\n    config: config,\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\n    channelCount: adtsChannelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec: manifestCodec\n  };\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader(data, offset)) {\n    // ADTS header Length\n    var headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    var frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    var config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  var headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    var frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength: headerLength,\n        frameLength: frameLength\n      };\n    }\n  }\n}\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  var frameDuration = getFrameDuration(track.samplerate);\n  var stamp = pts + frameIndex * frameDuration;\n  var header = parseFrameHeader(data, offset);\n  var unit;\n  if (header) {\n    var frameLength = header.frameLength,\n      headerLength = header.headerLength;\n    var _length = headerLength + frameLength;\n    var missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    var _sample = {\n      unit: unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing: missing\n    };\n  }\n  // overflow incomplete header\n  var length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  var sample = {\n    unit: unit,\n    pts: stamp\n  };\n  return {\n    sample: sample,\n    length: length,\n    missing: -1\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/demux/base-audio-demuxer.ts\":\n/*!*****************************************!*\\\n  !*** ./src/demux/base-audio-demuxer.ts ***!\n  \\*****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_522093__) => {\n\n\"use strict\";\n__nested_webpack_require_522093__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_522093__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"initPTSFn\": () => (/* binding */ initPTSFn)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_522093__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_522093__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_522093__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_522093__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_522093__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_522093__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\n\nvar BaseAudioDemuxer = /*#__PURE__*/function () {\n  function BaseAudioDemuxer() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  var _proto = BaseAudioDemuxer.prototype;\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  };\n  _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  };\n  _proto.resetContiguity = function resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  };\n  _proto.canParse = function canParse(data, offset) {\n    return false;\n  };\n  _proto.appendFrame = function appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  ;\n  _proto.demux = function demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(this.cachedData, data);\n      this.cachedData = null;\n    }\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, 0);\n    var offset = id3Data ? id3Data.length : 0;\n    var lastDataIndex;\n    var track = this._audioTrack;\n    var id3Track = this._id3Track;\n    var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getTimeStamp(id3Data) : undefined;\n    var length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__.MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        var frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__.canParse(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__.MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        var partialData = (0,_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),\n      id3Track: id3Track,\n      textTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()\n    };\n  };\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n  };\n  _proto.flush = function flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    var cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),\n      id3Track: this._id3Track,\n      textTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()\n    };\n  };\n  _proto.destroy = function destroy() {};\n  return BaseAudioDemuxer;\n}();\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nvar initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {\n  if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(timestamp)) {\n    return timestamp * 90;\n  }\n  return timeOffset * 90000 + (initPTS || 0);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseAudioDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/chunk-cache.ts\":\n/*!**********************************!*\\\n  !*** ./src/demux/chunk-cache.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_528752__) => {\n\n\"use strict\";\n__nested_webpack_require_528752__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_528752__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChunkCache)\n/* harmony export */ });\nvar ChunkCache = /*#__PURE__*/function () {\n  function ChunkCache() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  var _proto = ChunkCache.prototype;\n  _proto.push = function push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  };\n  _proto.flush = function flush() {\n    var chunks = this.chunks,\n      dataLength = this.dataLength;\n    var result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  };\n  _proto.reset = function reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  };\n  return ChunkCache;\n}();\n\nfunction concatUint8Arrays(chunks, dataLength) {\n  var result = new Uint8Array(dataLength);\n  var offset = 0;\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/dummy-demuxed-track.ts\":\n/*!******************************************!*\\\n  !*** ./src/demux/dummy-demuxed-track.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_530255__) => {\n\n\"use strict\";\n__nested_webpack_require_530255__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_530255__.d(__nested_webpack_exports__, {\n/* harmony export */   \"dummyTrack\": () => (/* binding */ dummyTrack)\n/* harmony export */ });\nfunction dummyTrack(type, inputTimeScale) {\n  if (type === void 0) {\n    type = '';\n  }\n  if (inputTimeScale === void 0) {\n    inputTimeScale = 90000;\n  }\n  return {\n    type: type,\n    id: -1,\n    pid: -1,\n    inputTimeScale: inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/demux/exp-golomb.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/exp-golomb.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_531024__) => {\n\n\"use strict\";\n__nested_webpack_require_531024__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_531024__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_531024__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\n\nvar ExpGolomb = /*#__PURE__*/function () {\n  function ExpGolomb(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  var _proto = ExpGolomb.prototype;\n  _proto.loadWord = function loadWord() {\n    var data = this.data;\n    var bytesAvailable = this.bytesAvailable;\n    var position = data.byteLength - bytesAvailable;\n    var workingBytes = new Uint8Array(4);\n    var availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  ;\n  _proto.skipBits = function skipBits(count) {\n    var skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  ;\n  _proto.readBits = function readBits(size) {\n    var bits = Math.min(this.bitsAvailable, size); // :uint\n    var valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  ;\n  _proto.skipLZ = function skipLZ() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  ;\n  _proto.skipUEG = function skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  ;\n  _proto.skipEG = function skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  ;\n  _proto.readUEG = function readUEG() {\n    var clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  ;\n  _proto.readEG = function readEG() {\n    var valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  ;\n  _proto.readBoolean = function readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  ;\n  _proto.readUByte = function readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  ;\n  _proto.readUShort = function readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  ;\n  _proto.readUInt = function readUInt() {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */;\n  _proto.skipScalingList = function skipScalingList(count) {\n    var lastScale = 8;\n    var nextScale = 8;\n    var deltaScale;\n    for (var j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */;\n  _proto.readSPS = function readSPS() {\n    var frameCropLeftOffset = 0;\n    var frameCropRightOffset = 0;\n    var frameCropTopOffset = 0;\n    var frameCropBottomOffset = 0;\n    var numRefFramesInPicOrderCntCycle;\n    var scalingListCount;\n    var i;\n    var readUByte = this.readUByte.bind(this);\n    var readBits = this.readBits.bind(this);\n    var readUEG = this.readUEG.bind(this);\n    var readBoolean = this.readBoolean.bind(this);\n    var skipBits = this.skipBits.bind(this);\n    var skipEG = this.skipEG.bind(this);\n    var skipUEG = this.skipUEG.bind(this);\n    var skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    var profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      var chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    var picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    var picWidthInMbsMinus1 = readUEG();\n    var picHeightInMapUnitsMinus1 = readUEG();\n    var frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    var pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        var aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  };\n  _proto.readSliceType = function readSliceType() {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  };\n  return ExpGolomb;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExpGolomb);\n\n/***/ }),\n\n/***/ \"./src/demux/id3.ts\":\n/*!**************************!*\\\n  !*** ./src/demux/id3.ts ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_541987__) => {\n\n\"use strict\";\n__nested_webpack_require_541987__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_541987__.d(__nested_webpack_exports__, {\n/* harmony export */   \"canParse\": () => (/* binding */ canParse),\n/* harmony export */   \"decodeFrame\": () => (/* binding */ decodeFrame),\n/* harmony export */   \"getID3Data\": () => (/* binding */ getID3Data),\n/* harmony export */   \"getID3Frames\": () => (/* binding */ getID3Frames),\n/* harmony export */   \"getTimeStamp\": () => (/* binding */ getTimeStamp),\n/* harmony export */   \"isFooter\": () => (/* binding */ isFooter),\n/* harmony export */   \"isHeader\": () => (/* binding */ isHeader),\n/* harmony export */   \"isTimeStampFrame\": () => (/* binding */ isTimeStampFrame),\n/* harmony export */   \"testables\": () => (/* binding */ testables),\n/* harmony export */   \"utf8ArrayToStr\": () => (/* binding */ utf8ArrayToStr)\n/* harmony export */ });\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 header is found\n */\nvar isHeader = function isHeader(data, offset) {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 footer is found\n */\nvar isFooter = function isFooter(data, offset) {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {Uint8Array | undefined} - The block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nvar getID3Data = function getID3Data(data, offset) {\n  var front = offset;\n  var length = 0;\n  while (isHeader(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    var size = readSize(data, offset + 6);\n    length += size;\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n};\nvar readSize = function readSize(data, offset) {\n  var size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\nvar canParse = function canParse(data, offset) {\n  return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param {Uint8Array} data - Block of data containing one or more ID3 tags\n * @return {number | undefined} - The timestamp\n */\nvar getTimeStamp = function getTimeStamp(data) {\n  var frames = getID3Frames(data);\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n * @param {ID3 frame} frame\n */\nvar isTimeStampFrame = function isTimeStampFrame(frame) {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\nvar getFrameData = function getFrameData(data) {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  var size = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  var offset = 10;\n  return {\n    type: type,\n    size: size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags\n * @return {ID3.Frame[]} - Array of ID3 frame objects\n */\nvar getID3Frames = function getID3Frames(id3Data) {\n  var offset = 0;\n  var frames = [];\n  while (isHeader(id3Data, offset)) {\n    var size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    var end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      var frameData = getFrameData(id3Data.subarray(offset));\n      var frame = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n  return frames;\n};\nvar decodeFrame = function decodeFrame(frame) {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n  return decodeTextFrame(frame);\n};\nvar decodePrivFrame = function decodePrivFrame(frame) {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  var owner = utf8ArrayToStr(frame.data, true);\n  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\nvar decodeTextFrame = function decodeTextFrame(frame) {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  var text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\nvar decodeURLFrame = function decodeURLFrame(frame) {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  var url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\nvar readTimeStamp = function readTimeStamp(timeStampFrame) {\n  if (timeStampFrame.data.byteLength === 8) {\n    var data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    var pts33Bit = data[3] & 0x1;\n    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nvar utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n  if (exitOnNull === void 0) {\n    exitOnNull = false;\n  }\n  var decoder = getTextDecoder();\n  if (decoder) {\n    var decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      var idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  var len = array.length;\n  var c;\n  var char2;\n  var char3;\n  var out = '';\n  var i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n      default:\n    }\n  }\n  return out;\n};\nvar testables = {\n  decodeTextFrame: decodeTextFrame\n};\nvar decoder;\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n  return decoder;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/mp3demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp3demuxer.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_552919__) => {\n\n\"use strict\";\n__nested_webpack_require_552919__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_552919__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_552919__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_552919__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_552919__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_552919__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n/**\n * MP3 demuxer\n */\n\n\n\n\nvar MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n  function MP3Demuxer() {\n    return _BaseAudioDemuxer.apply(this, arguments) || this;\n  }\n  var _proto = MP3Demuxer.prototype;\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  };\n  MP3Demuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, 0) || [];\n    var offset = id3Data.length;\n    for (var length = data.length; offset < length; offset++) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__.probe(data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  };\n  _proto.canParse = function canParse(data, offset) {\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__.canParse(data, offset);\n  };\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__.appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n  };\n  return MP3Demuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MP3Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mp4demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp4demuxer.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_556513__) => {\n\n\"use strict\";\n__nested_webpack_require_556513__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_556513__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_556513__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_556513__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_556513__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_556513__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n\n/**\n * MP4 demuxer\n */\n\n\n\nvar emsgSchemePattern = /\\/emsg[-/]ID3/i;\nvar MP4Demuxer = /*#__PURE__*/function () {\n  function MP4Demuxer(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  var _proto = MP4Demuxer.prototype;\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    var videoTrack = this.videoTrack = (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)('video', 1);\n    var audioTrack = this.audioTrack = (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)('audio', 1);\n    var captionTrack = this.txtTrack = (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)('text', 1);\n    this.id3Track = (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)('id3', 1);\n    this.timeOffset = 0;\n    if (!initSegment || !initSegment.byteLength) {\n      return;\n    }\n    var initData = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseInitSegment)(initSegment);\n    if (initData.video) {\n      var _initData$video = initData.video,\n        id = _initData$video.id,\n        timescale = _initData$video.timescale,\n        codec = _initData$video.codec;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n    if (initData.audio) {\n      var _initData$audio = initData.audio,\n        _id = _initData$audio.id,\n        _timescale = _initData$audio.timescale,\n        _codec = _initData$audio.codec;\n      audioTrack.id = _id;\n      audioTrack.timescale = _timescale;\n      audioTrack.codec = _codec;\n    }\n    captionTrack.id = _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  };\n  _proto.resetContiguity = function resetContiguity() {};\n  MP4Demuxer.probe = function probe(data) {\n    // ensure we find a moof box in the first 16 kB\n    data = data.length > 16384 ? data.subarray(0, 16384) : data;\n    return (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.findBox)(data, ['moof']).length > 0;\n  };\n  _proto.demux = function demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    var videoSamples = data;\n    var videoTrack = this.videoTrack;\n    var textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.appendUint8Array)(this.remainderData, data);\n      }\n      var segmentedData = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.segmentValidRange)(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    var id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseSamples)(timeOffset, videoTrack);\n    return {\n      videoTrack: videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track: id3Track,\n      textTrack: this.txtTrack\n    };\n  };\n  _proto.flush = function flush() {\n    var timeOffset = this.timeOffset;\n    var videoTrack = this.videoTrack;\n    var textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseSamples)(timeOffset, videoTrack);\n    return {\n      videoTrack: videoTrack,\n      audioTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),\n      id3Track: id3Track,\n      textTrack: (0,_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()\n    };\n  };\n  _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n    var id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      var emsgs = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.findBox)(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(function (data) {\n          var emsgInfo = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseEmsg)(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            var pts = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            var duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            var payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: _types_demuxer__WEBPACK_IMPORTED_MODULE_1__.MetadataSchema.emsg,\n              duration: duration\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  };\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  };\n  _proto.destroy = function destroy() {};\n  return MP4Demuxer;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MP4Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mpegaudio.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/mpegaudio.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_563939__) => {\n\n\"use strict\";\n__nested_webpack_require_563939__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_563939__.d(__nested_webpack_exports__, {\n/* harmony export */   \"appendFrame\": () => (/* binding */ appendFrame),\n/* harmony export */   \"canParse\": () => (/* binding */ canParse),\n/* harmony export */   \"isHeader\": () => (/* binding */ isHeader),\n/* harmony export */   \"isHeaderPattern\": () => (/* binding */ isHeaderPattern),\n/* harmony export */   \"parseHeader\": () => (/* binding */ parseHeader),\n/* harmony export */   \"probe\": () => (/* binding */ probe)\n/* harmony export */ });\n/**\n *  MPEG parser helper\n */\n\nvar chromeVersion = null;\nvar BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nvar SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nvar SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\n\nvar BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\n\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  var header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    var stamp = pts + frameIndex * frameDuration;\n    var sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample: sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  var mpegVersion = data[offset + 1] >> 3 & 3;\n  var mpegLayer = data[offset + 1] >> 1 & 3;\n  var bitRateIndex = data[offset + 2] >> 4 & 15;\n  var sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    var paddingBit = data[offset + 2] >> 1 & 1;\n    var channelMode = data[offset + 3] >> 6;\n    var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    var bytesInSlot = BytesInSlot[mpegLayer];\n    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    var needChromeFix = !!chromeVersion && chromeVersion <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate: sampleRate,\n      channelCount: channelCount,\n      frameLength: frameLength,\n      samplesPerFrame: samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  var headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    var headerLength = 4;\n    // MPEG frame Length\n    var header = parseHeader(data, offset);\n    var frameLength = headerLength;\n    if (header !== null && header !== void 0 && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/sample-aes.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/sample-aes.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_569525__) => {\n\n\"use strict\";\n__nested_webpack_require_569525__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_569525__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_569525__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_569525__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/**\n * SAMPLE-AES decrypter\n */\n\n\n\nvar SampleAesDecrypter = /*#__PURE__*/function () {\n  function SampleAesDecrypter(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__[\"default\"](config, {\n      removePKCS7Padding: false\n    });\n  }\n  var _proto = SampleAesDecrypter.prototype;\n  _proto.decryptBuffer = function decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  ;\n  _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {\n    var _this = this;\n    var curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(function (decryptedBuffer) {\n      var decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!_this.decrypter.isSync()) {\n        _this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  };\n  _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  ;\n  _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    var encryptedData = new Int8Array(encryptedDataLen);\n    var outputPos = 0;\n    for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  };\n  _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n    var uint8DecryptedData = new Uint8Array(decryptedData);\n    var inputPos = 0;\n    for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  };\n  _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    var _this2 = this;\n    var decodedData = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__.discardEPB)(curUnit.data);\n    var encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(function (decryptedBuffer) {\n      curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!_this2.decrypter.isSync()) {\n        _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  };\n  _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      var curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        var curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  };\n  return SampleAesDecrypter;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SampleAesDecrypter);\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-interface.ts\":\n/*!*******************************************!*\\\n  !*** ./src/demux/transmuxer-interface.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_574803__) => {\n\n\"use strict\";\n__nested_webpack_require_574803__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_574803__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TransmuxerInterface)\n/* harmony export */ });\n/* harmony import */ var _webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_574803__(/*! ./webworkify-webpack */ \"./src/demux/webworkify-webpack.js\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_574803__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_574803__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_574803__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_574803__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_574803__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_574803__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_574803__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nvar MediaSource = (0,_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__.getMediaSource)() || {\n  isTypeSupported: function isTypeSupported() {\n    return false;\n  }\n};\nvar TransmuxerInterface = /*#__PURE__*/function () {\n  function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n    var _this = this;\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.worker = void 0;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    var config = hls.config;\n    this.hls = hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    var forwardMessage = function forwardMessage(ev, data) {\n      data = data || {};\n      data.frag = _this.frag;\n      data.id = _this.id;\n      _this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, forwardMessage);\n    var typeSupported = {\n      mp4: MediaSource.isTypeSupported('video/mp4'),\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    };\n    // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n    var vendor = navigator.vendor;\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log('demuxing in webworker');\n      var worker;\n      try {\n        worker = this.worker = (0,_webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(/*require.resolve*/(/*! ../demux/transmuxer-worker.ts */ \"./src/demux/transmuxer-worker.ts\"));\n        this.onwmsg = this.onWorkerMessage.bind(this);\n        worker.addEventListener('message', this.onwmsg);\n        worker.onerror = function (event) {\n          _this.useWorker = false;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Exception in webworker, fallback to inline');\n          _this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.OTHER_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.INTERNAL_EXCEPTION,\n            fatal: false,\n            event: 'demuxerWorker',\n            error: new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\")\n          });\n        };\n        worker.postMessage({\n          cmd: 'init',\n          typeSupported: typeSupported,\n          vendor: vendor,\n          id: id,\n          config: JSON.stringify(config)\n        });\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Error in worker:', err);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error('Error while initializing DemuxerWorker, fallback to inline');\n        if (worker) {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(worker.objectURL);\n        }\n        this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n        this.worker = null;\n      }\n    } else {\n      this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n    }\n  }\n  var _proto = TransmuxerInterface.prototype;\n  _proto.destroy = function destroy() {\n    var w = this.worker;\n    if (w) {\n      w.removeEventListener('message', this.onwmsg);\n      w.terminate();\n      this.worker = null;\n      this.onwmsg = undefined;\n    } else {\n      var transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    var observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  };\n  _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment,\n      _lastFrag$initSegment,\n      _this2 = this;\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n      worker = this.worker;\n    var timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    var decryptdata = frag.decryptdata;\n    var lastFrag = this.frag;\n    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag === null || lastFrag === void 0 ? void 0 : lastFrag.stats.chunkCount);\n    var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    var now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) === null || _lastFrag$initSegment === void 0 ? void 0 : _lastFrag$initSegment.url));\n    var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n      var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (worker) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      worker.postMessage({\n        cmd: 'demux',\n        data: data,\n        decryptdata: decryptdata,\n        chunkMeta: chunkMeta,\n        state: state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if ((0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult)) {\n        transmuxer.async = true;\n        _transmuxResult.then(function (data) {\n          _this2.handleTransmuxComplete(data);\n        }).catch(function (error) {\n          _this2.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        transmuxer.async = false;\n        this.handleTransmuxComplete(_transmuxResult);\n      }\n    }\n  };\n  _proto.flush = function flush(chunkMeta) {\n    var _this3 = this;\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n      worker = this.worker;\n    if (worker) {\n      1;\n      worker.postMessage({\n        cmd: 'flush',\n        chunkMeta: chunkMeta\n      });\n    } else if (transmuxer) {\n      var _transmuxResult2 = transmuxer.flush(chunkMeta);\n      var asyncFlush = (0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult2);\n      if (asyncFlush || transmuxer.async) {\n        if (!(0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult2)) {\n          _transmuxResult2 = Promise.resolve(_transmuxResult2);\n        }\n        _transmuxResult2.then(function (data) {\n          _this3.handleFlushResult(data, chunkMeta);\n        }).catch(function (error) {\n          _this3.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(_transmuxResult2, chunkMeta);\n      }\n    }\n  };\n  _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta: chunkMeta,\n      fatal: false,\n      error: error,\n      err: error,\n      reason: reason\n    });\n  };\n  _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n    var _this4 = this;\n    results.forEach(function (result) {\n      _this4.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  };\n  _proto.onWorkerMessage = function onWorkerMessage(ev) {\n    var data = ev.data;\n    var hls = this.hls;\n    switch (data.event) {\n      case 'init':\n        {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(this.worker.objectURL);\n          break;\n        }\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      // pass logs from the worker thread to the main logger\n      case 'workerLog':\n        if (_utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger[data.data.logType]) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger[data.data.logType](data.data.message);\n        }\n        break;\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  };\n  _proto.configureTransmuxer = function configureTransmuxer(config) {\n    var worker = this.worker,\n      transmuxer = this.transmuxer;\n    if (worker) {\n      worker.postMessage({\n        cmd: 'configure',\n        config: config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  };\n  _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  };\n  return TransmuxerInterface;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-worker.ts\":\n/*!****************************************!*\\\n  !*** ./src/demux/transmuxer-worker.ts ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_587782__) => {\n\n\"use strict\";\n__nested_webpack_require_587782__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_587782__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TransmuxerWorker)\n/* harmony export */ });\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_587782__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_587782__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_587782__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_587782__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_587782__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_587782__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\n\n\nfunction TransmuxerWorker(self) {\n  var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n  var forwardMessage = function forwardMessage(ev, data) {\n    self.postMessage({\n      event: ev,\n      data: data\n    });\n  };\n\n  // forward events to main thread\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, forwardMessage);\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, forwardMessage);\n\n  // forward logger events to main thread\n  var forwardWorkerLogs = function forwardWorkerLogs() {\n    var _loop = function _loop(logFn) {\n      var func = function func(message) {\n        forwardMessage('workerLog', {\n          logType: logFn,\n          message: message\n        });\n      };\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger[logFn] = func;\n    };\n    for (var logFn in _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger) {\n      _loop(logFn);\n    }\n  };\n  self.addEventListener('message', function (ev) {\n    var data = ev.data;\n    switch (data.cmd) {\n      case 'init':\n        {\n          var config = JSON.parse(data.config);\n          self.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](observer, data.typeSupported, config, data.vendor, data.id);\n          (0,_utils_logger__WEBPACK_IMPORTED_MODULE_2__.enableLogs)(config.debug, data.id);\n          forwardWorkerLogs();\n          forwardMessage('init', null);\n          break;\n        }\n      case 'configure':\n        {\n          self.transmuxer.configure(data.config);\n          break;\n        }\n      case 'demux':\n        {\n          var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n          if ((0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(transmuxResult)) {\n            self.transmuxer.async = true;\n            transmuxResult.then(function (data) {\n              emitTransmuxComplete(self, data);\n            }).catch(function (error) {\n              forwardMessage(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n                type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,\n                details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,\n                chunkMeta: data.chunkMeta,\n                fatal: false,\n                error: error,\n                err: error,\n                reason: \"transmuxer-worker push error\"\n              });\n            });\n          } else {\n            self.transmuxer.async = false;\n            emitTransmuxComplete(self, transmuxResult);\n          }\n          break;\n        }\n      case 'flush':\n        {\n          var id = data.chunkMeta;\n          var _transmuxResult = self.transmuxer.flush(id);\n          var asyncFlush = (0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(_transmuxResult);\n          if (asyncFlush || self.transmuxer.async) {\n            if (!(0,_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(_transmuxResult)) {\n              _transmuxResult = Promise.resolve(_transmuxResult);\n            }\n            _transmuxResult.then(function (results) {\n              handleFlushResult(self, results, id);\n            }).catch(function (error) {\n              forwardMessage(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n                type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,\n                details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,\n                chunkMeta: data.chunkMeta,\n                fatal: false,\n                error: error,\n                err: error,\n                reason: \"transmuxer-worker flush error\"\n              });\n            });\n          } else {\n            handleFlushResult(self, _transmuxResult, id);\n          }\n          break;\n        }\n      default:\n        break;\n    }\n  });\n}\nfunction emitTransmuxComplete(self, transmuxResult) {\n  if (isEmptyResult(transmuxResult.remuxResult)) {\n    return false;\n  }\n  var transferable = [];\n  var _transmuxResult$remux = transmuxResult.remuxResult,\n    audio = _transmuxResult$remux.audio,\n    video = _transmuxResult$remux.video;\n  if (audio) {\n    addToTransferable(transferable, audio);\n  }\n  if (video) {\n    addToTransferable(transferable, video);\n  }\n  self.postMessage({\n    event: 'transmuxComplete',\n    data: transmuxResult\n  }, transferable);\n  return true;\n}\n\n// Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n// in order to minimize message passing overhead\nfunction addToTransferable(transferable, track) {\n  if (track.data1) {\n    transferable.push(track.data1.buffer);\n  }\n  if (track.data2) {\n    transferable.push(track.data2.buffer);\n  }\n}\nfunction handleFlushResult(self, results, chunkMeta) {\n  var parsed = results.reduce(function (parsed, result) {\n    return emitTransmuxComplete(self, result) || parsed;\n  }, false);\n  if (!parsed) {\n    // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n    self.postMessage({\n      event: 'transmuxComplete',\n      data: results[0]\n    });\n  }\n  self.postMessage({\n    event: 'flush',\n    data: chunkMeta\n  });\n}\nfunction isEmptyResult(remuxResult) {\n  return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/transmuxer.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_594496__) => {\n\n\"use strict\";\n__nested_webpack_require_594496__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_594496__.d(__nested_webpack_exports__, {\n/* harmony export */   \"TransmuxConfig\": () => (/* binding */ TransmuxConfig),\n/* harmony export */   \"TransmuxState\": () => (/* binding */ TransmuxState),\n/* harmony export */   \"default\": () => (/* binding */ Transmuxer),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_594496__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_594496__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_594496__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_594496__(/*! ../demux/aacdemuxer */ \"./src/demux/aacdemuxer.ts\");\n/* harmony import */ var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_594496__(/*! ../demux/mp4demuxer */ \"./src/demux/mp4demuxer.ts\");\n/* harmony import */ var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_594496__(/*! ../demux/tsdemuxer */ \"./src/demux/tsdemuxer.ts\");\n/* harmony import */ var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_594496__(/*! ../demux/mp3demuxer */ \"./src/demux/mp3demuxer.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_594496__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n/* harmony import */ var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_594496__(/*! ../remux/passthrough-remuxer */ \"./src/remux/passthrough-remuxer.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_594496__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\nvar now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.debug('Unable to use Performance API on this environment');\n  now = self.Date.now;\n}\nvar muxConfig = [{\n  demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n}, {\n  demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}];\nvar Transmuxer = /*#__PURE__*/function () {\n  function Transmuxer(observer, typeSupported, config, vendor, id) {\n    this.async = false;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n  var _proto = Transmuxer.prototype;\n  _proto.configure = function configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  };\n  _proto.push = function push(data, decryptdata, chunkMeta, state) {\n    var _this = this;\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var uintData = new Uint8Array(data);\n    var currentTransmuxState = this.currentTransmuxState,\n      transmuxConfig = this.transmuxConfig;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    var _ref = state || currentTransmuxState,\n      contiguous = _ref.contiguous,\n      discontinuity = _ref.discontinuity,\n      trackSwitch = _ref.trackSwitch,\n      accurateTimeOffset = _ref.accurateTimeOffset,\n      timeOffset = _ref.timeOffset,\n      initSegmentChange = _ref.initSegmentChange;\n    var audioCodec = transmuxConfig.audioCodec,\n      videoCodec = transmuxConfig.videoCodec,\n      defaultInitPts = transmuxConfig.defaultInitPts,\n      duration = transmuxConfig.duration,\n      initSegmentData = transmuxConfig.initSegmentData;\n    var keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      var decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        var loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          var result = _this.push(decryptedData, null, chunkMeta);\n          _this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    var resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      this.configureTransmuxer(uintData);\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    var currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  ;\n  _proto.flush = function flush(chunkMeta) {\n    var _this2 = this;\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var decrypter = this.decrypter,\n      currentTransmuxState = this.currentTransmuxState,\n      decryptionPromise = this.decryptionPromise;\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(function () {\n        return _this2.flush(chunkMeta);\n      });\n    }\n    var transmuxResults = [];\n    var timeOffset = currentTransmuxState.timeOffset;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      var decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n    var demuxer = this.demuxer,\n      remuxer = this.remuxer;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: true,\n        reason: 'no demux matching with content found'\n      });\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n    var demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(function (demuxResult) {\n        _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  };\n  _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    var audioTrack = demuxResult.audioTrack,\n      videoTrack = demuxResult.videoTrack,\n      id3Track = demuxResult.id3Track,\n      textTrack = demuxResult.textTrack;\n    var _this$currentTransmux = this.currentTransmuxState,\n      accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n      timeOffset = _this$currentTransmux.timeOffset;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  };\n  _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n    var demuxer = this.demuxer,\n      remuxer = this.remuxer;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  };\n  _proto.resetContiguity = function resetContiguity() {\n    var demuxer = this.demuxer,\n      remuxer = this.remuxer;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  };\n  _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    var demuxer = this.demuxer,\n      remuxer = this.remuxer;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  };\n  _proto.destroy = function destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  };\n  _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  };\n  _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n      audioTrack = _demux.audioTrack,\n      videoTrack = _demux.videoTrack,\n      id3Track = _demux.id3Track,\n      textTrack = _demux.textTrack;\n    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    };\n  };\n  _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _this3 = this;\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n      var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n      return {\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      };\n    });\n  };\n  _proto.configureTransmuxer = function configureTransmuxer(data) {\n    var config = this.config,\n      observer = this.observer,\n      typeSupported = this.typeSupported,\n      vendor = this.vendor;\n    // probe for content type\n    var mux;\n    for (var i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      // If probing previous configs fail, use mp4 passthrough\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.warn('Failed to find demuxer by probing frag, treating as mp4 passthrough');\n      mux = {\n        demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n        remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n      };\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    var demuxer = this.demuxer;\n    var remuxer = this.remuxer;\n    var Remuxer = mux.remux;\n    var Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  };\n  _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  };\n  _proto.getDecrypter = function getDecrypter() {\n    var decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.config);\n    }\n    return decrypter;\n  };\n  return Transmuxer;\n}();\n\nfunction getEncryptionType(data, decryptData) {\n  var encryptionType = null;\n  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nvar emptyResult = function emptyResult(chunkMeta) {\n  return {\n    remuxResult: {},\n    chunkMeta: chunkMeta\n  };\n};\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nvar TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n  this.audioCodec = void 0;\n  this.videoCodec = void 0;\n  this.initSegmentData = void 0;\n  this.duration = void 0;\n  this.defaultInitPts = void 0;\n  this.audioCodec = audioCodec;\n  this.videoCodec = videoCodec;\n  this.initSegmentData = initSegmentData;\n  this.duration = duration;\n  this.defaultInitPts = defaultInitPts;\n};\nvar TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n  this.discontinuity = void 0;\n  this.contiguous = void 0;\n  this.accurateTimeOffset = void 0;\n  this.trackSwitch = void 0;\n  this.timeOffset = void 0;\n  this.initSegmentChange = void 0;\n  this.discontinuity = discontinuity;\n  this.contiguous = contiguous;\n  this.accurateTimeOffset = accurateTimeOffset;\n  this.trackSwitch = trackSwitch;\n  this.timeOffset = timeOffset;\n  this.initSegmentChange = initSegmentChange;\n};\n\n/***/ }),\n\n/***/ \"./src/demux/tsdemuxer.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/tsdemuxer.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_610850__) => {\n\n\"use strict\";\n__nested_webpack_require_610850__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_610850__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_610850__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_610850__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\n/* harmony import */ var _exp_golomb__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_610850__(/*! ./exp-golomb */ \"./src/demux/exp-golomb.ts\");\n/* harmony import */ var _sample_aes__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_610850__(/*! ./sample-aes */ \"./src/demux/sample-aes.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_610850__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_610850__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_610850__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_610850__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_610850__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n/**\n * highly optimized TS demuxer:\n * parse PAT, PMT\n * extract PES packet from audio and video PIDs\n * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n * trigger the remuxer upon parsing completion\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n * it also controls the remuxing process :\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n */\n\n\n\n\n\n\n\n\n\n\nvar PACKET_LENGTH = 188;\nvar TSDemuxer = /*#__PURE__*/function () {\n  function TSDemuxer(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._avcTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n  }\n  TSDemuxer.probe = function probe(data) {\n    var syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset);\n    }\n    return syncOffset !== -1;\n  };\n  TSDemuxer.syncOffset = function syncOffset(data) {\n    var length = data.length;\n    var scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\n    var i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      var foundPat = false;\n      for (var j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47) {\n          if (!foundPat && parsePID(data, j) === 0) {\n            foundPat = true;\n          }\n          if (foundPat && j + PACKET_LENGTH > scanwindow) {\n            return i;\n          }\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   *\n   * @param type 'audio' | 'video' | 'id3' | 'text'\n   * @param duration\n   * @return TSDemuxer's internal track model\n   */;\n  TSDemuxer.createTrack = function createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type: type,\n      id: _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */;\n  var _proto = TSDemuxer.prototype;\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._avcTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  };\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n  _proto.resetContiguity = function resetContiguity() {\n    var _audioTrack = this._audioTrack,\n      _avcTrack = this._avcTrack,\n      _id3Track = this._id3Track;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_avcTrack) {\n      _avcTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n  };\n  _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n    if (isSampleAes === void 0) {\n      isSampleAes = false;\n    }\n    if (flush === void 0) {\n      flush = false;\n    }\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    var pes;\n    var videoTrack = this._avcTrack;\n    var audioTrack = this._audioTrack;\n    var id3Track = this._id3Track;\n    var textTrack = this._txtTrack;\n    var avcId = videoTrack.pid;\n    var avcData = videoTrack.pesData;\n    var audioId = audioTrack.pid;\n    var id3Id = id3Track.pid;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData;\n    var unknownPID = null;\n    var pmtParsed = this.pmtParsed;\n    var pmtId = this._pmtId;\n    var len = data.length;\n    if (this.remainderData) {\n      data = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.appendUint8Array)(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack: audioTrack,\n        videoTrack: videoTrack,\n        id3Track: id3Track,\n        textTrack: textTrack\n      };\n    }\n    var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    var tsPacketErrors = 0;\n    for (var start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        var stt = !!(data[start + 1] & 0x40);\n        var pid = parsePID(data, start);\n        var atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        var offset = void 0;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case avcId:\n            if (stt) {\n              if (avcData && (pes = parsePES(avcData))) {\n                this.parseAVCPES(videoTrack, textTrack, pes, false);\n              }\n              avcData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (avcData) {\n              avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              avcData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioId:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Id:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              avcId = parsedPIDs.avc;\n              if (avcId > 0) {\n                videoTrack.pid = avcId;\n              }\n              audioId = parsedPIDs.audio;\n              if (audioId > 0) {\n                audioTrack.pid = audioId;\n                audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n              }\n              id3Id = parsedPIDs.id3;\n              if (id3Id > 0) {\n                id3Track.pid = id3Id;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"MPEG-TS PMT found at \" + start + \" after unknown PID '\" + unknownPID + \"'. Backtracking to sync byte @\" + syncOffset + \" to parse all TS packets.\");\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        reason: \"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\"\n      });\n    }\n    videoTrack.pesData = avcData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    var demuxResult = {\n      audioTrack: audioTrack,\n      videoTrack: videoTrack,\n      id3Track: id3Track,\n      textTrack: textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  };\n  _proto.flush = function flush() {\n    var remainderData = this.remainderData;\n    this.remainderData = null;\n    var result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._avcTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  };\n  _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n    var audioTrack = demuxResult.audioTrack,\n      videoTrack = demuxResult.videoTrack,\n      id3Track = demuxResult.id3Track,\n      textTrack = demuxResult.textTrack;\n    var avcData = videoTrack.pesData;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    var pes;\n    if (avcData && (pes = parsePES(avcData))) {\n      this.parseAVCPES(videoTrack, textTrack, pes, true);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = avcData;\n    }\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData !== null && audioData !== void 0 && audioData.size) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  };\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    var sampleAes = this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  };\n  _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n    return new Promise(function (resolve) {\n      var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n          resolve(demuxResult);\n        });\n      }\n    });\n  };\n  _proto.destroy = function destroy() {\n    this._duration = 0;\n  };\n  _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {\n    var _this = this;\n    var units = this.parseAVCNALu(track, pes.data);\n    var debug = false;\n    var avcSample = this.avcSample;\n    var push;\n    var spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (avcSample && units.length && !track.audFound) {\n      pushAccessUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n    units.forEach(function (unit) {\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            push = true;\n            if (!avcSample) {\n              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n            }\n            if (debug) {\n              avcSample.debug += 'NDR ';\n            }\n            avcSample.frame = true;\n            var data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                avcSample.key = true;\n              }\n            }\n            break;\n            // IDR\n          }\n\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          if (!avcSample) {\n            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n          }\n          if (debug) {\n            avcSample.debug += 'IDR ';\n          }\n          avcSample.key = true;\n          avcSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'SEI ';\n            }\n            (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.parseSEIMessageFromNALu)(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n\n        case 7:\n          push = true;\n          spsfound = true;\n          if (debug && avcSample) {\n            avcSample.debug += 'SPS ';\n          }\n          if (!track.sps) {\n            var expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](unit.data);\n            var config = expGolombDecoder.readSPS();\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            // TODO: `track.sps` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n            track.sps = [unit.data];\n            track.duration = _this._duration;\n            var codecarray = unit.data.subarray(1, 4);\n            var codecstring = 'avc1.';\n            for (var i = 0; i < 3; i++) {\n              var h = codecarray[i].toString(16);\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n              codecstring += h;\n            }\n            track.codec = codecstring;\n          }\n          break;\n        // PPS\n        case 8:\n          push = true;\n          if (debug && avcSample) {\n            avcSample.debug += 'PPS ';\n          }\n          if (!track.pps) {\n            // TODO: `track.pss` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n            track.pps = [unit.data];\n          }\n          break;\n        // AUD\n        case 9:\n          push = false;\n          track.audFound = true;\n          if (avcSample) {\n            pushAccessUnit(avcSample, track);\n          }\n          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          if (avcSample) {\n            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n          break;\n      }\n      if (avcSample && push) {\n        var _units = avcSample.units;\n        _units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && avcSample) {\n      pushAccessUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  };\n  _proto.getLastNalUnit = function getLastNalUnit(samples) {\n    var _avcSample;\n    var avcSample = this.avcSample;\n    var lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!avcSample || avcSample.units.length === 0) {\n      avcSample = samples[samples.length - 1];\n    }\n    if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {\n      var units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  };\n  _proto.parseAVCNALu = function parseAVCNALu(track, array) {\n    var len = array.byteLength;\n    var state = track.naluState || 0;\n    var lastState = state;\n    var units = [];\n    var i = 0;\n    var value;\n    var overflow;\n    var unitType;\n    var lastUnitStart = -1;\n    var lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          var unit = {\n            data: array.subarray(lastUnitStart, i - state - 1),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          var lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n            overflow = i - state - 1;\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      var _unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(_unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      var _lastUnit = this.getLastNalUnit(track.samples);\n      if (_lastUnit) {\n        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n        _tmp.set(_lastUnit.data, 0);\n        _tmp.set(array, _lastUnit.data.byteLength);\n        _lastUnit.data = _tmp;\n      }\n    }\n    track.naluState = state;\n    return units;\n  };\n  _proto.parseAACPES = function parseAACPES(track, pes) {\n    var startOffset = 0;\n    var aacOverFlow = this.aacOverFlow;\n    var data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      var frameMissingBytes = aacOverFlow.missing;\n      var sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        var tmp = new Uint8Array(sampleLength + data.byteLength);\n        tmp.set(aacOverFlow.sample.unit, 0);\n        tmp.set(data, sampleLength);\n        data = tmp;\n      } else {\n        var frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    var offset;\n    var len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_0__.isHeader(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      var reason;\n      var fatal;\n      if (offset < len - 1) {\n        reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n        fatal = false;\n      } else {\n        reason = 'no ADTS header found in AAC PES';\n        fatal = true;\n      }\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"parsing error:\" + reason);\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorTypes.MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: fatal,\n        reason: reason\n      });\n      if (fatal) {\n        return;\n      }\n    }\n    _adts__WEBPACK_IMPORTED_MODULE_0__.initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    var pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__.getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    var frameIndex = 0;\n    var frame;\n    while (offset < len) {\n      frame = _adts__WEBPACK_IMPORTED_MODULE_0__.appendFrame(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (_adts__WEBPACK_IMPORTED_MODULE_0__.isHeader(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  };\n  _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n    var data = pes.data;\n    var length = data.length;\n    var frameIndex = 0;\n    var offset = 0;\n    var pts = pes.pts;\n    if (pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__.isHeader(data, offset)) {\n        var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__.appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  };\n  _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    var id3Sample = _extends({}, pes, {\n      type: this._avcTrack ? _types_demuxer__WEBPACK_IMPORTED_MODULE_8__.MetadataSchema.emsg : _types_demuxer__WEBPACK_IMPORTED_MODULE_8__.MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  };\n  return TSDemuxer;\n}();\nfunction createAVCSample(key, pts, dts, debug) {\n  return {\n    key: key,\n    frame: false,\n    pts: pts,\n    dts: dts,\n    units: [],\n    debug: debug,\n    length: 0\n  };\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n  var result = {\n    audio: -1,\n    avc: -1,\n    id3: -1,\n    segmentCodec: 'aac'\n  };\n  var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  var tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var pid = parsePID(data, offset);\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.segmentCodec = 'mp3';\n        }\n        break;\n      case 0x24:\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn('Unsupported HEVC stream type found');\n        break;\n      default:\n        // logger.log('unknown stream type:' + data[offset]);\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n  }\n  return result;\n}\nfunction parsePES(stream) {\n  var i = 0;\n  var frag;\n  var pesLen;\n  var pesHdrLen;\n  var pesPts;\n  var pesDts;\n  var data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    var newData = new Uint8Array(data[0].length + data[1].length);\n    newData.set(data[0]);\n    newData.set(data[1], data[0].length);\n    data[0] = newData;\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    var pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    var payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    var pesData = new Uint8Array(stream.size);\n    for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      var len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\nfunction pushAccessUnit(avcSample, avcTrack) {\n  if (avcSample.units.length && avcSample.frame) {\n    // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n    if (avcSample.pts === undefined) {\n      var samples = avcTrack.samples;\n      var nbSamples = samples.length;\n      if (nbSamples) {\n        var lastSample = samples[nbSamples - 1];\n        avcSample.pts = lastSample.pts;\n        avcSample.dts = lastSample.dts;\n      } else {\n        // dropping samples, no timestamp found\n        avcTrack.dropped++;\n        return;\n      }\n    }\n    avcTrack.samples.push(avcSample);\n  }\n  if (avcSample.debug.length) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TSDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/webworkify-webpack.js\":\n/*!*****************************************!*\\\n  !*** ./src/demux/webworkify-webpack.js ***!\n  \\*****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_648645__) => {\n\n\"use strict\";\n__nested_webpack_require_648645__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_648645__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * Fork of webworkify-webpack with support for Webpack 5\n * https://github.com/wupeng-engineer/webworkify-webpack/blob/db0de7/index.js\n*/\n\nvar webpackBootstrapFunc = function webpackBootstrapFunc() {\n  // webpackBootstrap\n  /******/\n  var __webpack_modules__ = ENTRY_MODULE;\n  /************************************************************************/\n  /******/ // The module cache\n  /******/\n  var __webpack_module_cache__ = {};\n  /******/\n  /******/ // The require function\n  /******/\n  var __nested_webpack_require_497__ = function __nested_webpack_require_649458__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n    if (cachedModule !== undefined) {\n      /******/return cachedModule.exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/ // no module.id needed\n      /******/ // no module.loaded needed\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_649458__);\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  };\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __nested_webpack_require_497__.m = __webpack_modules__;\n  /******/\n  /************************************************************************/\n  /******/ /* webpack/runtime/compat get default export */\n  /******/\n  (function () {\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/__nested_webpack_require_497__.n = function (module) {\n      /******/var getter = module && module.__esModule ? /******/function () {\n        return module['default'];\n      } : /******/function () {\n        return module;\n      };\n      /******/\n      __nested_webpack_require_497__.d(getter, {\n        a: getter\n      });\n      /******/\n      return getter;\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /******/ /* webpack/runtime/define property getters */\n  /******/\n  (function () {\n    /******/ // define getter functions for harmony exports\n    /******/__nested_webpack_require_497__.d = function (exports, definition) {\n      /******/for (var key in definition) {\n        /******/if (__nested_webpack_require_497__.o(definition, key) && !__nested_webpack_require_497__.o(exports, key)) {\n          /******/Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /******/ /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  (function () {\n    /******/__nested_webpack_require_497__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  })();\n  /******/\n  /******/ /* webpack/runtime/make namespace object */\n  /******/\n  (function () {\n    /******/ // define __esModule on exports\n    /******/__nested_webpack_require_497__.r = function (exports) {\n      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        /******/Object.defineProperty(exports, Symbol.toStringTag, {\n          value: 'Module'\n        });\n        /******/\n      }\n      /******/\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /************************************************************************/\n  /******/\n  /******/ // module factories are used so entry inlining is disabled\n  /******/ // startup\n  /******/ // Load entry module and return exports\n  /******/\n  var result = __nested_webpack_require_497__(ENTRY_MODULE);\n  /******/\n  return result.default || result;\n};\nvar webpackBootstrapFuncArr = webpackBootstrapFunc.toString().split('ENTRY_MODULE');\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+';\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)';\nfunction quoteRegExp(str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n}\nfunction isNumeric(n) {\n  return !isNaN(1 * n);\n}\nfunction getModuleDependencies(sources, module, queueName) {\n  var retval = {};\n  retval[queueName] = [];\n  var fnString = module.toString().replace(/^\"[^\"]+\"/, 'function');\n  ;\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/) || fnString.match(/^\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)\\s?\\=\\s?\\>/);\n  if (!wrapperSignature) return retval;\n  var webpackRequireName = wrapperSignature[1];\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');\n  var match;\n  while (match = re.exec(fnString)) {\n    if (match[3] === 'dll-reference') continue;\n    retval[queueName].push(match[3]);\n  }\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g');\n  while (match = re.exec(fnString)) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1]);\n      sources[match[2]] = __nested_webpack_require_648645__(match[1]).m;\n    }\n    retval[match[2]] = retval[match[2]] || [];\n    retval[match[2]].push(match[4]);\n  }\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n  return retval;\n}\nfunction hasValuesInQueues(queues) {\n  var keys = Object.keys(queues);\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0;\n  }, false);\n}\nfunction getRequiredModules(sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  };\n  var requiredModules = {\n    main: []\n  };\n  var seenModules = {\n    main: {}\n  };\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue);\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i];\n      var queue = modulesQueue[queueName];\n      var moduleToCheck = queue.pop();\n      seenModules[queueName] = seenModules[queueName] || {};\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;\n      seenModules[queueName][moduleToCheck] = true;\n      requiredModules[queueName] = requiredModules[queueName] || [];\n      requiredModules[queueName].push(moduleToCheck);\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);\n      var newModulesKeys = Object.keys(newModules);\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);\n      }\n    }\n  }\n  return requiredModules;\n}\nfunction getWebpackString(requiredModules, sources, entryModule, key) {\n  var moduleString = requiredModules[key].map(function (id) {\n    return \"\\\"\" + id + \"\\\": \" + sources[key][id].toString().replace(/^\"[^\"]+\"/, 'function');\n  }).join(\",\");\n  return webpackBootstrapFuncArr[0] + \"{\" + moduleString + \"}\" + webpackBootstrapFuncArr[1] + \"\\\"\" + entryModule + \"\\\"\" + webpackBootstrapFuncArr[2];\n}\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {\n  options = options || {};\n  var sources = {\n    main: __nested_webpack_require_648645__.m\n  };\n  var requiredModules = options.all ? {\n    main: Object.keys(sources.main)\n  } : getRequiredModules(sources, moduleId);\n  var src = '';\n  Object.keys(requiredModules).filter(function (m) {\n    return m !== 'main';\n  }).forEach(function (module) {\n    var entryModule = 0;\n    while (requiredModules[module][entryModule]) {\n      entryModule++;\n    }\n    requiredModules[module].push(entryModule);\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';\n    src = src + (\"var \" + module + \" = (\" + getWebpackString(requiredModules, sources, entryModule, modules) + \")();\\n\");\n  });\n  src = src + (\"new ((\" + getWebpackString(requiredModules, sources, moduleId, 'main') + \")())(self);\");\n  var blob = new window.Blob([src], {\n    type: 'text/javascript'\n  });\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n  var workerUrl = URL.createObjectURL(blob);\n  var worker = new window.Worker(workerUrl);\n  worker.objectURL = workerUrl;\n  return worker;\n}\n\n/***/ }),\n\n/***/ \"./src/errors.ts\":\n/*!***********************!*\\\n  !*** ./src/errors.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_657754__) => {\n\n\"use strict\";\n__nested_webpack_require_657754__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_657754__.d(__nested_webpack_exports__, {\n/* harmony export */   \"ErrorDetails\": () => (/* binding */ ErrorDetails),\n/* harmony export */   \"ErrorTypes\": () => (/* binding */ ErrorTypes)\n/* harmony export */ });\nvar ErrorTypes;\n\n/**\n * @enum {ErrorDetails}\n * @typedef {string} ErrorDetail\n */\n(function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n})(ErrorTypes || (ErrorTypes = {}));\nvar ErrorDetails;\n(function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n})(ErrorDetails || (ErrorDetails = {}));\n\n/***/ }),\n\n/***/ \"./src/events.ts\":\n/*!***********************!*\\\n  !*** ./src/events.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_661399__) => {\n\n\"use strict\";\n__nested_webpack_require_661399__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_661399__.d(__nested_webpack_exports__, {\n/* harmony export */   \"Events\": () => (/* binding */ Events)\n/* harmony export */ });\n/**\n * @readonly\n * @enum {string}\n */\nvar Events;\n(function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n})(Events || (Events = {}));\n\n/***/ }),\n\n/***/ \"./src/hls.ts\":\n/*!********************!*\\\n  !*** ./src/hls.ts ***!\n  \\********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_664754__) => {\n\n\"use strict\";\n__nested_webpack_require_664754__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_664754__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hls)\n/* harmony export */ });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_664754__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_664754__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_664754__(/*! ./loader/playlist-loader */ \"./src/loader/playlist-loader.ts\");\n/* harmony import */ var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_664754__(/*! ./controller/id3-track-controller */ \"./src/controller/id3-track-controller.ts\");\n/* harmony import */ var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_664754__(/*! ./controller/latency-controller */ \"./src/controller/latency-controller.ts\");\n/* harmony import */ var _controller_level_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_664754__(/*! ./controller/level-controller */ \"./src/controller/level-controller.ts\");\n/* harmony import */ var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_664754__(/*! ./controller/fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _loader_key_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_664754__(/*! ./loader/key-loader */ \"./src/loader/key-loader.ts\");\n/* harmony import */ var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_664754__(/*! ./controller/stream-controller */ \"./src/controller/stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_664754__(/*! ./is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_664754__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_664754__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_664754__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__nested_webpack_require_664754__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_664754__(/*! ./events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_664754__(/*! ./errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_664754__(/*! ./types/level */ \"./src/types/level.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @module Hls\n * @class\n * @constructor\n */\nvar Hls = /*#__PURE__*/function () {\n  Hls.isSupported = function isSupported() {\n    return (0,_is_supported__WEBPACK_IMPORTED_MODULE_8__.isSupported)();\n  };\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   *\n   * @constructs Hls\n   * @param {HlsConfig} config\n   */\n  function Hls(userConfig) {\n    if (userConfig === void 0) {\n      userConfig = {};\n    }\n    this.config = void 0;\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__.EventEmitter();\n    this._autoLevelCapping = void 0;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    var config = this.config = (0,_config__WEBPACK_IMPORTED_MODULE_10__.mergeConfig)(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    (0,_utils_logger__WEBPACK_IMPORTED_MODULE_9__.enableLogs)(config.debug, 'Hls instance');\n    this._autoLevelCapping = -1;\n    if (config.progressive) {\n      (0,_config__WEBPACK_IMPORTED_MODULE_10__.enableStreamingMode)(config);\n    }\n\n    // core controllers and network loaders\n    var ConfigAbrController = config.abrController,\n      ConfigBufferController = config.bufferController,\n      ConfigCapLevelController = config.capLevelController,\n      ConfigFpsController = config.fpsController;\n    var abrController = this.abrController = new ConfigAbrController(this);\n    var bufferController = this.bufferController = new ConfigBufferController(this);\n    var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    var fpsController = new ConfigFpsController(this);\n    var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n\n    // network controllers\n    var levelController = this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentTracker(this);\n    var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.config);\n    var streamController = this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this, fragmentTracker, keyLoader);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    var networkControllers = [playListLoader, levelController, streamController];\n    this.networkControllers = networkControllers;\n    var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    var AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    var SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_3__[\"default\"], coreComponents);\n    this.coreComponents = coreComponents;\n  }\n  var _proto = Hls.prototype;\n  _proto.createController = function createController(ControllerClass, components) {\n    if (ControllerClass) {\n      var controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  ;\n  _proto.on = function on(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n    this._emitter.on(event, listener, context);\n  };\n  _proto.once = function once(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n    this._emitter.once(event, listener, context);\n  };\n  _proto.removeAllListeners = function removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  };\n  _proto.off = function off(event, listener, context, once) {\n    if (context === void 0) {\n      context = this;\n    }\n    this._emitter.off(event, listener, context, once);\n  };\n  _proto.listeners = function listeners(event) {\n    return this._emitter.listeners(event);\n  };\n  _proto.emit = function emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  };\n  _proto.trigger = function trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes.OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.INTERNAL_EXCEPTION,\n          fatal: false,\n          event: event,\n          error: e\n        });\n      }\n    }\n    return false;\n  };\n  _proto.listenerCount = function listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */;\n  _proto.destroy = function destroy() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('destroy');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(function (component) {\n      return component.destroy();\n    });\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(function (component) {\n      return component.destroy();\n    });\n    this.coreComponents.length = 0;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   * @param {HTMLMediaElement} media\n   */;\n  _proto.attachMedia = function attachMedia(media) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('attachMedia');\n    this._media = media;\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */;\n  _proto.detachMedia = function detachMedia() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('detachMedia');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   * @param {string} url\n   */;\n  _proto.loadSource = function loadSource(url) {\n    this.stopLoad();\n    var media = this.media;\n    var loadedSource = this.url;\n    var loadingSource = this.url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"loadSource:\" + loadingSource);\n    if (media && loadedSource && loadedSource !== loadingSource && this.bufferController.hasSourceTypes()) {\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param {number} startPosition Set the start position to stream from\n   * @default -1 None (from earliest point)\n   */;\n  _proto.startLoad = function startLoad(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = -1;\n    }\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"startLoad(\" + startPosition + \")\");\n    this.networkControllers.forEach(function (controller) {\n      controller.startLoad(startPosition);\n    });\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */;\n  _proto.stopLoad = function stopLoad() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('stopLoad');\n    this.networkControllers.forEach(function (controller) {\n      controller.stopLoad();\n    });\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */;\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */;\n  _proto.recoverMediaError = function recoverMediaError() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log('recoverMediaError');\n    var media = this._media;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n    }\n  };\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    if (urlId === void 0) {\n      urlId = 0;\n    }\n    this.levelController.removeLevel(levelIndex, urlId);\n  }\n\n  /**\n   * @type {Level[]}\n   */;\n  _createClass(Hls, [{\n    key: \"levels\",\n    get: function get() {\n      var levels = this.levelController.levels;\n      return levels ? levels : [];\n    }\n\n    /**\n     * Index of quality level currently played\n     * @type {number}\n     */\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      return this.streamController.currentLevel;\n    }\n\n    /**\n     * Set quality level index immediately .\n     * This will flush the current buffer to replace the quality asap.\n     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.\n     * @type {number} -1 for automatic level selection\n     */,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set currentLevel:\" + newLevel);\n      this.loadLevel = newLevel;\n      this.abrController.clearTimer();\n      this.streamController.immediateLevelSwitch();\n    }\n\n    /**\n     * Index of next quality level loaded as scheduled by stream controller.\n     * @type {number}\n     */\n  }, {\n    key: \"nextLevel\",\n    get: function get() {\n      return this.streamController.nextLevel;\n    }\n\n    /**\n     * Set quality level index for next loaded data.\n     * This will switch the video quality asap, without interrupting playback.\n     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n     * @type {number} -1 for automatic level selection\n     */,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set nextLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n      this.streamController.nextLevelSwitch();\n    }\n\n    /**\n     * Return the quality level of the currently or last (of none is loaded currently) segment\n     * @type {number}\n     */\n  }, {\n    key: \"loadLevel\",\n    get: function get() {\n      return this.levelController.level;\n    }\n\n    /**\n     * Set quality level index for next loaded data in a conservative way.\n     * This will switch the quality without flushing, but interrupt current loading.\n     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n     * @type {number} newLevel -1 for automatic level selection\n     */,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set loadLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n    }\n\n    /**\n     * get next quality level loaded\n     * @type {number}\n     */\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      return this.levelController.nextLoadLevel;\n    }\n\n    /**\n     * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n     * Same as `loadLevel` but will wait for next switch (until current loading is done).\n     * @type {number} level\n     */,\n    set: function set(level) {\n      this.levelController.nextLoadLevel = level;\n    }\n\n    /**\n     * Return \"first level\": like a default level, if not set,\n     * falls back to index of first level referenced in manifest\n     * @type {number}\n     */\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n\n    /**\n     * Sets \"first-level\", see getter.\n     * @type {number}\n     */,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set firstLevel:\" + newLevel);\n      this.levelController.firstLevel = newLevel;\n    }\n\n    /**\n     * Return start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number}\n     */\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      return this.levelController.startLevel;\n    }\n\n    /**\n     * set  start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number} newLevel\n     */,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set startLevel:\" + newLevel);\n      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n      if (newLevel !== -1) {\n        newLevel = Math.max(newLevel, this.minAutoLevel);\n      }\n      this.levelController.startLevel = newLevel;\n    }\n\n    /**\n     * Get the current setting for capLevelToPlayerSize\n     *\n     * @type {boolean}\n     */\n  }, {\n    key: \"capLevelToPlayerSize\",\n    get: function get() {\n      return this.config.capLevelToPlayerSize;\n    }\n\n    /**\n     * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)\n     *\n     * @type {boolean}\n     */,\n    set: function set(shouldStartCapping) {\n      var newCapLevelToPlayerSize = !!shouldStartCapping;\n      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n        if (newCapLevelToPlayerSize) {\n          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n        } else {\n          this.capLevelController.stopCapping();\n          this.autoLevelCapping = -1;\n          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n        }\n\n        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n      }\n    }\n\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n  }, {\n    key: \"autoLevelCapping\",\n    get: function get() {\n      return this._autoLevelCapping;\n    }\n\n    /**\n     * get bandwidth estimate\n     * @type {number}\n     */,\n    set:\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n    function set(newLevel) {\n      if (this._autoLevelCapping !== newLevel) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log(\"set autoLevelCapping:\" + newLevel);\n        this._autoLevelCapping = newLevel;\n      }\n    }\n  }, {\n    key: \"bandwidthEstimate\",\n    get: function get() {\n      var bwEstimator = this.abrController.bwEstimator;\n      if (!bwEstimator) {\n        return NaN;\n      }\n      return bwEstimator.getEstimate();\n    }\n  }, {\n    key: \"maxHdcpLevel\",\n    get: function get() {\n      return this._maxHdcpLevel;\n    },\n    set: function set(value) {\n      if (_types_level__WEBPACK_IMPORTED_MODULE_14__.HdcpLevels.indexOf(value) > -1) {\n        this._maxHdcpLevel = value;\n      }\n    }\n\n    /**\n     * True when automatic level selection enabled\n     * @type {boolean}\n     */\n  }, {\n    key: \"autoLevelEnabled\",\n    get: function get() {\n      return this.levelController.manualLevel === -1;\n    }\n\n    /**\n     * Level set manually (if any)\n     * @type {number}\n     */\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.levelController.manualLevel;\n    }\n\n    /**\n     * min level selectable in auto mode according to config.minAutoBitrate\n     * @type {number}\n     */\n  }, {\n    key: \"minAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n        minAutoBitrate = this.config.minAutoBitrate;\n      if (!levels) return 0;\n      var len = levels.length;\n      for (var i = 0; i < len; i++) {\n        if (levels[i].maxBitrate >= minAutoBitrate) {\n          return i;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * max level selectable in auto mode according to autoLevelCapping\n     * @type {number}\n     */\n  }, {\n    key: \"maxAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n        autoLevelCapping = this.autoLevelCapping,\n        maxHdcpLevel = this.maxHdcpLevel;\n      var maxAutoLevel;\n      if (autoLevelCapping === -1 && levels && levels.length) {\n        maxAutoLevel = levels.length - 1;\n      } else {\n        maxAutoLevel = autoLevelCapping;\n      }\n      if (maxHdcpLevel) {\n        for (var i = maxAutoLevel; i--;) {\n          var hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n          if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n            return i;\n          }\n        }\n      }\n      return maxAutoLevel;\n    }\n\n    /**\n     * next automatically selected quality level\n     * @type {number}\n     */\n  }, {\n    key: \"nextAutoLevel\",\n    get: function get() {\n      // ensure next auto level is between  min and max auto level\n      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n    }\n\n    /**\n     * this setter is used to force next auto level.\n     * this is useful to force a switch down in auto mode:\n     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n     * forced value is valid for one fragment. upon successful frag loading at forced level,\n     * this value will be resetted to -1 by ABR controller.\n     * @type {number}\n     */,\n    set: function set(nextLevel) {\n      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n    }\n\n    /**\n     * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n     * @type {Date}\n     */\n  }, {\n    key: \"playingDate\",\n    get: function get() {\n      return this.streamController.currentProgramDateTime;\n    }\n  }, {\n    key: \"mainForwardBufferInfo\",\n    get: function get() {\n      return this.streamController.getMainFwdBufferInfo();\n    }\n\n    /**\n     * @type {AudioTrack[]}\n     */\n  }, {\n    key: \"audioTracks\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n\n    /**\n     * index of the selected audio track (index in audio track lists)\n     * @type {number}\n     */\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n\n    /**\n     * selects an audio track, based on its index in audio track lists\n     * @type {number}\n     */,\n    set: function set(audioTrackId) {\n      var audioTrackController = this.audioTrackController;\n      if (audioTrackController) {\n        audioTrackController.audioTrack = audioTrackId;\n      }\n    }\n\n    /**\n     * get alternate subtitle tracks list from playlist\n     * @type {MediaPlaylist[]}\n     */\n  }, {\n    key: \"subtitleTracks\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n\n    /**\n     * index of the selected subtitle track (index in subtitle track lists)\n     * @type {number}\n     */\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    },\n    set:\n    /**\n     * select an subtitle track, based on its index in subtitle track lists\n     * @type {number}\n     */\n    function set(subtitleTrackId) {\n      var subtitleTrackController = this.subtitleTrackController;\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleTrack = subtitleTrackId;\n      }\n    }\n\n    /**\n     * @type {boolean}\n     */\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this._media;\n    }\n  }, {\n    key: \"subtitleDisplay\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n    }\n\n    /**\n     * Enable/disable subtitle display rendering\n     * @type {boolean}\n     */,\n    set: function set(value) {\n      var subtitleTrackController = this.subtitleTrackController;\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleDisplay = value;\n      }\n    }\n\n    /**\n     * get mode for Low-Latency HLS loading\n     * @type {boolean}\n     */\n  }, {\n    key: \"lowLatencyMode\",\n    get: function get() {\n      return this.config.lowLatencyMode;\n    }\n\n    /**\n     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n     * @type {boolean}\n     */,\n    set: function set(mode) {\n      this.config.lowLatencyMode = mode;\n    }\n\n    /**\n     * position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n     * @type {number}\n     */\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      return this.latencyController.liveSyncPosition;\n    }\n\n    /**\n     * estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n  }, {\n    key: \"latency\",\n    get: function get() {\n      return this.latencyController.latency;\n    }\n\n    /**\n     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      return this.latencyController.maxLatency;\n    }\n\n    /**\n     * target distance from the edge as calculated by the latency controller\n     * @type {number}\n     */\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      return this.latencyController.targetLatency;\n    }\n\n    /**\n     * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n     * @type {number}\n     */\n  }, {\n    key: \"drift\",\n    get: function get() {\n      return this.latencyController.drift;\n    }\n\n    /**\n     * set to true when startLoad is called before MANIFEST_PARSED event\n     * @type {boolean}\n     */\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this.streamController.forceStartLoad;\n    }\n  }], [{\n    key: \"version\",\n    get: function get() {\n      return \"1.3.5\";\n    }\n  }, {\n    key: \"Events\",\n    get: function get() {\n      return _events__WEBPACK_IMPORTED_MODULE_12__.Events;\n    }\n  }, {\n    key: \"ErrorTypes\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes;\n    }\n  }, {\n    key: \"ErrorDetails\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails;\n    }\n  }, {\n    key: \"DefaultConfig\",\n    get: function get() {\n      if (!Hls.defaultConfig) {\n        return _config__WEBPACK_IMPORTED_MODULE_10__.hlsDefaultConfig;\n      }\n      return Hls.defaultConfig;\n    }\n\n    /**\n     * @type {HlsConfig}\n     */,\n    set: function set(defaultConfig) {\n      Hls.defaultConfig = defaultConfig;\n    }\n  }]);\n  return Hls;\n}();\nHls.defaultConfig = void 0;\n\n\n/***/ }),\n\n/***/ \"./src/is-supported.ts\":\n/*!*****************************!*\\\n  !*** ./src/is-supported.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_695064__) => {\n\n\"use strict\";\n__nested_webpack_require_695064__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_695064__.d(__nested_webpack_exports__, {\n/* harmony export */   \"changeTypeSupported\": () => (/* binding */ changeTypeSupported),\n/* harmony export */   \"isSupported\": () => (/* binding */ isSupported)\n/* harmony export */ });\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_695064__(/*! ./utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isSupported() {\n  var mediaSource = (0,_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__.getMediaSource)();\n  if (!mediaSource) {\n    return false;\n  }\n  var sourceBuffer = getSourceBuffer();\n  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  return !!isTypeSupported && !!sourceBufferValidAPI;\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  var sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n/***/ }),\n\n/***/ \"./src/loader/date-range.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/date-range.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_697014__) => {\n\n\"use strict\";\n__nested_webpack_require_697014__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_697014__.d(__nested_webpack_exports__, {\n/* harmony export */   \"DateRange\": () => (/* binding */ DateRange),\n/* harmony export */   \"DateRangeAttribute\": () => (/* binding */ DateRangeAttribute)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_697014__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_697014__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_697014__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar DateRangeAttribute;\n(function (DateRangeAttribute) {\n  DateRangeAttribute[\"ID\"] = \"ID\";\n  DateRangeAttribute[\"CLASS\"] = \"CLASS\";\n  DateRangeAttribute[\"START_DATE\"] = \"START-DATE\";\n  DateRangeAttribute[\"DURATION\"] = \"DURATION\";\n  DateRangeAttribute[\"END_DATE\"] = \"END-DATE\";\n  DateRangeAttribute[\"END_ON_NEXT\"] = \"END-ON-NEXT\";\n  DateRangeAttribute[\"PLANNED_DURATION\"] = \"PLANNED-DURATION\";\n  DateRangeAttribute[\"SCTE35_OUT\"] = \"SCTE35-OUT\";\n  DateRangeAttribute[\"SCTE35_IN\"] = \"SCTE35-IN\";\n})(DateRangeAttribute || (DateRangeAttribute = {}));\nvar DateRange = /*#__PURE__*/function () {\n  function DateRange(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n    if (dateRangeWithSameId) {\n      var previousAttr = dateRangeWithSameId.attr;\n      for (var key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__.AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[DateRangeAttribute.START_DATE]);\n    if (DateRangeAttribute.END_DATE in this.attr) {\n      var endDate = new Date(this.attr[DateRangeAttribute.END_DATE]);\n      if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  _createClass(DateRange, [{\n    key: \"id\",\n    get: function get() {\n      return this.attr.ID;\n    }\n  }, {\n    key: \"class\",\n    get: function get() {\n      return this.attr.CLASS;\n    }\n  }, {\n    key: \"startDate\",\n    get: function get() {\n      return this._startDate;\n    }\n  }, {\n    key: \"endDate\",\n    get: function get() {\n      if (this._endDate) {\n        return this._endDate;\n      }\n      var duration = this.duration;\n      if (duration !== null) {\n        return new Date(this._startDate.getTime() + duration * 1000);\n      }\n      return null;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (DateRangeAttribute.DURATION in this.attr) {\n        var duration = this.attr.decimalFloatingPoint(DateRangeAttribute.DURATION);\n        if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(duration)) {\n          return duration;\n        }\n      } else if (this._endDate) {\n        return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n      }\n      return null;\n    }\n  }, {\n    key: \"plannedDuration\",\n    get: function get() {\n      if (DateRangeAttribute.PLANNED_DURATION in this.attr) {\n        return this.attr.decimalFloatingPoint(DateRangeAttribute.PLANNED_DURATION);\n      }\n      return null;\n    }\n  }, {\n    key: \"endOnNext\",\n    get: function get() {\n      return this.attr.bool(DateRangeAttribute.END_ON_NEXT);\n    }\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return !!this.id && !this._badValueForSameId && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n    }\n  }]);\n  return DateRange;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/fragment-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/fragment-loader.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_703165__) => {\n\n\"use strict\";\n__nested_webpack_require_703165__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_703165__.d(__nested_webpack_exports__, {\n/* harmony export */   \"LoadError\": () => (/* binding */ LoadError),\n/* harmony export */   \"default\": () => (/* binding */ FragmentLoader)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_703165__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_703165__(/*! ../errors */ \"./src/errors.ts\");\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\nvar FragmentLoader = /*#__PURE__*/function () {\n  function FragmentLoader(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  var _proto = FragmentLoader.prototype;\n  _proto.destroy = function destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n  _proto.abort = function abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  };\n  _proto.load = function load(frag, _onProgress) {\n    var _this = this;\n    var url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag: frag,\n        networkDetails: null\n      }, \"Fragment does not have a \" + (url ? 'part list' : 'url')));\n    }\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this.loader) {\n        _this.loader.destroy();\n      }\n      var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n          var payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag: frag,\n            part: null,\n            payload: payload,\n            networkDetails: networkDetails\n          });\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onProgress: function onProgress(stats, context, data, networkDetails) {\n          if (_onProgress) {\n            _onProgress({\n              frag: frag,\n              part: null,\n              payload: data,\n              networkDetails: networkDetails\n            });\n          }\n        }\n      });\n    });\n  };\n  _proto.loadPart = function loadPart(frag, part, onProgress) {\n    var _this2 = this;\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this2.loader) {\n        _this2.loader.destroy();\n      }\n      var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag, part);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n          _this2.updateStatsFromPart(frag, part);\n          var partLoadedData = {\n            frag: frag,\n            part: part,\n            payload: response.data,\n            networkDetails: networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            part: part,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          frag.stats.aborted = part.stats.aborted;\n          _this2.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        }\n      });\n    });\n  };\n  _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n    var fragStats = frag.stats;\n    var partStats = part.stats;\n    var partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      var estTotalParts = Math.round(frag.duration / part.duration);\n      var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      var estRemainingParts = estTotalParts - estLoadedParts;\n      var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    var fragLoading = fragStats.loading;\n    var partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  };\n  _proto.resetLoader = function resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  };\n  return FragmentLoader;\n}();\n\nfunction createLoaderContext(frag, part) {\n  if (part === void 0) {\n    part = null;\n  }\n  var segment = part || frag;\n  var loaderContext = {\n    frag: frag,\n    part: part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  var start = segment.byteRangeStartOffset;\n  var end = segment.byteRangeEndOffset;\n  if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(start) && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(end)) {\n    var _frag$decryptdata;\n    var byteRangeStart = start;\n    var byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n      // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      var fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nvar LoadError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(LoadError, _Error);\n  function LoadError(data) {\n    var _this3;\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;\n    _this3.data = void 0;\n    _this3.data = data;\n    return _this3;\n  }\n  return LoadError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n/***/ }),\n\n/***/ \"./src/loader/fragment.ts\":\n/*!********************************!*\\\n  !*** ./src/loader/fragment.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_716370__) => {\n\n\"use strict\";\n__nested_webpack_require_716370__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_716370__.d(__nested_webpack_exports__, {\n/* harmony export */   \"BaseSegment\": () => (/* binding */ BaseSegment),\n/* harmony export */   \"ElementaryStreamTypes\": () => (/* binding */ ElementaryStreamTypes),\n/* harmony export */   \"Fragment\": () => (/* binding */ Fragment),\n/* harmony export */   \"Part\": () => (/* binding */ Part)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_716370__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_716370__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_716370__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _load_stats__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_716370__(/*! ./load-stats */ \"./src/loader/load-stats.ts\");\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar ElementaryStreamTypes;\n(function (ElementaryStreamTypes) {\n  ElementaryStreamTypes[\"AUDIO\"] = \"audio\";\n  ElementaryStreamTypes[\"VIDEO\"] = \"video\";\n  ElementaryStreamTypes[\"AUDIOVIDEO\"] = \"audiovideo\";\n})(ElementaryStreamTypes || (ElementaryStreamTypes = {}));\nvar BaseSegment = /*#__PURE__*/function () {\n  // baseurl is the URL to the playlist\n\n  // relurl is the portion of the URL that comes from inside the playlist.\n\n  // Holds the types of data this fragment supports\n\n  function BaseSegment(baseurl) {\n    var _this$elementaryStrea;\n    this._byteRange = null;\n    this._url = null;\n    this.baseurl = void 0;\n    this.relurl = void 0;\n    this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n    this.baseurl = baseurl;\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  var _proto = BaseSegment.prototype;\n  _proto.setByteRange = function setByteRange(value, previous) {\n    var params = value.split('@', 2);\n    var byteRange = [];\n    if (params.length === 1) {\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n    } else {\n      byteRange[0] = parseInt(params[1]);\n    }\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\n    this._byteRange = byteRange;\n  };\n  _createClass(BaseSegment, [{\n    key: \"byteRange\",\n    get: function get() {\n      if (!this._byteRange) {\n        return [];\n      }\n      return this._byteRange;\n    }\n  }, {\n    key: \"byteRangeStartOffset\",\n    get: function get() {\n      return this.byteRange[0];\n    }\n  }, {\n    key: \"byteRangeEndOffset\",\n    get: function get() {\n      return this.byteRange[1];\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      if (!this._url && this.baseurl && this.relurl) {\n        this._url = (0,url_toolkit__WEBPACK_IMPORTED_MODULE_1__.buildAbsoluteURL)(this.baseurl, this.relurl, {\n          alwaysNormalize: true\n        });\n      }\n      return this._url || '';\n    },\n    set: function set(value) {\n      this._url = value;\n    }\n  }]);\n  return BaseSegment;\n}();\nvar Fragment = /*#__PURE__*/function (_BaseSegment) {\n  _inheritsLoose(Fragment, _BaseSegment);\n  // EXTINF has to be present for a m3u8 to be considered valid\n\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n\n  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n\n  // A string representing the fragment type\n\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n\n  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n\n  // The level/track index to which the fragment belongs\n\n  // The continuity counter of the fragment\n\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n\n  // The latest Presentation Time Stamp (PTS) appended to the buffer.\n\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n\n  // Set by `updateFragPTSDTS` in level-helper\n\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n\n  // Load/parse timing information\n\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n\n  // #EXTINF  segment title\n\n  // The Media Initialization Section for this segment\n\n  // Fragment is the last fragment in the media playlist\n\n  function Fragment(type, baseurl) {\n    var _this;\n    _this = _BaseSegment.call(this, baseurl) || this;\n    _this._decryptdata = null;\n    _this.rawProgramDateTime = null;\n    _this.programDateTime = null;\n    _this.tagList = [];\n    _this.duration = 0;\n    _this.sn = 0;\n    _this.levelkeys = void 0;\n    _this.type = void 0;\n    _this.loader = null;\n    _this.keyLoader = null;\n    _this.level = -1;\n    _this.cc = 0;\n    _this.startPTS = void 0;\n    _this.endPTS = void 0;\n    _this.appendedPTS = void 0;\n    _this.startDTS = void 0;\n    _this.endDTS = void 0;\n    _this.start = 0;\n    _this.deltaPTS = void 0;\n    _this.maxStartPTS = void 0;\n    _this.minEndPTS = void 0;\n    _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_2__.LoadStats();\n    _this.urlId = 0;\n    _this.data = void 0;\n    _this.bitrateTest = false;\n    _this.title = null;\n    _this.initSegment = null;\n    _this.endList = void 0;\n    _this.type = type;\n    return _this;\n  }\n  var _proto2 = Fragment.prototype;\n  _proto2.setKeyFormat = function setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      var _key = this.levelkeys[keyFormat];\n      if (_key && !this._decryptdata) {\n        this._decryptdata = _key.getDecryptData(this.sn);\n      }\n    }\n  };\n  _proto2.abortRequests = function abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) === null || _this$loader === void 0 ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) === null || _this$keyLoader === void 0 ? void 0 : _this$keyLoader.abort();\n  };\n  _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n    if (partial === void 0) {\n      partial = false;\n    }\n    var elementaryStreams = this.elementaryStreams;\n    var info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS: startPTS,\n        endPTS: endPTS,\n        startDTS: startDTS,\n        endDTS: endDTS,\n        partial: partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  };\n  _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n    var elementaryStreams = this.elementaryStreams;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  };\n  _createClass(Fragment, [{\n    key: \"decryptdata\",\n    get: function get() {\n      var levelkeys = this.levelkeys;\n      if (!levelkeys && !this._decryptdata) {\n        return null;\n      }\n      if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n        var _key2 = this.levelkeys.identity;\n        if (_key2) {\n          this._decryptdata = _key2.getDecryptData(this.sn);\n        } else {\n          var keyFormats = Object.keys(this.levelkeys);\n          if (keyFormats.length === 1) {\n            return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n          } else {\n            // Multiple keys. key-loader to call Fragment.setKeyFormat based on selected key-system.\n          }\n        }\n      }\n      return this._decryptdata;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"endProgramDateTime\",\n    get: function get() {\n      if (this.programDateTime === null) {\n        return null;\n      }\n      if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.programDateTime)) {\n        return null;\n      }\n      var duration = !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.duration) ? 0 : this.duration;\n      return this.programDateTime + duration * 1000;\n    }\n  }, {\n    key: \"encrypted\",\n    get: function get() {\n      var _this$_decryptdata;\n      // At the m3u8-parser level we need to add support for manifest signalled keyformats\n      // when we want the fragment to start reporting that it is encrypted.\n      // Currently, keyFormat will only be set for identity keys\n      if ((_this$_decryptdata = this._decryptdata) !== null && _this$_decryptdata !== void 0 && _this$_decryptdata.encrypted) {\n        return true;\n      } else if (this.levelkeys) {\n        var keyFormats = Object.keys(this.levelkeys);\n        var len = keyFormats.length;\n        if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }]);\n  return Fragment;\n}(BaseSegment);\nvar Part = /*#__PURE__*/function (_BaseSegment2) {\n  _inheritsLoose(Part, _BaseSegment2);\n  function Part(partAttrs, frag, baseurl, index, previous) {\n    var _this2;\n    _this2 = _BaseSegment2.call(this, baseurl) || this;\n    _this2.fragOffset = 0;\n    _this2.duration = 0;\n    _this2.gap = false;\n    _this2.independent = false;\n    _this2.relurl = void 0;\n    _this2.fragment = void 0;\n    _this2.index = void 0;\n    _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_2__.LoadStats();\n    _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n    _this2.gap = partAttrs.bool('GAP');\n    _this2.independent = partAttrs.bool('INDEPENDENT');\n    _this2.relurl = partAttrs.enumeratedString('URI');\n    _this2.fragment = frag;\n    _this2.index = index;\n    var byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      _this2.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      _this2.fragOffset = previous.fragOffset + previous.duration;\n    }\n    return _this2;\n  }\n  _createClass(Part, [{\n    key: \"start\",\n    get: function get() {\n      return this.fragment.start + this.fragOffset;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      var elementaryStreams = this.elementaryStreams;\n      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n    }\n  }]);\n  return Part;\n}(BaseSegment);\n\n/***/ }),\n\n/***/ \"./src/loader/key-loader.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/key-loader.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_729676__) => {\n\n\"use strict\";\n__nested_webpack_require_729676__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_729676__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ KeyLoader)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_729676__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _fragment_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_729676__(/*! ./fragment-loader */ \"./src/loader/fragment-loader.ts\");\n\n\nvar KeyLoader = /*#__PURE__*/function () {\n  function KeyLoader(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  var _proto = KeyLoader.prototype;\n  _proto.abort = function abort() {\n    for (var uri in this.keyUriToKeyInfo) {\n      var loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.abort();\n      }\n    }\n  };\n  _proto.detach = function detach() {\n    for (var uri in this.keyUriToKeyInfo) {\n      var keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  };\n  _proto.destroy = function destroy() {\n    this.detach();\n    for (var uri in this.keyUriToKeyInfo) {\n      var loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  };\n  _proto.createKeyLoadError = function createKeyLoadError(frag, details, networkDetails, message) {\n    if (details === void 0) {\n      details = _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR;\n    }\n    return new _fragment_loader__WEBPACK_IMPORTED_MODULE_1__.LoadError({\n      type: _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorTypes.NETWORK_ERROR,\n      details: details,\n      fatal: false,\n      frag: frag,\n      networkDetails: networkDetails\n    });\n  };\n  _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {\n    var _this = this;\n    if (this.emeController && this.config.emeEnabled) {\n      // access key-system with nearest key on start (loaidng frag is unencrypted)\n      var sn = loadingFrag.sn,\n        cc = loadingFrag.cc;\n      var _loop = function _loop(i) {\n        var frag = encryptedFragments[i];\n        if (cc <= frag.cc && (sn === 'initSegment' || sn < frag.sn)) {\n          _this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n            frag.setKeyFormat(keySystemFormat);\n          });\n          return \"break\";\n        }\n      };\n      for (var i = 0; i < encryptedFragments.length; i++) {\n        var _ret = _loop(i);\n        if (_ret === \"break\") break;\n      }\n    }\n  };\n  _proto.load = function load(frag) {\n    var _this2 = this;\n    if (!frag.decryptdata && frag.encrypted && this.emeController) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n        return _this2.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  };\n  _proto.loadInternal = function loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    var decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      var errorMessage = keySystemFormat ? \"Expected frag.decryptdata to be defined after setting format \" + keySystemFormat : 'Missing decryption data on fragment in onKeyLoading';\n      return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, errorMessage));\n    }\n    var uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, \"Invalid key URI: \\\"\" + uri + \"\\\"\"));\n    }\n    var keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) !== null && _keyInfo !== void 0 && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag: frag,\n        keyInfo: keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) !== null && _keyInfo2 !== void 0 && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) === null || _keyInfo$mediaKeySess === void 0 ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(function (keyLoadedData) {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag: frag,\n              keyInfo: keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata: decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, \"Key supplied with unsupported METHOD: \\\"\" + decryptdata.method + \"\\\"\"));\n    }\n  };\n  _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {\n    var keyLoadedData = {\n      frag: frag,\n      keyInfo: keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function (keySessionContext) {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(function (error) {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  };\n  _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {\n    var _this3 = this;\n    var config = this.config;\n    var Loader = config.loader;\n    var keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise(function (resolve, reject) {\n      var loaderContext = {\n        keyInfo: keyInfo,\n        frag: frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: config.fragLoadingRetryDelay,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: 0\n      };\n      var loaderCallbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          var frag = context.frag,\n            keyInfo = context.keyInfo,\n            uri = context.url;\n          if (!frag.decryptdata || keyInfo !== _this3.keyUriToKeyInfo[uri]) {\n            return reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, networkDetails, 'after key load, decryptdata unset or changed'));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag: frag,\n            keyInfo: keyInfo\n          });\n        },\n        onError: function onError(error, context, networkDetails) {\n          _this3.resetLoader(context);\n          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, networkDetails));\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          _this3.resetLoader(context);\n          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_TIMEOUT, networkDetails));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          _this3.resetLoader(context);\n          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.INTERNAL_ABORTED, networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  };\n  _proto.resetLoader = function resetLoader(context) {\n    var frag = context.frag,\n      keyInfo = context.keyInfo,\n      uri = context.url;\n    var loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  };\n  return KeyLoader;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/loader/level-details.ts\":\n/*!*************************************!*\\\n  !*** ./src/loader/level-details.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_739837__) => {\n\n\"use strict\";\n__nested_webpack_require_739837__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_739837__.d(__nested_webpack_exports__, {\n/* harmony export */   \"LevelDetails\": () => (/* binding */ LevelDetails)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_739837__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar DEFAULT_TARGET_DURATION = 10;\nvar LevelDetails = /*#__PURE__*/function () {\n  // Manifest reload synchronization\n\n  function LevelDetails(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  var _proto = LevelDetails.prototype;\n  _proto.reloaded = function reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    var partSnDiff = this.lastPartSn - previous.lastPartSn;\n    var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n    this.availabilityDelay = previous.availabilityDelay;\n  };\n  _createClass(LevelDetails, [{\n    key: \"hasProgramDateTime\",\n    get: function get() {\n      if (this.fragments.length) {\n        return (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime);\n      }\n      return false;\n    }\n  }, {\n    key: \"levelTargetDuration\",\n    get: function get() {\n      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var runTime = this.driftEndTime - this.driftStartTime;\n      if (runTime > 0) {\n        var runDuration = this.driftEnd - this.driftStart;\n        return runDuration * 1000 / runTime;\n      }\n      return 1;\n    }\n  }, {\n    key: \"edge\",\n    get: function get() {\n      return this.partEnd || this.fragmentEnd;\n    }\n  }, {\n    key: \"partEnd\",\n    get: function get() {\n      var _this$partList;\n      if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {\n        return this.partList[this.partList.length - 1].end;\n      }\n      return this.fragmentEnd;\n    }\n  }, {\n    key: \"fragmentEnd\",\n    get: function get() {\n      var _this$fragments;\n      if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {\n        return this.fragments[this.fragments.length - 1].end;\n      }\n      return 0;\n    }\n  }, {\n    key: \"age\",\n    get: function get() {\n      if (this.advancedDateTime) {\n        return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n      }\n      return 0;\n    }\n  }, {\n    key: \"lastPartIndex\",\n    get: function get() {\n      var _this$partList2;\n      if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {\n        return this.partList[this.partList.length - 1].index;\n      }\n      return -1;\n    }\n  }, {\n    key: \"lastPartSn\",\n    get: function get() {\n      var _this$partList3;\n      if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {\n        return this.partList[this.partList.length - 1].fragment.sn;\n      }\n      return this.endSN;\n    }\n  }]);\n  return LevelDetails;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/level-key.ts\":\n/*!*********************************!*\\\n  !*** ./src/loader/level-key.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_746062__) => {\n\n\"use strict\";\n__nested_webpack_require_746062__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_746062__.d(__nested_webpack_exports__, {\n/* harmony export */   \"LevelKey\": () => (/* binding */ LevelKey)\n/* harmony export */ });\n/* harmony import */ var _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_746062__(/*! ../utils/keysystem-util */ \"./src/utils/keysystem-util.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_746062__(/*! ../utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_746062__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_746062__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_746062__(/*! ../utils/numeric-encoding-utils */ \"./src/utils/numeric-encoding-utils.ts\");\n\n\n\n\n\nvar keyUriToKeyIdMap = {};\nvar LevelKey = /*#__PURE__*/function () {\n  LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  };\n  function LevelKey(method, uri, format, formatversions, iv) {\n    if (formatversions === void 0) {\n      formatversions = [1];\n    }\n    if (iv === void 0) {\n      iv = null;\n    }\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n  }\n  var _proto = LevelKey.prototype;\n  _proto.isSupported = function isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (this.method === 'AES-128' || this.method === 'NONE') {\n        return true;\n      }\n      switch (this.keyFormat) {\n        case 'identity':\n          // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n          return this.method === 'SAMPLE-AES';\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.FAIRPLAY:\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.WIDEVINE:\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.PLAYREADY:\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.CLEARKEY:\n          return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n      }\n    }\n    return false;\n  };\n  _proto.getDecryptData = function getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (this.method === 'AES-128' && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        if (this.method === 'AES-128' && !this.iv) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"missing IV for initialization segment with method=\\\"\" + this.method + \"\\\" - compliance issue\");\n        }\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      var iv = createInitializationVector(sn);\n      var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n\n    // Initialize keyId if possible\n    var keyBytes = (0,_utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__.convertDataUriToArrayBytes)(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.WIDEVINE:\n          this.pssh = keyBytes;\n          // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n          if (keyBytes.length >= 22) {\n            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n          }\n          break;\n        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.PLAYREADY:\n          {\n            var PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n            this.pssh = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.mp4pssh)(PlayReadyKeySystemUUID, null, keyBytes);\n            var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n            var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n            // Parse Playready WRMHeader XML\n            var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n            var parser = new DOMParser();\n            var xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n            var keyData = xmlDoc.getElementsByTagName('KID')[0];\n            if (keyData) {\n              var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n              if (keyId) {\n                var keyIdArray = (0,_utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_4__.base64Decode)(keyId).subarray(0, 16);\n                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                // KID value in ‘tenc’ is a big endian UUID GUID interpretation of UUID\n                (0,_utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__.changeEndianness)(keyIdArray);\n                this.keyId = keyIdArray;\n              }\n            }\n            break;\n          }\n        default:\n          {\n            var keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              var padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      var _keyId = keyUriToKeyIdMap[this.uri];\n      if (!_keyId) {\n        var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        _keyId = new Uint8Array(16);\n        var dv = new DataView(_keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = _keyId;\n      }\n      this.keyId = _keyId;\n    }\n    return this;\n  };\n  return LevelKey;\n}();\nfunction createInitializationVector(segmentNumber) {\n  var uint8View = new Uint8Array(16);\n  for (var i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\n/***/ }),\n\n/***/ \"./src/loader/load-stats.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/load-stats.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_753427__) => {\n\n\"use strict\";\n__nested_webpack_require_753427__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_753427__.d(__nested_webpack_exports__, {\n/* harmony export */   \"LoadStats\": () => (/* binding */ LoadStats)\n/* harmony export */ });\nvar LoadStats = function LoadStats() {\n  this.aborted = false;\n  this.loaded = 0;\n  this.retry = 0;\n  this.total = 0;\n  this.chunkCount = 0;\n  this.bwEstimate = 0;\n  this.loading = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n  this.parsing = {\n    start: 0,\n    end: 0\n  };\n  this.buffering = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/loader/m3u8-parser.ts\":\n/*!***********************************!*\\\n  !*** ./src/loader/m3u8-parser.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_754240__) => {\n\n\"use strict\";\n__nested_webpack_require_754240__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_754240__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ M3U8Parser)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_754240__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_754240__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_754240__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _date_range__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_754240__(/*! ./date-range */ \"./src/loader/date-range.ts\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_754240__(/*! ./fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _level_details__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_754240__(/*! ./level-details */ \"./src/loader/level-details.ts\");\n/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_754240__(/*! ./level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_754240__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_754240__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_754240__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n\n\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-SESSION-DATA:([^\\r\\n]*)[\\r\\n]+|#EXT-X-SESSION-KEY:([^\\n\\r]*)[\\r\\n]+/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nvar LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source,\n// next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n// next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nvar LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nvar M3U8Parser = /*#__PURE__*/function () {\n  function M3U8Parser() {}\n  M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  };\n  M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    var avcdata = codec.split('.');\n    if (avcdata.length > 2) {\n      var result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n      return result;\n    }\n    return codec;\n  };\n  M3U8Parser.resolve = function resolve(url, baseUrl) {\n    return (0,url_toolkit__WEBPACK_IMPORTED_MODULE_1__.buildAbsoluteURL)(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  };\n  M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n    var levels = [];\n    var levelsWithKnownCodecs = [];\n    var sessionData = {};\n    var sessionKeys = [];\n    var hasSessionData = false;\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    var result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[1]);\n        var level = {\n          attrs: attrs,\n          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(result[2], baseurl)\n        };\n        var resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {\n          return c;\n        }), level);\n        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n        }\n        if (!((_level$unknownCodecs = level.unknownCodecs) !== null && _level$unknownCodecs !== void 0 && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        levels.push(level);\n      } else if (result[3]) {\n        // '#EXT-X-SESSION-DATA' is found, parse session data in group 3\n        var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[3]);\n        if (sessionAttrs['DATA-ID']) {\n          hasSessionData = true;\n          sessionData[sessionAttrs['DATA-ID']] = sessionAttrs;\n        }\n      } else if (result[4]) {\n        // '#EXT-X-SESSION-KEY' is found\n        var keyTag = result[4];\n        var sessionKey = parseKey(keyTag, baseurl);\n        if (sessionKey.encrypted && sessionKey.isSupported()) {\n          sessionKeys.push(sessionKey);\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn(\"[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \\\"\" + keyTag + \"\\\"\");\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < levels.length;\n    return {\n      levels: stripUnknownCodecLevels ? levelsWithKnownCodecs : levels,\n      sessionData: hasSessionData ? sessionData : null,\n      sessionKeys: sessionKeys.length ? sessionKeys : null\n    };\n  };\n  M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {\n    if (groups === void 0) {\n      groups = [];\n    }\n    var result;\n    var medias = [];\n    var id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[1]);\n      if (attrs.TYPE === type) {\n        var media = {\n          attrs: attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'],\n          instreamId: attrs['INSTREAM-ID'],\n          name: attrs.NAME || attrs.LANGUAGE || '',\n          type: type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang: attrs.LANGUAGE,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return medias;\n  };\n  M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {\n    var level = new _level_details__WEBPACK_IMPORTED_MODULE_4__.LevelDetails(baseurl);\n    var fragments = level.fragments;\n    // The most recent init segment seen (applies to all subsequent segments)\n    var currentInitSegment = null;\n    var currentSN = 0;\n    var currentPart = 0;\n    var totalduration = 0;\n    var discontinuityCounter = 0;\n    var prevFrag = null;\n    var frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);\n    var result;\n    var i;\n    var levelkeys;\n    var firstPdtIndex = -1;\n    var createNextFrag = false;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);\n        // setup the next fragment for part loading\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n        }\n      }\n      var duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        var title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.duration)) {\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          frag.urlId = levelUrlId;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          frag.relurl = (' ' + result[3]).slice(1);\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        var data = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        var tag = (' ' + result[i]).slice(1);\n        var value1 = (' ' + result[i + 1]).slice(1);\n        var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(skippedSegments)) {\n                level.skippedSegments = skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (var _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n                currentSN += skippedSegments;\n              }\n              var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            level.targetduration = parseFloat(value1);\n            break;\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n          case 'EXTM3U':\n            break;\n          case 'ENDLIST':\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n          case 'DATERANGE':\n            {\n              var dateRangeAttr = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              var dateRange = new _date_range__WEBPACK_IMPORTED_MODULE_2__.DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              var levelKey = parseKey(value1, baseurl);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                if (levelkeys[levelKey.keyFormat]) {\n                  levelkeys = _extends({}, levelkeys);\n                }\n                levelkeys[levelKey.keyFormat] = levelKey;\n              } else {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn(\"[Keys] Ignoring invalid EXT-X-KEY tag: \\\"\" + value1 + \"\\\"\");\n              }\n              break;\n            }\n          case 'START':\n            {\n              var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n              // TIME-OFFSET can be 0\n              if ((0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(startTimeOffset)) {\n                level.startTimeOffset = startTimeOffset;\n              }\n              break;\n            }\n          case 'MAP':\n            {\n              var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                var init = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              var partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              var index = currentPart++;\n              var part = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Part(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1), frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn(\"line parsed but not handled: \" + result);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    var fragmentLength = fragments.length;\n    var firstFragment = fragments[0];\n    var lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      var lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n    return level;\n  };\n  return M3U8Parser;\n}();\n\nfunction parseKey(keyTag, baseurl) {\n  var _keyAttrs$enumeratedS, _keyAttrs$enumeratedS2;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(keyTag);\n  var decryptmethod = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString('METHOD')) != null ? _keyAttrs$enumeratedS : '';\n  var decrypturi = keyAttrs.URI;\n  var decryptiv = keyAttrs.hexadecimalInteger('IV');\n  var decryptkeyformatversions = keyAttrs.enumeratedString('KEYFORMATVERSIONS');\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  var decryptkeyformat = (_keyAttrs$enumeratedS2 = keyAttrs.enumeratedString('KEYFORMAT')) != null ? _keyAttrs$enumeratedS2 : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.error(\"Invalid IV: \" + keyAttrs.IV);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new _level_key__WEBPACK_IMPORTED_MODULE_5__.LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction setCodecs(codecs, level) {\n  ['video', 'audio', 'text'].forEach(function (type) {\n    var filtered = codecs.filter(function (codec) {\n      return (0,_utils_codecs__WEBPACK_IMPORTED_MODULE_8__.isCodecType)(codec, type);\n    });\n    if (filtered.length) {\n      var preferred = filtered.filter(function (codec) {\n        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n      });\n      level[type + \"Codec\"] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n      // remove from list\n      codecs = codecs.filter(function (codec) {\n        return filtered.indexOf(codec) === -1;\n      });\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  var codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  var fragPrev = fragments[firstPdtIndex];\n  for (var i = firstPdtIndex; i--;) {\n    var frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n  if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  var encryptedFragments = level.encryptedFragments;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {\n    return levelkeys[format].isCommonEncryption;\n  })) {\n    encryptedFragments.push(frag);\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/loader/playlist-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/playlist-loader.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_779733__) => {\n\n\"use strict\";\n__nested_webpack_require_779733__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_779733__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_779733__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_779733__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_779733__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_779733__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_779733__(/*! ./m3u8-parser */ \"./src/loader/m3u8-parser.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_779733__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_779733__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n\n\n/**\n * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.\n *\n * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.\n *\n * Uses loader(s) set in config to do actual internal loading of resource tasks.\n *\n * @module\n *\n */\n\n\n\n\n\n\n\nfunction mapContextToLevelType(context) {\n  var type = context.type;\n  switch (type) {\n    case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.AUDIO;\n    case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.SUBTITLE;\n    default:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  var url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nvar PlaylistLoader = /*#__PURE__*/function () {\n  function PlaylistLoader(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.hls = hls;\n    this.registerListeners();\n  }\n  var _proto = PlaylistLoader.prototype;\n  _proto.startLoad = function startLoad(startPosition) {};\n  _proto.stopLoad = function stopLoad() {\n    this.destroyInternalLoaders();\n  };\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  };\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */;\n  _proto.createInternalLoader = function createInternalLoader(context) {\n    var config = this.hls.config;\n    var PLoader = config.pLoader;\n    var Loader = config.loader;\n    var InternalLoader = PLoader || Loader;\n    var loader = new InternalLoader(config);\n    context.loader = loader;\n    this.loaders[context.type] = loader;\n    return loader;\n  };\n  _proto.getInternalLoader = function getInternalLoader(context) {\n    return this.loaders[context.type];\n  };\n  _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */;\n  _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n    for (var contextType in this.loaders) {\n      var loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  };\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  };\n  _proto.onManifestLoading = function onManifestLoading(event, data) {\n    var url = data.url;\n    this.load({\n      id: null,\n      groupId: null,\n      level: 0,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST,\n      url: url,\n      deliveryDirectives: null\n    });\n  };\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var id = data.id,\n      level = data.level,\n      url = data.url,\n      deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: null,\n      level: level,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n  _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n    var id = data.id,\n      groupId = data.groupId,\n      url = data.url,\n      deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n  _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n    var id = data.id,\n      groupId = data.groupId,\n      url = data.url,\n      deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n  _proto.load = function load(context) {\n    var _context$deliveryDire;\n    var config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    var loader = this.getInternalLoader(context);\n    if (loader) {\n      var loaderContext = loader.context;\n      if (loaderContext && loaderContext.url === context.url) {\n        // same URL can't overlap\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n      loader.abort();\n    }\n    var maxRetry;\n    var timeout;\n    var retryDelay;\n    var maxRetryDelay;\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:\n        maxRetry = config.manifestLoadingMaxRetry;\n        timeout = config.manifestLoadingTimeOut;\n        retryDelay = config.manifestLoadingRetryDelay;\n        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:\n        // Manage retries in Level/Track Controller\n        maxRetry = 0;\n        timeout = config.levelLoadingTimeOut;\n        break;\n      default:\n        maxRetry = config.levelLoadingMaxRetry;\n        timeout = config.levelLoadingTimeOut;\n        retryDelay = config.levelLoadingRetryDelay;\n        maxRetryDelay = config.levelLoadingMaxRetryTimeout;\n        break;\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {\n      var levelDetails;\n      if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        var partTarget = levelDetails.partTarget;\n        var targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1000, timeout);\n        }\n      }\n    }\n    var loaderConfig = {\n      timeout: timeout,\n      maxRetry: maxRetry,\n      retryDelay: retryDelay,\n      maxRetryDelay: maxRetryDelay,\n      highWaterMark: 0\n    };\n    var loaderCallbacks = {\n      onSuccess: this.loadsuccess.bind(this),\n      onError: this.loaderror.bind(this),\n      onTimeout: this.loadtimeout.bind(this)\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  };\n  _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n    this.resetInternalLoader(context.type);\n    var string = response.data;\n\n    // Validate if it is an M3U8 at all\n    if (string.indexOf('#EXTM3U') !== 0) {\n      this.handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);\n      return;\n    }\n    stats.parsing.start = performance.now();\n    // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)\n    if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {\n      this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);\n    } else {\n      this.handleMasterPlaylist(response, stats, context, networkDetails);\n    }\n  };\n  _proto.loaderror = function loaderror(response, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n    this.handleNetworkError(context, networkDetails, false, response);\n  };\n  _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n    this.handleNetworkError(context, networkDetails, true);\n  };\n  _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var string = response.data;\n    var url = getResponseUrl(response, context);\n    var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseMasterPlaylist(string, url),\n      levels = _M3U8Parser$parseMast.levels,\n      sessionData = _M3U8Parser$parseMast.sessionData,\n      sessionKeys = _M3U8Parser$parseMast.sessionKeys;\n    if (!levels.length) {\n      this.handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);\n      return;\n    }\n\n    // multi level playlist, parse level info\n    var audioGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      };\n    });\n    var subtitleGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      };\n    });\n    var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);\n    var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseMasterPlaylistMedia(string, url, 'SUBTITLES', subtitleGroups);\n    var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseMasterPlaylistMedia(string, url, 'CLOSED-CAPTIONS');\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n        return !audioTrack.url;\n      });\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, {\n      levels: levels,\n      audioTracks: audioTracks,\n      subtitles: subtitles,\n      captions: captions,\n      url: url,\n      stats: stats,\n      networkDetails: networkDetails,\n      sessionData: sessionData,\n      sessionKeys: sessionKeys\n    });\n  };\n  _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var id = context.id,\n      level = context.level,\n      type = context.type;\n    var url = getResponseUrl(response, context);\n    var levelUrlId = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(id) ? id : 0;\n    var levelId = (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(level) ? level : levelUrlId;\n    var levelType = mapContextToLevelType(context);\n    var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);\n    if (!levelDetails.fragments.length) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url: url,\n        reason: 'no fragments found in level',\n        level: typeof context.level === 'number' ? context.level : undefined\n      });\n      return;\n    }\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST) {\n      var singleLevel = {\n        attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url: url\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url: url,\n        stats: stats,\n        networkDetails: networkDetails,\n        sessionData: null,\n        sessionKeys: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(response, stats, context, networkDetails);\n  };\n  _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST,\n      url: response.url,\n      reason: reason,\n      response: response,\n      context: context,\n      networkDetails: networkDetails\n    });\n  };\n  _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {\n    if (timeout === void 0) {\n      timeout = false;\n    }\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"[playlist-loader]: A network \" + (timeout ? 'timeout' : 'error') + \" occurred while loading \" + context.type + \" level: \" + context.level + \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\");\n    var details = _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.UNKNOWN;\n    var fatal = false;\n    var loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    var errorData = {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,\n      details: details,\n      fatal: fatal,\n      url: context.url,\n      loader: loader,\n      context: context,\n      networkDetails: networkDetails\n    };\n    if (response) {\n      errorData.response = response;\n    }\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, errorData);\n  };\n  _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {\n    var type = context.type,\n      level = context.level,\n      id = context.id,\n      groupId = context.groupId,\n      loader = context.loader,\n      levelDetails = context.levelDetails,\n      deliveryDirectives = context.deliveryDirectives;\n    if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {\n      this.handleManifestParsingError(response, context, 'invalid target duration', networkDetails);\n      return;\n    }\n    if (!loader) {\n      return;\n    }\n    if (levelDetails.live) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, {\n          details: levelDetails,\n          level: level || 0,\n          id: id || 0,\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n    }\n  };\n  return PlaylistLoader;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlaylistLoader);\n\n/***/ }),\n\n/***/ \"./src/polyfills/number.ts\":\n/*!*********************************!*\\\n  !*** ./src/polyfills/number.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_802191__) => {\n\n\"use strict\";\n__nested_webpack_require_802191__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_802191__.d(__nested_webpack_exports__, {\n/* harmony export */   \"MAX_SAFE_INTEGER\": () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   \"isFiniteNumber\": () => (/* binding */ isFiniteNumber)\n/* harmony export */ });\nvar isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n/***/ }),\n\n/***/ \"./src/remux/aac-helper.ts\":\n/*!*********************************!*\\\n  !*** ./src/remux/aac-helper.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_802930__) => {\n\n\"use strict\";\n__nested_webpack_require_802930__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_802930__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n *  AAC helper\n */\nvar AAC = /*#__PURE__*/function () {\n  function AAC() {}\n  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  };\n  return AAC;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AAC);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-generator.ts\":\n/*!************************************!*\\\n  !*** ./src/remux/mp4-generator.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_806595__) => {\n\n\"use strict\";\n__nested_webpack_require_806595__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_806595__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Generate MP4 Box\n */\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar MP4 = /*#__PURE__*/function () {\n  function MP4() {}\n  MP4.init = function init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    var i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    var videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n\n    var audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    var dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n\n    var stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    var minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  };\n  MP4.box = function box(type) {\n    var size = 8;\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n    var i = payload.length;\n    var len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    var result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  };\n  MP4.hdlr = function hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  };\n  MP4.mdat = function mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  };\n  MP4.mdhd = function mdhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  };\n  MP4.mdia = function mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  };\n  MP4.mfhd = function mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  };\n  MP4.minf = function minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  };\n  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n\n  /**\n   * @param tracks... (optional) {array} the tracks associated with this movie\n   */;\n  MP4.moov = function moov(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  };\n  MP4.mvex = function mvex(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n  };\n  MP4.mvhd = function mvhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    var bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n\n    return MP4.box(MP4.types.mvhd, bytes);\n  };\n  MP4.sdtp = function sdtp(track) {\n    var samples = track.samples || [];\n    var bytes = new Uint8Array(4 + samples.length);\n    var i;\n    var flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  };\n  MP4.stbl = function stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  };\n  MP4.avc1 = function avc1(track) {\n    var sps = [];\n    var pps = [];\n    var i;\n    var data;\n    var len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    var width = track.width;\n    var height = track.height;\n    var hSpacing = track.pixelRatio[0];\n    var vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  };\n  MP4.esds = function esds(track) {\n    var configlen = track.config.length;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x17 + configlen,\n    // length\n    0x00, 0x01,\n    // es_id\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x0f + configlen,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  };\n  MP4.mp4a = function mp4a(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n  };\n  MP4.mp3 = function mp3(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]));\n  };\n  MP4.stsd = function stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  };\n  MP4.tkhd = function tkhd(track) {\n    var id = track.id;\n    var duration = track.duration * track.timescale;\n    var width = track.width;\n    var height = track.height;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  };\n  MP4.traf = function traf(track, baseMediaDecodeTime) {\n    var sampleDependencyTable = MP4.sdtp(track);\n    var id = track.id;\n    var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */;\n  MP4.trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  };\n  MP4.trex = function trex(track) {\n    var id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  };\n  MP4.trun = function trun(track, offset) {\n    var samples = track.samples || [];\n    var len = samples.length;\n    var arraylen = 12 + 16 * len;\n    var array = new Uint8Array(arraylen);\n    var i;\n    var sample;\n    var duration;\n    var size;\n    var flags;\n    var cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  };\n  MP4.initSegment = function initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    var movie = MP4.moov(tracks);\n    var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  };\n  return MP4;\n}();\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MP4);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-remuxer.ts\":\n/*!**********************************!*\\\n  !*** ./src/remux/mp4-remuxer.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_826306__) => {\n\n\"use strict\";\n__nested_webpack_require_826306__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_826306__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MP4Remuxer),\n/* harmony export */   \"flushTextTrackMetadataCueSamples\": () => (/* binding */ flushTextTrackMetadataCueSamples),\n/* harmony export */   \"flushTextTrackUserdataCueSamples\": () => (/* binding */ flushTextTrackUserdataCueSamples),\n/* harmony export */   \"normalizePts\": () => (/* binding */ normalizePts)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_826306__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_826306__(/*! ./aac-helper */ \"./src/remux/aac-helper.ts\");\n/* harmony import */ var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_826306__(/*! ./mp4-generator */ \"./src/remux/mp4-generator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_826306__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_826306__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_826306__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_826306__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_826306__(/*! ../utils/timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\nvar MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nvar AAC_SAMPLES_PER_FRAME = 1024;\nvar MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nvar chromeVersion = null;\nvar safariWebkitVersion = null;\nvar MP4Remuxer = /*#__PURE__*/function () {\n  function MP4Remuxer(observer, config, typeSupported, vendor) {\n    if (vendor === void 0) {\n      vendor = '';\n    }\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = void 0;\n    this._initDTS = void 0;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n    }\n  }\n  var _proto = MP4Remuxer.prototype;\n  _proto.destroy = function destroy() {};\n  _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  };\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  };\n  _proto.resetInitSegment = function resetInitSegment() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  };\n  _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n    var rolloverDetected = false;\n    var startPTS = videoSamples.reduce(function (minPTS, sample) {\n      var delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  };\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    var video;\n    var audio;\n    var initSegment;\n    var text;\n    var id3;\n    var independent;\n    var audioTimeOffset = timeOffset;\n    var videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    var hasAudio = audioTrack.pid > -1;\n    var hasVideo = videoTrack.pid > -1;\n    var length = videoTrack.samples.length;\n    var enoughAudioSamples = audioTrack.samples.length > 0;\n    var enoughVideoSamples = flush && length > 0 || length > 1;\n    var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n      }\n      var isVideoContiguous = this.isVideoContiguous;\n      var firstKeyFrameIndex = -1;\n      var firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n            var startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          var _startPTS = this.getVideoStartPts(videoTrack.samples);\n          var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n          var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio: audio,\n      video: video,\n      initSegment: initSegment,\n      independent: independent,\n      text: text,\n      id3: id3\n    };\n  };\n  _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {\n    var audioSamples = audioTrack.samples;\n    var videoSamples = videoTrack.samples;\n    var typeSupported = this.typeSupported;\n    var tracks = {};\n    var computePTSDTS = !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this._initPTS);\n    var container = 'audio/mp4';\n    var initPTS;\n    var initDTS;\n    var timescale;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        // remember first PTS of this demuxing context. for audio, PTS = DTS\n        initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        var startPTS = this.getVideoStartPts(videoSamples);\n        var startOffset = Math.round(timescale * timeOffset);\n        initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n        initPTS = Math.min(initPTS, startPTS - startOffset);\n      }\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = initPTS;\n        this._initDTS = initDTS;\n      }\n      return {\n        tracks: tracks,\n        initPTS: initPTS,\n        timescale: timescale\n      };\n    }\n  };\n  _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    var timeScale = track.inputTimeScale;\n    var inputSamples = track.samples;\n    var outputSamples = [];\n    var nbSamples = inputSamples.length;\n    var initPTS = this._initPTS;\n    var nextAvcDts = this.nextAvcDts;\n    var offset = 8;\n    var mp4SampleDuration = this.videoSampleDuration;\n    var firstDTS;\n    var lastDTS;\n    var minPTS = Number.POSITIVE_INFINITY;\n    var maxPTS = Number.NEGATIVE_INFINITY;\n    var sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      var pts = timeOffset * timeScale;\n      var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      // if not contiguous, let's use target timeOffset\n      nextAvcDts = pts - cts;\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    for (var i = 0; i < nbSamples; i++) {\n      var sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initPTS, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initPTS, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        var deltadts = a.dts - b.dts;\n        var deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    var inputDuration = lastDTS - firstDTS;\n    var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      var delta = firstDTS - nextAvcDts;\n      var foundHole = delta > averageSampleDuration;\n      var foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"AVC: \" + (0,_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected, filling it\");\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"AVC: \" + (0,_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected\");\n        }\n        if (!foundOverlap || nextAvcDts > inputSamples[0].pts) {\n          firstDTS = nextAvcDts;\n          var firstPTS = inputSamples[0].pts - delta;\n          inputSamples[0].dts = firstDTS;\n          inputSamples[0].pts = firstPTS;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log(\"Video: First PTS/DTS adjusted: \" + (0,_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(firstPTS, true) + \"/\" + (0,_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(firstDTS, true) + \", delta: \" + (0,_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(delta, true) + \" ms\");\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    var nbNalu = 0;\n    var naluLen = 0;\n    for (var _i = 0; _i < nbSamples; _i++) {\n      // compute total/avc sample length and nb of NAL units\n      var _sample = inputSamples[_i];\n      var units = _sample.units;\n      var nbUnits = units.length;\n      var sampleLen = 0;\n      for (var j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      _sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      _sample.dts = Math.max(_sample.dts, firstDTS);\n      minPTS = Math.min(_sample.pts, minPTS);\n      maxPTS = Math.max(_sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    var mdatSize = naluLen + 4 * nbNalu + 8;\n    var mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MUX_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        bytes: mdatSize,\n        reason: \"fail allocating video mdat \" + mdatSize\n      });\n      return;\n    }\n    var view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n    var stretchedLastFrame = false;\n    var minDtsDelta = Number.POSITIVE_INFINITY;\n    var minPtsDelta = Number.POSITIVE_INFINITY;\n    var maxDtsDelta = Number.NEGATIVE_INFINITY;\n    var maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n      var avcSample = inputSamples[_i2];\n      var avcSampleUnits = avcSample.units;\n      var mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n        var unit = avcSampleUnits[_j];\n        var unitData = unit.data;\n        var unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      var ptsDelta = void 0;\n      if (_i2 < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n        ptsDelta = inputSamples[_i2 + 1].pts - avcSample.pts;\n      } else {\n        var config = this.config;\n        var lastFrameDuration = _i2 > 0 ? avcSample.dts - inputSamples[_i2 - 1].dts : averageSampleDuration;\n        ptsDelta = _i2 > 0 ? avcSample.pts - inputSamples[_i2 - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          var flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          var dts = firstDTS;\n          for (var _i3 = 0, len = outputSamples.length; _i3 < len; _i3++) {\n            var nextDts = dts + outputSamples[_i3].duration;\n            var _pts = dts + outputSamples[_i3].cts;\n            if (_i3 < len - 1) {\n              var nextPts = nextDts + outputSamples[_i3 + 1].cts;\n              outputSamples[_i3].duration = nextPts - _pts;\n            } else {\n              outputSamples[_i3].duration = _i3 ? outputSamples[_i3 - 1].duration : averageSampleDuration;\n            }\n            outputSamples[_i3].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    console.assert(mp4SampleDuration !== null, 'mp4SampleDuration must be computed');\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    var type = 'video';\n    var data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type: type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return data;\n  };\n  _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    var inputSampleDuration = mp4SampleDuration * scaleFactor;\n    var initPTS = this._initPTS;\n    var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    var outputSamples = [];\n    var alignedWithVideo = videoTimeOffset !== undefined;\n    var inputSamples = track.samples;\n    var offset = rawMPEG ? 0 : 8;\n    var nextAudioPts = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    var timeOffsetMpegTS = timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initPTS, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(function (sample) {\n        return sample.pts >= 0;\n      });\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        var sample = inputSamples[i];\n        var pts = sample.pts;\n        var delta = pts - nextPts;\n        var duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          var missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n          for (var j = 0; j < missing; j++) {\n            var newStamp = Math.max(nextPts, 0);\n            var fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    var firstPTS = null;\n    var lastPTS = null;\n    var mdat;\n    var mdatSize = 0;\n    var sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n      var audioSample = inputSamples[_j2];\n      var unit = audioSample.unit;\n      var _pts2 = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        var prevSample = outputSamples[_j2 - 1];\n        prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          _pts2 = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = _pts2;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, {\n              type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MUX_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              bytes: mdatSize,\n              reason: \"fail allocating audio mdat \" + mdatSize\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            var view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      var unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = _pts2;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    var nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    var lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    var start = firstPTS / inputTimeScale;\n    var end = nextAudioPts / inputTimeScale;\n    var type = 'audio';\n    var audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type: type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return audioData;\n  };\n  _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var nextAudioPts = this.nextAudioPts;\n    // sync with video's timestamp\n    var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;\n    var endDTS = videoData.endDTS * inputTimeScale + this._initDTS;\n    // one sample's duration value\n    var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n    var samples = [];\n    for (var i = 0; i < nbSamples; i++) {\n      var stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  };\n  return MP4Remuxer;\n}();\n\nfunction normalizePts(value, reference) {\n  var offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (var i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  var length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  var inputTimeScale = track.inputTimeScale;\n  for (var index = 0; index < length; index++) {\n    var sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  var samples = track.samples;\n  track.samples = [];\n  return {\n    samples: samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  var length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  var inputTimeScale = track.inputTimeScale;\n  for (var index = 0; index < length; index++) {\n    var sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort(function (a, b) {\n    return a.pts - b.pts;\n  });\n  var samples = track.samples;\n  track.samples = [];\n  return {\n    samples: samples\n  };\n}\nvar Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n  this.size = void 0;\n  this.duration = void 0;\n  this.cts = void 0;\n  this.flags = void 0;\n  this.duration = duration;\n  this.size = size;\n  this.cts = cts;\n  this.flags = new Mp4SampleFlags(isKeyframe);\n};\nvar Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {\n  this.isLeading = 0;\n  this.isDependedOn = 0;\n  this.hasRedundancy = 0;\n  this.degradPrio = 0;\n  this.dependsOn = 1;\n  this.isNonSync = 1;\n  this.dependsOn = isKeyframe ? 2 : 1;\n  this.isNonSync = isKeyframe ? 0 : 1;\n};\n\n/***/ }),\n\n/***/ \"./src/remux/passthrough-remuxer.ts\":\n/*!******************************************!*\\\n  !*** ./src/remux/passthrough-remuxer.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_866081__) => {\n\n\"use strict\";\n__nested_webpack_require_866081__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_866081__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_866081__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_866081__(/*! ./mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_866081__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_866081__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_866081__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\nvar PassThroughRemuxer = /*#__PURE__*/function () {\n  function PassThroughRemuxer() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = void 0;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n  }\n  var _proto = PassThroughRemuxer.prototype;\n  _proto.destroy = function destroy() {};\n  _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndTime = null;\n  };\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    this.lastEndTime = null;\n  };\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment((0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.patchEncyptionData)(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  };\n  _proto.generateInitSegment = function generateInitSegment(initSegment) {\n    var audioCodec = this.audioCodec,\n      videoCodec = this.videoCodec;\n    if (!initSegment || !initSegment.byteLength) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    var initData = this.initData = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseInitSegment)(initSegment);\n\n    // Get codec from initSegment or fallback to default\n    if (!audioCodec) {\n      audioCodec = getParsedTrackCodec(initData.audio, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.AUDIO);\n    }\n    if (!videoCodec) {\n      videoCodec = getParsedTrackCodec(initData.video, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.VIDEO);\n    }\n    var tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment: initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  };\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {\n    var _this$initPTS;\n    var initPTS = this.initPTS,\n      lastEndTime = this.lastEndTime;\n    var result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    var data = videoTrack.samples;\n    if (!data || !data.length) {\n      return result;\n    }\n    var initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    var initData = this.initData;\n    if (!initData || !initData.length) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!initData || !initData.length) {\n      // We can't remux if the initSegment could not be generated\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    var startDTS = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.getStartDTS)(initData, data);\n    if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS)) {\n      this.initPTS = initSegment.initPTS = initPTS = startDTS - timeOffset;\n    }\n    var duration = (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.getDuration)(data, initData);\n    var startTime = audioTrack ? startDTS - initPTS : lastEndTime;\n    var endTime = startTime + duration;\n    (0,_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.offsetStartDTS)(initData, data, initPTS);\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    var hasAudio = !!initData.audio;\n    var hasVideo = !!initData.video;\n    var type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    var track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type: type,\n      hasAudio: hasAudio,\n      hasVideo: hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    var initPtsNum = (_this$initPTS = this.initPTS) != null ? _this$initPTS : 0;\n    result.id3 = (0,_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__.flushTextTrackMetadataCueSamples)(id3Track, timeOffset, initPtsNum, initPtsNum);\n    if (textTrack.samples.length) {\n      result.text = (0,_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__.flushTextTrackUserdataCueSamples)(textTrack, timeOffset, initPtsNum);\n    }\n    return result;\n  };\n  return PassThroughRemuxer;\n}();\nfunction getParsedTrackCodec(track, type) {\n  var parsedCodec = track === null || track === void 0 ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.c.L120.90';\n  }\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n  if (parsedCodec === 'avc1' || type === _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.VIDEO) {\n    return 'avc1.42e01e';\n  }\n  return 'mp4a.40.5';\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PassThroughRemuxer);\n\n/***/ }),\n\n/***/ \"./src/task-loop.ts\":\n/*!**************************!*\\\n  !*** ./src/task-loop.ts ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_874298__) => {\n\n\"use strict\";\n__nested_webpack_require_874298__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_874298__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TaskLoop)\n/* harmony export */ });\n/**\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nvar TaskLoop = /*#__PURE__*/function () {\n  function TaskLoop() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  var _proto = TaskLoop.prototype;\n  _proto.destroy = function destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  };\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  };\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {}\n\n  /**\n   * @returns {boolean}\n   */;\n  _proto.hasInterval = function hasInterval() {\n    return !!this._tickInterval;\n  }\n\n  /**\n   * @returns {boolean}\n   */;\n  _proto.hasNextTick = function hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param {number} millis Interval time (ms)\n   * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)\n   */;\n  _proto.setInterval = function setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} True when interval was cleared, false when none was set (no effect)\n   */;\n  _proto.clearInterval = function clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} True when timeout was cleared, false when none was set (no effect)\n   */;\n  _proto.clearNextTick = function clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */;\n  _proto.tick = function tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  };\n  _proto.tickImmediate = function tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */;\n  _proto.doTick = function doTick() {};\n  return TaskLoop;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/types/cmcd.ts\":\n/*!***************************!*\\\n  !*** ./src/types/cmcd.ts ***!\n  \\***************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_879086__) => {\n\n\"use strict\";\n__nested_webpack_require_879086__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_879086__.d(__nested_webpack_exports__, {\n/* harmony export */   \"CMCDObjectType\": () => (/* binding */ CMCDObjectType),\n/* harmony export */   \"CMCDStreamType\": () => (/* binding */ CMCDStreamType),\n/* harmony export */   \"CMCDStreamingFormat\": () => (/* binding */ CMCDStreamingFormat),\n/* harmony export */   \"CMCDVersion\": () => (/* binding */ CMCDVersion)\n/* harmony export */ });\n/**\n * CMCD spec version\n */\nvar CMCDVersion = 1;\n\n/**\n * CMCD Object Type\n */\nvar CMCDObjectType;\n\n/**\n * CMCD Streaming Format\n */\n(function (CMCDObjectType) {\n  CMCDObjectType[\"MANIFEST\"] = \"m\";\n  CMCDObjectType[\"AUDIO\"] = \"a\";\n  CMCDObjectType[\"VIDEO\"] = \"v\";\n  CMCDObjectType[\"MUXED\"] = \"av\";\n  CMCDObjectType[\"INIT\"] = \"i\";\n  CMCDObjectType[\"CAPTION\"] = \"c\";\n  CMCDObjectType[\"TIMED_TEXT\"] = \"tt\";\n  CMCDObjectType[\"KEY\"] = \"k\";\n  CMCDObjectType[\"OTHER\"] = \"o\";\n})(CMCDObjectType || (CMCDObjectType = {}));\nvar CMCDStreamingFormat;\n\n/**\n * CMCD Streaming Type\n */\n(function (CMCDStreamingFormat) {\n  CMCDStreamingFormat[\"DASH\"] = \"d\";\n  CMCDStreamingFormat[\"HLS\"] = \"h\";\n  CMCDStreamingFormat[\"SMOOTH\"] = \"s\";\n  CMCDStreamingFormat[\"OTHER\"] = \"o\";\n})(CMCDStreamingFormat || (CMCDStreamingFormat = {}));\nvar CMCDStreamType;\n\n/**\n * CMCD Headers\n */\n(function (CMCDStreamType) {\n  CMCDStreamType[\"VOD\"] = \"v\";\n  CMCDStreamType[\"LIVE\"] = \"l\";\n})(CMCDStreamType || (CMCDStreamType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/demuxer.ts\":\n/*!******************************!*\\\n  !*** ./src/types/demuxer.ts ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_880777__) => {\n\n\"use strict\";\n__nested_webpack_require_880777__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_880777__.d(__nested_webpack_exports__, {\n/* harmony export */   \"MetadataSchema\": () => (/* binding */ MetadataSchema)\n/* harmony export */ });\nvar MetadataSchema;\n(function (MetadataSchema) {\n  MetadataSchema[\"audioId3\"] = \"org.id3\";\n  MetadataSchema[\"dateRange\"] = \"com.apple.quicktime.HLS\";\n  MetadataSchema[\"emsg\"] = \"https://aomedia.org/emsg/ID3\";\n})(MetadataSchema || (MetadataSchema = {}));\n\n/***/ }),\n\n/***/ \"./src/types/level.ts\":\n/*!****************************!*\\\n  !*** ./src/types/level.ts ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_881482__) => {\n\n\"use strict\";\n__nested_webpack_require_881482__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_881482__.d(__nested_webpack_exports__, {\n/* harmony export */   \"HdcpLevels\": () => (/* binding */ HdcpLevels),\n/* harmony export */   \"HlsSkip\": () => (/* binding */ HlsSkip),\n/* harmony export */   \"HlsUrlParameters\": () => (/* binding */ HlsUrlParameters),\n/* harmony export */   \"Level\": () => (/* binding */ Level),\n/* harmony export */   \"getSkipValue\": () => (/* binding */ getSkipValue)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', 'TYPE-2', null];\nvar HlsSkip;\n(function (HlsSkip) {\n  HlsSkip[\"No\"] = \"\";\n  HlsSkip[\"Yes\"] = \"YES\";\n  HlsSkip[\"v2\"] = \"v2\";\n})(HlsSkip || (HlsSkip = {}));\nfunction getSkipValue(details, msn) {\n  var canSkipUntil = details.canSkipUntil,\n    canSkipDateRanges = details.canSkipDateRanges,\n    endSN = details.endSN;\n  var snChangeGoal = msn !== undefined ? msn - endSN : 0;\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nvar HlsUrlParameters = /*#__PURE__*/function () {\n  function HlsUrlParameters(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  var _proto = HlsUrlParameters.prototype;\n  _proto.addDirectives = function addDirectives(uri) {\n    var url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  };\n  return HlsUrlParameters;\n}();\nvar Level = /*#__PURE__*/function () {\n  function Level(data) {\n    this.attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.unknownCodecs = void 0;\n    this.audioGroupIds = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.textGroupIds = void 0;\n    this.url = void 0;\n    this._urlId = 0;\n    this.url = [data.url];\n    this.attrs = data.attrs;\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.unknownCodecs = data.unknownCodecs;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n      return c;\n    }).join(',').replace(/\\.[^.,]+/g, '');\n  }\n  _createClass(Level, [{\n    key: \"maxBitrate\",\n    get: function get() {\n      return Math.max(this.realBitrate, this.bitrate);\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.url[this._urlId] || '';\n    }\n  }, {\n    key: \"urlId\",\n    get: function get() {\n      return this._urlId;\n    },\n    set: function set(value) {\n      var newValue = value % this.url.length;\n      if (this._urlId !== newValue) {\n        this.details = undefined;\n        this._urlId = newValue;\n      }\n    }\n  }]);\n  return Level;\n}();\n\n/***/ }),\n\n/***/ \"./src/types/loader.ts\":\n/*!*****************************!*\\\n  !*** ./src/types/loader.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_886281__) => {\n\n\"use strict\";\n__nested_webpack_require_886281__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_886281__.d(__nested_webpack_exports__, {\n/* harmony export */   \"PlaylistContextType\": () => (/* binding */ PlaylistContextType),\n/* harmony export */   \"PlaylistLevelType\": () => (/* binding */ PlaylistLevelType)\n/* harmony export */ });\nvar PlaylistContextType;\n(function (PlaylistContextType) {\n  PlaylistContextType[\"MANIFEST\"] = \"manifest\";\n  PlaylistContextType[\"LEVEL\"] = \"level\";\n  PlaylistContextType[\"AUDIO_TRACK\"] = \"audioTrack\";\n  PlaylistContextType[\"SUBTITLE_TRACK\"] = \"subtitleTrack\";\n})(PlaylistContextType || (PlaylistContextType = {}));\nvar PlaylistLevelType;\n(function (PlaylistLevelType) {\n  PlaylistLevelType[\"MAIN\"] = \"main\";\n  PlaylistLevelType[\"AUDIO\"] = \"audio\";\n  PlaylistLevelType[\"SUBTITLE\"] = \"subtitle\";\n})(PlaylistLevelType || (PlaylistLevelType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/types/transmuxer.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_887393__) => {\n\n\"use strict\";\n__nested_webpack_require_887393__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_887393__.d(__nested_webpack_exports__, {\n/* harmony export */   \"ChunkMetadata\": () => (/* binding */ ChunkMetadata)\n/* harmony export */ });\nvar ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n  if (size === void 0) {\n    size = 0;\n  }\n  if (part === void 0) {\n    part = -1;\n  }\n  if (partial === void 0) {\n    partial = false;\n  }\n  this.level = void 0;\n  this.sn = void 0;\n  this.part = void 0;\n  this.id = void 0;\n  this.size = void 0;\n  this.partial = void 0;\n  this.transmuxing = getNewPerformanceTiming();\n  this.buffering = {\n    audio: getNewPerformanceTiming(),\n    video: getNewPerformanceTiming(),\n    audiovideo: getNewPerformanceTiming()\n  };\n  this.level = level;\n  this.sn = sn;\n  this.id = id;\n  this.size = size;\n  this.part = part;\n  this.partial = partial;\n};\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/utils/attr-list.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/attr-list.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_888646__) => {\n\n\"use strict\";\n__nested_webpack_require_888646__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_888646__.d(__nested_webpack_exports__, {\n/* harmony export */   \"AttrList\": () => (/* binding */ AttrList)\n/* harmony export */ });\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/; // eslint-disable-line no-useless-escape\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nvar AttrList = /*#__PURE__*/function () {\n  function AttrList(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    for (var attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n  var _proto = AttrList.prototype;\n  _proto.decimalInteger = function decimalInteger(attrName) {\n    var intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  };\n  _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      var stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      var value = new Uint8Array(stringValue.length / 2);\n      for (var i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    } else {\n      return null;\n    }\n  };\n  _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n    var intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  };\n  _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  };\n  _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n    var value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  };\n  _proto.enumeratedString = function enumeratedString(attrName) {\n    return this[attrName];\n  };\n  _proto.bool = function bool(attrName) {\n    return this[attrName] === 'YES';\n  };\n  _proto.decimalResolution = function decimalResolution(attrName) {\n    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  };\n  AttrList.parseAttrList = function parseAttrList(input) {\n    var match;\n    var attrs = {};\n    var quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      var value = match[2];\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n      attrs[match[1]] = value;\n    }\n    return attrs;\n  };\n  return AttrList;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/binary-search.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/binary-search.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_891838__) => {\n\n\"use strict\";\n__nested_webpack_require_891838__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_891838__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param {Array<T>} list The array to search.\n   * @param {BinarySearchComparison<T>} comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @return {T | null} The object if it is found or null otherwise.\n   */\n  search: function search(list, comparisonFn) {\n    var minIndex = 0;\n    var maxIndex = list.length - 1;\n    var currentIndex = null;\n    var currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      var comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BinarySearch);\n\n/***/ }),\n\n/***/ \"./src/utils/buffer-helper.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/buffer-helper.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_893712__) => {\n\n\"use strict\";\n__nested_webpack_require_893712__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_893712__.d(__nested_webpack_exports__, {\n/* harmony export */   \"BufferHelper\": () => (/* binding */ BufferHelper)\n/* harmony export */ });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_893712__(/*! ./logger */ \"./src/utils/logger.ts\");\n/**\n * @module BufferHelper\n *\n * Providing methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\n\nvar noopBuffered = {\n  length: 0,\n  start: function start() {\n    return 0;\n  },\n  end: function end() {\n    return 0;\n  }\n};\nvar BufferHelper = /*#__PURE__*/function () {\n  function BufferHelper() {}\n  /**\n   * Return true if `media`'s buffered include `position`\n   * @param {Bufferable} media\n   * @param {number} position\n   * @returns {boolean}\n   */\n  BufferHelper.isBuffered = function isBuffered(media, position) {\n    try {\n      if (media) {\n        var buffered = BufferHelper.getBuffered(media);\n        for (var i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return false;\n  };\n  BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        var vbuffered = BufferHelper.getBuffered(media);\n        var buffered = [];\n        var i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  };\n  BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    buffered.sort(function (a, b) {\n      var diff = a.start - b.start;\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    var buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (var i = 0; i < buffered.length; i++) {\n        var buf2len = buffered2.length;\n        if (buf2len) {\n          var buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    var bufferLen = 0;\n\n    // bufferStartNext can possibly be undefined based on the conditional logic below\n    var bufferStartNext;\n\n    // bufferStart and bufferEnd are buffer boundaries around current video position\n    var bufferStart = pos;\n    var bufferEnd = pos;\n    for (var _i = 0; _i < buffered2.length; _i++) {\n      var start = buffered2[_i].start;\n      var end = buffered2[_i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */;\n  BufferHelper.getBuffered = function getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__.logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  };\n  return BufferHelper;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/cea-608-parser.ts\":\n/*!*************************************!*\\\n  !*** ./src/utils/cea-608-parser.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_899357__) => {\n\n\"use strict\";\n__nested_webpack_require_899357__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_899357__.d(__nested_webpack_exports__, {\n/* harmony export */   \"CaptionScreen\": () => (/* binding */ CaptionScreen),\n/* harmony export */   \"Row\": () => (/* binding */ Row),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_899357__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nvar specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nvar getCharForByte = function getCharForByte(_byte) {\n  var charCode = _byte;\n  if (specialCea608CharsCodes.hasOwnProperty(_byte)) {\n    charCode = specialCea608CharsCodes[_byte];\n  }\n  return String.fromCharCode(charCode);\n};\nvar NR_ROWS = 15;\nvar NR_COLS = 100;\n// Tables to look up row from PAC data\nvar rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nvar rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nvar rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nvar rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nvar backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nvar VerboseLevel;\n(function (VerboseLevel) {\n  VerboseLevel[VerboseLevel[\"ERROR\"] = 0] = \"ERROR\";\n  VerboseLevel[VerboseLevel[\"TEXT\"] = 1] = \"TEXT\";\n  VerboseLevel[VerboseLevel[\"WARNING\"] = 2] = \"WARNING\";\n  VerboseLevel[VerboseLevel[\"INFO\"] = 2] = \"INFO\";\n  VerboseLevel[VerboseLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n  VerboseLevel[VerboseLevel[\"DATA\"] = 3] = \"DATA\";\n})(VerboseLevel || (VerboseLevel = {}));\nvar CaptionsLogger = /*#__PURE__*/function () {\n  function CaptionsLogger() {\n    this.time = null;\n    this.verboseLevel = VerboseLevel.ERROR;\n  }\n  var _proto = CaptionsLogger.prototype;\n  _proto.log = function log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      var m = typeof msg === 'function' ? msg() : msg;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log(this.time + \" [\" + severity + \"] \" + m);\n    }\n  };\n  return CaptionsLogger;\n}();\nvar numArrayToHexArray = function numArrayToHexArray(numArray) {\n  var hexArray = [];\n  for (var j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nvar PenState = /*#__PURE__*/function () {\n  function PenState(foreground, underline, italics, background, flash) {\n    this.foreground = void 0;\n    this.underline = void 0;\n    this.italics = void 0;\n    this.background = void 0;\n    this.flash = void 0;\n    this.foreground = foreground || 'white';\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || 'black';\n    this.flash = flash || false;\n  }\n  var _proto2 = PenState.prototype;\n  _proto2.reset = function reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  };\n  _proto2.setStyles = function setStyles(styles) {\n    var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (var i = 0; i < attribs.length; i++) {\n      var style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  };\n  _proto2.isDefault = function isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  };\n  _proto2.equals = function equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  };\n  _proto2.copy = function copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  };\n  _proto2.toString = function toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  };\n  return PenState;\n}();\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nvar StyledUnicodeChar = /*#__PURE__*/function () {\n  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = void 0;\n    this.penState = void 0;\n    this.uchar = uchar || ' '; // unicode character\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  }\n  var _proto3 = StyledUnicodeChar.prototype;\n  _proto3.reset = function reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  };\n  _proto3.setChar = function setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  };\n  _proto3.setPenState = function setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  };\n  _proto3.equals = function equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  };\n  _proto3.copy = function copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  };\n  _proto3.isEmpty = function isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  };\n  return StyledUnicodeChar;\n}();\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nvar Row = /*#__PURE__*/function () {\n  function Row(logger) {\n    this.chars = void 0;\n    this.pos = void 0;\n    this.currPenState = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chars = [];\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n    this.pos = 0;\n    this.currPenState = new PenState();\n  }\n  var _proto4 = Row.prototype;\n  _proto4.equals = function equals(other) {\n    var equal = true;\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  };\n  _proto4.copy = function copy(other) {\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  };\n  _proto4.isEmpty = function isEmpty() {\n    var empty = true;\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */;\n  _proto4.setCursor = function setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(VerboseLevel.DEBUG, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(VerboseLevel.DEBUG, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */;\n  _proto4.moveCursor = function moveCursor(relPos) {\n    var newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (var i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */;\n  _proto4.backSpace = function backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  };\n  _proto4.insertChar = function insertChar(_byte2) {\n    var _this = this;\n    if (_byte2 >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    var _char = getCharForByte(_byte2);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(VerboseLevel.ERROR, function () {\n        return 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + _this.pos + '. Skipping it!';\n      });\n      return;\n    }\n    this.chars[this.pos].setChar(_char, this.currPenState);\n    this.moveCursor(1);\n  };\n  _proto4.clearFromPos = function clearFromPos(startPos) {\n    var i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  };\n  _proto4.clear = function clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  };\n  _proto4.clearToEndOfRow = function clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  };\n  _proto4.getTextString = function getTextString() {\n    var chars = [];\n    var empty = true;\n    for (var i = 0; i < NR_COLS; i++) {\n      var _char2 = this.chars[i].uchar;\n      if (_char2 !== ' ') {\n        empty = false;\n      }\n      chars.push(_char2);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  };\n  _proto4.setPenStyles = function setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    var currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  };\n  return Row;\n}();\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nvar CaptionScreen = /*#__PURE__*/function () {\n  function CaptionScreen(logger) {\n    this.rows = void 0;\n    this.currRow = void 0;\n    this.nrRollUpRows = void 0;\n    this.lastOutputScreen = void 0;\n    this.logger = void 0;\n    this.rows = [];\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    } // Note that we use zero-based numbering (0-14)\n\n    this.logger = logger;\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.reset();\n  }\n  var _proto5 = CaptionScreen.prototype;\n  _proto5.reset = function reset() {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  };\n  _proto5.equals = function equals(other) {\n    var equal = true;\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  };\n  _proto5.copy = function copy(other) {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  };\n  _proto5.isEmpty = function isEmpty() {\n    var empty = true;\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  };\n  _proto5.backSpace = function backSpace() {\n    var row = this.rows[this.currRow];\n    row.backSpace();\n  };\n  _proto5.clearToEndOfRow = function clearToEndOfRow() {\n    var row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */;\n  _proto5.insertChar = function insertChar(_char3) {\n    var row = this.rows[this.currRow];\n    row.insertChar(_char3);\n  };\n  _proto5.setPen = function setPen(styles) {\n    var row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  };\n  _proto5.moveCursor = function moveCursor(relPos) {\n    var row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  };\n  _proto5.setCursor = function setCursor(absPos) {\n    this.logger.log(VerboseLevel.INFO, 'setCursor: ' + absPos);\n    var row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  };\n  _proto5.setPAC = function setPAC(pacData) {\n    this.logger.log(VerboseLevel.INFO, function () {\n      return 'pacData = ' + JSON.stringify(pacData);\n    });\n    var newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      var lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        var time = this.logger.time;\n        if (prevLineTime && time !== null && prevLineTime < time) {\n          for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    var row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      var indent = pacData.indent;\n      var prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    var styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */;\n  _proto5.setBkgData = function setBkgData(bkgData) {\n    this.logger.log(VerboseLevel.INFO, function () {\n      return 'bkgData = ' + JSON.stringify(bkgData);\n    });\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  };\n  _proto5.setRollUpRows = function setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  };\n  _proto5.rollUp = function rollUp() {\n    var _this2 = this;\n    if (this.nrRollUpRows === null) {\n      this.logger.log(VerboseLevel.DEBUG, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n\n    this.logger.log(VerboseLevel.TEXT, function () {\n      return _this2.getDisplayText();\n    });\n    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    var topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(VerboseLevel.INFO, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */;\n  _proto5.getDisplayText = function getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    var displayText = [];\n    var text = '';\n    var rowNr = -1;\n    for (var i = 0; i < NR_ROWS; i++) {\n      var rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  };\n  _proto5.getTextAndFormat = function getTextAndFormat() {\n    return this.rows;\n  };\n  return CaptionScreen;\n}();\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\nvar Cea608Channel = /*#__PURE__*/function () {\n  function Cea608Channel(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  var _proto6 = Cea608Channel.prototype;\n  _proto6.reset = function reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  };\n  _proto6.getHandler = function getHandler() {\n    return this.outputFilter;\n  };\n  _proto6.setHandler = function setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  };\n  _proto6.setPAC = function setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  };\n  _proto6.setBkgData = function setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  };\n  _proto6.setMode = function setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(VerboseLevel.INFO, function () {\n      return 'MODE=' + newMode;\n    });\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  };\n  _proto6.insertChars = function insertChars(chars) {\n    var _this3 = this;\n    for (var i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(VerboseLevel.INFO, function () {\n      return screen + ': ' + _this3.writeScreen.getDisplayText(true);\n    });\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(VerboseLevel.TEXT, function () {\n        return 'DISPLAYED: ' + _this3.displayedMemory.getDisplayText(true);\n      });\n      this.outputDataUpdate();\n    }\n  };\n  _proto6.ccRCL = function ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(VerboseLevel.INFO, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  };\n  _proto6.ccBS = function ccBS() {\n    // BackSpace\n    this.logger.log(VerboseLevel.INFO, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  };\n  _proto6.ccAOF = function ccAOF() {\n    // Reserved (formerly Alarm Off)\n  };\n  _proto6.ccAON = function ccAON() {\n    // Reserved (formerly Alarm On)\n  };\n  _proto6.ccDER = function ccDER() {\n    // Delete to End of Row\n    this.logger.log(VerboseLevel.INFO, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  };\n  _proto6.ccRU = function ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(VerboseLevel.INFO, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  };\n  _proto6.ccFON = function ccFON() {\n    // Flash On\n    this.logger.log(VerboseLevel.INFO, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  };\n  _proto6.ccRDC = function ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(VerboseLevel.INFO, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  };\n  _proto6.ccTR = function ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'TR');\n    this.setMode('MODE_TEXT');\n  };\n  _proto6.ccRTD = function ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'RTD');\n    this.setMode('MODE_TEXT');\n  };\n  _proto6.ccEDM = function ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  };\n  _proto6.ccCR = function ccCR() {\n    // Carriage Return\n    this.logger.log(VerboseLevel.INFO, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  };\n  _proto6.ccENM = function ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  };\n  _proto6.ccEOC = function ccEOC() {\n    var _this4 = this;\n    // End of Caption (Flip Memories)\n    this.logger.log(VerboseLevel.INFO, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      var tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(VerboseLevel.TEXT, function () {\n        return 'DISP: ' + _this4.displayedMemory.getDisplayText();\n      });\n    }\n    this.outputDataUpdate(true);\n  };\n  _proto6.ccTO = function ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(VerboseLevel.INFO, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  };\n  _proto6.ccMIDROW = function ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    var styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      var colorIndex = Math.floor(secondByte / 2) - 0x10;\n      var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(VerboseLevel.INFO, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  };\n  _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {\n    if (dispatch === void 0) {\n      dispatch = false;\n    }\n    var time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  };\n  _proto6.cueSplitAtTime = function cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  };\n  return Cea608Channel;\n}();\nvar Cea608Parser = /*#__PURE__*/function () {\n  function Cea608Parser(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = void 0;\n    this.logger = void 0;\n    var logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    this.cmdHistory = createCmdHistory();\n    this.logger = logger;\n  }\n  var _proto7 = Cea608Parser.prototype;\n  _proto7.getHandler = function getHandler(channel) {\n    return this.channels[channel].getHandler();\n  };\n  _proto7.setHandler = function setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */;\n  _proto7.addData = function addData(time, byteList) {\n    var cmdFound;\n    var a;\n    var b;\n    var charsFound = false;\n    this.logger.time = time;\n    for (var i = 0; i < byteList.length; i += 2) {\n      a = byteList[i] & 0x7f;\n      b = byteList[i + 1] & 0x7f;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(VerboseLevel.DATA, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      cmdFound = this.parseCmd(a, b);\n      if (!cmdFound) {\n        cmdFound = this.parseMidrow(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parsePAC(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parseBackgroundAttributes(a, b);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          var currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            var channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(VerboseLevel.WARNING, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(VerboseLevel.WARNING, \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns {Boolean} Tells if a command was found\n   */;\n  _proto7.parseCmd = function parseCmd(a, b) {\n    var cmdHistory = this.cmdHistory;\n    var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      this.logger.log(VerboseLevel.DEBUG, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n      return true;\n    }\n    var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   * @returns {Boolean}\n   */;\n  _proto7.parseMidrow = function parseMidrow(a, b) {\n    var chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(VerboseLevel.ERROR, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      var channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(VerboseLevel.DEBUG, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */;\n  _proto7.parsePAC = function parsePAC(a, b) {\n    var row;\n    var cmdHistory = this.cmdHistory;\n    var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      return true; // Repeated commands are dropped (once)\n    }\n\n    var chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    var channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns {Object} pacData with style parameters.\n   */;\n  _proto7.interpretPAC = function interpretPAC(row, _byte3) {\n    var pacIndex;\n    var pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (_byte3 > 0x5f) {\n      pacIndex = _byte3 - 0x60;\n    } else {\n      pacIndex = _byte3 - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */;\n  _proto7.parseChars = function parseChars(a, b) {\n    var channelNr;\n    var charCodes = null;\n    var charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      var oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(VerboseLevel.INFO, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      var hexCodes = numArrayToHexArray(charCodes);\n      this.logger.log(VerboseLevel.DEBUG, 'Char codes =  ' + hexCodes.join(','));\n      setLastCmd(a, b, this.cmdHistory);\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns {Boolean} Tells if background attributes are found\n   */;\n  _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {\n    var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    var index;\n    var bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    var chNr = a <= 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    setLastCmd(a, b, this.cmdHistory);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */;\n  _proto7.reset = function reset() {\n    for (var i = 0; i < Object.keys(this.channels).length; i++) {\n      var channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    this.cmdHistory = createCmdHistory();\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */;\n  _proto7.cueSplitAtTime = function cueSplitAtTime(t) {\n    for (var i = 0; i < this.channels.length; i++) {\n      var channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  };\n  return Cea608Parser;\n}();\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cea608Parser);\n\n/***/ }),\n\n/***/ \"./src/utils/codecs.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/codecs.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_939094__) => {\n\n\"use strict\";\n__nested_webpack_require_939094__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_939094__.d(__nested_webpack_exports__, {\n/* harmony export */   \"isCodecSupportedInMp4\": () => (/* binding */ isCodecSupportedInMp4),\n/* harmony export */   \"isCodecType\": () => (/* binding */ isCodecType)\n/* harmony export */ });\n// from http://mp4ra.org/codecs.html\nvar sampleEntryCodesISO = {\n  audio: {\n    a3ds: true,\n    'ac-3': true,\n    'ac-4': true,\n    alac: true,\n    alaw: true,\n    dra1: true,\n    'dts+': true,\n    'dts-': true,\n    dtsc: true,\n    dtse: true,\n    dtsh: true,\n    'ec-3': true,\n    enca: true,\n    g719: true,\n    g726: true,\n    m4ae: true,\n    mha1: true,\n    mha2: true,\n    mhm1: true,\n    mhm2: true,\n    mlpa: true,\n    mp4a: true,\n    'raw ': true,\n    Opus: true,\n    opus: true,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: true,\n    sawb: true,\n    sawp: true,\n    sevc: true,\n    sqcp: true,\n    ssmv: true,\n    twos: true,\n    ulaw: true\n  },\n  video: {\n    avc1: true,\n    avc2: true,\n    avc3: true,\n    avc4: true,\n    avcp: true,\n    av01: true,\n    drac: true,\n    dva1: true,\n    dvav: true,\n    dvh1: true,\n    dvhe: true,\n    encv: true,\n    hev1: true,\n    hvc1: true,\n    mjp2: true,\n    mp4v: true,\n    mvc1: true,\n    mvc2: true,\n    mvc3: true,\n    mvc4: true,\n    resv: true,\n    rv60: true,\n    s263: true,\n    svc1: true,\n    svc2: true,\n    'vc-1': true,\n    vp08: true,\n    vp09: true\n  },\n  text: {\n    stpp: true,\n    wvtt: true\n  }\n};\nfunction isCodecType(codec, type) {\n  var typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\nfunction isCodecSupportedInMp4(codec, type) {\n  return MediaSource.isTypeSupported((type || 'video') + \"/mp4;codecs=\\\"\" + codec + \"\\\"\");\n}\n\n/***/ }),\n\n/***/ \"./src/utils/cues.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/cues.ts ***!\n  \\***************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_941116__) => {\n\n\"use strict\";\n__nested_webpack_require_941116__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_941116__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_941116__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_941116__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_941116__(/*! ./texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n\n\n\nvar WHITESPACE_CHAR = /\\s/;\nvar Cues = {\n  newCue: function newCue(track, startTime, endTime, captionScreen) {\n    var result = [];\n    var row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    var cue;\n    var indenting;\n    var indent;\n    var text;\n    var Cue = self.VTTCue || self.TextTrackCue;\n    for (var r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        for (var c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        var cueText = (0,_vttparser__WEBPACK_IMPORTED_MODULE_0__.fixLineBreaks)(text.trim());\n        var id = (0,_webvtt_parser__WEBPACK_IMPORTED_MODULE_1__.generateCueId)(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!track || !track.cues || !track.cues.getCueById(id)) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort(function (cueA, cueB) {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(function (cue) {\n        return (0,_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.addCueToTrack)(track, cue);\n      });\n    }\n    return result;\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cues);\n\n/***/ }),\n\n/***/ \"./src/utils/discontinuities.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/discontinuities.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_944752__) => {\n\n\"use strict\";\n__nested_webpack_require_944752__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_944752__.d(__nested_webpack_exports__, {\n/* harmony export */   \"adjustSlidingStart\": () => (/* binding */ adjustSlidingStart),\n/* harmony export */   \"alignMediaPlaylistByPDT\": () => (/* binding */ alignMediaPlaylistByPDT),\n/* harmony export */   \"alignPDT\": () => (/* binding */ alignPDT),\n/* harmony export */   \"alignStream\": () => (/* binding */ alignStream),\n/* harmony export */   \"findDiscontinuousReferenceFrag\": () => (/* binding */ findDiscontinuousReferenceFrag),\n/* harmony export */   \"findFirstFragWithCC\": () => (/* binding */ findFirstFragWithCC),\n/* harmony export */   \"shouldAlignOnDiscontinuities\": () => (/* binding */ shouldAlignOnDiscontinuities)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_944752__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_944752__(/*! ./logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_944752__(/*! ../controller/level-helper */ \"./src/controller/level-helper.ts\");\n\n\n\n\nfunction findFirstFragWithCC(fragments, cc) {\n  var firstFrag = null;\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    var currentFrag = fragments[i];\n    if (currentFrag && currentFrag.cc === cc) {\n      firstFrag = currentFrag;\n      break;\n    }\n  }\n  return firstFrag;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n  if (lastLevel.details) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex) {\n  if (referenceIndex === void 0) {\n    referenceIndex = 0;\n  }\n  var prevFrags = prevDetails.fragments;\n  var curFrags = curDetails.fragments;\n  if (!curFrags.length || !prevFrags.length) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log('No fragments to align');\n    return;\n  }\n  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log('No frag in previous level to align on');\n    return;\n  }\n  return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    var start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  var fragments = details.fragments;\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\nfunction alignStream(lastFrag, lastLevel, details) {\n  if (!lastLevel) {\n    return;\n  }\n  alignDiscontinuities(lastFrag, details, lastLevel);\n  if (!details.alignedSliding && lastLevel.details) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignPDT(details, lastLevel.details);\n  }\n  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    (0,_controller_level_helper__WEBPACK_IMPORTED_MODULE_2__.adjustSliding)(lastLevel.details, details);\n  }\n}\n\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(lastFrag, details, lastLevel) {\n  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n    if (referenceFrag && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(referenceFrag.start)) {\n      _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n\n/**\n * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n * @param details - The details of the new level\n * @param lastDetails - The details of the last loaded level\n */\nfunction alignPDT(details, lastDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n    return;\n  }\n  // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n  // then we can deduce that playlist B sliding is 1000+8 = 1008s\n  var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n  var newPDT = details.fragments[0].programDateTime;\n  // date diff is in ms. frag.start is in seconds\n  var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n  if (sliding && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(sliding)) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"Adjusting PTS using programDateTime delta \" + (newPDT - lastPDT) + \"ms, sliding:\" + sliding.toFixed(3) + \" \" + details.url + \" \");\n    adjustSlidingStart(sliding, details);\n  }\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT. Unlike `alignPDT`, which adjusts\n * the timeline based on the delta between PDTs of the 0th fragment of two playlists/`LevelDetails`,\n * this function assumes the timelines represented in `refDetails` are accurate, including the PDTs,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  var fragments = details.fragments;\n  var refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  var middleFrag = Math.round(refFragments.length / 2) - 1;\n  var refFrag = refFragments[middleFrag];\n  var frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];\n  var refPDT = refFrag.programDateTime;\n  var targetPDT = frag.programDateTime;\n  if (refPDT === null || targetPDT === null) {\n    return;\n  }\n  var delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\n/***/ }),\n\n/***/ \"./src/utils/ewma-bandwidth-estimator.ts\":\n/*!***********************************************!*\\\n  !*** ./src/utils/ewma-bandwidth-estimator.ts ***!\n  \\***********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_953959__) => {\n\n\"use strict\";\n__nested_webpack_require_953959__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_953959__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_953959__(/*! ../utils/ewma */ \"./src/utils/ewma.ts\");\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\n\nvar EwmaBandWidthEstimator = /*#__PURE__*/function () {\n  function EwmaBandWidthEstimator(slow, fast, defaultEstimate) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow);\n    this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast);\n  }\n  var _proto = EwmaBandWidthEstimator.prototype;\n  _proto.update = function update(slow, fast) {\n    var slow_ = this.slow_,\n      fast_ = this.fast_;\n    if (this.slow_.halfLife !== slow) {\n      this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (this.fast_.halfLife !== fast) {\n      this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n  };\n  _proto.sample = function sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    var numBits = 8 * numBytes;\n    // weight is duration in seconds\n    var durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    var bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  };\n  _proto.canEstimate = function canEstimate() {\n    var fast = this.fast_;\n    return fast && fast.getTotalWeight() >= this.minWeight_;\n  };\n  _proto.getEstimate = function getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  };\n  _proto.destroy = function destroy() {};\n  return EwmaBandWidthEstimator;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EwmaBandWidthEstimator);\n\n/***/ }),\n\n/***/ \"./src/utils/ewma.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/ewma.ts ***!\n  \\***************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_957030__) => {\n\n\"use strict\";\n__nested_webpack_require_957030__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_957030__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\nvar EWMA = /*#__PURE__*/function () {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  function EWMA(halfLife, estimate, weight) {\n    if (estimate === void 0) {\n      estimate = 0;\n    }\n    if (weight === void 0) {\n      weight = 0;\n    }\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  var _proto = EWMA.prototype;\n  _proto.sample = function sample(weight, value) {\n    var adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  };\n  _proto.getTotalWeight = function getTotalWeight() {\n    return this.totalWeight_;\n  };\n  _proto.getEstimate = function getEstimate() {\n    if (this.alpha_) {\n      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  };\n  return EWMA;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EWMA);\n\n/***/ }),\n\n/***/ \"./src/utils/fetch-loader.ts\":\n/*!***********************************!*\\\n  !*** ./src/utils/fetch-loader.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_958986__) => {\n\n\"use strict\";\n__nested_webpack_require_958986__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_958986__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"fetchSupported\": () => (/* binding */ fetchSupported)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_958986__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_958986__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_958986__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nvar FetchLoader = /*#__PURE__*/function () {\n  function FetchLoader(config /* HlsConfig */) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = void 0;\n    this.response = void 0;\n    this.controller = void 0;\n    this.context = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__.LoadStats();\n  }\n  var _proto = FetchLoader.prototype;\n  _proto.destroy = function destroy() {\n    this.loader = this.callbacks = null;\n    this.abortInternal();\n  };\n  _proto.abortInternal = function abortInternal() {\n    var response = this.response;\n    if (!response || !response.ok) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  };\n  _proto.abort = function abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  };\n  _proto.load = function load(context, config, callbacks) {\n    var _this = this;\n    var stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    var initParams = getRequestParameters(context, this.controller.signal);\n    var onProgress = callbacks.onProgress;\n    var isArrayBuffer = context.responseType === 'arraybuffer';\n    var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(function () {\n      _this.abortInternal();\n      callbacks.onTimeout(stats, context, _this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(function (response) {\n      _this.response = _this.loader = response;\n      if (!response.ok) {\n        var status = response.status,\n          statusText = response.statusText;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      stats.total = parseInt(response.headers.get('Content-Length') || '0');\n      if (onProgress && (0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(config.highWaterMark)) {\n        return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      return response.text();\n    }).then(function (responseData) {\n      var response = _this.response;\n      self.clearTimeout(_this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      var total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      var loaderResponse = {\n        url: response.url,\n        data: responseData\n      };\n      if (onProgress && !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(function (error) {\n      self.clearTimeout(_this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      var code = !error ? 0 : error.code || 0;\n      var text = !error ? null : error.message;\n      callbacks.onError({\n        code: code,\n        text: text\n      }, context, error ? error.details : null);\n    });\n  };\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n    if (this.response) {\n      var ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  };\n  _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n    if (highWaterMark === void 0) {\n      highWaterMark = 0;\n    }\n    var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    var reader = response.body.getReader();\n    var pump = function pump() {\n      return reader.read().then(function (data) {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        var chunk = data.value;\n        var len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n        return pump();\n      }).catch(function () {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  };\n  return FetchLoader;\n}();\nfunction getRequestParameters(context, signal) {\n  var initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal: signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nvar FetchError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(FetchError, _Error);\n  function FetchError(message, code, details) {\n    var _this2;\n    _this2 = _Error.call(this, message) || this;\n    _this2.code = void 0;\n    _this2.details = void 0;\n    _this2.code = code;\n    _this2.details = details;\n    return _this2;\n  }\n  return FetchError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FetchLoader);\n\n/***/ }),\n\n/***/ \"./src/utils/hex.ts\":\n/*!**************************!*\\\n  !*** ./src/utils/hex.ts ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_969602__) => {\n\n\"use strict\";\n__nested_webpack_require_969602__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_969602__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n *  hex dump helper class\n */\n\nvar Hex = {\n  hexDump: function hexDump(array) {\n    var str = '';\n    for (var i = 0; i < array.length; i++) {\n      var h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hex);\n\n/***/ }),\n\n/***/ \"./src/utils/imsc1-ttml-parser.ts\":\n/*!****************************************!*\\\n  !*** ./src/utils/imsc1-ttml-parser.ts ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_970447__) => {\n\n\"use strict\";\n__nested_webpack_require_970447__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_970447__.d(__nested_webpack_exports__, {\n/* harmony export */   \"IMSC1_CODEC\": () => (/* binding */ IMSC1_CODEC),\n/* harmony export */   \"parseIMSC1\": () => (/* binding */ parseIMSC1)\n/* harmony export */ });\n/* harmony import */ var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_970447__(/*! ./mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_970447__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_970447__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_970447__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_970447__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_970447__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\nvar IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nvar HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nvar TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nvar textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {\n  var results = (0,_mp4_tools__WEBPACK_IMPORTED_MODULE_0__.findBox)(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  var ttmlList = results.map(function (mdat) {\n    return (0,_demux_id3__WEBPACK_IMPORTED_MODULE_3__.utf8ArrayToStr)(mdat);\n  });\n  var syncTime = (0,_timescale_conversion__WEBPACK_IMPORTED_MODULE_4__.toTimescaleFromScale)(initPTS, 1, timescale);\n  try {\n    ttmlList.forEach(function (ttml) {\n      return callBack(parseTTML(ttml, syncTime));\n    });\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  var parser = new DOMParser();\n  var xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  var tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  var defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {\n    result[key] = tt.getAttribute(\"ttp:\" + key) || defaultRateInfo[key];\n    return result;\n  }, {});\n  var trim = tt.getAttribute('xml:space') !== 'preserve';\n  var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  var cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, function (cueElement) {\n    var cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__[\"default\"](startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = (0,_webvtt_parser__WEBPACK_IMPORTED_MODULE_5__.generateCueId)(cue.startTime, cue.endTime, cue.text);\n    var region = regionElements[cueElement.getAttribute('region')];\n    var style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    var styles = getTtmlStyles(region, style, styleElements);\n    var textAlign = styles.textAlign;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      var lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(function (cue) {\n    return cue !== null;\n  });\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  var parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce(function (dict, element) {\n    var id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce(function (str, node, i) {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  var ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  var regionStyle = null;\n  var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n\n  var regionStyleName = region !== null && region !== void 0 && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce(function (styles, name) {\n    var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(\"Could not parse ttml timestamp \" + node);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  var seconds = (0,_vttparser__WEBPACK_IMPORTED_MODULE_1__.parseTimeStamp)(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  var m = HMSF_REGEX.exec(timeAttributeValue);\n  var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  var m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  var value = Number(m[1]);\n  var unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/keysystem-util.ts\":\n/*!*************************************!*\\\n  !*** ./src/utils/keysystem-util.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_978920__) => {\n\n\"use strict\";\n__nested_webpack_require_978920__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_978920__.d(__nested_webpack_exports__, {\n/* harmony export */   \"changeEndianness\": () => (/* binding */ changeEndianness),\n/* harmony export */   \"convertDataUriToArrayBytes\": () => (/* binding */ convertDataUriToArrayBytes),\n/* harmony export */   \"strToUtf8array\": () => (/* binding */ strToUtf8array)\n/* harmony export */ });\n/* harmony import */ var _numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_978920__(/*! ./numeric-encoding-utils */ \"./src/utils/numeric-encoding-utils.ts\");\n\nfunction getKeyIdBytes(str) {\n  var keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  var paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  var swap = function swap(array, from, to) {\n    var cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  var colonsplit = uri.split(':');\n  var keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    var semicolonsplit = colonsplit[1].split(';');\n    var commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      var isbase64 = commasplit[0] === 'base64';\n      var data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = (0,_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), function (c) {\n    return c.charCodeAt(0);\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/utils/logger.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/logger.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_981081__) => {\n\n\"use strict\";\n__nested_webpack_require_981081__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_981081__.d(__nested_webpack_exports__, {\n/* harmony export */   \"enableLogs\": () => (/* binding */ enableLogs),\n/* harmony export */   \"logger\": () => (/* binding */ logger)\n/* harmony export */ });\nvar noop = function noop() {};\nvar fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nvar exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  var func = self.console[type];\n  if (func) {\n    return func.bind(self.console, \"[\" + type + \"] >\");\n  }\n  return noop;\n}\nfunction exportLoggerFunctions(debugConfig) {\n  for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    functions[_key - 1] = arguments[_key];\n  }\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\nfunction enableLogs(debugConfig, id) {\n  // check that console is available\n  if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(\"Debug logs enabled for \\\"\" + id + \"\\\"\");\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nvar logger = exportedLogger;\n\n/***/ }),\n\n/***/ \"./src/utils/mediakeys-helper.ts\":\n/*!***************************************!*\\\n  !*** ./src/utils/mediakeys-helper.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_983274__) => {\n\n\"use strict\";\n__nested_webpack_require_983274__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_983274__.d(__nested_webpack_exports__, {\n/* harmony export */   \"KeySystemFormats\": () => (/* binding */ KeySystemFormats),\n/* harmony export */   \"KeySystemIds\": () => (/* binding */ KeySystemIds),\n/* harmony export */   \"KeySystems\": () => (/* binding */ KeySystems),\n/* harmony export */   \"getKeySystemsForConfig\": () => (/* binding */ getKeySystemsForConfig),\n/* harmony export */   \"getSupportedMediaKeySystemConfigurations\": () => (/* binding */ getSupportedMediaKeySystemConfigurations),\n/* harmony export */   \"keySystemDomainToKeySystemFormat\": () => (/* binding */ keySystemDomainToKeySystemFormat),\n/* harmony export */   \"keySystemFormatToKeySystemDomain\": () => (/* binding */ keySystemFormatToKeySystemDomain),\n/* harmony export */   \"keySystemIdToKeySystemDomain\": () => (/* binding */ keySystemIdToKeySystemDomain),\n/* harmony export */   \"requestMediaKeySystemAccess\": () => (/* binding */ requestMediaKeySystemAccess)\n/* harmony export */ });\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems;\n\n// Playlist #EXT-X-KEY KEYFORMAT values\n(function (KeySystems) {\n  KeySystems[\"CLEARKEY\"] = \"org.w3.clearkey\";\n  KeySystems[\"FAIRPLAY\"] = \"com.apple.fps\";\n  KeySystems[\"PLAYREADY\"] = \"com.microsoft.playready\";\n  KeySystems[\"WIDEVINE\"] = \"com.widevine.alpha\";\n})(KeySystems || (KeySystems = {}));\nvar KeySystemFormats;\n(function (KeySystemFormats) {\n  KeySystemFormats[\"CLEARKEY\"] = \"org.w3.clearkey\";\n  KeySystemFormats[\"FAIRPLAY\"] = \"com.apple.streamingkeydelivery\";\n  KeySystemFormats[\"PLAYREADY\"] = \"com.microsoft.playready\";\n  KeySystemFormats[\"WIDEVINE\"] = \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\";\n})(KeySystemFormats || (KeySystemFormats = {}));\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\n\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds;\n(function (KeySystemIds) {\n  KeySystemIds[\"WIDEVINE\"] = \"edef8ba979d64acea3c827dcd51d21ed\";\n})(KeySystemIds || (KeySystemIds = {}));\nfunction keySystemIdToKeySystemDomain(systemId) {\n  if (systemId === KeySystemIds.WIDEVINE) {\n    return KeySystems.WIDEVINE;\n    // } else if (systemId === KeySystemIds.PLAYREADY) {\n    //   return KeySystems.PLAYREADY;\n    // } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    //   return KeySystems.CLEARKEY;\n  }\n}\n\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  var drmSystems = config.drmSystems,\n    widevineLicenseUrl = config.widevineLicenseUrl;\n  var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function (keySystem) {\n    return !!drmSystems[keySystem];\n  }) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nvar requestMediaKeySystemAccess = function () {\n  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  var initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(\"Unknown key-system: \" + keySystem);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  var baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'not-allowed',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'not-allowed',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(function (codec) {\n      return {\n        contentType: \"audio/mp4; codecs=\\\"\" + codec + \"\\\"\",\n        robustness: drmSystemOptions.audioRobustness || '',\n        encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n      };\n    }),\n    videoCapabilities: videoCodecs.map(function (codec) {\n      return {\n        contentType: \"video/mp4; codecs=\\\"\" + codec + \"\\\"\",\n        robustness: drmSystemOptions.videoRobustness || '',\n        encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n      };\n    })\n  };\n  return [baseConfig];\n}\n\n/***/ }),\n\n/***/ \"./src/utils/mediasource-helper.ts\":\n/*!*****************************************!*\\\n  !*** ./src/utils/mediasource-helper.ts ***!\n  \\*****************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_989152__) => {\n\n\"use strict\";\n__nested_webpack_require_989152__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_989152__.d(__nested_webpack_exports__, {\n/* harmony export */   \"getMediaSource\": () => (/* binding */ getMediaSource)\n/* harmony export */ });\n/**\n * MediaSource helper\n */\n\nfunction getMediaSource() {\n  return self.MediaSource || self.WebKitMediaSource;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/mp4-tools.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/mp4-tools.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_989733__) => {\n\n\"use strict\";\n__nested_webpack_require_989733__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_989733__.d(__nested_webpack_exports__, {\n/* harmony export */   \"RemuxerTrackIdConfig\": () => (/* binding */ RemuxerTrackIdConfig),\n/* harmony export */   \"appendUint8Array\": () => (/* binding */ appendUint8Array),\n/* harmony export */   \"bin2str\": () => (/* binding */ bin2str),\n/* harmony export */   \"computeRawDurationFromSamples\": () => (/* binding */ computeRawDurationFromSamples),\n/* harmony export */   \"discardEPB\": () => (/* binding */ discardEPB),\n/* harmony export */   \"findBox\": () => (/* binding */ findBox),\n/* harmony export */   \"getDuration\": () => (/* binding */ getDuration),\n/* harmony export */   \"getStartDTS\": () => (/* binding */ getStartDTS),\n/* harmony export */   \"mp4Box\": () => (/* binding */ mp4Box),\n/* harmony export */   \"mp4pssh\": () => (/* binding */ mp4pssh),\n/* harmony export */   \"offsetStartDTS\": () => (/* binding */ offsetStartDTS),\n/* harmony export */   \"parseEmsg\": () => (/* binding */ parseEmsg),\n/* harmony export */   \"parseInitSegment\": () => (/* binding */ parseInitSegment),\n/* harmony export */   \"parsePssh\": () => (/* binding */ parsePssh),\n/* harmony export */   \"parseSEIMessageFromNALu\": () => (/* binding */ parseSEIMessageFromNALu),\n/* harmony export */   \"parseSamples\": () => (/* binding */ parseSamples),\n/* harmony export */   \"parseSegmentIndex\": () => (/* binding */ parseSegmentIndex),\n/* harmony export */   \"parseSinf\": () => (/* binding */ parseSinf),\n/* harmony export */   \"patchEncyptionData\": () => (/* binding */ patchEncyptionData),\n/* harmony export */   \"readSint32\": () => (/* binding */ readSint32),\n/* harmony export */   \"readUint16\": () => (/* binding */ readUint16),\n/* harmony export */   \"readUint32\": () => (/* binding */ readUint32),\n/* harmony export */   \"segmentValidRange\": () => (/* binding */ segmentValidRange),\n/* harmony export */   \"writeUint32\": () => (/* binding */ writeUint32)\n/* harmony export */ });\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_989733__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _typed_array__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_989733__(/*! ./typed-array */ \"./src/utils/typed-array.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_989733__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_989733__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _hex__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_989733__(/*! ./hex */ \"./src/utils/hex.ts\");\n\n\n\n\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nvar RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  var val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  var val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  var results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  var end = data.byteLength;\n  for (var i = 0; i < end;) {\n    var size = readUint32(data, i);\n    var type = bin2str(data.subarray(i + 4, i + 8));\n    var endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  var references = [];\n  var version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  var index = 8;\n  var timescale = readUint32(sidx, index);\n  index += 4;\n\n  // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n  var earliestPresentationTime = 0;\n  var firstOffset = 0;\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  var startByte = sidx.length + firstOffset;\n  var referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (var i = 0; i < referencesCount; i++) {\n    var referenceIndex = index;\n    var referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    var referenceSize = referenceInfo & 0x7fffffff;\n    var referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      // eslint-disable-next-line no-console\n      console.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    var subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize: referenceSize,\n      subsegmentDuration: subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime: earliestPresentationTime,\n    timescale: timescale,\n    version: version,\n    referencesCount: referencesCount,\n    references: references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment {Uint8Array} the bytes of the init segment\n * @return {InitData} a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  var result = [];\n  var traks = findBox(initSegment, ['moov', 'trak']);\n  for (var i = 0; i < traks.length; i++) {\n    var trak = traks[i];\n    var tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      var version = tkhd[0];\n      var _index = version === 0 ? 12 : 20;\n      var trackId = readUint32(tkhd, _index);\n      var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        _index = version === 0 ? 12 : 20;\n        var timescale = readUint32(mdhd, _index);\n        var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          var hdlrType = bin2str(hdlr.subarray(8, 12));\n          var type = {\n            soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.AUDIO,\n            vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            var codec = void 0;\n            if (stsd) {\n              codec = bin2str(stsd.subarray(12, 16));\n              // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n\n            result[trackId] = {\n              timescale: timescale,\n              type: type\n            };\n            result[type] = {\n              timescale: timescale,\n              id: trackId,\n              codec: codec\n            };\n          }\n        }\n      }\n    }\n  }\n  var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(function (trex) {\n    var trackId = readUint32(trex, 4);\n    var track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  var keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    var traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(function (trak) {\n      var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      var sampleEntries = stsd.subarray(8);\n      var encBoxes = findBox(sampleEntries, ['enca']);\n      var isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(function (enc) {\n        var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        var sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(function (sinf) {\n          var tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            var tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(function (b) {\n              return b !== 0;\n            })) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"[eme] Patching keyId in 'enc\" + (isAudio ? 'a' : 'v') + \">sinf>>tenc' box: \" + _hex__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hexDump(tencKeyId) + \" -> \" + _hex__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hexDump(keyId));\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  var schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    var scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"[eme] missing 'schm' box\");\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData {InitData} a hash of track type to timescale values\n * @param fmp4 {Uint8Array} the bytes of the mp4 fragment\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n    var tfdt = findBox(traf, ['tfdt'])[0];\n    var version = tfdt[0];\n    var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n      if (track) {\n        var baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          baseTime *= Math.pow(2, 32);\n          baseTime += readUint32(tfdt, 8);\n        }\n        // assume a 90kHz clock if no timescale was specified\n        var scale = track.timescale || 90e3;\n        // convert base time to seconds\n        var startTime = baseTime / scale;\n        if (isFinite(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n      return result;\n    }, null);\n    if (start !== null && isFinite(start) && (result === null || start < result)) {\n      return start;\n    }\n    return result;\n  }, null) || 0;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(‘tfhd’, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nfunction getDuration(data, initData) {\n  var rawDuration = 0;\n  var videoDuration = 0;\n  var audioDuration = 0;\n  var trafs = findBox(data, ['moof', 'traf']);\n  for (var i = 0; i < trafs.length; i++) {\n    var traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    var tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    var id = readUint32(tfhd, 4);\n    var track = initData[id];\n    if (!track) {\n      continue;\n    }\n    var trackDefault = track.default;\n    var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);\n    var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    var timescale = track.timescale || 90e3;\n    var truns = findBox(traf, ['trun']);\n    for (var j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        var sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    var sidxDuration = 0;\n    var sidxs = findBox(data, ['sidx']);\n    for (var _i = 0; _i < sidxs.length; _i++) {\n      var sidx = parseSegmentIndex(sidxs[_i]);\n      if (sidx !== null && sidx !== void 0 && sidx.references) {\n        sidxDuration += sidx.references.reduce(function (dur, ref) {\n          return dur + ref.info.duration || 0;\n        }, 0);\n      }\n    }\n    return sidxDuration;\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(‘trun’, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nfunction computeRawDurationFromSamples(trun) {\n  var flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  var offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n  var duration = 0;\n  var sampleCount = readUint32(trun, 4);\n  for (var i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      var sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n    findBox(traf, ['tfhd']).forEach(function (tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      var timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach(function (tfdt) {\n        var version = tfdt[0];\n        var baseMediaDecodeTime = readUint32(tfdt, 4);\n        if (version === 0) {\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          writeUint32(tfdt, 4, baseMediaDecodeTime);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  var segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  var moofs = findBox(data, ['moof']);\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  var last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = (0,_typed_array__WEBPACK_IMPORTED_MODULE_1__.sliceUint8)(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = (0,_typed_array__WEBPACK_IMPORTED_MODULE_1__.sliceUint8)(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  var temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  var seiSamples = [];\n  var videoData = track.samples;\n  var timescale = track.timescale;\n  var trackId = track.id;\n  var isHEVCFlavor = false;\n  var moofs = findBox(videoData, ['moof']);\n  moofs.map(function (moof) {\n    var moofOffset = moof.byteOffset - 8;\n    var trafs = findBox(moof, ['traf']);\n    trafs.map(function (traf) {\n      // get the base media decode time from the tfdt\n      var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n        var version = tfdt[0];\n        var result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(function (tfhd) {\n        var id = readUint32(tfhd, 4);\n        var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        var defaultSampleDuration = 0;\n        var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        var defaultSampleSize = 0;\n        var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        var tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(function (trun) {\n            var version = trun[0];\n            var flags = readUint32(trun, 0) & 0xffffff;\n            var dataOffsetPresent = (flags & 0x000001) !== 0;\n            var dataOffset = 0;\n            var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            var sampleDurationPresent = (flags & 0x000100) !== 0;\n            var sampleDuration = 0;\n            var sampleSizePresent = (flags & 0x000200) !== 0;\n            var sampleSize = 0;\n            var sampleFlagsPresent = (flags & 0x000400) !== 0;\n            var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            var compositionOffset = 0;\n            var sampleCount = readUint32(trun, 4);\n            var trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            var sampleOffset = dataOffset + moofOffset;\n            for (var ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO) {\n                var naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  var naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  var delimit = codec.indexOf('.');\n  var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    var naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    var _naluType = naluHeader & 0x1f;\n    return _naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  var data = discardEPB(unescapedData);\n  var seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  var payloadType = 0;\n  var payloadSize = 0;\n  var endOfCaptions = false;\n  var b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    var leftOver = data.length - seiPtr;\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n      endOfCaptions = true;\n      var countryCode = data[seiPtr++];\n      if (countryCode === 181) {\n        var providerCode = readUint16(data, seiPtr);\n        seiPtr += 2;\n        if (providerCode === 49) {\n          var userStructure = readUint32(data, seiPtr);\n          seiPtr += 4;\n          if (userStructure === 0x47413934) {\n            var userDataType = data[seiPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              var firstByte = data[seiPtr++];\n              var totalCCs = 0x1f & firstByte;\n              var enabled = 0x40 & firstByte;\n              var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              var byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (var i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[seiPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType: payloadType,\n                pts: pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5 && payloadSize < leftOver) {\n      endOfCaptions = true;\n      if (payloadSize > 16) {\n        var uuidStrArray = [];\n        for (var _i2 = 0; _i2 < 16; _i2++) {\n          var _b = data[seiPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (_i2 === 3 || _i2 === 5 || _i2 === 7 || _i2 === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        var length = payloadSize - 16;\n        var userDataBytes = new Uint8Array(length);\n        for (var _i3 = 0; _i3 < length; _i3++) {\n          userDataBytes[_i3] = data[seiPtr++];\n        }\n        samples.push({\n          payloadType: payloadType,\n          pts: pts,\n          uuid: uuidStrArray.join(''),\n          userData: (0,_demux_id3__WEBPACK_IMPORTED_MODULE_2__.utf8ArrayToStr)(userDataBytes),\n          userDataBytes: userDataBytes\n        });\n      }\n    } else if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      break;\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  var length = data.byteLength;\n  var EPBPositions = [];\n  var i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  var newLength = length - EPBPositions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  var version = data[0];\n  var schemeIdUri = '';\n  var value = '';\n  var timeScale = 0;\n  var presentationTimeDelta = 0;\n  var presentationTime = 0;\n  var eventDuration = 0;\n  var id = 0;\n  var offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    var leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    var rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      // eslint-disable-next-line no-console\n      console.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  var payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri: schemeIdUri,\n    value: value,\n    timeScale: timeScale,\n    presentationTime: presentationTime,\n    presentationTimeDelta: presentationTimeDelta,\n    eventDuration: eventDuration,\n    id: id,\n    payload: payload\n  };\n}\nfunction mp4Box(type) {\n  for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    payload[_key - 1] = arguments[_key];\n  }\n  var len = payload.length;\n  var size = 8;\n  var i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  var result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  var version;\n  var kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (var ix = 0; ix < keyids.length; ix++) {\n      var k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  var kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  var dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parsePssh(initData) {\n  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n    return null;\n  }\n  var result = {\n    version: 0,\n    systemId: '',\n    kids: null,\n    data: null\n  };\n  var view = new DataView(initData);\n  var boxSize = view.getUint32(0);\n  if (initData.byteLength !== boxSize && boxSize > 44) {\n    return null;\n  }\n  var type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return null;\n  }\n  result.version = view.getUint32(8) >>> 24;\n  if (result.version > 1) {\n    return null;\n  }\n  result.systemId = _hex__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hexDump(new Uint8Array(initData, 12, 16));\n  var dataSizeOrKidCount = view.getUint32(28);\n  if (result.version === 0) {\n    if (boxSize - 32 < dataSizeOrKidCount) {\n      return null;\n    }\n    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n  } else if (result.version === 1) {\n    result.kids = [];\n    for (var i = 0; i < dataSizeOrKidCount; i++) {\n      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n    }\n  }\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/numeric-encoding-utils.ts\":\n/*!*********************************************!*\\\n  !*** ./src/utils/numeric-encoding-utils.ts ***!\n  \\*********************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1024747__) => {\n\n\"use strict\";\n__nested_webpack_require_1024747__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1024747__.d(__nested_webpack_exports__, {\n/* harmony export */   \"base64Decode\": () => (/* binding */ base64Decode),\n/* harmony export */   \"base64DecodeToStr\": () => (/* binding */ base64DecodeToStr),\n/* harmony export */   \"base64Encode\": () => (/* binding */ base64Encode),\n/* harmony export */   \"base64ToBase64Url\": () => (/* binding */ base64ToBase64Url),\n/* harmony export */   \"base64UrlEncode\": () => (/* binding */ base64UrlEncode),\n/* harmony export */   \"strToBase64Encode\": () => (/* binding */ strToBase64Encode)\n/* harmony export */ });\nfunction base64ToBase64Url(base64encodedStr) {\n  return base64encodedStr.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\nfunction strToBase64Encode(str) {\n  return btoa(str);\n}\nfunction base64DecodeToStr(str) {\n  return atob(str);\n}\nfunction base64Encode(input) {\n  return btoa(String.fromCharCode.apply(String, input));\n}\nfunction base64UrlEncode(input) {\n  return base64ToBase64Url(base64Encode(input));\n}\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), function (c) {\n    return c.charCodeAt(0);\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/utils/output-filter.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/output-filter.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1026201__) => {\n\n\"use strict\";\n__nested_webpack_require_1026201__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1026201__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OutputFilter)\n/* harmony export */ });\nvar OutputFilter = /*#__PURE__*/function () {\n  function OutputFilter(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  var _proto = OutputFilter.prototype;\n  _proto.dispatchCue = function dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  };\n  _proto.newCue = function newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  };\n  _proto.reset = function reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  };\n  return OutputFilter;\n}();\n\n\n/***/ }),\n\n/***/ \"./src/utils/texttrack-utils.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/texttrack-utils.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1027741__) => {\n\n\"use strict\";\n__nested_webpack_require_1027741__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1027741__.d(__nested_webpack_exports__, {\n/* harmony export */   \"addCueToTrack\": () => (/* binding */ addCueToTrack),\n/* harmony export */   \"clearCurrentCues\": () => (/* binding */ clearCurrentCues),\n/* harmony export */   \"getCuesInRange\": () => (/* binding */ getCuesInRange),\n/* harmony export */   \"removeCuesInRange\": () => (/* binding */ removeCuesInRange),\n/* harmony export */   \"sendAddTrackEvent\": () => (/* binding */ sendAddTrackEvent)\n/* harmony export */ });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1027741__(/*! ./logger */ \"./src/utils/logger.ts\");\n\nfunction sendAddTrackEvent(track, videoEl) {\n  var event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  var mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(\"addCue is failed for: \" + cue);\n      }\n    } catch (err) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__.logger.debug(\"[texttrack-utils]: \" + err);\n      var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n      textTrackCue.id = cue.id;\n      track.addCue(textTrackCue);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  var mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (var i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  var mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    var cues = getCuesInRange(track.cues, start, end);\n    for (var i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  var len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  var left = 0;\n  var right = len;\n  while (left <= right) {\n    var mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  var cuesFound = [];\n  var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n      var _cue = cues[i];\n      if (_cue.startTime >= start && _cue.endTime <= end) {\n        cuesFound.push(_cue);\n      } else if (_cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/time-ranges.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/time-ranges.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1032118__) => {\n\n\"use strict\";\n__nested_webpack_require_1032118__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1032118__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n *  TimeRanges to string helper\n */\n\nvar TimeRanges = {\n  toString: function toString(r) {\n    var log = '';\n    var len = r.length;\n    for (var i = 0; i < len; i++) {\n      log += \"[\" + r.start(i).toFixed(3) + \"-\" + r.end(i).toFixed(3) + \"]\";\n    }\n    return log;\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimeRanges);\n\n/***/ }),\n\n/***/ \"./src/utils/timescale-conversion.ts\":\n/*!*******************************************!*\\\n  !*** ./src/utils/timescale-conversion.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1032976__) => {\n\n\"use strict\";\n__nested_webpack_require_1032976__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1032976__.d(__nested_webpack_exports__, {\n/* harmony export */   \"toMpegTsClockFromTimescale\": () => (/* binding */ toMpegTsClockFromTimescale),\n/* harmony export */   \"toMsFromMpegTsClock\": () => (/* binding */ toMsFromMpegTsClock),\n/* harmony export */   \"toTimescaleFromBase\": () => (/* binding */ toTimescaleFromBase),\n/* harmony export */   \"toTimescaleFromScale\": () => (/* binding */ toTimescaleFromScale)\n/* harmony export */ });\nvar MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(value, destScale, srcBase, round) {\n  if (srcBase === void 0) {\n    srcBase = 1;\n  }\n  if (round === void 0) {\n    round = false;\n  }\n  var result = value * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(value, destScale, srcScale, round) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n  if (round === void 0) {\n    round = false;\n  }\n  return toTimescaleFromBase(value, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(value, round) {\n  if (round === void 0) {\n    round = false;\n  }\n  return toTimescaleFromBase(value, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(value, srcScale) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n  return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\n/***/ }),\n\n/***/ \"./src/utils/typed-array.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/typed-array.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1034675__) => {\n\n\"use strict\";\n__nested_webpack_require_1034675__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1034675__.d(__nested_webpack_exports__, {\n/* harmony export */   \"sliceUint8\": () => (/* binding */ sliceUint8)\n/* harmony export */ });\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n/***/ }),\n\n/***/ \"./src/utils/vttcue.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/vttcue.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1035455__) => {\n\n\"use strict\";\n__nested_webpack_require_1035455__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1035455__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function () {\n  if (typeof self !== 'undefined' && self.VTTCue) {\n    return self.VTTCue;\n  }\n  var AllowedDirections = ['', 'lr', 'rl'];\n  var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    var lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n    var i = 1;\n    for (; i < arguments.length; i++) {\n      var cobj = arguments[i];\n      for (var p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    var cue = this;\n    var baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = '';\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = '';\n    var _snapToLines = true;\n    var _line = 'auto';\n    var _lineAlign = 'start';\n    var _position = 50;\n    var _positionAlign = 'middle';\n    var _size = 50;\n    var _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function get() {\n        return _id;\n      },\n      set: function set(value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function get() {\n        return _pauseOnExit;\n      },\n      set: function set(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function get() {\n        return _startTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function get() {\n        return _endTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function get() {\n        return _text;\n      },\n      set: function set(value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function get() {\n        return _region;\n      },\n      set: function set(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function get() {\n        return _vertical;\n      },\n      set: function set(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function get() {\n        return _snapToLines;\n      },\n      set: function set(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function get() {\n        return _line;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function get() {\n        return _lineAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function get() {\n        return _position;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function get() {\n        return _positionAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function get() {\n        return _size;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function get() {\n        return _align;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    var WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})());\n\n/***/ }),\n\n/***/ \"./src/utils/vttparser.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/vttparser.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1043938__) => {\n\n\"use strict\";\n__nested_webpack_require_1043938__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1043938__.d(__nested_webpack_exports__, {\n/* harmony export */   \"VTTParser\": () => (/* binding */ VTTParser),\n/* harmony export */   \"fixLineBreaks\": () => (/* binding */ fixLineBreaks),\n/* harmony export */   \"parseTimeStamp\": () => (/* binding */ parseTimeStamp)\n/* harmony export */ });\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1043938__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\n\nvar StringDecoder = /*#__PURE__*/function () {\n  function StringDecoder() {}\n  var _proto = StringDecoder.prototype;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _proto.decode = function decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  };\n  return StringDecoder;\n}(); // Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  var m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nvar Settings = /*#__PURE__*/function () {\n  function Settings() {\n    this.values = Object.create(null);\n  }\n  var _proto2 = Settings.prototype;\n  // Only accept the first assignment to any key.\n  _proto2.set = function set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  ;\n  _proto2.get = function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  ;\n  _proto2.has = function has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  ;\n  _proto2.alt = function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  ;\n  _proto2.integer = function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  ;\n  _proto2.percent = function percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      var percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  };\n  return Settings;\n}(); // Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var _k = kv[0];\n    var _v = kv[1];\n    callback(_k, _v);\n  }\n}\nvar defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nvar center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n    parseOptions(input, function (k, v) {\n      var vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    var line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    var position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nvar VTTParser = /*#__PURE__*/function () {\n  function VTTParser() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  var _proto3 = VTTParser.prototype;\n  _proto3.parse = function parse(data) {\n    var _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      var buffer = _this.buffer;\n      var pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        var m = line.match(/^(ï»¿)?WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      var alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              var hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  };\n  _proto3.flush = function flush() {\n    var _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  };\n  return VTTParser;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/webvtt-parser.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/webvtt-parser.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1058593__) => {\n\n\"use strict\";\n__nested_webpack_require_1058593__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1058593__.d(__nested_webpack_exports__, {\n/* harmony export */   \"generateCueId\": () => (/* binding */ generateCueId),\n/* harmony export */   \"parseWebVTT\": () => (/* binding */ parseWebVTT)\n/* harmony export */ });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1058593__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1058593__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1058593__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1058593__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1058593__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n\n\n\n\n\n\n\n\nvar LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nvar startsWith = function startsWith(inputString, searchString, position) {\n  if (position === void 0) {\n    position = 0;\n  }\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nvar cueString2millis = function cueString2millis(timeString) {\n  var ts = parseInt(timeString.slice(-3));\n  var secs = parseInt(timeString.slice(-6, -4));\n  var mins = parseInt(timeString.slice(-9, -7));\n  var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(ts) || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(secs) || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mins) || !(0,_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(hours)) {\n    throw Error(\"Malformed X-TIMESTAMP-MAP: Local:\" + timeString);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// From https://github.com/darkskyapp/string-hash\nvar hash = function hash(text) {\n  var hash = 5381;\n  var i = text.length;\n  while (i) {\n    hash = hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (hash >>> 0).toString();\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nvar calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  var currCC = vttCCs[cc];\n  var prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__.VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  var vttLines = (0,_demux_id3__WEBPACK_IMPORTED_MODULE_2__.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  var cues = [];\n  var initPTS90Hz = (0,_timescale_conversion__WEBPACK_IMPORTED_MODULE_3__.toMpegTsClockFromTimescale)(initPTS, timescale);\n  var cueTime = '00:00.000';\n  var timestampMapMPEGTS = 0;\n  var timestampMapLOCAL = 0;\n  var parsingError;\n  var inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    var currCC = vttCCs[cc];\n    var cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC !== null && currCC !== void 0 && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    var duration = cue.endTime - cue.startTime;\n    var startTime = (0,_remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__.normalizePts)((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    var text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(function (line) {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(function (timestamp) {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\n/***/ }),\n\n/***/ \"./src/utils/xhr-loader.ts\":\n/*!*********************************!*\\\n  !*** ./src/utils/xhr-loader.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1066133__) => {\n\n\"use strict\";\n__nested_webpack_require_1066133__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1066133__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1066133__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1066133__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n\n\nvar AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/m;\nvar XhrLoader = /*#__PURE__*/function () {\n  function XhrLoader(config /* HlsConfig */) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = void 0;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup : null;\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__.LoadStats();\n    this.retryDelay = 0;\n  }\n  var _proto = XhrLoader.prototype;\n  _proto.destroy = function destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n  };\n  _proto.abortInternal = function abortInternal() {\n    var loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  };\n  _proto.abort = function abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  };\n  _proto.load = function load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.retryDelay = config.retryDelay;\n    this.loadInternal();\n  };\n  _proto.loadInternal = function loadInternal() {\n    var config = this.config,\n      context = this.context;\n    if (!config) {\n      return;\n    }\n    var xhr = this.loader = new self.XMLHttpRequest();\n    var stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    var xhrSetup = this.xhrSetup;\n    try {\n      if (xhrSetup) {\n        try {\n          xhrSetup(xhr, context.url);\n        } catch (e) {\n          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader(\"Content-Language\", \"test\");}\n          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN\n          xhr.open('GET', context.url, true);\n          xhrSetup(xhr, context.url);\n        }\n      }\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n      var headers = this.context.headers;\n      if (headers) {\n        for (var header in headers) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      this.callbacks.onError({\n        code: xhr.status,\n        text: e.message\n      }, context, xhr);\n      return;\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  };\n  _proto.readystatechange = function readystatechange() {\n    var context = this.context,\n      xhr = this.loader,\n      stats = this.stats;\n    if (!context || !xhr) {\n      return;\n    }\n    var readyState = xhr.readyState;\n    var config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      // clear xhr timeout and rearm it if readyState less than 4\n      self.clearTimeout(this.requestTimeout);\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      }\n      if (readyState === 4) {\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        var status = xhr.status;\n        // http status between 200 to 299 are all successful\n        var isArrayBuffer = xhr.responseType === 'arraybuffer';\n        if (status >= 200 && status < 300 && (isArrayBuffer && xhr.response || xhr.responseText !== null)) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          var data;\n          var len;\n          if (isArrayBuffer) {\n            data = xhr.response;\n            len = data.byteLength;\n          } else {\n            data = xhr.responseText;\n            len = data.length;\n          }\n          stats.loaded = stats.total = len;\n          if (!this.callbacks) {\n            return;\n          }\n          var onProgress = this.callbacks.onProgress;\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n          if (!this.callbacks) {\n            return;\n          }\n          var response = {\n            url: xhr.responseURL,\n            data: data\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(status + \" while loading \" + context.url);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr);\n          } else {\n            // retry\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn(status + \" while loading \" + context.url + \", retrying in \" + this.retryDelay + \"...\");\n            // abort and reset internal state\n            this.abortInternal();\n            this.loader = null;\n            // schedule retry\n            self.clearTimeout(this.retryTimeout);\n            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n            // set exponential backoff\n            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n            stats.retry++;\n          }\n        }\n      } else {\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        self.clearTimeout(this.requestTimeout);\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n      }\n    }\n  };\n  _proto.loadtimeout = function loadtimeout() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn(\"timeout while loading \" + this.context.url);\n    var callbacks = this.callbacks;\n    if (callbacks) {\n      this.abortInternal();\n      callbacks.onTimeout(this.stats, this.context, this.loader);\n    }\n  };\n  _proto.loadprogress = function loadprogress(event) {\n    var stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  };\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      var ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  };\n  return XhrLoader;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XhrLoader);\n\n/***/ }),\n\n/***/ \"./node_modules/eventemitter3/index.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/eventemitter3/index.js ***!\n  \\*********************************************/\n/***/ ((module) => {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/url-toolkit/src/url-toolkit.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!\n  \\*****************************************************/\n/***/ (function(module) {\n\n// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (true)\n    module.exports = URLToolkit;\n  else {}\n})(this);\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_1091013__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1091013__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_1091013__.m = __webpack_modules__;\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_1091013__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_1091013__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_1091013__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_1091013__.o(definition, key) && !__nested_webpack_require_1091013__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_1091013__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_1091013__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// module factories are used so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_1091013__(\"./src/hls.ts\");\n/******/ \t__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=hls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUtvQjtBQUMxQixDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUFtQixFQUFFLDhCQUFtQjs7QUFFekU7QUFDQSw4QkFBbUIsR0FBRywwQkFBbUI7QUFDekMscUJBQXFCLDhCQUFtQixHQUFHLDBCQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsbUZBQW1GLDhCQUFtQjtBQUN0Ryw0RkFBNEYsOEJBQW1CO0FBQy9HLDJGQUEyRiw4QkFBbUI7QUFDOUcsK0ZBQStGLDhCQUFtQjtBQUNsSCw4RkFBOEYsOEJBQW1CO0FBQ2pILHNGQUFzRiw4QkFBbUI7QUFDekcsd0ZBQXdGLDhCQUFtQjtBQUMzRyx5RkFBeUYsOEJBQW1CO0FBQzVHLG1GQUFtRiw4QkFBbUI7QUFDdEcsbUZBQW1GLDhCQUFtQjtBQUN0RyxxRkFBcUYsOEJBQW1CO0FBQ3hHLDJFQUEyRSw4QkFBbUI7QUFDOUYsNkVBQTZFLDhCQUFtQjtBQUNoRyxxRUFBcUUsOEJBQW1CO0FBQ3hGLGlGQUFpRiw4QkFBbUI7QUFDcEcsdUVBQXVFLDhCQUFtQjtBQUMxRixzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJuVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4Qiw2QkFBNkIsS0FBSSxrR0FBa0csQ0FBQztBQUNwSSw0QkFBNEIsS0FBSSxtRkFBbUYsQ0FBQztBQUNwSCx1QkFBdUIsS0FBSSxxRkFBcUYsQ0FBQztBQUNqSCwwQkFBMEIsS0FBSSxpRkFBaUYsQ0FBQztBQUNoSCx5QkFBeUIsS0FBSSxnRkFBZ0YsQ0FBQztBQUM5RyxrQkFBa0IsS0FBSSx3RUFBd0UsQ0FBQztBQUMvRixtQkFBbUIsS0FBSSwwRUFBMEUsQ0FBQztBQUNsRyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUFtQixFQUFFLGdDQUFtQjs7QUFFekU7QUFDQSxnQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMscUJBQXFCLGdDQUFtQixHQUFHLDBCQUFtQjtBQUM5RDtBQUNBLHNCQUFzQjtBQUN0Qiw2R0FBNkcsZ0NBQW1CO0FBQ2hJLHdGQUF3RixnQ0FBbUI7QUFDM0csZ0VBQWdFLGdDQUFtQjtBQUNuRixnRUFBZ0UsZ0NBQW1CO0FBQ25GLHNFQUFzRSxnQ0FBbUI7QUFDekYsc0VBQXNFLGdDQUFtQjs7OztBQUl6Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7Ozs7OztBQU1uVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRNQUE0TTtBQUM1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUFtQixFQUFFLGdDQUFtQjs7QUFFekU7QUFDQSxnQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMscUJBQXFCLGdDQUFtQixHQUFHLDBCQUFtQjtBQUM5RDtBQUNBLHNCQUFzQjtBQUN0Qiw2R0FBNkcsZ0NBQW1CO0FBQ2hJLGdGQUFnRixnQ0FBbUI7QUFDbkcsZ0VBQWdFLGdDQUFtQjtBQUNuRiw2RUFBNkUsZ0NBQW1CO0FBQ2hHLDBFQUEwRSxnQ0FBbUI7QUFDN0YscUVBQXFFLGdDQUFtQjtBQUN4RixzRUFBc0UsZ0NBQW1CO0FBQ3pGLHlFQUF5RSxnQ0FBbUI7QUFDNUYsMkVBQTJFLGdDQUFtQjtBQUM5RixvRkFBb0YsZ0NBQW1CO0FBQ3ZHLDJFQUEyRSxnQ0FBbUI7QUFDOUYsMkVBQTJFLGdDQUFtQjtBQUM5RixnRkFBZ0YsZ0NBQW1CO0FBQ25HLGlFQUFpRSxnQ0FBbUI7O0FBRXBGLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVMsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7QUFDckosaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7QUFjeksseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFFBQVE7QUFDL0Y7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEIsNEJBQTRCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBbUIsRUFBRSxnQ0FBbUI7O0FBRXpFO0FBQ0EsZ0NBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLHFCQUFxQixnQ0FBbUIsR0FBRywwQkFBbUI7QUFDOUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2R0FBNkcsZ0NBQW1CO0FBQ2hJLG1FQUFtRSxnQ0FBbUI7QUFDdEYsMEVBQTBFLGdDQUFtQjtBQUM3Riw2RUFBNkUsZ0NBQW1CO0FBQ2hHLHNFQUFzRSxnQ0FBbUI7QUFDekYsZ0VBQWdFLGdDQUFtQjtBQUNuRixnRUFBZ0UsZ0NBQW1CO0FBQ25GLDBFQUEwRSxnQ0FBbUI7QUFDN0YseUVBQXlFLGdDQUFtQjtBQUM1RiwrRUFBK0UsZ0NBQW1CO0FBQ2xHLDJFQUEyRSxnQ0FBbUI7QUFDOUYsdUVBQXVFLGdDQUFtQjtBQUMxRixpRkFBaUYsZ0NBQW1CO0FBQ3BHLDBFQUEwRSxnQ0FBbUI7QUFDN0YsNEVBQTRFLGdDQUFtQjtBQUMvRix1RUFBdUUsZ0NBQW1COzs7Ozs7QUFNMUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHO0FBQ3hRLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLCtEQUErRCxzQ0FBc0MsMEJBQTBCLCtDQUErQyx5Q0FBeUMsdUVBQXVFO0FBQ25VLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKLGdEQUFnRCwwREFBMEQsMkNBQTJDO0FBQ3JKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQnpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUV6RTtBQUNBLGlDQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0Esc0JBQXNCO0FBQ3RCLDZHQUE2RyxpQ0FBbUI7QUFDaEksZ0VBQWdFLGlDQUFtQjtBQUNuRixzRUFBc0UsaUNBQW1CO0FBQ3pGLGdFQUFnRSxpQ0FBbUI7QUFDbkYsNkVBQTZFLGlDQUFtQjtBQUNoRyxrRkFBa0YsaUNBQW1CO0FBQ3JHLHlFQUF5RSxpQ0FBbUI7QUFDNUYsZ0ZBQWdGLGlDQUFtQjs7Ozs7Ozs7Ozs7OztBQWFuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdEQUFnRCxNQUFNO0FBQ3RELE9BQU87QUFDUDtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGtCQUFrQixLQUFLLGdCQUFnQixNQUFNLE1BQU07QUFDdEgsU0FBUztBQUNUO0FBQ0Esb0VBQW9FLGtCQUFrQixLQUFLLGdCQUFnQixNQUFNLE1BQU07QUFDdkg7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNEJBQTRCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSw4RUFBOEU7QUFDOUUsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9UQUFvVDtBQUNwVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUV6RTtBQUNBLGlDQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2R0FBNkcsaUNBQW1CO0FBQ2hJLHNFQUFzRSxpQ0FBbUI7QUFDekYsMkVBQTJFLGlDQUFtQjs7Ozs7O0FBTTlGLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVM7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVSxvQkFBb0IsUUFBUSxVQUFVLFdBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Ozs7Ozs7O0FBWXpLLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBbUIsRUFBRSxpQ0FBbUI7O0FBRXpFO0FBQ0EsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLHFCQUFxQixpQ0FBbUIsR0FBRywwQkFBbUI7QUFDOUQ7QUFDQSxzQkFBc0I7QUFDdEIsZ0VBQWdFLGlDQUFtQjtBQUNuRiw2RUFBNkUsaUNBQW1CO0FBQ2hHLDBFQUEwRSxpQ0FBbUI7QUFDN0YsK0VBQStFLGlDQUFtQjtBQUNsRyxzRUFBc0UsaUNBQW1CO0FBQ3pGLDBFQUEwRSxpQ0FBbUI7QUFDN0YsZ0ZBQWdGLGlDQUFtQjtBQUNuRyxzRUFBc0UsaUNBQW1CO0FBQ3pGLHFFQUFxRSxpQ0FBbUI7QUFDeEYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHO0FBQ3hRLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLCtEQUErRCxzQ0FBc0MsMEJBQTBCLCtDQUErQyx5Q0FBeUMsdUVBQXVFO0FBQ25VLGdEQUFnRCwwREFBMEQsMkNBQTJDO0FBQ3JKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7Ozs7Ozs7Ozs7QUFVeksseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBbUIsRUFBRSxpQ0FBbUI7O0FBRXpFO0FBQ0EsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLHFCQUFxQixpQ0FBbUIsR0FBRywwQkFBbUI7QUFDOUQ7QUFDQSxzQkFBc0I7QUFDdEIsZ0VBQWdFLGlDQUFtQjtBQUNuRiwrRUFBK0UsaUNBQW1CO0FBQ2xHLGtGQUFrRixpQ0FBbUI7QUFDckcsc0VBQXNFLGlDQUFtQjtBQUN6Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7QUFDblUsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7QUFDckosaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7Ozs7QUFLeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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NkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUV6RTtBQUNBLGlDQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0Esc0JBQXNCO0FBQ3RCLDhEQUE4RCxpQ0FBbUI7QUFDakYsbUVBQW1FLGlDQUFtQjtBQUN0RixvRUFBb0UsaUNBQW1CO0FBQ3ZGLG9FQUFvRSxpQ0FBbUI7QUFDdkYsZ0VBQWdFLGlDQUFtQjtBQUNuRix5RUFBeUUsaUNBQW1CO0FBQzVGLHNFQUFzRSxpQ0FBbUI7QUFDekYsZ0VBQWdFLGlDQUFtQjtBQUNuRix1RUFBdUUsaUNBQW1CO0FBQzFGLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUV6RTtBQUNBLGlDQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZHQUE2RyxpQ0FBbUI7QUFDaEksb0VBQW9FLGlDQUFtQjtBQUN2Rix5RkFBeUYsaUNBQW1CO0FBQzVHLG9FQUFvRSxpQ0FBbUI7OztBQUd2RixnREFBZ0QsMERBQTBELDJDQUEyQztBQUNySixpQ0FBaUMsMEdBQTBHLGlCQUFpQixhQUFhO0FBQ3pLLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEO0FBQy9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRztBQUN4USwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTs7O0FBR25VO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUFtQixFQUFFLGlDQUFtQjs7QUFFekU7QUFDQSxpQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMscUJBQXFCLGlDQUFtQixHQUFHLDBCQUFtQjtBQUM5RDtBQUNBLHNCQUFzQjtBQUN0Qiw2R0FBNkcsaUNBQW1CO0FBQ2hJLGdFQUFnRSxpQ0FBbUI7QUFDbkYsZ0VBQWdFLGlDQUFtQjtBQUNuRixzRUFBc0UsaUNBQW1CO0FBQ3pGLHFFQUFxRSxpQ0FBbUI7QUFDeEYsc0VBQXNFLGlDQUFtQjtBQUN6Rix5RUFBeUUsaUNBQW1COzs7QUFHNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsYUFBYSxXQUFXLGNBQWMsUUFBUSxXQUFXOztBQUU1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9GQUFvRixZQUFZOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLHVCQUF1QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0VBQXNFLGlDQUFtQjs7O0FBR3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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LGtDQUFtQjtBQUN2RCxVQUFVLDBCQUFtQixHQUFHLDBCQUFtQjtBQUNuRDtBQUNBLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanM/ZjdjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIbHNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSGxzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL2NvbmZpZy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29uZmlnLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImVuYWJsZVN0cmVhbWluZ01vZGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZW5hYmxlU3RyZWFtaW5nTW9kZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaGxzRGVmYXVsdENvbmZpZ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBobHNEZWZhdWx0Q29uZmlnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJtZXJnZUNvbmZpZ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBtZXJnZUNvbmZpZylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2Ficl9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2F1ZGlvX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2F1ZGlvX3RyYWNrX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3N1YnRpdGxlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3N1YnRpdGxlX3RyYWNrX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2J1ZmZlcl9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3RpbWVsaW5lX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2NhcF9sZXZlbF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2Zwc19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2VtZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2NtY2RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9jbWNkLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfeGhyX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMveGhyLWxvYWRlciAqLyBcIi4vc3JjL3V0aWxzL3hoci1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2ZldGNoX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvZmV0Y2gtbG9hZGVyICovIFwiLi9zcmMvdXRpbHMvZmV0Y2gtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jdWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9jdWVzICovIFwiLi9zcmMvdXRpbHMvY3Vlcy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gSWYgcG9zc2libGUsIGtlZXAgaGxzRGVmYXVsdENvbmZpZyBzaGFsbG93XG4vLyBJdCBpcyBjbG9uZWQgd2hlbmV2ZXIgYSBuZXcgSGxzIGluc3RhbmNlIGlzIGNyZWF0ZWQsIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ1xuLy8gc2hhbGxvdyB0aGUgcHJvcGVydGllcyBhcmUgY2xvbmVkLCBhbmQgd2UgZG9uJ3QgZW5kIHVwIG1hbmlwdWxhdGluZyB0aGUgZGVmYXVsdFxudmFyIGhsc0RlZmF1bHRDb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICBhdXRvU3RhcnRMb2FkOiB0cnVlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIHN0YXJ0UG9zaXRpb246IC0xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlZmF1bHRBdWRpb0NvZGVjOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVidWc6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGxvZ2dlclxuICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGlnbm9yZURldmljZVBpeGVsUmF0aW86IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgYmFja0J1ZmZlckxlbmd0aDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJIb2xlOiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAyLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlT2Zmc2V0OiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAvLyB1c2VkIGJ5IGRlbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IF91dGlsc194aHJfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZGVmYXVsdFwiXSxcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IF9jb250cm9sbGVyX2Ficl9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICBidWZmZXJDb250cm9sbGVyOiBfY29udHJvbGxlcl9idWZmZXJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSxcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBfY29udHJvbGxlcl9jYXBfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSxcbiAgZnBzQ29udHJvbGxlcjogX2NvbnRyb2xsZXJfZnBzX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0sXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LFxuICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsXG4gIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbXM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB0ZXN0QmFuZHdpZHRoOiB0cnVlLFxuICBwcm9ncmVzc2l2ZTogZmFsc2UsXG4gIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICBjbWNkOiB1bmRlZmluZWQsXG4gIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzOiB0cnVlXG59LCB0aW1lbGluZUNvbmZpZygpKSwge30sIHtcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX3N1YnRpdGxlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIDogMCxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfc3VidGl0bGVfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSA6IDAsXG4gIHRpbWVsaW5lQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl90aW1lbGluZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uVGltZWxpbmVDb250cm9sbGVyIDogMCxcbiAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX2F1ZGlvX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdIDogMCxcbiAgYXVkaW9UcmFja0NvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfYXVkaW9fdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSA6IDAsXG4gIGVtZUNvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfZW1lX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0gOiAwLFxuICBjbWNkQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9jbWNkX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJkZWZhdWx0XCJdIDogMFxufSk7XG5mdW5jdGlvbiB0aW1lbGluZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBfdXRpbHNfY3Vlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0sXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKSB7XG4gIGlmICgodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiKTtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICB9XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG59XG5mdW5jdGlvbiBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZykge1xuICB2YXIgY3VycmVudExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiZGVmYXVsdFwiXSAmJiBjdXJyZW50TG9hZGVyICE9PSBfdXRpbHNfeGhyX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImRlZmF1bHRcIl0pIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5sb2dnZXIubG9nKCdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9ICgwLF91dGlsc19mZXRjaF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uZmV0Y2hTdXBwb3J0ZWQpKCk7XG4gICAgaWYgKGNhblN0cmVhbVByb2dyZXNzaXZlbHkpIHtcbiAgICAgIGNvbmZpZy5sb2FkZXIgPSBfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiZGVmYXVsdFwiXTtcbiAgICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICBjb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5sb2dnZXIubG9nKCdbY29uZmlnXTogUHJvZ3Jlc3NpdmUgc3RyZWFtaW5nIGVuYWJsZWQsIHVzaW5nIEZldGNoTG9hZGVyJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19ld21hX2JhbmR3aWR0aF9lc3RpbWF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvciAqLyBcIi4vc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuXG5cblxuXG5cbnZhciBBYnJDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWJyQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgX3V0aWxzX2V3bWFfYmFuZHdpZHRoX2VzdGltYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXShjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gQWJyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uQ2hlY2sgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB2YXIgX2RhdGEkcGFydDtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgIHRoaXMucGFydEN1cnJlbnQgPSAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgIT0gbnVsbCA/IF9kYXRhJHBhcnQgOiBudWxsO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgICAgVGhpcyBtZXRob2QgbW9uaXRvcnMgdGhlIGRvd25sb2FkIHJhdGUgb2YgdGhlIGN1cnJlbnQgZnJhZ21lbnQsIGFuZCB3aWxsIGRvd25zd2l0Y2ggaWYgdGhhdCBmcmFnbWVudCB3aWxsIG5vdCBsb2FkXG4gICAgICBxdWlja2x5IGVub3VnaCB0byBwcmV2ZW50IHVuZGVyYnVmZmVyaW5nXG4gICAgKi87XG4gIF9wcm90by5fYWJhbmRvblJ1bGVzQ2hlY2sgPSBmdW5jdGlvbiBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgcGFydCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgYXV0b0xldmVsRW5hYmxlZCA9IGhscy5hdXRvTGV2ZWxFbmFibGVkLFxuICAgICAgbWVkaWEgPSBobHMubWVkaWE7XG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgdmFyIGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmIChzdGF0cy5hYm9ydGVkIHx8IHN0YXRzLmxvYWRlZCAmJiBzdGF0cy5sb2FkZWQgPT09IHN0YXRzLnRvdGFsIHx8IGZyYWcubGV2ZWwgPT09IDApIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGNoZWNrIG9ubHkgcnVucyBpZiB3ZSdyZSBpbiBBQlIgbW9kZSBhbmQgYWN0dWFsbHkgcGxheWluZ1xuICAgIGlmICghYXV0b0xldmVsRW5hYmxlZCB8fCBtZWRpYS5wYXVzZWQgfHwgIW1lZGlhLnBsYXliYWNrUmF0ZSB8fCAhbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTtcbiAgICAvLyBJbiBvcmRlciB0byB3b3JrIHdpdGggYSBzdGFibGUgYmFuZHdpZHRoLCBvbmx5IGJlZ2luIG1vbml0b3JpbmcgYmFuZHdpZHRoIGFmdGVyIGhhbGYgb2YgdGhlIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZFxuICAgIGlmIChyZXF1ZXN0RGVsYXkgPD0gNTAwICogZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiBzdGF0cy5sb2FkaW5nLmZpcnN0O1xuICAgIHZhciBid0VzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgIHZhciBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgdmFyIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgfHwgTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGR1cmF0aW9uICogbGV2ZWwubWF4Qml0cmF0ZSAvIDgpKTtcbiAgICB2YXIgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGUgPyBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5IDogMDtcblxuICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICB2YXIgZnJhZ0xvYWRlZERlbGF5ID0gbG9hZFJhdGUgPyAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUgOiBleHBlY3RlZExlbiAqIDggLyBid0VzdGltYXRlO1xuXG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgIHZhciBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSBidWZmZXJJbmZvLmxlbiAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgIGlmIChmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG5leHRMb2FkTGV2ZWw7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgbGFyZ2VzdCBvbmUgdGhhdCBhdm9pZHMgcmVidWZmZXJpbmdcbiAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICB2YXIgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gbG9hZFJhdGUgPyBkdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKSA6IGR1cmF0aW9uICogbGV2ZWxOZXh0Qml0cmF0ZSAvIGJ3RXN0aW1hdGU7XG4gICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgLy8gdG8gbG9hZCB0aGUgY3VycmVudCBvbmVcbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID49IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubG9nZ2VyLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGlzIGxvYWRpbmcgdG9vIHNsb3dseSBhbmQgd2lsbCBjYXVzZSBhbiB1bmRlcmJ1ZmZlcjsgYWJvcnRpbmcgYW5kIHN3aXRjaGluZyB0byBsZXZlbCBcIiArIG5leHRMb2FkTGV2ZWwgKyBcIlxcbiAgICAgIEN1cnJlbnQgQlcgZXN0aW1hdGU6IFwiICsgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoYndFc3RpbWF0ZSkgPyAoYndFc3RpbWF0ZSAvIDEwMjQpLnRvRml4ZWQoMykgOiAnVW5rbm93bicpICsgXCIgS2Ivc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6IFwiICsgZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMykgKyBcIiBzXFxuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgdGhlIG5leHQgZnJhZ21lbnQ6IFwiICsgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMykgKyBcIiBzXFxuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogXCIgKyBidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgzKSArIFwiIHNcIik7XG4gICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBiYW5kd2lkdGhcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSwgc3RhdHMubG9hZGVkKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgaWYgKGZyYWcubG9hZGVyIHx8IGZyYWcua2V5TG9hZGVyKSB7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgICBmcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICB9XG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgc3RhdHM6IHN0YXRzXG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgZnJhZyA9IF9yZWYuZnJhZyxcbiAgICAgIHBhcnQgPSBfcmVmLnBhcnQ7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShmcmFnLnNuKSkge1xuICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgdmFyIGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcblxuICAgICAgLy8gY29tcHV0ZSBsZXZlbCBhdmVyYWdlIGJpdHJhdGVcbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgc3RhdHMubG9hZGVkO1xuICAgICAgICB2YXIgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwubG9hZGVkID0ge1xuICAgICAgICAgIGJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgICBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHZhciBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19CVUZGRVJFRCwgZnJhZ0J1ZmZlcmVkRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgIGlmIChmcmFnLnR5cGUgIT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgIHZhciBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZnJhZztcbiAgICAvLyBzdG9wIHRpbWVyIGluIGNhc2Ugb2YgZnJhZyBsb2FkaW5nIGVycm9yXG4gICAgaWYgKCgoX2RhdGEkZnJhZyA9IGRhdGEuZnJhZykgPT09IG51bGwgfHwgX2RhdGEkZnJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkZnJhZy50eXBlKSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5jbGVhclRpbWVyID0gZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgO1xuICBfcHJvdG8uZ2V0TmV4dEFCUkF1dG9MZXZlbCA9IGZ1bmN0aW9uIGdldE5leHRBQlJBdXRvTGV2ZWwoKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCxcbiAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLFxuICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWwsXG4gICAgICBtZWRpYSA9IGhscy5tZWRpYTtcbiAgICB2YXIgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcblxuICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIG1lZGlhLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICB2YXIgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICB2YXIgYXZnYncgPSB0aGlzLmJ3RXN0aW1hdG9yID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICB2YXIgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgdmFyIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgdmFyIGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIudHJhY2UoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA/ICdyZWJ1ZmZlcmluZyBleHBlY3RlZCcgOiAnYnVmZmVyIGlzIGVtcHR5JykgKyBcIiwgZmluZGluZyBvcHRpbWFsIHF1YWxpdHkgbGV2ZWxcIik7XG4gICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgdmFyIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICB2YXIgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcbiAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICB2YXIgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyBcIm1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgXCIgbXNcIik7XG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgfTtcbiAgX3Byb3RvLmZpbmRCZXN0TGV2ZWwgPSBmdW5jdGlvbiBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICB2YXIgbGl2ZSA9ICEhKGxldmVsICE9PSBudWxsICYmIGxldmVsICE9PSB2b2lkIDAgJiYgKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgIT09IG51bGwgJiYgX2xldmVsJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfbGV2ZWwkZGV0YWlscy5saXZlKTtcbiAgICB2YXIgY3VycmVudENvZGVjU2V0ID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsLmNvZGVjU2V0O1xuICAgIHZhciBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICBpZiAoIWxldmVsSW5mbyB8fCBjdXJyZW50Q29kZWNTZXQgJiYgbGV2ZWxJbmZvLmNvZGVjU2V0ICE9PSBjdXJyZW50Q29kZWNTZXQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICB2YXIgYXZnRHVyYXRpb24gPSAocGFydEN1cnJlbnQgPyBsZXZlbERldGFpbHMgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICB2YXIgYWRqdXN0ZWRidyA9IHZvaWQgMDtcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG4gICAgICB2YXIgYml0cmF0ZSA9IGxldmVsc1tpXS5tYXhCaXRyYXRlO1xuICAgICAgdmFyIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci50cmFjZShcImxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246IFwiICsgaSArIFwiL1wiICsgTWF0aC5yb3VuZChhZGp1c3RlZGJ3KSArIFwiL1wiICsgYml0cmF0ZSArIFwiL1wiICsgYXZnRHVyYXRpb24gKyBcIi9cIiArIG1heEZldGNoRHVyYXRpb24gKyBcIi9cIiArIGZldGNoRHVyYXRpb24pO1xuICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICBpZiAoYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiYgKFxuICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICBmZXRjaER1cmF0aW9uID09PSAwIHx8ICEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGZldGNoRHVyYXRpb24pIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikpIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBlbm91Z2ggdGltZSBidWRnZXQgZXZlbiB3aXRoIHF1YWxpdHkgbGV2ZWwgMCAuLi4gcmVidWZmZXJpbmcgbWlnaHQgaGFwcGVuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBfY3JlYXRlQ2xhc3MoQWJyQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibmV4dEF1dG9MZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLmJ3RXN0aW1hdG9yO1xuICAgICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5nZXROZXh0QUJSQXV0b0xldmVsKCk7XG4gICAgICAvLyB1c2UgZm9yY2VkIGF1dG8gbGV2ZWwgd2hlbiBBQlIgc2VsZWN0ZWQgbGV2ZWwgaGFzIGVycm9yZWRcbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmIHRoaXMuaGxzLmxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBYnJDb250cm9sbGVyO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChBYnJDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xudmFyIEF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHJlYW1Db250cm9sbGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEF1ZGlvU3RyZWFtQ29udHJvbGxlciwgX0Jhc2VTdHJlYW1Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQXVkaW9TdHJlYW1Db250cm9sbGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgX3RoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIF90aGlzLnZpZGVvVHJhY2tDQyA9IC0xO1xuICAgIF90aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgX3RoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgX3RoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgIF90aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICBfdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgX3RoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gIH07XG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIElOSVRfUFRTX0ZPVU5EIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyB0cmFjayBwYXJzZWQgaW4gdGhlIHN0cmVhbS1jb250cm9sbGVyIGhhcyBhIG5ldyBQVFMgdmFsdWVcbiAgO1xuICBfcHJvdG8ub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChldmVudCwgX3JlZikge1xuICAgIHZhciBmcmFnID0gX3JlZi5mcmFnLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgaW5pdFBUUyA9IF9yZWYuaW5pdFBUUztcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAvLyBDYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgdmFyIGNjID0gZnJhZy5jYztcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IGluaXRQVFM7XG4gICAgICB0aGlzLmxvZyhcIkluaXRQVFMgZm9yIGNjOiBcIiArIGNjICsgXCIgZm91bmQgZnJvbSBtYWluOiBcIiArIGluaXRQVFMpO1xuICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcbiAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nLCB0aWNrIGltbWVkaWF0ZWx5IHRvIHVuYmxvY2sgYXVkaW8gZnJhZ21lbnQgdHJhbnNtdXhpbmdcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuU1RPUFBFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU6XG4gICAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9sZXZlbHMkdHJhY2tJZDtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxzID09PSBudWxsIHx8IGxldmVscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9sZXZlbHMkdHJhY2tJZCA9IGxldmVsc1t0cmFja0lkXSkgPT09IG51bGwgfHwgX2xldmVscyR0cmFja0lkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxzJHRyYWNrSWQuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT09IG51bGwgJiYgX3RoaXMkbWVkaWEgIT09IHZvaWQgMCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnUmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy50cmFja0lkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuV0FJVElOR19JTklUX1BUUzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gdGhlIFdBSVRJTkdfSU5JVF9QVFMgc3RhdGUgaWYgdGhlIHdhaXRpbmcgZnJhZyBDQyBkb2Vzbid0IG1hdGNoIGFueSBpbml0UFRTXG4gICAgICAgICAgdmFyIHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICAgICAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gd2FpdGluZ0RhdGEuZnJhZyxcbiAgICAgICAgICAgICAgcGFydCA9IHdhaXRpbmdEYXRhLnBhcnQsXG4gICAgICAgICAgICAgIGNhY2hlID0gd2FpdGluZ0RhdGEuY2FjaGUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlID0gd2FpdGluZ0RhdGEuY29tcGxldGU7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNhY2hlLmZsdXNoKCk7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSB0aGlzLndhaXRpbmdWaWRlb0NDKSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiB2aWRlb1RyYWNrQ0MgaGFzIGNoYW5nZWQgc2luY2Ugd2FpdGluZ0ZyYWdtZW50IHdhcyBzZXQgYW5kIGluaXRQVFMgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICB0aGlzLmxvZyhcIldhaXRpbmcgZnJhZ21lbnQgY2MgKFwiICsgZnJhZy5jYyArIFwiKSBjYW5jZWxsZWQgYmVjYXVzZSB2aWRlbyBpcyBhdCBjYyBcIiArIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIGFuIGVhcmxpZXIgZnJhZ21lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcG9zLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgICAgICAgdmFyIHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPSAoMCxfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5mcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpKGJ1ZmZlckluZm8uZW5kLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKTtcbiAgICAgICAgICAgICAgaWYgKHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coXCJXYWl0aW5nIGZyYWdtZW50IGNjIChcIiArIGZyYWcuY2MgKyBcIikgQCBcIiArIGZyYWcuc3RhcnQgKyBcIiBjYW5jZWxsZWQgYmVjYXVzZSBhbm90aGVyIGZyYWdtZW50IGF0IFwiICsgYnVmZmVySW5mby5lbmQgKyBcIiBpcyBuZWVkZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH07XG4gIF9wcm90by5jbGVhcldhaXRpbmdGcmFnbWVudCA9IGZ1bmN0aW9uIGNsZWFyV2FpdGluZ0ZyYWdtZW50KCkge1xuICAgIHZhciB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5yZXNldExvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0TG9hZGluZ1N0YXRlLmNhbGwodGhpcyk7XG4gIH07XG4gIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcbiAgX3Byb3RvLmRvVGlja0lkbGUgPSBmdW5jdGlvbiBkb1RpY2tJZGxlKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBpZiAoIWxldmVscyB8fCAhbGV2ZWxzW3RyYWNrSWRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3BcbiAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgaWYgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1t0cmFja0lkXTtcbiAgICB2YXIgdHJhY2tEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgaWYgKCF0cmFja0RldGFpbHMgfHwgdHJhY2tEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IHRyYWNrSWQgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBidWZmZXJhYmxlID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmICh0aGlzLmJ1ZmZlckZsdXNoZWQgJiYgYnVmZmVyYWJsZSkge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChidWZmZXJhYmxlLCBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIH1cbiAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2g7XG4gICAgaWYgKCFhdWRpb1N3aXRjaCAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkJVRkZFUl9FT1MsIHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIHZhciBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT09IG51bGwgfHwgbWFpbkJ1ZmZlckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbik7XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhYXVkaW9Td2l0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciB0YXJnZXRCdWZmZXJUaW1lID0gYnVmZmVySW5mby5lbmQ7XG4gICAgaWYgKGF1ZGlvU3dpdGNoICYmIG1lZGlhKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBwb3M7XG4gICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnQWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrJyk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBidWZmZXIgYXVkaW8gdXAgdG8gb25lIHRhcmdldCBkdXJhdGlvbiBhaGVhZCBvZiBtYWluIGJ1ZmZlclxuICAgIGlmIChtYWluQnVmZmVySW5mbyAmJiB0YXJnZXRCdWZmZXJUaW1lID4gbWFpbkJ1ZmZlckluZm8uZW5kICsgdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuICAgIGlmICgoIW1haW5CdWZmZXJJbmZvIHx8ICFtYWluQnVmZmVySW5mby5sZW4pICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIHRyYWNrRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH07XG4gIF9wcm90by5nZXRNYXhCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgIHZhciBtYXhDb25maWdCdWZmZXIgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heEJ1ZmZlckxlbmd0aC5jYWxsKHRoaXMpO1xuICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1heENvbmZpZ0J1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gIH07XG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLm9uQXVkaW9UcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrc1VwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gX3JlZjIuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmxldmVscyA9IGF1ZGlvVHJhY2tzLm1hcChmdW5jdGlvbiAobWVkaWFQbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5MZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyB0cmFuc211eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7XG4gICAgICAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICB9O1xuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIGlmICh0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICBpZiAodGhpcy5tYWluRGV0YWlscyA9PSBudWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgdHJhY2tJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKFwiVHJhY2sgXCIgKyB0cmFja0lkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXSxkdXJhdGlvbjpcIiArIG5ld0RldGFpbHMudG90YWxkdXJhdGlvbik7XG4gICAgdmFyIHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9PSBudWxsICYmIF90cmFjayRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmICghbmV3RGV0YWlscy5mcmFnbWVudHNbMF0pIHtcbiAgICAgICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCB8fCAhbWFpbkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzICYmIG5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIG1haW5EZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGF1ZGlvIHJlbmRpdGlvbiBpcyBhbGlnbmVkIHdpdGggdGhlIFwibWFpblwiIHJlbmRpdGlvbiwgdXNpbmdcbiAgICAgICAgLy8gcGR0IGFzIG91ciByZWZlcmVuY2UgdGltZXMuXG4gICAgICAgICgwLF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQpKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2tJZDtcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgd2UgYXJlIGFsaWduZWQgd2l0aCB0aGUgbWFpbiBwbGF5bGlzdFxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgKHRoaXMubWFpbkRldGFpbHMgfHwgIW5ld0RldGFpbHMubGl2ZSkpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0cmFjay5kZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkLFxuICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3aWxsIG5vdCBiZSBidWZmZXJlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGNvbnNvbGUuYXNzZXJ0KHRyYWNrLCAnQXVkaW8gdHJhY2sgaXMgZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgdmFyIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgIGNvbnNvbGUuYXNzZXJ0KGRldGFpbHMsICdBdWRpbyB0cmFjayBkZXRhaWxzIGFyZSBkZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MnKTtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXG4gICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICB2YXIgaW5pdFNlZ21lbnREYXRhID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2ZyYWckaW5pdFNlZ21lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LmRhdGE7XG4gICAgaWYgKGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsICcnLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coXCJVbmtub3duIHZpZGVvIFBUUyBmb3IgY2MgXCIgKyBmcmFnLmNjICsgXCIsIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLHRyYWNrIFwiICsgdHJhY2tJZCk7XG4gICAgICB2YXIgX3RoaXMkd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSB8fCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIGNhY2hlOiBuZXcgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdKCksXG4gICAgICAgICAgY29tcGxldGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlID0gX3RoaXMkd2FpdGluZ0RhdGEuY2FjaGU7XG4gICAgICBjYWNoZS5wdXNoKG5ldyBVaW50OEFycmF5KHBheWxvYWQpKTtcbiAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSB0aGlzLnZpZGVvVHJhY2tDQztcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEuY29tcGxldGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGZyYWdMb2FkZWREYXRhKTtcbiAgfTtcbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCAvKiBldmVudDogRXZlbnRzLkJVRkZFUl9SRVNFVCAqL1xuICApIHtcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gc291cmNlYnVmZmVyc1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gIH07XG4gIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXIgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEudHJhY2tzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyIHx8IG51bGw7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICBpZiAoZnJhZy50eXBlICE9PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgaWYgKChfcmVmMyA9IHRoaXMudmlkZW9CdWZmZXIgfHwgdGhpcy5tZWRpYSkgIT09IG51bGwgJiYgX3JlZjMgIT09IHZvaWQgMCAmJiBfcmVmMy5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSBvciBjb25jbHVkaW5nIHRoZSBhdWRpbyBzd2l0Y2g7IG90aGVyd2lzZSwgdGhlIHN3aXRjaGVkLXRvIHRyYWNrIHdpbGwgbm90IGJ1ZmZlclxuICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIiwgYXVkaW9Td2l0Y2g6IFwiICsgdGhpcy5hdWRpb1N3aXRjaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwge1xuICAgICAgICAgIGlkOiB0aGlzLnRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH07XG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLnR5cGUgPT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SKSB7XG4gICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fLkVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyBUT0RPOiBTa2lwIGZyYWdtZW50cyB0aGF0IGRvIG5vdCBiZWxvbmcgdG8gdGhpcy5mcmFnQ3VycmVudCBhdWRpby1ncm91cCBpZFxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXy5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXy5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLkVSUk9SICYmIHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5FUlJPUiA6IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICAgICAgICB0aGlzLndhcm4oZGF0YS5kZXRhaWxzICsgXCIgd2hpbGUgbG9hZGluZyBmcmFnLCBzd2l0Y2hpbmcgdG8gXCIgKyB0aGlzLnN0YXRlICsgXCIgc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgdmFyIGZsdXNoQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICB0aGlzLndhcm4oJ0J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBhdWRpbyBidWZmZXInKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWY0KSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlO1xuICAgIGlmICh0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgdmFyIF9pZDMkc2FtcGxlcztcbiAgICB2YXIgaWQgPSAnYXVkaW8nO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YSA9IHRyYW5zbXV4UmVzdWx0LmNodW5rTWV0YTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMud2FybihcIlRoZSBsb2FkaW5nIGNvbnRleHQgY2hhbmdlZCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIgKyBjaHVua01ldGEuc24gKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCArIFwiLiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgZGV0YWlscyA9IGNvbnRleHQubGV2ZWwuZGV0YWlscztcbiAgICB2YXIgYXVkaW8gPSByZW11eFJlc3VsdC5hdWRpbyxcbiAgICAgIHRleHQgPSByZW11eFJlc3VsdC50ZXh0LFxuICAgICAgaWQzID0gcmVtdXhSZXN1bHQuaWQzLFxuICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHx8ICFkZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2ggJiYgYXVkaW8pIHtcbiAgICAgIHRoaXMuY29tcGxldGVBdWRpb1N3aXRjaCgpO1xuICAgIH1cbiAgICBpZiAoaW5pdFNlZ21lbnQgIT09IG51bGwgJiYgaW5pdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICB9KTtcbiAgICAgIC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgIH1cblxuICAgIGlmIChhdWRpbykge1xuICAgICAgdmFyIHN0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyA9IGF1ZGlvLmVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMgPSBhdWRpby5zdGFydERUUyxcbiAgICAgICAgZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUzogc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFM6IHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUzogZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoYXVkaW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgfVxuICAgIGlmIChpZDMgIT09IG51bGwgJiYgaWQzICE9PSB2b2lkIDAgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMgIT09IHZvaWQgMCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZW1pdHRlZElEMyA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICB9LCBpZDMpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGVtaXR0ZWRUZXh0ID0gX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGRldGFpbHM6IGRldGFpbHNcbiAgICAgIH0sIHRleHQpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fYnVmZmVySW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfYnVmZmVySW5pdFNlZ21lbnQodHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gdHJhbnNtdXhlclxuICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICB2YXIgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XG4gICAgdHJhY2suaWQgPSAnYXVkaW8nO1xuICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbcGFyc2VkXT1bXCIgKyB0cmFjay5jb2RlYyArIFwiXVwiKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICBpZiAoaW5pdFNlZ21lbnQgIT09IG51bGwgJiYgaW5pdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICBkYXRhOiBpbml0U2VnbWVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuICBfcHJvdG8ubG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gbG9hZEZyYWdtZW50KGZyYWcsIHRyYWNrRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcblxuICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcbiAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5GcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCB0cmFja0RldGFpbHMpO1xuICAgICAgfSBlbHNlIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciBcIiArIGZyYWcuY2MgKyBcIiBvZiBsaXZlIHN0cmVhbSBiZWZvcmUgbG9hZGluZyBhdWRpbyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIHRoaXMudHJhY2tJZCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5jb21wbGV0ZUF1ZGlvU3dpdGNoID0gZnVuY3Rpb24gY29tcGxldGVBdWRpb1N3aXRjaCgpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwge1xuICAgICAgaWQ6IHRyYWNrSWRcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChBdWRpb1N0cmVhbUNvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG52YXIgQXVkaW9UcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUGxheWxpc3RDb250cm9sbCkge1xuICBfaW5oZXJpdHNMb29zZShBdWRpb1RyYWNrQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcbiAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICBfdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnRyYWNrTmFtZSA9ICcnO1xuICAgIF90aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDA7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9ICcnO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzIHx8IFtdO1xuICB9O1xuICBfcHJvdG8ub25BdWRpb1RyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgIHRoaXMud2FybihcIkludmFsaWQgYXVkaW8gdHJhY2sgaWQgXCIgKyBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJEZXRhaWxzID0gY3VycmVudFRyYWNrLmRldGFpbHM7XG4gICAgY3VycmVudFRyYWNrLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdGhpcy5sb2coXCJhdWRpb1RyYWNrIFwiICsgaWQgKyBcIiBsb2FkZWQgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdXCIpO1xuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH07XG4gIF9wcm90by5vbkxldmVsU3dpdGNoaW5nID0gZnVuY3Rpb24gb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH07XG4gIF9wcm90by5zd2l0Y2hMZXZlbCA9IGZ1bmN0aW9uIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmICghKGxldmVsSW5mbyAhPT0gbnVsbCAmJiBsZXZlbEluZm8gIT09IHZvaWQgMCAmJiBsZXZlbEluZm8uYXVkaW9Hcm91cElkcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmdyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcbiAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhYXVkaW9UcmFja3Muc29tZShmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrLmRlZmF1bHQ7XG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gYXVkaW9UcmFja3M7XG4gICAgICB2YXIgYXVkaW9UcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBhdWRpb1RyYWNrczogYXVkaW9UcmFja3NcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIGF1ZGlvIHRyYWNrcywgXCIgKyBhdWRpb1RyYWNrcy5sZW5ndGggKyBcIiB0cmFjayhzKSBmb3VuZCBpbiBcXFwiXCIgKyBhdWRpb0dyb3VwSWQgKyBcIlxcXCIgZ3JvdXAtaWRcIik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICB0aGlzLnNlbGVjdEluaXRpYWxUcmFjaygpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5vbkVycm9yLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpO1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiBkYXRhLmNvbnRleHQuZ3JvdXBJZCA9PT0gdGhpcy5ncm91cElkKSB7XG4gICAgICB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChkYXRhKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5zZXRBdWRpb1RyYWNrID0gZnVuY3Rpb24gc2V0QXVkaW9UcmFjayhuZXdJZCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybignSW52YWxpZCBpZCBwYXNzZWQgdG8gYXVkaW8tdHJhY2sgY29udHJvbGxlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHZhciBsYXN0VHJhY2sgPSB0cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICB0aGlzLmxvZyhcIk5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggXCIgKyBuZXdJZCk7XG4gICAgdmFyIHRyYWNrID0gdHJhY2tzW25ld0lkXTtcbiAgICB2YXIgaWQgPSB0cmFjay5pZCxcbiAgICAgIF90cmFjayRncm91cElkID0gdHJhY2suZ3JvdXBJZCxcbiAgICAgIGdyb3VwSWQgPSBfdHJhY2skZ3JvdXBJZCA9PT0gdm9pZCAwID8gJycgOiBfdHJhY2skZ3JvdXBJZCxcbiAgICAgIG5hbWUgPSB0cmFjay5uYW1lLFxuICAgICAgdHlwZSA9IHRyYWNrLnR5cGUsXG4gICAgICB1cmwgPSB0cmFjay51cmw7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgICAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG4gICAgaWYgKHRyYWNrLmRldGFpbHMgJiYgIXRyYWNrLmRldGFpbHMubGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICB9O1xuICBfcHJvdG8uc2VsZWN0SW5pdGlhbFRyYWNrID0gZnVuY3Rpb24gc2VsZWN0SW5pdGlhbFRyYWNrKCkge1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zb2xlLmFzc2VydChhdWRpb1RyYWNrcy5sZW5ndGgsICdJbml0aWFsIGF1ZGlvIHRyYWNrIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRyYWNrcyBhcmUga25vd24nKTtcbiAgICB2YXIgY3VycmVudEF1ZGlvVHJhY2tOYW1lID0gdGhpcy50cmFja05hbWU7XG4gICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRBdWRpb1RyYWNrTmFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuICAgIGlmICh0cmFja0lkICE9PSAtMSkge1xuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKHRyYWNrSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oXCJObyB0cmFjayBmb3VuZCBmb3IgcnVubmluZyBhdWRpbyBncm91cC1JRDogXCIgKyB0aGlzLmdyb3VwSWQpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5maW5kVHJhY2tJZCA9IGZ1bmN0aW9uIGZpbmRUcmFja0lkKG5hbWUpIHtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrIHx8IHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmxvYWRQbGF5bGlzdC5jYWxsKHRoaXMpO1xuICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW3RoaXMudHJhY2tJZF07XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFRyYWNrKGF1ZGlvVHJhY2spKSB7XG4gICAgICB2YXIgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgdGhpcy5sb2coXCJsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0IGZvciBpZDogXCIgKyBpZCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9jcmVhdGVDbGFzcyhBdWRpb1RyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiYXVkaW9UcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEF1ZGlvVHJhY2tDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xldmVsICovIFwiLi9zcmMvdHlwZXMvbGV2ZWwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuXG5cblxuXG52YXIgQmFzZVBsYXlsaXN0Q29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIoaGxzLCBsb2dQcmVmaXgpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZy5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIsIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICB0aGlzLndhcm4gPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLndhcm4uYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEJhc2VQbGF5bGlzdENvbnRyb2xsZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICB9O1xuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCAmJiAoZGF0YS50eXBlID09PSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SIHx8IGRhdGEudHlwZSA9PT0gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUikpIHtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5jbGVhclRpbWVyID0gZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IC0xO1xuICB9O1xuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9O1xuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfTtcbiAgX3Byb3RvLnN3aXRjaFBhcmFtcyA9IGZ1bmN0aW9uIHN3aXRjaFBhcmFtcyhwbGF5bGlzdFVyaSwgcHJldmlvdXMpIHtcbiAgICB2YXIgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09PSBudWxsIHx8IHByZXZpb3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICB2YXIgdXJpID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIud2FybihcIkNvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogXCIgKyBlcnJvcik7XG4gICAgICAgICAgdXJpID0gYXR0ci5VUkkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc2xpY2UoLXVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pIHx8IChwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXMubGFzdFBhcnRTbik7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSkgfHwgKHByZXZpb3VzID09PSBudWxsIHx8IHByZXZpb3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydEluZGV4KTtcbiAgICAgICAgICBpZiAodGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEdvYWwgPSBNYXRoLm1pbihwcmV2aW91cy5hZ2UgLSBwcmV2aW91cy5wYXJ0VGFyZ2V0LCBwcmV2aW91cy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkhsc1NraXAuTm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5zaG91bGRMb2FkVHJhY2sgPSBmdW5jdGlvbiBzaG91bGRMb2FkVHJhY2sodHJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmIHRyYWNrICYmICEhdHJhY2sudXJsICYmICghdHJhY2suZGV0YWlscyB8fCB0cmFjay5kZXRhaWxzLmxpdmUpO1xuICB9O1xuICBfcHJvdG8ucGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiBwbGF5bGlzdExvYWRlZChpbmRleCwgZGF0YSwgcHJldmlvdXNEZXRhaWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgIHN0YXRzID0gZGF0YS5zdGF0cztcblxuICAgIC8vIFNldCBsYXN0IHVwZGF0ZWQgZGF0ZS10aW1lXG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gTWF0aC5tYXgoMCwgbm93IC0gc3RhdHMubG9hZGluZy5maXJzdCkgOiAwO1xuICAgIGRldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IERhdGUubm93KCkgLSBlbGFwc2VkO1xuXG4gICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgcHJldmlvdXNEZXRhaWxzICE9PSBudWxsICYmIHByZXZpb3VzRGV0YWlscyAhPT0gdm9pZCAwICYmIHByZXZpb3VzRGV0YWlscy5saXZlKSB7XG4gICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG4gICAgICBpZiAocHJldmlvdXNEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMubG9nKFwibGl2ZSBwbGF5bGlzdCBcIiArIGluZGV4ICsgXCIgXCIgKyAoZGV0YWlscy5hZHZhbmNlZCA/ICdSRUZSRVNIRUQgJyArIGRldGFpbHMubGFzdFBhcnRTbiArICctJyArIGRldGFpbHMubGFzdFBhcnRJbmRleCA6ICdNSVNTRUQnKSk7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAoMCxfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ubWVyZ2VEZXRhaWxzKShwcmV2aW91c0RldGFpbHMsIGRldGFpbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgdmFyIG1zbiA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5lbmRTTiAmJiBkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICAgIC8vIExvYWQgbGV2ZWwgd2l0aCBMTC1ITFMgZGVsaXZlcnkgZGlyZWN0aXZlc1xuICAgICAgICB2YXIgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIHZhciBsYXN0UGFydFNuID0gZGV0YWlscy5sYXN0UGFydFNuO1xuICAgICAgICB2YXIgZW5kU24gPSBkZXRhaWxzLmVuZFNOO1xuICAgICAgICB2YXIgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgdmFyIGhhc1BhcnRzID0gbGFzdFBhcnRJbmRleCAhPT0gLTE7XG4gICAgICAgIHZhciBsYXN0UGFydCA9IGxhc3RQYXJ0U24gPT09IGVuZFNuO1xuICAgICAgICAvLyBXaGVuIGxvdyBsYXRlbmN5IG1vZGUgaXMgZGlzYWJsZWQsIHdlJ2xsIHNraXAgcGFydCByZXF1ZXN0cyBvbmNlIHRoZSBsYXN0IHBhcnQgaW5kZXggaXMgZm91bmRcbiAgICAgICAgdmFyIG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICB2YXIgbGFzdEFkdmFuY2VkID0gZGV0YWlscy5hZ2U7XG4gICAgICAgIHZhciBjZG5BZ2UgPSBsYXN0QWR2YW5jZWQgKyBkZXRhaWxzLmFnZUhlYWRlcjtcbiAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4oY2RuQWdlIC0gZGV0YWlscy5wYXJ0VGFyZ2V0LCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41KTtcbiAgICAgICAgaWYgKGN1cnJlbnRHb2FsID4gMCkge1xuICAgICAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdGVkIHRvIGdldCB0aGUgbmV4dCBvciBsYXRlc3QgcGxheWxpc3QgdXBkYXRlLCBidXQgY3VycmVudEdvYWwgaW5jcmVhc2VkLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBlaXRoZXIgY2FuJ3QgY2F0Y2h1cCwgb3IgdGhlIFwiYWdlXCIgaGVhZGVyIGNhbm5vdCBiZSB0cnVzdGVkLlxuICAgICAgICAgICAgdGhpcy53YXJuKFwiQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogXCIgKyBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCArIFwiIHRvOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgd2l0aCBwbGF5bGlzdCBhZ2U6IFwiICsgZGV0YWlscy5hZ2UpO1xuICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IE1hdGgucm91bmQoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIC8gZGV0YWlscy5wYXJ0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcGFydCArPSBwYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nKFwiQ0ROIFR1bmUtaW4gYWdlOiBcIiArIGRldGFpbHMuYWdlSGVhZGVyICsgXCJzIGxhc3QgYWR2YW5jZWQgXCIgKyBsYXN0QWR2YW5jZWQudG9GaXhlZCgyKSArIFwicyBnb2FsOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgc2tpcCBzbiBcIiArIHNlZ21lbnRzICsgXCIgdG8gcGFydCBcIiArIHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzLnR1bmVJbkdvYWwgPSBjdXJyZW50R29hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgICAgaWYgKGxvd0xhdGVuY3lNb2RlIHx8ICFsYXN0UGFydCkge1xuICAgICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5obHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgdmFyIHBvc2l0aW9uID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIC0gYnVmZmVySW5mby5sZW4gOiAwO1xuICAgICAgdmFyIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gKGRldGFpbHMuZWRnZSAtIHBvc2l0aW9uKSAqIDEwMDA7XG4gICAgICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSAoMCxfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY29tcHV0ZVJlbG9hZEludGVydmFsKShkZXRhaWxzLCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyk7XG4gICAgICBpZiAoIWRldGFpbHMudXBkYXRlZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAobm93ID4gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgKyByZWxvYWRJbnRlcnZhbCAtIChkZXRhaWxzLnBhcnRUYXJnZXQgKiAxMDAwIHx8IDEwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gKHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEgPyBub3cgOiB0aGlzLnJlcXVlc3RTY2hlZHVsZWQpICsgcmVsb2FkSW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICB2YXIgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gTWF0aC5tYXgoMCwgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbiAgICAgIHRoaXMubG9nKFwicmVsb2FkIGxpdmUgcGxheWxpc3QgXCIgKyBpbmRleCArIFwiIGluIFwiICsgTWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpICsgXCIgbXNcIik7XG4gICAgICAvLyAgICAgdGhpcy5sb2coXG4gICAgICAvLyAgICAgICBgbGl2ZSByZWxvYWQgJHtkZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfVxuICAgICAgLy8gcmVsb2FkIGluICR7ZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlIC8gMTAwMH1cbiAgICAgIC8vIHJvdW5kIHRyaXAgJHsoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSAvIDEwMDB9XG4gICAgICAvLyBkaWZmICR7XG4gICAgICAvLyAgIChyZWxvYWRJbnRlcnZhbCAtXG4gICAgICAvLyAgICAgKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSArIHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCkpIC9cbiAgICAgIC8vICAgMTAwMFxuICAgICAgLy8gfVxuICAgICAgLy8gcmVsb2FkIGludGVydmFsICR7cmVsb2FkSW50ZXJ2YWwgLyAxMDAwfVxuICAgICAgLy8gdGFyZ2V0IGR1cmF0aW9uICR7ZGV0YWlscy50YXJnZXRkdXJhdGlvbn1cbiAgICAgIC8vIGRpc3RhbmNlIHRvIGVkZ2UgJHtkaXN0YW5jZVRvTGl2ZUVkZ2VNcyAvIDEwMDB9YFxuICAgICAgLy8gICAgICk7XG5cbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICB9LCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXREZWxpdmVyeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiBnZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCkge1xuICAgIHZhciBza2lwID0gKDAsX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0U2tpcFZhbHVlKShkZXRhaWxzLCBtc24pO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPT0gbnVsbCAmJiBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPT0gdm9pZCAwICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uSGxzU2tpcC5ObztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5IbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gIH07XG4gIF9wcm90by5yZXRyeUxvYWRpbmdPckZhaWwgPSBmdW5jdGlvbiByZXRyeUxvYWRpbmdPckZhaWwoZXJyb3JFdmVudCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgdmFyIHJldHJ5ID0gdGhpcy5yZXRyeUNvdW50IDwgY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIHRoaXMucmV0cnlDb3VudCsrO1xuICAgICAgaWYgKGVycm9yRXZlbnQuZGV0YWlscy5pbmRleE9mKCdMb2FkVGltZU91dCcpID4gLTEgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9PSBudWxsICYmIF9lcnJvckV2ZW50JGNvbnRleHQgIT09IHZvaWQgMCAmJiBfZXJyb3JFdmVudCRjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAvLyBUaGUgTEwtSExTIHJlcXVlc3QgYWxyZWFkeSB0aW1lZCBvdXQgc28gcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy53YXJuKFwicmV0cnkgcGxheWxpc3QgbG9hZGluZyAjXCIgKyB0aGlzLnJldHJ5Q291bnQgKyBcIiBhZnRlciBcXFwiXCIgKyBlcnJvckV2ZW50LmRldGFpbHMgKyBcIlxcXCJcIik7XG4gICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgdGltZW91dFxuICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCB0aGlzLnJldHJ5Q291bnQpICogY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbC90cmFjayByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5sb2FkUGxheWxpc3QoKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB0aGlzLndhcm4oXCJyZXRyeSBwbGF5bGlzdCBsb2FkaW5nICNcIiArIHRoaXMucmV0cnlDb3VudCArIFwiIGluIFwiICsgZGVsYXkgKyBcIiBtcyBhZnRlciBcXFwiXCIgKyBlcnJvckV2ZW50LmRldGFpbHMgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihcImNhbm5vdCByZWNvdmVyIGZyb20gZXJyb3IgXFxcIlwiICsgZXJyb3JFdmVudC5kZXRhaWxzICsgXCJcXFwiXCIpO1xuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXRyeTtcbiAgfTtcbiAgcmV0dXJuIEJhc2VQbGF5bGlzdENvbnRyb2xsZXI7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiU3RhdGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3RhdGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmFzZVN0cmVhbUNvbnRyb2xsZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGFza19sb29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90YXNrLWxvb3AgKi8gXCIuL3NyYy90YXNrLWxvb3AudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LWZpbmRlcnMgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190aW1lX3Jhbmdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RpbWUtcmFuZ2VzICovIFwiLi9zcmMvdXRpbHMvdGltZS1yYW5nZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcblxuXG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xudmFyIEJhc2VTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGFza0xvb3ApIHtcbiAgX2luaGVyaXRzTG9vc2UoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIF9UYXNrTG9vcCk7XG4gIGZ1bmN0aW9uIEJhc2VTdHJlYW1Db250cm9sbGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsIGxvZ1ByZWZpeCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UYXNrTG9vcC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGxzID0gdm9pZCAwO1xuICAgIF90aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICBfdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICBfdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICBfdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgX3RoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICBfdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gMDtcbiAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICBfdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIF90aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIF90aGlzLnJldHJ5RGF0ZSA9IDA7XG4gICAgX3RoaXMubGV2ZWxzID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnbWVudExvYWRlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5rZXlMb2FkZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMubGV2ZWxMYXN0TG9hZGVkID0gbnVsbDtcbiAgICBfdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuaW5pdFBUUyA9IFtdO1xuICAgIF90aGlzLm9udnNlZWtpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICBfdGhpcy5sb2dQcmVmaXggPSAnJztcbiAgICBfdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgX3RoaXMud2FybiA9IHZvaWQgMDtcbiAgICBfdGhpcy5sb2dQcmVmaXggPSBsb2dQcmVmaXg7XG4gICAgX3RoaXMubG9nID0gX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmxvZ2dlci5sb2cuYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18ubG9nZ2VyLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgX3RoaXMud2FybiA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5sb2dnZXIud2Fybi5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5sb2dnZXIsIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdKGhscy5jb25maWcpO1xuICAgIF90aGlzLmtleUxvYWRlciA9IGtleUxvYWRlcjtcbiAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBfdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0oaGxzLmNvbmZpZyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5FdmVudHMuTEVWRUxfU1dJVENISU5HLCBfdGhpcy5vbkxldmVsU3dpdGNoaW5nLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfTtcbiAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICA7XG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge307XG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlci5hYm9ydCgpO1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH07XG4gIF9wcm90by5fc3RyZWFtRW5kZWQgPSBmdW5jdGlvbiBfc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgLy8gSWYgcGxheWxpc3QgaXMgbGl2ZSwgdGhlcmUgaXMgYW5vdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciB0aGUgY3VycmVudCByYW5nZSwgbm90aGluZyBidWZmZXJlZCwgbWVkaWEgaXMgZGV0YWNoZWQsXG4gICAgLy8gb2Ygbm90aGluZyBsb2FkaW5nL2xvYWRlZCByZXR1cm4gZmFsc2VcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgIWJ1ZmZlckluZm8uZW5kIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICAvLyBTaW5jZSB0aGUgbGFzdCBwYXJ0IGlzbid0IGd1YXJhbnRlZWQgdG8gY29ycmVzcG9uZCB0byB0aGUgbGFzdCBwbGF5bGlzdCBzZWdtZW50IGZvciBMb3ctTGF0ZW5jeSBITFMsXG4gICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgIGlmIChwYXJ0TGlzdCAhPT0gbnVsbCAmJiBwYXJ0TGlzdCAhPT0gdm9pZCAwICYmIHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICB2YXIgbGFzdFBhcnRCdWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgbGFzdFBhcnQuc3RhcnQgKyBsYXN0UGFydC5kdXJhdGlvbiAvIDIpO1xuICAgICAgcmV0dXJuIGxhc3RQYXJ0QnVmZmVyZWQ7XG4gICAgfVxuICAgIHZhciBwbGF5bGlzdFR5cGUgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuaXNFbmRMaXN0QXBwZW5kZWQocGxheWxpc3RUeXBlKTtcbiAgfTtcbiAgX3Byb3RvLmdldExldmVsRGV0YWlscyA9IGZ1bmN0aW9uIGdldExldmVsRGV0YWlscygpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbHMkdGhpcyRsZXY7XG4gICAgICByZXR1cm4gKF90aGlzJGxldmVscyR0aGlzJGxldiA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXSkgPT09IG51bGwgfHwgX3RoaXMkbGV2ZWxzJHRoaXMkbGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbHMkdGhpcyRsZXYuZGV0YWlscztcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgIT09IG51bGwgJiYgbWVkaWEgIT09IHZvaWQgMCAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnNlZWtpbmcgJiYgdGhpcy5vbnZlbmRlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiBvbk1lZGlhU2Vla2luZygpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIsXG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7XG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLmxvZyhcIm1lZGlhIHNlZWtpbmcgdG8gXCIgKyAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWUpICsgXCIsIHN0YXRlOiBcIiArIHN0YXRlKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAvLyBTZWVraW5nIHdoaWxlIGZyYWcgbG9hZCBpcyBpbiBwcm9ncmVzc1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgdmFyIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgdmFyIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgLy8gaWYgc2Vla2luZyBvdXQgb2YgYnVmZmVyZWQgcmFuZ2Ugb3IgaW50byBuZXcgb25lXG4gICAgICBpZiAoIWJ1ZmZlckluZm8ubGVuIHx8IGZyYWdFbmRPZmZzZXQgPCBidWZmZXJJbmZvLnN0YXJ0IHx8IGZyYWdTdGFydE9mZnNldCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICAgIHZhciBwYXN0RnJhZ21lbnQgPSBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQ7XG4gICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmICFidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gQXN5bmMgdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH07XG4gIF9wcm90by5vbk1lZGlhRW5kZWQgPSBmdW5jdGlvbiBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9O1xuICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICB9O1xuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIF9UYXNrTG9vcC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWluZy5jYWxsKHRoaXMpO1xuICB9O1xuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5rZXlMb2FkZXIgPSB0aGlzLmZyYWdtZW50TG9hZGVyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIF9UYXNrTG9vcC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkLmNhbGwodGhpcyk7XG4gIH07XG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9O1xuICBfcHJvdG8uX2xvYWRGcmFnRm9yUGxheWJhY2sgPSBmdW5jdGlvbiBfbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB2YXIgcHJvZ3Jlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIHByb2dyZXNzQ2FsbGJhY2soZGF0YSkge1xuICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgX3RoaXMyLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAoZGF0YS5wYXJ0ID8gJyBwOiAnICsgZGF0YS5wYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2FzIGRyb3BwZWQgZHVyaW5nIGRvd25sb2FkLlwiKTtcbiAgICAgICAgX3RoaXMyLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50Kys7XG4gICAgICBfdGhpczIuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlIHdlIHByb2JhYmx5IG5lZWRlZCB0byBiYWNrdHJhY2sgb3IgYXJlIHdhaXRpbmcgZm9yIG1vcmUgcGFydHNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgdmFyIHN0YXRlID0gX3RoaXMyLnN0YXRlO1xuICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgIV90aGlzMi5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgX3RoaXMyLmxvZyhcIkxvYWRlZCBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwpO1xuICAgICAgICBfdGhpczIuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgIF90aGlzMi5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKF90aGlzMi5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCBfdGhpczIuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMi53YXJuKHJlYXNvbik7XG4gICAgICBfdGhpczIucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIHZhciBmbHVzaFNjb3BlID0ge1xuICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTtcbiAgICAvLyBSZXNldCBsb2FkIGVycm9ycyBvbiBmbHVzaFxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH07XG4gIF9wcm90by5fbG9hZEluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2xvYWRJbml0U2VnbWVudChmcmFnLCBkZXRhaWxzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBkZXRhaWxzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEgfHwgX3RoaXMzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhX3RoaXMzLmxldmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMzLmhscztcbiAgICAgIHZhciBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEuaXYgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xuICAgICAgICByZXR1cm4gX3RoaXMzLmRlY3J5cHRlci5kZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IF90aGlzMy5mcmFnQ3VycmVudCxcbiAgICAgICAgaGxzID0gX3RoaXMzLmhscyxcbiAgICAgICAgbGV2ZWxzID0gX3RoaXMzLmxldmVscztcbiAgICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgICB9XG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsc1tmcmFnLmxldmVsXS5kZXRhaWxzO1xuICAgICAgY29uc29sZS5hc3NlcnQoZGV0YWlscywgJ0xldmVsIGRldGFpbHMgYXJlIGRlZmluZWQgd2hlbiBpbml0IHNlZ21lbnQgaXMgbG9hZGVkJyk7XG4gICAgICB2YXIgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgX3RoaXMzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIF90aGlzMy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNpbGVuY2UgRlJBR19CVUZGRVJFRCBldmVudCBpZiBmcmFnQ3VycmVudCBpcyBudWxsXG4gICAgICBpZiAoZGF0YS5mcmFnID09PSBmcmFnQ3VycmVudCkge1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgZnJhZzogZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX3RoaXMzLnRpY2soKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoX3RoaXMzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IF90aGlzMy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMzLndhcm4ocmVhc29uKTtcbiAgICAgIF90aGlzMy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmZyYWdDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsIHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcudXJsSWQgIT09IGZyYWdDdXJyZW50LnVybElkO1xuICB9O1xuICBfcHJvdG8uZnJhZ0J1ZmZlcmVkQ29tcGxldGUgPSBmdW5jdGlvbiBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIF9mcmFnJHN0YXJ0UFRTLCBfZnJhZyRlbmRQVFMsIF90aGlzJGZyYWdDdXJyZW50LCBfdGhpcyRmcmFnUHJldmlvdXM7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKFwiQnVmZmVyZWQgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgXCIgKyAodGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiIFwiICsgZnJhZy5sZXZlbCArIFwiIChmcmFnOltcIiArICgoX2ZyYWckc3RhcnRQVFMgPSBmcmFnLnN0YXJ0UFRTKSAhPSBudWxsID8gX2ZyYWckc3RhcnRQVFMgOiBOYU4pLnRvRml4ZWQoMykgKyBcIi1cIiArICgoX2ZyYWckZW5kUFRTID0gZnJhZy5lbmRQVFMpICE9IG51bGwgPyBfZnJhZyRlbmRQVFMgOiBOYU4pLnRvRml4ZWQoMykgKyBcIl0gPiBidWZmZXI6XCIgKyAobWVkaWEgPyBfdXRpbHNfdGltZV9yYW5nZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXCJkZWZhdWx0XCJdLnRvU3RyaW5nKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKSkgOiAnKGRldGFjaGVkKScpICsgXCIpXCIpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGZyYWcudHlwZSA9PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoICYmICgoX3RoaXMkZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRmcmFnQ3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQuc24pID09PSAoKF90aGlzJGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzKSA9PT0gbnVsbCB8fCBfdGhpcyRmcmFnUHJldmlvdXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGZyYWdQcmV2aW91cy5zbikpIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5zZWVrVG9TdGFydFBvcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcbiAgX3Byb3RvLnNlZWtUb1N0YXJ0UG9zID0gZnVuY3Rpb24gc2Vla1RvU3RhcnRQb3MoKSB7fTtcbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWRFbmREYXRhLmZyYWcsXG4gICAgICBwYXJ0ID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydCxcbiAgICAgIHBhcnRzTG9hZGVkID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydHNMb2FkZWQ7XG4gICAgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuICAgIHZhciBjb21wbGV0ZSA9ICFwYXJ0c0xvYWRlZCB8fCBwYXJ0c0xvYWRlZC5sZW5ndGggPT09IDAgfHwgcGFydHNMb2FkZWQuc29tZShmdW5jdGlvbiAoZnJhZ0xvYWRlZCkge1xuICAgICAgcmV0dXJuICFmcmFnTG9hZGVkO1xuICAgIH0pO1xuICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5DaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCArIDEsIDAsIHBhcnQgPyBwYXJ0LmluZGV4IDogLTEsICFjb21wbGV0ZSk7XG4gICAgdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICA7XG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZnJhZykge307XG4gIF9wcm90by5fZG9GcmFnTG9hZCA9IGZ1bmN0aW9uIF9kb0ZyYWdMb2FkKGZyYWcsIGRldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGEsXG4gICAgICBfdGhpczQgPSB0aGlzO1xuICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgIH1cbiAgICB2YXIga2V5TG9hZGluZ1Byb21pc2UgPSBudWxsO1xuICAgIGlmIChmcmFnLmVuY3J5cHRlZCAmJiAhKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpICE9PSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhICE9PSB2b2lkIDAgJiYgX2ZyYWckZGVjcnlwdGRhdGEua2V5KSkge1xuICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLCBcIiArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgaWYgKCFfdGhpczQuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICBfdGhpczQuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICBpZiAoX3RoaXM0LnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICAgICAgX3RoaXM0LnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLktFWV9MT0FESU5HLCB7XG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgICAgdGhpcy50aHJvd0lmRnJhZ0NvbnRleHRDaGFuZ2VkKCdLRVlfTE9BRElORycpO1xuICAgIH0gZWxzZSBpZiAoIWZyYWcuZW5jcnlwdGVkICYmIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXlMb2FkZXIubG9hZENsZWFyKGZyYWcsIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzKTtcbiAgICB9XG4gICAgdGFyZ2V0QnVmZmVyVGltZSA9IE1hdGgubWF4KGZyYWcuc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUgfHwgMCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGRldGFpbHMpIHtcbiAgICAgIHZhciBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG4gICAgICBpZiAocGFydExpc3QgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA+IGZyYWcuZW5kICYmIGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSB0aGlzLmdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0TGlzdFtwYXJ0SW5kZXhdO1xuICAgICAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBwYXJ0IHNuOiBcIiArIGZyYWcuc24gKyBcIiBwOiBcIiArIHBhcnQuaW5kZXggKyBcIiBjYzogXCIgKyBmcmFnLmNjICsgXCIgb2YgcGxheWxpc3QgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdIHBhcnRzIFswLVwiICsgcGFydEluZGV4ICsgXCItXCIgKyAocGFydExpc3QubGVuZ3RoIC0gMSkgKyBcIl0gXCIgKyAodGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiOiBcIiArIGZyYWcubGV2ZWwgKyBcIiwgdGFyZ2V0OiBcIiArIHBhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKSk7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gcGFydC5zdGFydCArIHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5FdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydExpc3RbcGFydEluZGV4XSxcbiAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnRocm93SWZGcmFnQ29udGV4dENoYW5nZWQoJ0ZSQUdfTE9BRElORyBwYXJ0cycpO1xuICAgICAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleUxvYWRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IF90aGlzNC5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnRMaXN0LCBwYXJ0SW5kZXgsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnRMaXN0LCBwYXJ0SW5kZXgsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghZnJhZy51cmwgfHwgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZyhcIkxvYWRpbmcgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIFwiICsgKGRldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnKSArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTtcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShmcmFnLnNuKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICB9KTtcbiAgICB0aGlzLnRocm93SWZGcmFnQ29udGV4dENoYW5nZWQoJ0ZSQUdfTE9BRElORycpO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgdmFyIGRhdGFPblByb2dyZXNzID0gdGhpcy5jb25maWcucHJvZ3Jlc3NpdmU7XG4gICAgaWYgKGRhdGFPblByb2dyZXNzICYmIGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICByZXR1cm4ga2V5TG9hZGluZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoa2V5TG9hZGVkRGF0YSkge1xuICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgX3RoaXM0LmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhID09PSBudWxsIHx8IGtleUxvYWRlZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM0LmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGxvYWQgdW5lbmNyeXB0ZWQgZnJhZ21lbnQgZGF0YSB3aXRoIHByb2dyZXNzIGV2ZW50LFxuICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGZyYWdMb2FkZWREYXRhID0gX3JlZlswXTtcbiAgICAgIGlmICghZGF0YU9uUHJvZ3Jlc3MgJiYgZnJhZ0xvYWRlZERhdGEgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnTG9hZGVkRGF0YTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by50aHJvd0lmRnJhZ0NvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gdGhyb3dJZkZyYWdDb250ZXh0Q2hhbmdlZChjb250ZXh0KSB7XG4gICAgLy8gZXhpdCBpZiBjb250ZXh0IGNoYW5nZWQgZHVyaW5nIGV2ZW50IGxvb3BcbiAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBcIiArIGNvbnRleHQpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRvRnJhZ1BhcnRzTG9hZCA9IGZ1bmN0aW9uIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0TGlzdCwgcGFydEluZGV4LCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBwYXJ0c0xvYWRlZCA9IFtdO1xuICAgICAgdmFyIGxvYWRQYXJ0SW5kZXggPSBmdW5jdGlvbiBsb2FkUGFydEluZGV4KGluZGV4KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaW5kZXhdO1xuICAgICAgICBfdGhpczUuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQoZnJhZywgcGFydCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAocGFydExvYWRlZERhdGEpIHtcbiAgICAgICAgICBwYXJ0c0xvYWRlZFtwYXJ0LmluZGV4XSA9IHBhcnRMb2FkZWREYXRhO1xuICAgICAgICAgIHZhciBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydDtcbiAgICAgICAgICBfdGhpczUuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5GUkFHX0xPQURFRCwgcGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIHZhciBuZXh0UGFydCA9IHBhcnRMaXN0W2luZGV4ICsgMV07XG4gICAgICAgICAgaWYgKG5leHRQYXJ0ICYmIG5leHRQYXJ0LmZyYWdtZW50ID09PSBmcmFnKSB7XG4gICAgICAgICAgICBsb2FkUGFydEluZGV4KGluZGV4ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgcGFydHNMb2FkZWQ6IHBhcnRzTG9hZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9O1xuICAgICAgbG9hZFBhcnRJbmRleChwYXJ0SW5kZXgpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uaGFuZGxlRnJhZ0xvYWRFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICB2YXIgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICBpZiAoZXJyb3IuZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5FcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5FdmVudHMuRVJST1IsIGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5FcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaCA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eGVyRmx1c2goY2h1bmtNZXRhKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgIHBhcnQgPSBjb250ZXh0LnBhcnQsXG4gICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICB9O1xuICBfcHJvdG8uZ2V0Q3VycmVudENvbnRleHQgPSBmdW5jdGlvbiBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIGxldmVsSW5kZXggPSBjaHVua01ldGEubGV2ZWwsXG4gICAgICBzbiA9IGNodW5rTWV0YS5zbixcbiAgICAgIHBhcnRJbmRleCA9IGNodW5rTWV0YS5wYXJ0O1xuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbbGV2ZWxJbmRleF0pIHtcbiAgICAgIHRoaXMud2FybihcIkxldmVscyBvYmplY3Qgd2FzIHVuc2V0IHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIiArIHNuICsgXCIgb2YgbGV2ZWwgXCIgKyBsZXZlbEluZGV4ICsgXCIuIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgdmFyIHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/ICgwLF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18uZ2V0UGFydFdpdGgpKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgdmFyIGZyYWcgPSBwYXJ0ID8gcGFydC5mcmFnbWVudCA6ICgwLF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18uZ2V0RnJhZ21lbnRXaXRoU04pKGxldmVsLCBzbiwgdGhpcy5mcmFnQ3VycmVudCk7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgbGV2ZWw6IGxldmVsXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLmJ1ZmZlckZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIGJ1ZmZlckZyYWdtZW50RGF0YShkYXRhLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpIHtcbiAgICBpZiAoIWRhdGEgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGF0YTEgPSBkYXRhLmRhdGExLFxuICAgICAgZGF0YTIgPSBkYXRhLmRhdGEyO1xuICAgIHZhciBidWZmZXIgPSBkYXRhMTtcbiAgICBpZiAoZGF0YTEgJiYgZGF0YTIpIHtcbiAgICAgIC8vIENvbWJpbmUgdGhlIG1vb2YgKyBtZGF0IHNvIHRoYXQgd2UgYnVmZmVyIHdpdGggYSBzaW5nbGUgYXBwZW5kXG4gICAgICBidWZmZXIgPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uYXBwZW5kVWludDhBcnJheSkoZGF0YTEsIGRhdGEyKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXIgfHwgIWJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICBkYXRhOiBidWZmZXJcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICBpZiAoZGF0YS5kcm9wcGVkICYmIGRhdGEuaW5kZXBlbmRlbnQgJiYgIXBhcnQpIHtcbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZmx1c2hCdWZmZXJHYXAgPSBmdW5jdGlvbiBmbHVzaEJ1ZmZlckdhcChmcmFnKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIGN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgY2xlYXIgdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGJhY2t0cmFjayBhcyBtdWNoIGFzIG5lZWRlZFxuICAgIGlmICghX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgZnJhZ0R1cmF0aW9uID0gZnJhZy5kdXJhdGlvbjtcbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsIGZyYWdEdXJhdGlvbiAqIDAuMjUpO1xuICAgIHZhciBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuICAgIGlmIChmcmFnLnN0YXJ0IC0gc3RhcnQgPiBzZWdtZW50RnJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0LCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXRGd2RCdWZmZXJJbmZvID0gZnVuY3Rpb24gZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCB0eXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBidWZmZXJlZEZyYWdBdFBvcyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3MsIHR5cGUpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZ0F0UG9zICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDwgYnVmZmVyZWRGcmFnQXRQb3MuZW5kKSB7XG4gICAgICAgIHJldHVybiBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgTWF0aC5tYXgoYnVmZmVySW5mby5uZXh0U3RhcnQsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJJbmZvO1xuICB9O1xuICBfcHJvdG8uZ2V0TWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsQml0cmF0ZSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgbWF4QnVmTGVuO1xuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9O1xuICBfcHJvdG8ucmVkdWNlTWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRocmVzaG9sZCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgbWluTGVuZ3RoID0gdGhyZXNob2xkIHx8IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIHRoaXMud2FybihcIlJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byBcIiArIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKyBcInNcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uZ2V0TmV4dEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmICghZnJhZ0xlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBmcmFnO1xuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLndhcm4oXCJOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogXCIgKyBmcmFnTGVuICsgXCIsIG5lZWQ6IFwiICsgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlYWwgZnJhZ21lbnQgc3RhcnQgdGltZXMgZm9yIGEgbGl2ZSBzdHJlYW0gYXJlIG9ubHkga25vd24gYWZ0ZXIgdGhlIFBUUyByYW5nZSBmb3IgdGhhdCBsZXZlbCBpcyBrbm93bi5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGRpc2NvdmVyIHRoZSByYW5nZSwgd2UgbG9hZCB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhhdCBsZXZlbCBhbmQgZGVtdXggaXQuXG4gICAgICAvLyBEbyBub3QgbG9hZCB1c2luZyBsaXZlIGxvZ2ljIGlmIHRoZSBzdGFydGluZyBmcmFnIGlzIHJlcXVlc3RlZCAtIHdlIHdhbnQgdG8gdXNlIGdldEZyYWdtZW50QXRQb3NpdGlvbigpIHNvIHRoYXRcbiAgICAgIC8vIHdlIGdldCB0aGUgZnJhZ21lbnQgbWF0Y2hpbmcgdGhhdCBzdGFydCB0aW1lXG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gZnJhZyA/IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgZnJhZy5zdGFydCA6IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuICAgIGlmICghZnJhZykge1xuICAgICAgdmFyIGVuZCA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKHBvcywgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpO1xuICB9O1xuICBfcHJvdG8ubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZCA9IGZ1bmN0aW9uIG1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZnJhZykge1xuICAgIC8vIElmIGFuIGluaXRTZWdtZW50IGlzIHByZXNlbnQsIGl0IG11c3QgYmUgYnVmZmVyZWQgZmlyc3RcbiAgICBpZiAoZnJhZyAhPT0gbnVsbCAmJiBmcmFnICE9PSB2b2lkIDAgJiYgZnJhZy5pbml0U2VnbWVudCAmJiAhKGZyYWcgIT09IG51bGwgJiYgZnJhZyAhPT0gdm9pZCAwICYmIGZyYWcuaW5pdFNlZ21lbnQuZGF0YSkgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfTtcbiAgX3Byb3RvLmdldE5leHRQYXJ0ID0gZnVuY3Rpb24gZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgbmV4dFBhcnQgPSAtMTtcbiAgICB2YXIgY29udGlndW91cyA9IGZhbHNlO1xuICAgIHZhciBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgfSBlbHNlIGlmICgoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQYXJ0O1xuICB9O1xuICBfcHJvdG8ubG9hZGVkRW5kT2ZQYXJ0cyA9IGZ1bmN0aW9uIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdFBhcnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA+IGxhc3RQYXJ0LnN0YXJ0ICYmIGxhc3RQYXJ0LmxvYWRlZDtcbiAgfVxuXG4gIC8qXG4gICBUaGlzIG1ldGhvZCBpcyB1c2VkIGZpbmQgdGhlIGJlc3QgbWF0Y2hpbmcgZmlyc3QgZnJhZ21lbnQgZm9yIGEgbGl2ZSBwbGF5bGlzdC4gVGhpcyBmcmFnbWVudCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgIFwic2xpZGluZ1wiIG9mIHRoZSBwbGF5bGlzdCwgd2hpY2ggaXMgaXRzIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBwbGF5YmFjay4gQWZ0ZXIgc2xpZGluZyB3ZSBjYW4gY29tcHV0ZSB0aGUgcmVhbFxuICAgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgZWFjaCBmcmFnbWVudCBpbiB0aGUgcGxheWxpc3QgKGFmdGVyIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgbm90IG5lZWQgdG8gYmUgY2FsbGVkKS5cbiAgKi87XG4gIF9wcm90by5nZXRJbml0aWFsTGl2ZUZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cykge1xuICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICB2YXIgZnJhZyA9IG51bGw7XG4gICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gUHJlZmVyIHVzaW5nIFBEVCwgYmVjYXVzZSBpdCBjYW4gYmUgYWNjdXJhdGUgZW5vdWdoIHRvIGNob29zZSB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRob3V0IGtub3dpbmcgdGhlIGxldmVsIHNsaWRpbmdcbiAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiBcIiArIGZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgICBmcmFnID0gKDAsX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uZmluZEZyYWdtZW50QnlQRFQpKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICB2YXIgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UncmUgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UsIHNpbmNlIFBUUyByZXNldHMgdXBvbiBhIG5ldyByYW5nZVxuICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gKDAsX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uZmluZEZyYWdXaXRoQ0MpKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmNjKTtcbiAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgdmFyIGxpdmVTdGFydCA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpZiAobGl2ZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihsaXZlU3RhcnQsIHRoaXMuYml0cmF0ZVRlc3QgPyBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQgOiBsZXZlbERldGFpbHMuZWRnZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKlxuICBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBnaXZlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb24uXG4gICAqLztcbiAgX3Byb3RvLmdldEZyYWdtZW50QXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgIGVuZFNOID0gbGV2ZWxEZXRhaWxzLmVuZFNOO1xuICAgIHZhciBmcmFnbWVudEhpbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICB2YXIgbG9hZGluZ1BhcnRzID0gISEoY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0TGlzdCAmJiBmcmFnbWVudEhpbnQpO1xuICAgIGlmIChsb2FkaW5nUGFydHMgJiYgZnJhZ21lbnRIaW50ICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAvLyBJbmNsdWRlIGluY29tcGxldGUgZnJhZ21lbnQgd2l0aCBwYXJ0cyBhdCBlbmRcbiAgICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cy5jb25jYXQoZnJhZ21lbnRIaW50KTtcbiAgICAgIGVuZFNOID0gZnJhZ21lbnRIaW50LnNuO1xuICAgIH1cbiAgICB2YXIgZnJhZztcbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICB2YXIgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSAoMCxfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5maW5kRnJhZ21lbnRCeVBUUykoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIC8vIE1vdmUgZnJhZ1ByZXZpb3VzIGZvcndhcmQgdG8gc3VwcG9ydCBmb3JjaW5nIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWRcbiAgICAgIC8vIHdoZW4gdGhlIGJ1ZmZlciBjYXRjaGVzIHVwIHRvIGEgcHJldmlvdXNseSBidWZmZXJlZCByYW5nZS5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5GcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgIGZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbiAmJiAhbG9hZGluZ1BhcnRzKSB7XG4gICAgICAgIC8vIEZvcmNlIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWQgaWYgdGhlIHByZXZpb3VzIG9uZSB3YXMgYWxyZWFkeSBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjYXNpb25hbGx5IGhhcHBlbiB3aXRoXG4gICAgICAgIC8vIG5vbi11bmlmb3JtIGZyYWdtZW50IGR1cmF0aW9uc1xuICAgICAgICB2YXIgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCkge1xuICAgICAgICAgIHZhciBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgZW5kU04gJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUobmV4dEZyYWcpICE9PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiU04gXCIgKyBmcmFnLnNuICsgXCIganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiICsgbmV4dEZyYWcuc24pO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH07XG4gIF9wcm90by5zeW5jaHJvbml6ZVRvTGl2ZUVkZ2UgPSBmdW5jdGlvbiBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBzdGFydCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgdmFyIGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIHZhciB3aXRoaW5TbGlkaW5nV2luZG93ID0gY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJiBjdXJyZW50VGltZSA8PSBlbmQ7XG4gICAgLy8gQ29udGludWUgaWYgd2UgY2FuIHNlZWsgZm9yd2FyZCB0byBzeW5jIHBvc2l0aW9uIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBvdXRzaWRlIG9mIHNsaWRpbmcgd2luZG93XG4gICAgaWYgKGxpdmVTeW5jUG9zaXRpb24gIT09IG51bGwgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uICYmIChjdXJyZW50VGltZSA8IGxpdmVTeW5jUG9zaXRpb24gfHwgIXdpdGhpblNsaWRpbmdXaW5kb3cpKSB7XG4gICAgICAvLyBDb250aW51ZSBpZiBidWZmZXIgaXMgc3RhcnZpbmcgb3IgaWYgY3VycmVudCB0aW1lIGlzIGJlaGluZCBtYXggbGF0ZW5jeVxuICAgICAgdmFyIG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgaWYgKCF3aXRoaW5TbGlkaW5nV2luZG93ICYmIG1lZGlhLnJlYWR5U3RhdGUgPCA0IHx8IGN1cnJlbnRUaW1lIDwgZW5kIC0gbWF4TGF0ZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgc2VlayBpZiByZWFkeSBhbmQgdGhlcmUgaXMgbm90IGEgc2lnbmlmaWNhbnQgZm9yd2FyZCBidWZmZXIgYXZhaWxhYmxlIGZvciBwbGF5YmFja1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHRoaXMud2FybihcIlBsYXliYWNrOiBcIiArIGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgKyBcIiBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdDogXCIgKyBlbmQgKyBcIiwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiBcIiArIGxpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYWxpZ25QbGF5bGlzdHMgPSBmdW5jdGlvbiBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICBsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCxcbiAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIHZhciBsYXN0TGV2ZWwgPSBsZXZlbExhc3RMb2FkZWQgIT09IG51bGwgPyBsZXZlbHNbbGV2ZWxMYXN0TG9hZGVkXSA6IG51bGw7XG5cbiAgICAvLyBGSVhNRTogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG4gICAgdmFyIGxlbmd0aCA9IGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKFwiTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RcIik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG4gICAgdmFyIGFsaWduZWQgPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoc2xpZGluZ1N0YXJ0KTtcbiAgICBpZiAoZmlyc3RMZXZlbExvYWQgfHwgIWFsaWduZWQgJiYgIXNsaWRpbmdTdGFydCkge1xuICAgICAgKDAsX3V0aWxzX2Rpc2NvbnRpbnVpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmFsaWduU3RyZWFtKShmcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgZGV0YWlscyk7XG4gICAgICB2YXIgYWxpZ25lZFNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0IHNsaWRpbmc6IFwiICsgYWxpZ25lZFNsaWRpbmdTdGFydC50b0ZpeGVkKDIpICsgXCIgc3RhcnQtc246IFwiICsgKHByZXZpb3VzRGV0YWlscyA/IHByZXZpb3VzRGV0YWlscy5zdGFydFNOIDogJ25hJykgKyBcIi0+XCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIiBwcmV2LXNuOiBcIiArIChmcmFnUHJldmlvdXMgPyBmcmFnUHJldmlvdXMuc24gOiAnbmEnKSArIFwiIGZyYWdtZW50czogXCIgKyBsZW5ndGgpO1xuICAgICAgcmV0dXJuIGFsaWduZWRTbGlkaW5nU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH07XG4gIF9wcm90by53YWl0Rm9yQ2RuVHVuZUluID0gZnVuY3Rpb24gd2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSB7XG4gICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW4gdG8gZ2V0IGFuIHVwZGF0ZWQgcGxheWxpc3RcbiAgICB2YXIgYWR2YW5jZVBhcnRMaW1pdCA9IDM7XG4gICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMucGFydFRhcmdldCAmJiBkZXRhaWxzLnR1bmVJbkdvYWwgPiBNYXRoLm1heChkZXRhaWxzLnBhcnRIb2xkQmFjaywgZGV0YWlscy5wYXJ0VGFyZ2V0ICogYWR2YW5jZVBhcnRMaW1pdCk7XG4gIH07XG4gIF9wcm90by5zZXRTdGFydFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBzbGlkaW5nKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IGRldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgaWYgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGluZywgc3RhcnRQb3NpdGlvbiksIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZyhcIlN0YXJ0IHRpbWUgb2Zmc2V0IFwiICsgc3RhcnRUaW1lT2Zmc2V0ICsgXCIgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAvLyBub3QgYmVlbiBzcGVjaWZpZWQgdmlhIHRoZSBjb25maWcgb3IgYW4gYXMgYW4gYXJndW1lbnQgdG8gc3RhcnRMb2FkICgjMzczNikuXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IHNsaWRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgfTtcbiAgX3Byb3RvLmdldExvYWRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICB2YXIgcG9zID0gMDtcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfTtcbiAgX3Byb3RvLmhhbmRsZUZyYWdMb2FkQWJvcnRlZCA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdMb2FkQWJvcnRlZChmcmFnLCBwYXJ0KSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlciAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmIGZyYWcuc3RhdHMuYWJvcnRlZCkge1xuICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdhcyBhYm9ydGVkXCIpO1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5yZXNldEZyYWdtZW50TG9hZGluZyA9IGZ1bmN0aW9uIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpIHtcbiAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IgPSBmdW5jdGlvbiBvbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoZmlsdGVyVHlwZSwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoZGF0YS5jaHVua01ldGEpIHtcbiAgICAgIC8vIFBhcnNpbmcgRXJyb3I6IG5vIHJldHJpZXNcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChkYXRhLmNodW5rTWV0YSk7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBkYXRhLmZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc29sZS5hc3NlcnQoZnJhZ0N1cnJlbnQgJiYgZnJhZy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgZnJhZy51cmxJZCA9PT0gZnJhZ0N1cnJlbnQudXJsSWQsICdGcmFnIGxvYWQgZXJyb3IgbXVzdCBtYXRjaCBjdXJyZW50IGZyYWcgdG8gcmV0cnknKTtcbiAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICBpZiAodGhpcy5mcmFnTG9hZEVycm9yICsgMSA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5mcmFnTG9hZEVycm9yKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBcIiArIGZpbHRlclR5cGUgKyBcIiBcIiArIGZyYWcubGV2ZWwgKyBcIiBmYWlsZWQgdG8gbG9hZCwgcmV0cnlpbmcgaW4gXCIgKyBkZWxheSArIFwibXNcIik7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvcisrO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZXZlbFJldHJ5KSB7XG4gICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5QbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgICAvLyBSZXNldCBjdXJyZW50IGZyYWdtZW50IHNpbmNlIGF1ZGlvIHRyYWNrIGF1ZGlvIGlzIGVzc2VudGlhbCBhbmQgbWF5IG5vdCBoYXZlIGEgZmFpbC1vdmVyIHRyYWNrXG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRnJhZ21lbnQgZXJyb3JzIHRoYXQgcmVzdWx0IGluIGEgbGV2ZWwgc3dpdGNoIG9yIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgIC8vIHNob3VsZCByZXNldCB0aGUgc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdG8gaWRsZVxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18ubG9nZ2VyLmVycm9yKGRhdGEuZGV0YWlscyArIFwiIHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLlwiKTtcbiAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICB0aGlzLmhscy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFmdGVyQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uIGFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYSwgYnVmZmVyVHlwZSwgcGxheWxpc3RUeXBlKSB7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFncyB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhXG4gICAgLy8gKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICB2YXIgYnVmZmVyZWRUaW1lUmFuZ2VzID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5CdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnJlc2V0TG9hZGluZ1N0YXRlID0gZnVuY3Rpb24gcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH07XG4gIF9wcm90by5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCA9IGZ1bmN0aW9uIHJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGxldmVsKSB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5sZXZlbHMgPyB0aGlzLmxldmVsc1tsZXZlbF0uZGV0YWlscyA6IG51bGw7XG4gICAgICBpZiAoZGV0YWlscyAhPT0gbnVsbCAmJiBkZXRhaWxzICE9PSB2b2lkIDAgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8udXBkYXRlTGV2ZWxUaW1pbmcgPSBmdW5jdGlvbiB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgcGFydGlhbCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBjb25zb2xlLmFzc2VydCghIWRldGFpbHMsICdsZXZlbC5kZXRhaWxzIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHZhciBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgdmFyIHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgLy8gVGhlIG5ldyB0cmFuc211eGVyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIGEgdGltZSBvZmZzZXQgbWF0Y2hpbmcgdGhlIG5leHQgZnJhZ21lbnQgc3RhcnQsXG4gICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICBfdGhpczYud2FybihcIkNvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBcIiArIHR5cGUgKyBcIiBkdXJhdGlvbiByZWxpYWJseSAoXCIgKyBwYXJzZWREdXJhdGlvbiArIFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmlmdCA9IHBhcnRpYWwgPyAwIDogKDAsX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy51cGRhdGVGcmFnUFRTRFRTKShkZXRhaWxzLCBmcmFnLCBpbmZvLnN0YXJ0UFRTLCBpbmZvLmVuZFBUUywgaW5mby5zdGFydERUUywgaW5mby5lbmREVFMpO1xuICAgICAgICBfdGhpczYuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLkV2ZW50cy5MRVZFTF9QVFNfVVBEQVRFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgIGRyaWZ0OiBkcmlmdCxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZhbHNlKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhpcy53YXJuKFwiRm91bmQgbm8gbWVkaWEgaW4gZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBsZXZlbC5pZCArIFwiIHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ1wiKTtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRXZlbnRzLkZSQUdfUEFSU0VELCB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydFxuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVzZXRUcmFuc211eGVyID0gZnVuY3Rpb24gcmVzZXRUcmFuc211eGVyKCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKEJhc2VTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogXCJzdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dFN0YXRlKSB7XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgdGhpcy5sb2cocHJldmlvdXNTdGF0ZSArIFwiLT5cIiArIG5leHRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXNlU3RyZWFtQ29udHJvbGxlcjtcbn0oX3Rhc2tfbG9vcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQnVmZmVyQ29udHJvbGxlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFzb3VyY2VfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9idWZmZXJfb3BlcmF0aW9uX3F1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J1ZmZlci1vcGVyYXRpb24tcXVldWUgKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1vcGVyYXRpb24tcXVldWUudHNcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgTWVkaWFTb3VyY2UgPSAoMCxfdXRpbHNfbWVkaWFzb3VyY2VfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uZ2V0TWVkaWFTb3VyY2UpKCk7XG52YXIgVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UgPSAvKFtoYV12Yy4pKD86XFwuW14uLF0rKSsvO1xudmFyIEJ1ZmZlckNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG5cbiAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcblxuICAvLyBBIHF1ZXVlIG9mIGJ1ZmZlciBvcGVyYXRpb25zIHdoaWNoIHJlcXVpcmUgdGhlIFNvdXJjZUJ1ZmZlciB0byBub3QgYmUgdXBkYXRpbmcgdXBvbiBleGVjdXRpb25cblxuICAvLyBSZWZlcmVuY2VzIHRvIGV2ZW50IGxpc3RlbmVycyBmb3IgZWFjaCBTb3VyY2VCdWZmZXIsIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCBmb3IgZXZlbnQgcmVtb3ZhbFxuXG4gIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcblxuICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgbWVkaWEgc291cmNlXG5cbiAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcblxuICAvLyBjb3VudGVyc1xuXG4gIGZ1bmN0aW9uIEJ1ZmZlckNvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSAwO1xuICAgIHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1lZGlhID0gX3RoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gX3RoaXMubWVkaWFTb3VyY2U7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCBfdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICBfdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF90aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICB9XG4gICAgICBfdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGVuZGVkJyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhRW1wdGllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZWRpYSA9IF90aGlzLm1lZGlhLFxuICAgICAgICBfb2JqZWN0VXJsID0gX3RoaXMuX29iamVjdFVybDtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5zcmMgIT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5lcnJvcihcIk1lZGlhIGVsZW1lbnQgc3JjIHdhcyBzZXQgd2hpbGUgYXR0YWNoaW5nIE1lZGlhU291cmNlIChcIiArIF9vYmplY3RVcmwgKyBcIiA+IFwiICsgbWVkaWEuc3JjICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5oYXNTb3VyY2VUeXBlcyA9IGZ1bmN0aW9uIGhhc1NvdXJjZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdUcmFja3MpLmxlbmd0aCA+IDA7XG4gIH07XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX2luaXRTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgX2J1ZmZlcl9vcGVyYXRpb25fcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0odGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgdmFyIGNvZGVjRXZlbnRzID0gMjtcbiAgICBpZiAoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbyB8fCAhZGF0YS5hbHRBdWRpbykge1xuICAgICAgY29kZWNFdmVudHMgPSAxO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZyh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZFwiKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgIF9vYmplY3RVcmwgPSB0aGlzLl9vYmplY3RVcmw7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IG9uTWVkaWFEZXRhY2hpbmc6IFwiICsgZXJyLm1lc3NhZ2UgKyBcIiB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG4gICAgICB0aGlzLm9uQnVmZmVyUmVzZXQoKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChfb2JqZWN0VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICBpZiAobWVkaWEuc3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci53YXJuKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBtZWRpYS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdW5kZWZpbmVkKTtcbiAgfTtcbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2IgPSBfdGhpczIuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgX3RoaXMyLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgICBpZiAoX3RoaXMyLm1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICBfdGhpczIubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3luY2hyb25vdXNseSByZW1vdmUgdGhlIFNCIGZyb20gdGhlIG1hcCBiZWZvcmUgdGhlIG5leHQgY2FsbCBpbiBvcmRlciB0byBwcmV2ZW50IGFuIGFzeW5jIGZ1bmN0aW9uIGZyb21cbiAgICAgICAgICAvLyBhY2Nlc3NpbmcgaXRcbiAgICAgICAgICBfdGhpczIuc291cmNlQnVmZmVyW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlc2V0IHRoZSBcIiArIHR5cGUgKyBcIiBidWZmZXJcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gIH07XG4gIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlckNvdW50ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aDtcbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIHZhciB0cmFjayA9IF90aGlzMy50cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfZGF0YSR0cmFja05hbWUgPSBkYXRhW3RyYWNrTmFtZV0sXG4gICAgICAgICAgICBpZCA9IF9kYXRhJHRyYWNrTmFtZS5pZCxcbiAgICAgICAgICAgIGNvZGVjID0gX2RhdGEkdHJhY2tOYW1lLmNvZGVjLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5sZXZlbENvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyID0gX2RhdGEkdHJhY2tOYW1lLmNvbnRhaW5lcixcbiAgICAgICAgICAgIG1ldGFkYXRhID0gX2RhdGEkdHJhY2tOYW1lLm1ldGFkYXRhO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29kZWMgPSAodHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYykucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSwgJyQxJyk7XG4gICAgICAgICAgdmFyIG5leHRDb2RlYyA9IChsZXZlbENvZGVjIHx8IGNvZGVjKS5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLCAnJDEnKTtcbiAgICAgICAgICBpZiAoY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IGNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIChsZXZlbENvZGVjIHx8IGNvZGVjKTtcbiAgICAgICAgICAgIF90aGlzMy5hcHBlbmRDaGFuZ2VUeXBlKHRyYWNrTmFtZSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBzd2l0Y2hpbmcgY29kZWMgXCIgKyBjdXJyZW50Q29kZWMgKyBcIiB0byBcIiArIG5leHRDb2RlYyk7XG4gICAgICAgICAgICBfdGhpczMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdHJhY2suYnVmZmVyLFxuICAgICAgICAgICAgICBjb2RlYzogY29kZWMsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjOiBsZXZlbENvZGVjLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICBfdGhpczMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsIDApO1xuICAgIGlmICh0aGlzLm1lZGlhU291cmNlICYmIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFwcGVuZENoYW5nZVR5cGUgPSBmdW5jdGlvbiBhcHBlbmRDaGFuZ2VUeXBlKHR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgdmFyIHNiID0gX3RoaXM0LnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBjaGFuZ2luZyBcIiArIHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgdHlwZSB0byBcIiArIG1pbWVUeXBlKTtcbiAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7fSxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gY2hhbmdlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciB0eXBlXCIsIGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gIH07XG4gIF9wcm90by5vbkJ1ZmZlckFwcGVuZGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kaW5nKGV2ZW50LCBldmVudERhdGEpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICB2YXIgZGF0YSA9IGV2ZW50RGF0YS5kYXRhLFxuICAgICAgdHlwZSA9IGV2ZW50RGF0YS50eXBlLFxuICAgICAgZnJhZyA9IGV2ZW50RGF0YS5mcmFnLFxuICAgICAgcGFydCA9IGV2ZW50RGF0YS5wYXJ0LFxuICAgICAgY2h1bmtNZXRhID0gZXZlbnREYXRhLmNodW5rTWV0YTtcbiAgICB2YXIgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG4gICAgdmFyIGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgdmFyIGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICB2YXIgcGFydEJ1ZmZlcmluZyA9IHBhcnQgPyBwYXJ0LnN0YXRzLmJ1ZmZlcmluZyA6IG51bGw7XG4gICAgaWYgKGZyYWdCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIGZyYWdCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9XG4gICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgcGFydEJ1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIFRPRE86IE9ubHkgdXBkYXRlIHRpbWVzdGFtcE9mZnNldCB3aGVuIGF1ZGlvL21wZWcgZnJhZ21lbnQgb3IgcGFydCBpcyBub3QgY29udGlndW91cyB3aXRoIHByZXZpb3VzbHkgYXBwZW5kZWRcbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuICAgIHZhciBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIHZhciBjaGVja1RpbWVzdGFtcE9mZnNldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIChhdWRpb1RyYWNrID09PSBudWxsIHx8IGF1ZGlvVHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1ZGlvVHJhY2suY29udGFpbmVyKSA9PT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICBjaGVja1RpbWVzdGFtcE9mZnNldCA9ICF0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayB8fCBjaHVua01ldGEuaWQgPT09IDEgfHwgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsuc24gIT09IGNodW5rTWV0YS5zbjtcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gY2h1bmtNZXRhO1xuICAgIH1cbiAgICB2YXIgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoY2hlY2tUaW1lc3RhbXBPZmZzZXQpIHtcbiAgICAgICAgICB2YXIgc2IgPSBfdGhpczUuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZnJhZ1N0YXJ0IC0gc2IudGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAwLjEpIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBhdWRpbyBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvIFwiICsgZnJhZ1N0YXJ0ICsgXCIgKGRlbHRhOiBcIiArIGRlbHRhICsgXCIpIHNuOiBcIiArIGZyYWcuc24gKyBcIilcIik7XG4gICAgICAgICAgICAgIHNiLnRpbWVzdGFtcE9mZnNldCA9IGZyYWdTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM1LmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICB2YXIgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG4gICAgICAgIGlmIChmcmFnQnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgZnJhZ0J1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgcGFydEJ1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXM1LnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX3R5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgdGltZVJhbmdlc1tfdHlwZV0gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzb3VyY2VCdWZmZXJbX3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczUuYXBwZW5kRXJyb3IgPSAwO1xuICAgICAgICBfdGhpczUuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzOiB0aW1lUmFuZ2VzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIuZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZXJyKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNS5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIFJldHJ5aW5nIGNhbiBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoX3RoaXM1LmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmVycm9yKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIFwiICsgaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyXCIpO1xuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgaGxzLnN0b3BMb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICB9O1xuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgIHZhciBmbHVzaE9wZXJhdGlvbiA9IGZ1bmN0aW9uIGZsdXNoT3BlcmF0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGU6IF90aGlzNi5yZW1vdmVFeGVjdXRvci5iaW5kKF90aGlzNiwgdHlwZSwgZGF0YS5zdGFydE9mZnNldCwgZGF0YS5lbmRPZmZzZXQpLFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogU3RhcnRlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEZpbmlzaGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICAgIF90aGlzNi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZW1vdmUgZnJvbSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoZGF0YS50eXBlKSB7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24oZGF0YS50eXBlKSwgZGF0YS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKHR5cGUpLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICB2YXIgYnVmZmVyc0FwcGVuZGVkVG8gPSBbXTtcbiAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSBwYXJ0ID8gcGFydC5lbGVtZW50YXJ5U3RyZWFtcyA6IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvJyk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgndmlkZW8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9uVW5ibG9ja2VkID0gZnVuY3Rpb24gb25VbmJsb2NrZWQoKSB7XG4gICAgICB2YXIgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZyYWcuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIF90aGlzNy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChidWZmZXJzQXBwZW5kZWRUby5sZW5ndGggPT09IDApIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIud2FybihcIkZyYWdtZW50cyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIEVsZW1lbnRhcnlTdHJlYW1UeXBlIHNldC4gdHlwZTogXCIgKyBmcmFnLnR5cGUgKyBcIiBsZXZlbDogXCIgKyBmcmFnLmxldmVsICsgXCIgc246IFwiICsgZnJhZy5zbik7XG4gICAgfVxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gIH07XG4gIF9wcm90by5vbkZyYWdDaGFuZ2VkID0gZnVuY3Rpb24gb25GcmFnQ2hhbmdlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuZmx1c2hCYWNrQnVmZmVyKCk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICA7XG4gIF9wcm90by5vbkJ1ZmZlckVvcyA9IGZ1bmN0aW9uIG9uQnVmZmVyRW9zKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgdmFyIGVuZGVkID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0eXBlKSB7XG4gICAgICB2YXIgc2IgPSBfdGhpczguc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiICYmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgc2IuZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFzYi5lbmRlZCkge1xuICAgICAgICAgIHNiLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICYmICEhKCFzYiB8fCBzYi5lbmRlZCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgaWYgKGVuZGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFF1ZXVlaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClcIik7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzOC5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB2YXIgc2IgPSBfdGhpczguc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1lZGlhU291cmNlID0gX3RoaXM4Lm1lZGlhU291cmNlO1xuICAgICAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5pbmZvKFwiW2J1ZmZlci1jb250cm9sbGVyXTogQ291bGQgbm90IGNhbGwgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKS4gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZTogXCIgKyBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogQ2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpXCIpO1xuICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cbiAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgZGV0YWlscyA9IF9yZWYuZGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIGlmICh0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycyh0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZmx1c2hCYWNrQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hCYWNrQnVmZmVyKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgIGRldGFpbHMgPSB0aGlzLmRldGFpbHMsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBpZiAoIW1lZGlhIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIGlmICghc291cmNlQnVmZmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBsaXZlQmFja0J1ZmZlckxlbmd0aFxuICAgIHZhciBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBobHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogaGxzLmNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuICAgIGlmICghKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShiYWNrQnVmZmVyTGVuZ3RoKSB8fCBiYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgdmFyIG1heEJhY2tCdWZmZXJMZW5ndGggPSBNYXRoLm1heChiYWNrQnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgdmFyIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiAtIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgZXZlbnQ6XG4gICAgICAgICAgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2IuZW5kZWQgJiYgYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpIC0gY3VycmVudFRpbWUgPCB0YXJnZXREdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIuaW5mbyhcIltidWZmZXItY29udHJvbGxlcl06IENhbm5vdCBmbHVzaCBcIiArIHR5cGUgKyBcIiBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovO1xuICBfcHJvdG8udXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIHZhciBsZXZlbER1cmF0aW9uID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgdmFyIG1lZGlhRHVyYXRpb24gPSBtZWRpYS5kdXJhdGlvbjtcbiAgICB2YXIgbXNEdXJhdGlvbiA9ICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiAwO1xuICAgIGlmIChkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKGRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWxEdXJhdGlvbiA+IG1zRHVyYXRpb24gJiYgbGV2ZWxEdXJhdGlvbiA+IG1lZGlhRHVyYXRpb24gfHwgISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gXCIgKyBsZXZlbER1cmF0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnVwZGF0ZVNlZWthYmxlUmFuZ2UgPSBmdW5jdGlvbiB1cGRhdGVTZWVrYWJsZVJhbmdlKGxldmVsRGV0YWlscykge1xuICAgIHZhciBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBtZWRpYVNvdXJjZSAhPT0gbnVsbCAmJiBtZWRpYVNvdXJjZSAhPT0gdm9pZCAwICYmIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmNoZWNrUGVuZGluZ1RyYWNrcyA9IGZ1bmN0aW9uIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICB2YXIgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCxcbiAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgIHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3M7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cbiAgICB2YXIgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICB2YXIgYnVmZmVycyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JEZXRhaWxzLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5jcmVhdGVTb3VyY2VCdWZmZXJzID0gZnVuY3Rpb24gY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICB9XG4gICAgdmFyIHRyYWNrc0NyZWF0ZWQgPSAwO1xuICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcInNvdXJjZSBidWZmZXIgZXhpc3RzIGZvciB0cmFjayBcIiArIHRyYWNrTmFtZSArIFwiLCBob3dldmVyIHRyYWNrIGRvZXMgbm90XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIHZhciBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIHZhciBtaW1lVHlwZSA9IHRyYWNrLmNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIGNvZGVjO1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcihcIiArIG1pbWVUeXBlICsgXCIpXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICB2YXIgc2JOYW1lID0gdHJhY2tOYW1lO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAndXBkYXRlc3RhcnQnLCB0aGlzLl9vblNCVXBkYXRlU3RhcnQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAndXBkYXRlZW5kJywgdGhpcy5fb25TQlVwZGF0ZUVuZCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICdlcnJvcicsIHRoaXMuX29uU0JVcGRhdGVFcnJvcik7XG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcjogc2IsXG4gICAgICAgICAgICBjb2RlYzogY29kZWMsXG4gICAgICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGxldmVsQ29kZWM6IHRyYWNrLmxldmVsQ29kZWMsXG4gICAgICAgICAgICBtZXRhZGF0YTogdHJhY2subWV0YWRhdGEsXG4gICAgICAgICAgICBpZDogdHJhY2suaWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYWNrc0NyZWF0ZWQrKztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFja3NDcmVhdGVkKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgICAgdHJhY2tzOiB0aGlzLnRyYWNrc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gS2VlcCBhcyBhcnJvdyBmdW5jdGlvbnMgc28gdGhhdCB3ZSBjYW4gZGlyZWN0bHkgcmVmZXJlbmNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSBhcyBldmVudCBsaXN0ZW5lcnNcbiAgO1xuICBfcHJvdG8uX29uU0JVcGRhdGVTdGFydCA9IGZ1bmN0aW9uIF9vblNCVXBkYXRlU3RhcnQodHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uU3RhcnQoKTtcbiAgfTtcbiAgX3Byb3RvLl9vblNCVXBkYXRlRW5kID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuICBfcHJvdG8uX29uU0JVcGRhdGVFcnJvciA9IGZ1bmN0aW9uIF9vblNCVXBkYXRlRXJyb3IodHlwZSwgZXZlbnQpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmVycm9yKFwiW2J1ZmZlci1jb250cm9sbGVyXTogXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyIGVycm9yXCIsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgIGZhdGFsOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHVwZGF0ZWVuZCBpcyBhbHdheXMgZmlyZWQgYWZ0ZXIgZXJyb3IsIHNvIHdlJ2xsIGFsbG93IHRoYXQgdG8gc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiBvZiB0aGUgcXVldWVcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIHJlbW92ZSBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICA7XG4gIF9wcm90by5yZW1vdmVFeGVjdXRvciA9IGZ1bmN0aW9uIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlLFxuICAgICAgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlLFxuICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byByZW1vdmUgZnJvbSB0aGUgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9ICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikobWVkaWEuZHVyYXRpb24pID8gbWVkaWEuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgbXNEdXJhdGlvbiA9ICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgdmFyIHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICFzYi5lbmRpbmcpIHtcbiAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFJlbW92aW5nIFtcIiArIHJlbW92ZVN0YXJ0ICsgXCIsXCIgKyByZW1vdmVFbmQgKyBcIl0gZnJvbSB0aGUgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyXCIpO1xuICAgICAgY29uc29sZS5hc3NlcnQoIXNiLnVwZGF0aW5nLCB0eXBlICsgXCIgc291cmNlQnVmZmVyIG11c3Qgbm90IGJlIHVwZGF0aW5nXCIpO1xuICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiBhcHBlbmQgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgO1xuICBfcHJvdG8uYXBwZW5kRXhlY3V0b3IgPSBmdW5jdGlvbiBhcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKSB7XG4gICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIXNiKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCFzYi51cGRhdGluZywgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBtdXN0IG5vdCBiZSB1cGRhdGluZ1wiKTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH1cblxuICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gIC8vIHJlc29sdmUsIHRoZSBvblVuYmxvY2tlZCBmdW5jdGlvbiBpcyBleGVjdXRlZC4gRnVuY3Rpb25zIGNhbGxpbmcgdGhpcyBtZXRob2QgZG8gbm90IG5lZWQgdG8gdW5ibG9jayB0aGUgcXVldWVcbiAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgO1xuICBfcHJvdG8uYmxvY2tCdWZmZXJzID0gZnVuY3Rpb24gYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgaWYgKGJ1ZmZlcnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVmZmVycyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXJzLmxlbmd0aCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICB2YXIgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc2IgPSBfdGhpczkuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuICAgICAgICBpZiAoIXNiIHx8ICFzYi51cGRhdGluZykge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZ2V0U291cmNlQnVmZmVyVHlwZXMgPSBmdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpO1xuICB9O1xuICBfcHJvdG8uYWRkQnVmZmVyTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCBldmVudCwgZm4pIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH0pO1xuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH07XG4gIF9wcm90by5yZW1vdmVCdWZmZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICBidWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLmV2ZW50LCBsLmxpc3RlbmVyKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItb3BlcmF0aW9uLXF1ZXVlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1vcGVyYXRpb24tcXVldWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBCdWZmZXJPcGVyYXRpb25RdWV1ZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxudmFyIEJ1ZmZlck9wZXJhdGlvblF1ZXVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyT3BlcmF0aW9uUXVldWUoc291cmNlQnVmZmVyUmVmZXJlbmNlKSB7XG4gICAgdGhpcy5idWZmZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucXVldWVzID0ge1xuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMuYnVmZmVycyA9IHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTtcbiAgfVxuICB2YXIgX3Byb3RvID0gQnVmZmVyT3BlcmF0aW9uUXVldWUucHJvdG90eXBlO1xuICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmIHRoaXMuYnVmZmVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5pbnNlcnRBYm9ydCA9IGZ1bmN0aW9uIGluc2VydEFib3J0KG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kQmxvY2tlciA9IGZ1bmN0aW9uIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIHZhciBleGVjdXRlO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiBleGVjdXRlLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHt9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICBfcHJvdG8uZXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBleGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnMsXG4gICAgICBxdWV1ZXMgPSB0aGlzLnF1ZXVlcztcbiAgICB2YXIgc2IgPSBidWZmZXJzW3R5cGVdO1xuICAgIHZhciBxdWV1ZSA9IHF1ZXVlc1t0eXBlXTtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcXVldWVbMF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAvLyB3aGljaCBkbyBub3QgZW5kIHdpdGggdGhpcyBldmVudCBtdXN0IGNhbGwgX29uU0JVcGRhdGVFbmQgbWFudWFsbHlcbiAgICAgICAgb3BlcmF0aW9uLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvZ2dlci53YXJuKCdbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IFVuaGFuZGxlZCBleGNlcHRpb24gZXhlY3V0aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbicpO1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlKTtcblxuICAgICAgICAvLyBPbmx5IHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYsIG90aGVyd2lzZSB0aGUgdXBkYXRlZW5kIGhhbmRsZXIgd2lsbCBkbyB0aGlzIGZvciB1c1xuICAgICAgICBpZiAoIXNiIHx8ICFzYi51cGRhdGluZykge1xuICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnNoaWZ0QW5kRXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICB0aGlzLnF1ZXVlc1t0eXBlXS5zaGlmdCgpO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH07XG4gIF9wcm90by5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVzW3R5cGVdWzBdO1xuICB9O1xuICByZXR1cm4gQnVmZmVyT3BlcmF0aW9uUXVldWU7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiAqL1xuXG5cbnZhciBDYXBMZXZlbENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgdmFyIF9wcm90byA9IENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVyKCk7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH07XG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8ub25GcHNEcm9wTGV2ZWxDYXBwaW5nID0gZnVuY3Rpb24gb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gRG9uJ3QgYWRkIGEgcmVzdHJpY3RlZCBsZXZlbCBtb3JlIHRoYW4gb25jZVxuICAgIGlmIChDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoZGF0YS5kcm9wcGVkTGV2ZWwsIHRoaXMucmVzdHJpY3RlZExldmVscykpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gIH07XG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgO1xuICBfcHJvdG8ub25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gIH07XG4gIF9wcm90by5kZXRlY3RQbGF5ZXJTaXplID0gZnVuY3Rpb24gZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhSGVpZ2h0ID4gMCAmJiB0aGlzLm1lZGlhV2lkdGggPiAwKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcgJiYgdGhpcy5zdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICAqLztcbiAgX3Byb3RvLmdldE1heExldmVsID0gZnVuY3Rpb24gZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGluZGV4LCBfdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9O1xuICBfcHJvdG8uc3RhcnRDYXBwaW5nID0gZnVuY3Rpb24gc3RhcnRDYXBwaW5nKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH07XG4gIF9wcm90by5zdG9wQ2FwcGluZyA9IGZ1bmN0aW9uIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXREaW1lbnNpb25zID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5jbGllbnRSZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0O1xuICAgIH1cbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdmFyIGNsaWVudFJlY3QgPSBtZWRpYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICAgIGlmICghYm91bmRzUmVjdC53aWR0aCAmJiAhYm91bmRzUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbWVkaWEgZWxlbWVudCBoYXMgbm8gd2lkdGggb3IgaGVpZ2h0IChlcXVpdmFsZW50IHRvIG5vdCBiZWluZyBpbiB0aGUgRE9NKSxcbiAgICAgICAgLy8gdGhlbiB1c2UgaXRzIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcyAobWVkaWEud2lkdGgsIG1lZGlhLmhlaWdodClcbiAgICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQgfHwgbWVkaWEud2lkdGggfHwgMDtcbiAgICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wIHx8IG1lZGlhLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9O1xuICBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQgPSBmdW5jdGlvbiBpc0xldmVsQWxsb3dlZChsZXZlbCwgcmVzdHJpY3RlZExldmVscykge1xuICAgIGlmIChyZXN0cmljdGVkTGV2ZWxzID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgPT09IC0xO1xuICB9O1xuICBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSA9IGZ1bmN0aW9uIGdldE1heExldmVsQnlNZWRpYVNpemUobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICB2YXIgYXRHcmVhdGVzdEJhbmR3aWR0aCA9IGZ1bmN0aW9uIGF0R3JlYXRlc3RCYW5kd2lkdGgoY3VyTGV2ZWwsIG5leHRMZXZlbCkge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICB2YXIgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoKGxldmVsLndpZHRoID49IHdpZHRoIHx8IGxldmVsLmhlaWdodCA+PSBoZWlnaHQpICYmIGF0R3JlYXRlc3RCYW5kd2lkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH07XG4gIF9jcmVhdGVDbGFzcyhDYXBMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcIm1lZGlhV2lkdGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS53aWR0aCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZWRpYUhlaWdodFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50U2NhbGVGYWN0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gMTtcbiAgICAgIGlmICghdGhpcy5obHMuY29uZmlnLmlnbm9yZURldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKENhcExldmVsQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvY21jZC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvY21jZC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBDTUNEQ29udHJvbGxlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvY21jZCAqLyBcIi4vc3JjL3R5cGVzL2NtY2QudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuXG5cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gKiBAc2VlIGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmXG4gKi9cbnZhciBDTUNEQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgZnVuY3Rpb24gQ01DRENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMuc2lkID0gdm9pZCAwO1xuICAgIHRoaXMuY2lkID0gdm9pZCAwO1xuICAgIHRoaXMudXNlSGVhZGVycyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMub25XYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIF90aGlzLnN0YXJ2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMub25QbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBfdGhpcy5idWZmZXJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuYXBwbHlQbGF5bGlzdERhdGEgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuYXBwbHkoY29udGV4dCwge1xuICAgICAgICAgIG90OiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RPYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgIHN1OiAhX3RoaXMuaW5pdGlhbGl6ZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBnZW5lcmF0ZSBtYW5pZmVzdCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hcHBseUZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIHZhciBsZXZlbCA9IF90aGlzLmhscy5sZXZlbHNbZnJhZ21lbnQubGV2ZWxdO1xuICAgICAgICB2YXIgb3QgPSBfdGhpcy5nZXRPYmplY3RUeXBlKGZyYWdtZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgZDogZnJhZ21lbnQuZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgIG90OiBvdFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQ01DRE9iamVjdFR5cGUuVklERU8gfHwgb3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQ01DRE9iamVjdFR5cGUuQVVESU8gfHwgb3QgPT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNET2JqZWN0VHlwZS5NVVhFRCkge1xuICAgICAgICAgIGRhdGEuYnIgPSBsZXZlbC5iaXRyYXRlIC8gMTAwMDtcbiAgICAgICAgICBkYXRhLnRiID0gX3RoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IF90aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYXBwbHkoY29udGV4dCwgZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBnZW5lcmF0ZSBzZWdtZW50IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHZhciBjbWNkID0gY29uZmlnLmNtY2Q7XG4gICAgaWYgKGNtY2QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLnBMb2FkZXIgPSB0aGlzLmNyZWF0ZVBsYXlsaXN0TG9hZGVyKCk7XG4gICAgICBjb25maWcuZkxvYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRMb2FkZXIoKTtcbiAgICAgIHRoaXMuc2lkID0gY21jZC5zZXNzaW9uSWQgfHwgQ01DRENvbnRyb2xsZXIudXVpZCgpO1xuICAgICAgdGhpcy5jaWQgPSBjbWNkLmNvbnRlbnRJZDtcbiAgICAgIHRoaXMudXNlSGVhZGVycyA9IGNtY2QudXNlSGVhZGVycyA9PT0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcm90byA9IENNQ0RDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG4gIH07XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5hdWRpb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm9uQnVmZmVyQ3JlYXRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSR0cmFja3MkYXVkaW8sIF9kYXRhJHRyYWNrcyR2aWRlbztcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gKF9kYXRhJHRyYWNrcyRhdWRpbyA9IGRhdGEudHJhY2tzLmF1ZGlvKSA9PT0gbnVsbCB8fCBfZGF0YSR0cmFja3MkYXVkaW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyRhdWRpby5idWZmZXI7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkdmlkZW8gPSBkYXRhLnRyYWNrcy52aWRlbykgPT09IG51bGwgfHwgX2RhdGEkdHJhY2tzJHZpZGVvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkdmlkZW8uYnVmZmVyO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGJhc2VsaW5lIENNQ0QgZGF0YVxuICAgKi9cbiAgX3Byb3RvLmNyZWF0ZURhdGEgPSBmdW5jdGlvbiBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNEVmVyc2lvbixcbiAgICAgIHNmOiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RTdHJlYW1pbmdGb3JtYXQuSExTLFxuICAgICAgc2lkOiB0aGlzLnNpZCxcbiAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT09IG51bGwgfHwgX3RoaXMkbWVkaWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgIG10cDogdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgLyAxMDAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSByZXF1ZXN0LlxuICAgKi87XG4gIF9wcm90by5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGNvbnRleHQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgfVxuICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG4gICAgdmFyIGlzVmlkZW8gPSBkYXRhLm90ID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RPYmplY3RUeXBlLklOSVQgfHwgZGF0YS5vdCA9PT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNET2JqZWN0VHlwZS5WSURFTyB8fCBkYXRhLm90ID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RPYmplY3RUeXBlLk1VWEVEO1xuICAgIGlmICh0aGlzLnN0YXJ2ZWQgJiYgaXNWaWRlbykge1xuICAgICAgZGF0YS5icyA9IHRydWU7XG4gICAgICBkYXRhLnN1ID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHJ0cCwgbnJyLCBub3IsIGRsXG5cbiAgICBpZiAodGhpcy51c2VIZWFkZXJzKSB7XG4gICAgICB2YXIgaGVhZGVycyA9IENNQ0RDb250cm9sbGVyLnRvSGVhZGVycyhkYXRhKTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoaGVhZGVycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY29udGV4dC5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnRleHQuaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgX2V4dGVuZHMoY29udGV4dC5oZWFkZXJzLCBoZWFkZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHF1ZXJ5ID0gQ01DRENvbnRyb2xsZXIudG9RdWVyeShkYXRhKTtcbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC51cmwgPSBDTUNEQ29udHJvbGxlci5hcHBlbmRRdWVyeVRvVXJpKGNvbnRleHQudXJsLCBxdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAqLztcbiAgLyoqXG4gICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgKi9cbiAgX3Byb3RvLmdldE9iamVjdFR5cGUgPSBmdW5jdGlvbiBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBmcmFnbWVudC50eXBlO1xuICAgIGlmICh0eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNET2JqZWN0VHlwZS5USU1FRF9URVhUO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RPYmplY3RUeXBlLklOSVQ7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNET2JqZWN0VHlwZS5BVURJTztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLmhscy5hdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQ01DRE9iamVjdFR5cGUuTVVYRUQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5DTUNET2JqZWN0VHlwZS5WSURFTztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhpZ2hlc3QgYml0cmF0ZS5cbiAgICovO1xuICBfcHJvdG8uZ2V0VG9wQmFuZHdpZHRoID0gZnVuY3Rpb24gZ2V0VG9wQmFuZHdpZHRoKHR5cGUpIHtcbiAgICB2YXIgYml0cmF0ZSA9IDA7XG4gICAgdmFyIGxldmVscztcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHR5cGUgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQ01DRE9iamVjdFR5cGUuQVVESU8pIHtcbiAgICAgIGxldmVscyA9IGhscy5hdWRpb1RyYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICB2YXIgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLnNsaWNlKDAsIGxlbik7XG4gICAgfVxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobGV2ZWxzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBsZXZlbCA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKGxldmVsLmJpdHJhdGUgPiBiaXRyYXRlKSB7XG4gICAgICAgIGJpdHJhdGUgPSBsZXZlbC5iaXRyYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYml0cmF0ZSA+IDAgPyBiaXRyYXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGxlbmd0aCBmb3IgYSBtZWRpYSB0eXBlIGluIG1pbGxpc2Vjb25kc1xuICAgKi87XG4gIF9wcm90by5nZXRCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRCdWZmZXJMZW5ndGgodHlwZSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMuaGxzLm1lZGlhO1xuICAgIHZhciBidWZmZXIgPSB0eXBlID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkNNQ0RPYmplY3RUeXBlLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgaWYgKCFidWZmZXIgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgaW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyLCBtZWRpYS5jdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovO1xuICBfcHJvdG8uY3JlYXRlUGxheWxpc3RMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVQbGF5bGlzdExvYWRlcigpIHtcbiAgICB2YXIgcExvYWRlciA9IHRoaXMuY29uZmlnLnBMb2FkZXI7XG4gICAgdmFyIGFwcGx5ID0gdGhpcy5hcHBseVBsYXlsaXN0RGF0YTtcbiAgICB2YXIgQ3RvciA9IHBMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ21jZFBsYXlsaXN0TG9hZGVyKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgdmFyIF9wcm90bzIgPSBDbWNkUGxheWxpc3RMb2FkZXIucHJvdG90eXBlO1xuICAgICAgX3Byb3RvMi5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfTtcbiAgICAgIF9wcm90bzIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgICBfcHJvdG8yLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH07XG4gICAgICBfY3JlYXRlQ2xhc3MoQ21jZFBsYXlsaXN0TG9hZGVyLCBbe1xuICAgICAgICBrZXk6IFwic3RhdHNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gQ21jZFBsYXlsaXN0TG9hZGVyO1xuICAgIH0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovO1xuICBfcHJvdG8uY3JlYXRlRnJhZ21lbnRMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudExvYWRlcigpIHtcbiAgICB2YXIgZkxvYWRlciA9IHRoaXMuY29uZmlnLmZMb2FkZXI7XG4gICAgdmFyIGFwcGx5ID0gdGhpcy5hcHBseUZyYWdtZW50RGF0YTtcbiAgICB2YXIgQ3RvciA9IGZMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ21jZEZyYWdtZW50TG9hZGVyKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgdmFyIF9wcm90bzMgPSBDbWNkRnJhZ21lbnRMb2FkZXIucHJvdG90eXBlO1xuICAgICAgX3Byb3RvMy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfTtcbiAgICAgIF9wcm90bzMuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgICBfcHJvdG8zLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH07XG4gICAgICBfY3JlYXRlQ2xhc3MoQ21jZEZyYWdtZW50TG9hZGVyLCBbe1xuICAgICAgICBrZXk6IFwic3RhdHNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gQ21jZEZyYWdtZW50TG9hZGVyO1xuICAgIH0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovO1xuICBDTUNEQ29udHJvbGxlci51dWlkID0gZnVuY3Rpb24gdXVpZCgpIHtcbiAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICB2YXIgdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICByZXR1cm4gdXVpZC5zbGljZSh1dWlkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBDTUNEIGRhdGEgb2JqZWN0IGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBpbiB0aGVcbiAgICogc2VjdGlvbiAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqLztcbiAgQ01DRENvbnRyb2xsZXIuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGRhdGEpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9O1xuICAgIHZhciB0b1JvdW5kZWQgPSBmdW5jdGlvbiB0b1JvdW5kZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciB0b0h1bmRyZWQgPSBmdW5jdGlvbiB0b0h1bmRyZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1JvdW5kZWQodmFsdWUgLyAxMDApICogMTAwO1xuICAgIH07XG4gICAgdmFyIHRvVXJsU2FmZSA9IGZ1bmN0aW9uIHRvVXJsU2FmZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybWF0dGVycyA9IHtcbiAgICAgIGJyOiB0b1JvdW5kZWQsXG4gICAgICBkOiB0b1JvdW5kZWQsXG4gICAgICBibDogdG9IdW5kcmVkLFxuICAgICAgZGw6IHRvSHVuZHJlZCxcbiAgICAgIG10cDogdG9IdW5kcmVkLFxuICAgICAgbm9yOiB0b1VybFNhZmUsXG4gICAgICBydHA6IHRvSHVuZHJlZCxcbiAgICAgIHRiOiB0b1JvdW5kZWRcbiAgICB9O1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSB8fCB7fSkuc29ydCgpO1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGtleXMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgLy8gaWdub3JlIGludmFsaWQgdmFsdWVzXG4gICAgICBpZiAoIWlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJzaW9uIHNob3VsZCBvbmx5IGJlIHJlcG9ydGVkIGlmIG5vdCBlcXVhbCB0byAxLlxuICAgICAgaWYgKGtleSA9PT0gJ3YnICYmIHZhbHVlID09PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBQbGF5YmFjayByYXRlIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgICBpZiAoa2V5ID09ICdwcicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENlcnRhaW4gdmFsdWVzIHJlcXVpcmUgc3BlY2lhbCBmb3JtYXR0aW5nXG4gICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1trZXldO1xuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlcmlhbGl6ZSB0aGUga2V5L3ZhbHVlIHBhaXJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGlmIChrZXkgPT09ICdvdCcgfHwga2V5ID09PSAnc2YnIHx8IGtleSA9PT0gJ3N0Jykge1xuICAgICAgICByZXN1bHQgPSBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIHJlcXVlc3QgaGVhZGVycyBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzXG4gICAqIGRlZmluZWQgaW4gdGhlIHNlY3Rpb24gMi4xIGFuZCAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqLztcbiAgQ01DRENvbnRyb2xsZXIudG9IZWFkZXJzID0gZnVuY3Rpb24gdG9IZWFkZXJzKGRhdGEpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgdmFyIGhlYWRlck5hbWVzID0gWydPYmplY3QnLCAnUmVxdWVzdCcsICdTZXNzaW9uJywgJ1N0YXR1cyddO1xuICAgIHZhciBoZWFkZXJHcm91cHMgPSBbe30sIHt9LCB7fSwge31dO1xuICAgIHZhciBoZWFkZXJNYXAgPSB7XG4gICAgICBicjogMCxcbiAgICAgIGQ6IDAsXG4gICAgICBvdDogMCxcbiAgICAgIHRiOiAwLFxuICAgICAgYmw6IDEsXG4gICAgICBkbDogMSxcbiAgICAgIG10cDogMSxcbiAgICAgIG5vcjogMSxcbiAgICAgIG5ycjogMSxcbiAgICAgIHN1OiAxLFxuICAgICAgY2lkOiAyLFxuICAgICAgcHI6IDIsXG4gICAgICBzZjogMixcbiAgICAgIHNpZDogMixcbiAgICAgIHN0OiAyLFxuICAgICAgdjogMixcbiAgICAgIGJzOiAzLFxuICAgICAgcnRwOiAzXG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9rZXlzID0ga2V5czsgX2kgPCBfa2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrZXkgPSBfa2V5c1tfaV07XG4gICAgICAvLyBVbm1hcHBlZCBmaWVsZHMgYXJlIG1hcHBlZCB0byB0aGUgUmVxdWVzdCBoZWFkZXJcbiAgICAgIHZhciBpbmRleCA9IGhlYWRlck1hcFtrZXldICE9IG51bGwgPyBoZWFkZXJNYXBba2V5XSA6IDE7XG4gICAgICBoZWFkZXJHcm91cHNbaW5kZXhdW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBDTUNEQ29udHJvbGxlci5zZXJpYWxpemUoaGVhZGVyR3JvdXBzW2ldKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBoZWFkZXJzW1wiQ01DRC1cIiArIGhlYWRlck5hbWVzW2ldXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byBxdWVyeSBhcmdzIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAgICogZGVmaW5lZCBpbiB0aGUgc2VjdGlvbiAyLjIgYW5kIDMuMiBvZlxuICAgKiBbQ1RBLTUwMDRdKGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmKS5cbiAgICovO1xuICBDTUNEQ29udHJvbGxlci50b1F1ZXJ5ID0gZnVuY3Rpb24gdG9RdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ01DRD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChDTUNEQ29udHJvbGxlci5zZXJpYWxpemUoZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBxdWVyeSBhcmdzIHRvIGEgdXJpLlxuICAgKi87XG4gIENNQ0RDb250cm9sbGVyLmFwcGVuZFF1ZXJ5VG9VcmkgPSBmdW5jdGlvbiBhcHBlbmRRdWVyeVRvVXJpKHVyaSwgcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICB2YXIgc2VwYXJhdG9yID0gdXJpLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gICAgcmV0dXJuIFwiXCIgKyB1cmkgKyBzZXBhcmF0b3IgKyBxdWVyeTtcbiAgfTtcbiAgcmV0dXJuIENNQ0RDb250cm9sbGVyO1xufSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYWtleXMtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfa2V5c3lzdGVtX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2tleXN5c3RlbS11dGlsICovIFwiLi9zcmMvdXRpbHMva2V5c3lzdGVtLXV0aWwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX251bWVyaWNfZW5jb2RpbmdfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL251bWVyaWMtZW5jb2RpbmctdXRpbHMgKi8gXCIuL3NyYy91dGlscy9udW1lcmljLWVuY29kaW5nLXV0aWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfbGV2ZWxfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9oZXggKi8gXCIuL3NyYy91dGlscy9oZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18pO1xuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG4vKipcbiAqIEBhdXRob3IgU3RlcGhhbiBIZXNzZSA8ZGlzcGFyYXRAZ21haWwuY29tPiB8IDx0Y2hha2FiYW1AZ21haWwuY29tPlxuICpcbiAqIERSTSBzdXBwb3J0IGZvciBIbHMuanNcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcbnZhciBMT0dHRVJfUFJFRklYID0gJ1tlbWVdJztcbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMgKEVNRSlcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFTUVDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRU1FQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB7fTtcbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA/IFtFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlXSA6IFtdO1xuICAgIHRoaXMub25NZWRpYUVuY3J5cHRlZCA9IHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IHRoaXMuX29uV2FpdGluZ0ZvcktleS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGVidWcgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmRlYnVnLmJpbmQoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5sb2cgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZy5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMud2FybiA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIud2Fybi5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMuZXJyb3IgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmVycm9yLmJpbmQoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gRU1FQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hlZCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMub25NZWRpYUVuY3J5cHRlZCA9IHRoaXMub25XYWl0aW5nRm9yS2V5ID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSBudWxsO1xuICB9O1xuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmdldExpY2Vuc2VTZXJ2ZXJVcmwgPSBmdW5jdGlvbiBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgIHZhciBfdGhpcyRjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgIGRybVN5c3RlbXMgPSBfdGhpcyRjb25maWcuZHJtU3lzdGVtcyxcbiAgICAgIHdpZGV2aW5lTGljZW5zZVVybCA9IF90aGlzJGNvbmZpZy53aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgdmFyIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLmxpY2Vuc2VVcmw7XG4gICAgfVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoa2V5U3lzdGVtID09PSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLktleVN5c3RlbXMuV0lERVZJTkUgJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gIH07XG4gIF9wcm90by5nZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybCA9IGZ1bmN0aW9uIGdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSkge1xuICAgIHZhciBkcm1TeXN0ZW1zID0gdGhpcy5jb25maWcuZHJtU3lzdGVtcztcbiAgICB2YXIga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24uc2VydmVyQ2VydGlmaWNhdGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKFwiTm8gU2VydmVyIENlcnRpZmljYXRlIGluIGNvbmZpZy5kcm1TeXN0ZW1zW1xcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIl1cIik7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIGF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICB2YXIgdW5pcXVlQ29kZWMgPSBmdW5jdGlvbiB1bmlxdWVDb2RlYyh2YWx1ZSwgaSwgYSkge1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgYS5pbmRleE9mKHZhbHVlKSA9PT0gaTtcbiAgICB9O1xuICAgIHZhciBhdWRpb0NvZGVjcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICB9KS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIHZhciB2aWRlb0NvZGVjcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4gbGV2ZWwudmlkZW9Db2RlYztcbiAgICB9KS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGlmIChhdWRpb0NvZGVjcy5sZW5ndGggKyB2aWRlb0NvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZpZGVvQ29kZWNzLnB1c2goJ2F2YzEuNDJlMDFlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgYXR0ZW1wdCA9IGZ1bmN0aW9uIGF0dGVtcHQoa2V5U3lzdGVtcykge1xuICAgICAgICB2YXIga2V5U3lzdGVtID0ga2V5U3lzdGVtcy5zaGlmdCgpO1xuICAgICAgICBfdGhpcy5nZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKS50aGVuKGZ1bmN0aW9uIChtZWRpYUtleXMpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICBrZXlTeXN0ZW06IGtleVN5c3RlbSxcbiAgICAgICAgICAgIG1lZGlhS2V5czogbWVkaWFLZXlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChrZXlTeXN0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0ZW1wdChrZXlTeXN0ZW1zKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9LCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBhdHRlbXB0KGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gZnVuY3Rpb24gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICB2YXIgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyA9IHRoaXMuY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM7XG4gICAgaWYgKCEodHlwZW9mIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB2YXIgZXJyTWVzc2FnZSA9IFwiQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gXCIgKyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuICAgICAgaWYgKF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgZXJyTWVzc2FnZSA9IFwibmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBpcyBub3QgYXZhaWxhYmxlIG92ZXIgaW5zZWN1cmUgcHJvdG9jb2wgXCIgKyBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyhrZXlTeXN0ZW0sIHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zKTtcbiAgfTtcbiAgX3Byb3RvLmdldE1lZGlhS2V5c1Byb21pc2UgPSBmdW5jdGlvbiBnZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgIHZhciBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSAoMCxfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMpKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICB2YXIga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV07XG4gICAgdmFyIGtleVN5c3RlbUFjY2VzcyA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID09PSBudWxsIHx8IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5rZXlTeXN0ZW1BY2Nlc3M7XG4gICAgaWYgKCFrZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHRoaXMubG9nKFwiUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGtleS1zeXN0ZW0gYWNjZXNzIHdpdGggY29uZmlnOiBcIiArIEpTT04uc3RyaW5naWZ5KG1lZGlhS2V5U3lzdGVtQ29uZmlncykpO1xuICAgICAga2V5U3lzdGVtQWNjZXNzID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgICAgdmFyIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzOiBrZXlTeXN0ZW1BY2Nlc3NcbiAgICAgIH07XG4gICAgICBrZXlTeXN0ZW1BY2Nlc3MuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIF90aGlzMi5sb2coXCJGYWlsZWQgdG8gb2J0YWluIGFjY2VzcyB0byBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIjogXCIgKyBlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbihmdW5jdGlvbiAobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgX3RoaXMyLmxvZyhcIkFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBtZWRpYUtleVN5c3RlbUFjY2Vzcy5rZXlTeXN0ZW0gKyBcIlxcXCIgb2J0YWluZWRcIik7XG4gICAgICAgIHZhciBjZXJ0aWZpY2F0ZVJlcXVlc3QgPSBfdGhpczIuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pO1xuICAgICAgICBfdGhpczIubG9nKFwiQ3JlYXRlIG1lZGlhLWtleXMgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyA9IG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpLnRoZW4oZnVuY3Rpb24gKG1lZGlhS2V5cykge1xuICAgICAgICAgIF90aGlzMi5sb2coXCJNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgICByZXR1cm4gY2VydGlmaWNhdGVSZXF1ZXN0LnRoZW4oZnVuY3Rpb24gKGNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICBpZiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzIGZvciBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJ9OiBcIiArIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoX3JlZikge1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IF9yZWYuZGVjcnlwdGRhdGEsXG4gICAgICBrZXlTeXN0ZW0gPSBfcmVmLmtleVN5c3RlbSxcbiAgICAgIG1lZGlhS2V5cyA9IF9yZWYubWVkaWFLZXlzO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCEhbWVkaWFLZXlzLCAnbWVkaWFLZXlzIGlzIGRlZmluZWQnKTtcbiAgICB0aGlzLmxvZyhcIkNyZWF0aW5nIGtleS1zeXN0ZW0gc2Vzc2lvbiBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIga2V5SWQ6IFwiICsgX3V0aWxzX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXS5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKSk7XG4gICAgdmFyIG1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgIHZhciBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0ge1xuICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhLFxuICAgICAga2V5U3lzdGVtOiBrZXlTeXN0ZW0sXG4gICAgICBtZWRpYUtleXM6IG1lZGlhS2V5cyxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb246IG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBrZXlTdGF0dXM6ICdzdGF0dXMtcGVuZGluZydcbiAgICB9O1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9O1xuICBfcHJvdG8ucmVuZXdLZXlTZXNzaW9uID0gZnVuY3Rpb24gcmVuZXdLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICB2YXIgZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhO1xuICAgIGlmIChkZWNyeXB0ZGF0YS5wc3NoKSB7XG4gICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICB2YXIgX2tleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICB2YXIgc2NoZW1lID0gJ2NlbmMnO1xuICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2VbX2tleUlkXSA9IHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgZGVjcnlwdGRhdGEucHNzaCwgJ2V4cGlyZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IHJlbmV3IGV4cGlyZWQgc2Vzc2lvbi4gTWlzc2luZyBwc3NoIGluaXREYXRhLlwiKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICB9O1xuICBfcHJvdG8uZ2V0S2V5SWRTdHJpbmcgPSBmdW5jdGlvbiBnZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSkge1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlYWQga2V5SWQgb2YgdW5kZWZpbmVkIGRlY3J5cHRkYXRhJyk7XG4gICAgfVxuICAgIGlmIChkZWNyeXB0ZGF0YS5rZXlJZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXlJZCBpcyBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBfdXRpbHNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdLmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQpO1xuICB9O1xuICBfcHJvdG8udXBkYXRlS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIHVwZGF0ZUtleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCwgZGF0YSkge1xuICAgIHZhciBfbWVkaWFLZXlTZXNzaW9uQ29udGU7XG4gICAgdmFyIGtleVNlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgdGhpcy5sb2coXCJVcGRhdGluZyBrZXktc2Vzc2lvbiBcXFwiXCIgKyBrZXlTZXNzaW9uLnNlc3Npb25JZCArIFwiXFxcIiBmb3Iga2V5SUQgXCIgKyBfdXRpbHNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdLmhleER1bXAoKChfbWVkaWFLZXlTZXNzaW9uQ29udGUgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhKSA9PT0gbnVsbCB8fCBfbWVkaWFLZXlTZXNzaW9uQ29udGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tZWRpYUtleVNlc3Npb25Db250ZS5rZXlJZCkgfHwgW10pICsgXCJcXG4gICAgICB9IChkYXRhIGxlbmd0aDogXCIgKyAoZGF0YSA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGEpICsgXCIpXCIpO1xuICAgIHJldHVybiBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgfTtcbiAgX3Byb3RvLnNlbGVjdEtleVN5c3RlbUZvcm1hdCA9IGZ1bmN0aW9uIHNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKSB7XG4gICAgdmFyIGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyhmcmFnLmxldmVsa2V5cyB8fCB7fSk7XG4gICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgIHRoaXMubG9nKFwiU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBmcmFnbWVudCAoc246IFwiICsgZnJhZy5zbiArIFwiIFwiICsgZnJhZy50eXBlICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiKSBrZXkgZm9ybWF0cyBcIiArIGtleUZvcm1hdHMuam9pbignLCAnKSk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2U7XG4gIH07XG4gIF9wcm90by5nZXRLZXlGb3JtYXRQcm9taXNlID0gZnVuY3Rpb24gZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBrZXlTeXN0ZW1zSW5Db25maWcgPSAoMCxfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmdldEtleVN5c3RlbXNGb3JDb25maWcpKF90aGlzMy5jb25maWcpO1xuICAgICAgdmFyIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmIGtleVN5c3RlbXNJbkNvbmZpZy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpczMuZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShrZXlTeXN0ZW1zVG9BdHRlbXB0KS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIga2V5U3lzdGVtID0gX3JlZjIua2V5U3lzdGVtO1xuICAgICAgICB2YXIga2V5U3lzdGVtRm9ybWF0ID0gKDAsX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5rZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdCkoa2V5U3lzdGVtKTtcbiAgICAgICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgICAgIHJlc29sdmUoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgZm9ybWF0IGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5sb2FkS2V5ID0gZnVuY3Rpb24gbG9hZEtleShkYXRhKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgdmFyIGRlY3J5cHRkYXRhID0gZGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhO1xuICAgIHZhciBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgIHZhciBrZXlEZXRhaWxzID0gXCIoa2V5SWQ6IFwiICsga2V5SWQgKyBcIiBmb3JtYXQ6IFxcXCJcIiArIGRlY3J5cHRkYXRhLmtleUZvcm1hdCArIFwiXFxcIiBtZXRob2Q6IFwiICsgZGVjcnlwdGRhdGEubWV0aG9kICsgXCIgdXJpOiBcIiArIGRlY3J5cHRkYXRhLnVyaSArIFwiKVwiO1xuICAgIHRoaXMubG9nKFwiU3RhcnRpbmcgc2Vzc2lvbiBmb3Iga2V5IFwiICsga2V5RGV0YWlscyk7XG4gICAgdmFyIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKS50aGVuKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIga2V5U3lzdGVtID0gX3JlZjMua2V5U3lzdGVtLFxuICAgICAgICAgIG1lZGlhS2V5cyA9IF9yZWYzLm1lZGlhS2V5cztcbiAgICAgICAgX3RoaXM0LnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgX3RoaXM0LmxvZyhcIkhhbmRsZSBlbmNyeXB0ZWQgbWVkaWEgc246IFwiICsgZGF0YS5mcmFnLnNuICsgXCIgXCIgKyBkYXRhLmZyYWcudHlwZSArIFwiOiBcIiArIGRhdGEuZnJhZy5sZXZlbCArIFwiIHVzaW5nIGtleSBcIiArIGtleURldGFpbHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM0LmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdmFyIGtleVNlc3Npb25Db250ZXh0ID0gX3RoaXM0LmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAga2V5U3lzdGVtOiBrZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXM6IG1lZGlhS2V5cyxcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBkZWNyeXB0ZGF0YS5wc3NoLCAncGxheWxpc3Qta2V5Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZXNzaW9uQ29udGV4dFByb21pc2U7XG4gIH07XG4gIF9wcm90by50aHJvd0lmRGVzdHJveWVkID0gZnVuY3Rpb24gdGhyb3dJZkRlc3Ryb3llZChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkge1xuICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIHN0YXRlJztcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCBlcnJvci5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlID0gZnVuY3Rpb24gZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZShkZWNyeXB0ZGF0YSkge1xuICAgIHZhciBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgIHZhciBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgIGlmICghbWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgdmFyIGtleVN5c3RlbSA9ICgwLF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ua2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4pKGRlY3J5cHRkYXRhLmtleUZvcm1hdCk7XG4gICAgICB2YXIga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGtleVN5c3RlbSA/IFtrZXlTeXN0ZW1dIDogKDAsX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5nZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKSh0aGlzLmNvbmZpZyk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgfTtcbiAgX3Byb3RvLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2UgPSBmdW5jdGlvbiBnZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoKSB7XG4gICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0gKDAsX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5nZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKSh0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0sIFwiTWlzc2luZyBrZXktc3lzdGVtIGxpY2Vuc2UgY29uZmlndXJhdGlvbiBvcHRpb25zIFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkcm1TeXN0ZW1zOiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gIH07XG4gIF9wcm90by5fb25NZWRpYUVuY3J5cHRlZCA9IGZ1bmN0aW9uIF9vbk1lZGlhRW5jcnlwdGVkKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgdmFyIGluaXREYXRhVHlwZSA9IGV2ZW50LmluaXREYXRhVHlwZSxcbiAgICAgIGluaXREYXRhID0gZXZlbnQuaW5pdERhdGE7XG4gICAgdGhpcy5kZWJ1ZyhcIlxcXCJcIiArIGV2ZW50LnR5cGUgKyBcIlxcXCIgZXZlbnQ6IGluaXQgZGF0YSB0eXBlOiBcXFwiXCIgKyBpbml0RGF0YVR5cGUgKyBcIlxcXCJcIik7XG5cbiAgICAvLyBJZ25vcmUgZXZlbnQgd2hlbiBpbml0RGF0YSBpcyBudWxsXG4gICAgaWYgKGluaXREYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlJZDtcbiAgICB2YXIga2V5U3lzdGVtRG9tYWluO1xuICAgIGlmIChpbml0RGF0YVR5cGUgPT09ICdzaW5mJyAmJiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zW191dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uS2V5U3lzdGVtcy5GQUlSUExBWV0pIHtcbiAgICAgIC8vIE1hdGNoIHNpbmYga2V5SWQgdG8gcGxheWxpc3Qgc2tkOi8va2V5SWQ9XG4gICAgICB2YXIganNvbiA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5iaW4yc3RyKShuZXcgVWludDhBcnJheShpbml0RGF0YSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNpbmYgPSAoMCxfdXRpbHNfbnVtZXJpY19lbmNvZGluZ191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmJhc2U2NERlY29kZSkoSlNPTi5wYXJzZShqc29uKS5zaW5mKTtcbiAgICAgICAgdmFyIHRlbmMgPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18ucGFyc2VTaW5mKShuZXcgVWludDhBcnJheShzaW5mKSk7XG4gICAgICAgIGlmICghdGVuYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICBrZXlTeXN0ZW1Eb21haW4gPSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLktleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBzaW5mIFwiZW5jcnlwdGVkXCIgZXZlbnQgbWVzc2FnZSBpbml0RGF0YScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgY2xlYXItbGVhZCBrZXktc2Vzc2lvbiBjcmVhdGlvbiAob3RoZXJ3aXNlIGRlcGVuZCBvbiBwbGF5bGlzdCBrZXlzKVxuICAgICAgdmFyIHBzc2hJbmZvID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLnBhcnNlUHNzaCkoaW5pdERhdGEpO1xuICAgICAgaWYgKHBzc2hJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwc3NoSW5mby52ZXJzaW9uID09PSAwICYmIHBzc2hJbmZvLnN5c3RlbUlkID09PSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLktleVN5c3RlbUlkcy5XSURFVklORSAmJiBwc3NoSW5mby5kYXRhKSB7XG4gICAgICAgIGtleUlkID0gcHNzaEluZm8uZGF0YS5zdWJhcnJheSg4LCAyNCk7XG4gICAgICB9XG4gICAgICBrZXlTeXN0ZW1Eb21haW4gPSAoMCxfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmtleVN5c3RlbUlkVG9LZXlTeXN0ZW1Eb21haW4pKHBzc2hJbmZvLnN5c3RlbUlkKTtcbiAgICB9XG4gICAgaWYgKCFrZXlTeXN0ZW1Eb21haW4gfHwgIWtleUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlJZEhleCA9IF91dGlsc19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0uaGV4RHVtcChrZXlJZCk7XG4gICAgdmFyIGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlLFxuICAgICAgbWVkaWFLZXlTZXNzaW9ucyA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucztcbiAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XTtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAvLyBNYXRjaCBwbGF5bGlzdCBrZXlcbiAgICAgIHZhciBrZXlDb250ZXh0ID0gbWVkaWFLZXlTZXNzaW9uc1tpXTtcbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGtleUNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCB8fCAhZGVjcnlwdGRhdGEua2V5SWQpIHtcbiAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRLZXlJZEhleCA9IF91dGlsc19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0uaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCk7XG4gICAgICBpZiAoa2V5SWRIZXggPT09IG9sZEtleUlkSGV4IHx8IGRlY3J5cHRkYXRhLnVyaS5yZXBsYWNlKC8tL2csICcnKS5pbmRleE9mKGtleUlkSGV4KSAhPT0gLTEpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW29sZEtleUlkSGV4XTtcbiAgICAgICAgZGVsZXRlIGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtvbGRLZXlJZEhleF07XG4gICAgICAgIGRlY3J5cHRkYXRhLnBzc2ggPSBuZXcgVWludDhBcnJheShpbml0RGF0YSk7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF0gPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlDb250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LWtleS1tYXRjaCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFLZXlTZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChpKTtcbiAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICAgIGlmICgha2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAvLyBDbGVhci1sZWFkIGtleSAobm90IGVuY291bnRlcmVkIGluIHBsYXlsaXN0KVxuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XSA9IHRoaXMuZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShba2V5U3lzdGVtRG9tYWluXSkudGhlbihmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIF9rZXlTeXN0ZW1Ub0tleVN5c3RlbTtcbiAgICAgICAgdmFyIGtleVN5c3RlbSA9IF9yZWY0LmtleVN5c3RlbSxcbiAgICAgICAgICBtZWRpYUtleXMgPSBfcmVmNC5tZWRpYUtleXM7XG4gICAgICAgIF90aGlzNS50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG5ldyBfbG9hZGVyX2xldmVsX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkxldmVsS2V5KCdJU08tMjMwMDEtNycsIGtleUlkSGV4LCAoX2tleVN5c3RlbVRvS2V5U3lzdGVtID0gKDAsX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5rZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdCkoa2V5U3lzdGVtKSkgIT0gbnVsbCA/IF9rZXlTeXN0ZW1Ub0tleVN5c3RlbSA6ICcnKTtcbiAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5SWQgPSBrZXlJZDtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5hdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHZhciBrZXlTZXNzaW9uQ29udGV4dCA9IF90aGlzNS5jcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgICAgICAgIGtleVN5c3RlbToga2V5U3lzdGVtLFxuICAgICAgICAgICAgbWVkaWFLZXlzOiBtZWRpYUtleXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LW5vLW1hdGNoJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdGhpczUuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uX29uV2FpdGluZ0ZvcktleSA9IGZ1bmN0aW9uIF9vbldhaXRpbmdGb3JLZXkoZXZlbnQpIHtcbiAgICB0aGlzLmxvZyhcIlxcXCJcIiArIGV2ZW50LnR5cGUgKyBcIlxcXCIgZXZlbnRcIik7XG4gIH07XG4gIF9wcm90by5hdHRlbXB0U2V0TWVkaWFLZXlzID0gZnVuY3Rpb24gYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuc2V0TWVkaWFLZXlzUXVldWUuc2xpY2UoKTtcbiAgICB0aGlzLmxvZyhcIlNldHRpbmcgbWVkaWEta2V5cyBmb3IgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgLy8gY2FuIGJlIHF1ZXVlZCBmb3IgZXhlY3V0aW9uIGZvciBtdWx0aXBsZSBrZXkgc2Vzc2lvbnMuXG4gICAgdmFyIHNldE1lZGlhS2V5c1Byb21pc2UgPSBQcm9taXNlLmFsbChxdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzNi5tZWRpYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgbWVkaWEgZWxlbWVudCBhdHRhY2hlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzNi5tZWRpYS5zZXRNZWRpYUtleXMobWVkaWFLZXlzKTtcbiAgICB9KTtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgcmV0dXJuIHNldE1lZGlhS2V5c1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczYubG9nKFwiTWVkaWEta2V5cyBzZXQgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgIHF1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgICBfdGhpczYuc2V0TWVkaWFLZXlzUXVldWUgPSBfdGhpczYuc2V0TWVkaWFLZXlzUXVldWUuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZS5pbmRleE9mKHApID09PSAtMTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24gPSBmdW5jdGlvbiBnZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihjb250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCByZWFzb24pIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnJGRybVN5c3RlLFxuICAgICAgX3RoaXMkY29uZmlnJGRybVN5c3RlMixcbiAgICAgIF90aGlzNyA9IHRoaXM7XG4gICAgdmFyIGdlbmVyYXRlUmVxdWVzdEZpbHRlciA9IChfdGhpcyRjb25maWckZHJtU3lzdGUgPSB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zKSA9PT0gbnVsbCB8fCBfdGhpcyRjb25maWckZHJtU3lzdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpcyRjb25maWckZHJtU3lzdGUyID0gX3RoaXMkY29uZmlnJGRybVN5c3RlW2NvbnRleHQua2V5U3lzdGVtXSkgPT09IG51bGwgfHwgX3RoaXMkY29uZmlnJGRybVN5c3RlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY29uZmlnJGRybVN5c3RlMi5nZW5lcmF0ZVJlcXVlc3Q7XG4gICAgaWYgKGdlbmVyYXRlUmVxdWVzdEZpbHRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG1hcHBlZEluaXREYXRhID0gZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyLmNhbGwodGhpcy5obHMsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIW1hcHBlZEluaXREYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZyb20gY29uZmlndXJlZCBnZW5lcmF0ZVJlcXVlc3QgZmlsdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdERhdGFUeXBlID0gbWFwcGVkSW5pdERhdGEuaW5pdERhdGFUeXBlO1xuICAgICAgICBpbml0RGF0YSA9IGNvbnRleHQuZGVjcnlwdGRhdGEucHNzaCA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhID8gbmV3IFVpbnQ4QXJyYXkobWFwcGVkSW5pdERhdGEuaW5pdERhdGEpIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyRobHM7XG4gICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT09IG51bGwgJiYgX3RoaXMkaGxzICE9PSB2b2lkIDAgJiYgX3RoaXMkaGxzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2coXCJTa2lwcGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcXFwiXCIgKyByZWFzb24gKyBcIlxcXCIgKG5vIGluaXREYXRhKVwiKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgfVxuICAgIHZhciBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoY29udGV4dC5kZWNyeXB0ZGF0YSk7XG4gICAgdGhpcy5sb2coXCJHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFxcXCJcIiArIHJlYXNvbiArIFwiXFxcIjogXCIgKyBrZXlJZCArIFwiIChpbml0IGRhdGEgdHlwZTogXCIgKyBpbml0RGF0YVR5cGUgKyBcIiBsZW5ndGg6IFwiICsgKGluaXREYXRhID8gaW5pdERhdGEuYnl0ZUxlbmd0aCA6IG51bGwpICsgXCIpXCIpO1xuICAgIHZhciBsaWNlbnNlU3RhdHVzID0gbmV3IChldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCgpKSgpO1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZXNzYWdlVHlwZSA9IGV2ZW50Lm1lc3NhZ2VUeXBlLFxuICAgICAgICBtZXNzYWdlID0gZXZlbnQubWVzc2FnZTtcbiAgICAgIF90aGlzNy5sb2coXCJcXFwiXCIgKyBtZXNzYWdlVHlwZSArIFwiXFxcIiBtZXNzYWdlIGV2ZW50IGZvciBzZXNzaW9uIFxcXCJcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkICsgXCJcXFwiIG1lc3NhZ2Ugc2l6ZTogXCIgKyBtZXNzYWdlLmJ5dGVMZW5ndGgpO1xuICAgICAgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZXF1ZXN0JyB8fCBtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVuZXdhbCcpIHtcbiAgICAgICAgX3RoaXM3LnJlbmV3TGljZW5zZShjb250ZXh0LCBtZXNzYWdlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczcuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVsZWFzZScpIHtcbiAgICAgICAgaWYgKGNvbnRleHQua2V5U3lzdGVtID09PSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLktleVN5c3RlbXMuRkFJUlBMQVkpIHtcbiAgICAgICAgICBfdGhpczcudXBkYXRlS2V5U2Vzc2lvbihjb250ZXh0LCAoMCxfdXRpbHNfa2V5c3lzdGVtX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5zdHJUb1V0ZjhhcnJheSkoJ2Fja25vd2xlZGdlZCcpKTtcbiAgICAgICAgICBfdGhpczcucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXM3Lndhcm4oXCJ1bmhhbmRsZWQgbWVkaWEga2V5IG1lc3NhZ2UgdHlwZSBcXFwiXCIgKyBtZXNzYWdlVHlwZSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5vbmtleXN0YXR1c2VzY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczcub25LZXlTdGF0dXNDaGFuZ2UoY29udGV4dCk7XG4gICAgICB2YXIga2V5U3RhdHVzID0gY29udGV4dC5rZXlTdGF0dXM7XG4gICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2tleVN0YXR1cycsIGtleVN0YXR1cyk7XG4gICAgICBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgX3RoaXM3Lndhcm4oY29udGV4dC5rZXlTeXN0ZW0gKyBcIiBleHBpcmVkIGZvciBrZXkgXCIgKyBrZXlJZCk7XG4gICAgICAgIF90aGlzNy5yZW5ld0tleVNlc3Npb24oY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIga2V5VXNhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2tleVN0YXR1cycsIGZ1bmN0aW9uIChrZXlTdGF0dXMpIHtcbiAgICAgICAgaWYgKGtleVN0YXR1cy5zdGFydHNXaXRoKCd1c2FibGUnKSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdvdXRwdXQtcmVzdHJpY3RlZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgICAgfSwgJ0hEQ1AgbGV2ZWwgb3V0cHV0IHJlc3RyaWN0ZWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnaW50ZXJuYWwtZXJyb3InKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgfSwgXCJrZXkgc3RhdHVzIGNoYW5nZWQgdG8gXFxcIlwiICsga2V5U3RhdHVzICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdleHBpcmVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2tleSBleHBpcmVkIHdoaWxlIGdlbmVyYXRpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczcud2FybihcInVuaGFuZGxlZCBrZXkgc3RhdHVzIGNoYW5nZSBcXFwiXCIgKyBrZXlTdGF0dXMgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb250ZXh0JG1lZGlhS2V5c1NlcztcbiAgICAgIF90aGlzNy5sb2coXCJSZXF1ZXN0IGdlbmVyYXRlZCBmb3Iga2V5LXNlc3Npb24gXFxcIlwiICsgKChfY29udGV4dCRtZWRpYUtleXNTZXMgPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pID09PSBudWxsIHx8IF9jb250ZXh0JG1lZGlhS2V5c1NlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHQkbWVkaWFLZXlzU2VzLnNlc3Npb25JZCkgKyBcIlxcXCIga2V5SWQ6IFwiICsga2V5SWQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9LCBcIkVycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDogXCIgKyBlcnJvcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ga2V5VXNhYmxlUHJvbWlzZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICBfdGhpczcucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ub25LZXlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiBvbktleVN0YXR1c0NoYW5nZShtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmZvckVhY2goZnVuY3Rpb24gKHN0YXR1cywga2V5SWQpIHtcbiAgICAgIF90aGlzOC5sb2coXCJrZXkgc3RhdHVzIGNoYW5nZSBcXFwiXCIgKyBzdGF0dXMgKyBcIlxcXCIgZm9yIGtleVN0YXR1c2VzIGtleUlkOiBcIiArIF91dGlsc19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0uaGV4RHVtcCgnYnVmZmVyJyBpbiBrZXlJZCA/IG5ldyBVaW50OEFycmF5KGtleUlkLmJ1ZmZlciwga2V5SWQuYnl0ZU9mZnNldCwga2V5SWQuYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShrZXlJZCkpICsgXCIgc2Vzc2lvbiBrZXlJZDogXCIgKyBfdXRpbHNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdLmhleER1bXAobmV3IFVpbnQ4QXJyYXkobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YS5rZXlJZCB8fCBbXSkpICsgXCIgdXJpOiBcIiArIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEudXJpKTtcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQua2V5U3RhdHVzID0gc3RhdHVzO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uIGZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB1cmwgPSBfdGhpczkuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKTtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBfdGhpczkubG9nKFwiRmV0Y2hpbmcgc2VydmVyQ2VydGlmaWNhdGUgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHhoclxuICAgICAgICAgICAgfSwgXCJcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgY2VydGlmaWNhdGUgcmVxdWVzdCBYSFIgZmFpbGVkIChcIiArIHVybCArIFwiKS4gU3RhdHVzOiBcIiArIHhoci5zdGF0dXMgKyBcIiAoXCIgKyB4aHIuc3RhdHVzVGV4dCArIFwiKVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLnNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlID0gZnVuY3Rpb24gc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnQpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIG1lZGlhS2V5cy5zZXRTZXJ2ZXJDZXJ0aWZpY2F0ZShjZXJ0KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgIF90aGlzMTAubG9nKFwic2V0U2VydmVyQ2VydGlmaWNhdGUgXCIgKyAoc3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdub3Qgc3VwcG9ydGVkIGJ5IENETScpICsgXCIgKFwiICsgKGNlcnQgPT09IG51bGwgfHwgY2VydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VydC5ieXRlTGVuZ3RoKSArIFwiKSBvbiBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICAgIHJlc29sdmUobWVkaWFLZXlzKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5yZW5ld0xpY2Vuc2UgPSBmdW5jdGlvbiByZW5ld0xpY2Vuc2UoY29udGV4dCwga2V5TWVzc2FnZSkge1xuICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TGljZW5zZShjb250ZXh0LCBuZXcgVWludDhBcnJheShrZXlNZXNzYWdlKSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIF90aGlzMTEudXBkYXRlS2V5U2Vzc2lvbihjb250ZXh0LCBuZXcgVWludDhBcnJheShkYXRhKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uc2V0dXBMaWNlbnNlWEhSID0gZnVuY3Rpb24gc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG4gICAgdmFyIGxpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICBpZiAoIWxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHhocjogeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlOiBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcmVtb3ZlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKF90aGlzMTIuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgIC8vIEtleSBzZXNzaW9uIHJlbW92ZWQuIENhbmNlbCBsaWNlbnNlIHJlcXVlc3QuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaWNlbnNlWGhyU2V0dXAuY2FsbChfdGhpczEyLmhscywgeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAobGljZW5zZVhoclNldHVwUmVzdWx0KSB7XG4gICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbmFsTGljZW5zZUNoYWxsZW5nZSA9IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA/IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA6IGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4aHI6IHhocixcbiAgICAgICAgbGljZW5zZUNoYWxsZW5nZTogZmluYWxMaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVxdWVzdExpY2Vuc2UgPSBmdW5jdGlvbiByZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgIHZhciBfdGhpczEzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHVybCA9IF90aGlzMTMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0pO1xuICAgICAgX3RoaXMxMy5sb2coXCJTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6IFwiICsgdXJsKTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpczEzLmhscyB8fCAha2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIF90aGlzMTMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgX3RoaXMxMy5sb2coXCJMaWNlbnNlIHJlY2VpdmVkIFwiICsgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGEpKTtcbiAgICAgICAgICAgIHZhciBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IF90aGlzMTMuY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrLmNhbGwoX3RoaXMxMy5obHMsIHhociwgdXJsLCBrZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMxMy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzMTMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgICBpZiAoX3RoaXMxMy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPiBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIHx8IHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogeGhyXG4gICAgICAgICAgICAgIH0sIFwiTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKFwiICsgdXJsICsgXCIpLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyArIFwiIChcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIpXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhdHRlbXB0c0xlZnQgPSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIC0gX3RoaXMxMy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgKyAxO1xuICAgICAgICAgICAgICBfdGhpczEzLndhcm4oXCJSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsIFwiICsgYXR0ZW1wdHNMZWZ0ICsgXCIgYXR0ZW1wdHMgbGVmdFwiKTtcbiAgICAgICAgICAgICAgX3RoaXMxMy5yZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyICYmIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0geGhyO1xuICAgICAgX3RoaXMxMy5zZXR1cExpY2Vuc2VYSFIoeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgeGhyID0gX3JlZjUueGhyLFxuICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2UgPSBfcmVmNS5saWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgICB4aHIuc2VuZChsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmdmb3JrZXknLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gIH07XG4gIF9wcm90by5vbk1lZGlhRGV0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIG1lZGlhS2V5c0xpc3QgPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IFtdO1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucyA9IFtdO1xuICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgX2xvYWRlcl9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5MZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgIC8vIENsb3NlIGFsbCBzZXNzaW9ucyBhbmQgcmVtb3ZlIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICB2YXIga2V5U2Vzc2lvbkNvdW50ID0gbWVkaWFLZXlzTGlzdC5sZW5ndGg7XG4gICAgRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IFByb21pc2UuYWxsKG1lZGlhS2V5c0xpc3QubWFwKGZ1bmN0aW9uIChtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICByZXR1cm4gX3RoaXMxNC5yZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgIH0pLmNvbmNhdChtZWRpYSA9PT0gbnVsbCB8fCBtZWRpYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVkaWEuc2V0TWVkaWFLZXlzKG51bGwpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3RoaXMxNC5sb2coXCJDb3VsZCBub3QgY2xlYXIgbWVkaWEga2V5czogXCIgKyBlcnJvciArIFwiLiBtZWRpYS5zcmM6IFwiICsgKG1lZGlhID09PSBudWxsIHx8IG1lZGlhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZWRpYS5zcmMpKTtcbiAgICB9KSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGtleVNlc3Npb25Db3VudCkge1xuICAgICAgICBfdGhpczE0LmxvZygnZmluaXNoZWQgY2xvc2luZyBrZXkgc2Vzc2lvbnMgYW5kIGNsZWFyaW5nIG1lZGlhIGtleXMnKTtcbiAgICAgICAgbWVkaWFLZXlzTGlzdC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3RoaXMxNC5sb2coXCJDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbnMgYW5kIGNsZWFyIG1lZGlhIGtleXM6IFwiICsgZXJyb3IgKyBcIi4gbWVkaWEuc3JjOiBcIiArIChtZWRpYSA9PT0gbnVsbCB8fCBtZWRpYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVkaWEuc3JjKSk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChldmVudCwgX3JlZjYpIHtcbiAgICB2YXIgc2Vzc2lvbktleXMgPSBfcmVmNi5zZXNzaW9uS2V5cztcbiAgICBpZiAoIXNlc3Npb25LZXlzIHx8ICF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICB2YXIga2V5Rm9ybWF0cyA9IHNlc3Npb25LZXlzLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0cywgc2Vzc2lvbktleSkge1xuICAgICAgICBpZiAoZm9ybWF0cy5pbmRleE9mKHNlc3Npb25LZXkua2V5Rm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3JtYXRzLnB1c2goc2Vzc2lvbktleS5rZXlGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwgW10pO1xuICAgICAgdGhpcy5sb2coXCJTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIHNlc3Npb24ta2V5cyBcIiArIGtleUZvcm1hdHMuam9pbignLCAnKSk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucmVtb3ZlU2Vzc2lvbiA9IGZ1bmN0aW9uIHJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIHZhciBfdGhpczE1ID0gdGhpcztcbiAgICB2YXIgbWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbixcbiAgICAgIGxpY2Vuc2VYaHIgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHI7XG4gICAgaWYgKG1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgIHRoaXMubG9nKFwiUmVtb3ZlIGxpY2Vuc2VzIGFuZCBrZXlzIGFuZCBjbG9zZSBzZXNzaW9uIFwiICsgbWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5vbmtleXN0YXR1c2VzY2hhbmdlID0gbnVsbDtcbiAgICAgIGlmIChsaWNlbnNlWGhyICYmIGxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICBsaWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5tZWRpYUtleVNlc3Npb25zLmluZGV4T2YobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZSgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBfdGhpczE1LmxvZyhcIkNvdWxkIG5vdCByZW1vdmUgc2Vzc2lvbjogXCIgKyBlcnJvcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBfdGhpczE1LmxvZyhcIkNvdWxkIG5vdCBjbG9zZSBzZXNzaW9uOiBcIiArIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEVNRUNvbnRyb2xsZXI7XG59KCk7XG5FTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gdm9pZCAwO1xudmFyIEVNRUtleUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoRU1FS2V5RXJyb3IsIF9FcnJvcik7XG4gIGZ1bmN0aW9uIEVNRUtleUVycm9yKGRhdGEsIG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXMxNjtcbiAgICBfdGhpczE2ID0gX0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpczE2LmRhdGEgPSB2b2lkIDA7XG4gICAgX3RoaXMxNi5kYXRhID0gZGF0YTtcbiAgICBkYXRhLmVyciA9IGRhdGEuZXJyb3I7XG4gICAgcmV0dXJuIF90aGlzMTY7XG4gIH1cbiAgcmV0dXJuIEVNRUtleUVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoRU1FQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxudmFyIEZQU0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcblxuICBmdW5jdGlvbiBGUFNDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHZhciBfcHJvdG8gPSBGUFNDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnNldFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9O1xuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nKTtcbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5jaGVja0ZQUyA9IGZ1bmN0aW9uIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuICAgICAgICB2YXIgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgdmFyIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXM7XG4gICAgICAgIHZhciBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkZQU19EUk9QLCB7XG4gICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5sb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywge1xuICAgICAgICAgICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgICAgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH07XG4gIF9wcm90by5jaGVja0ZQU0ludGVydmFsID0gZnVuY3Rpb24gY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICB2YXIgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSFRNTFZpZGVvRWxlbWVudCBkb2Vzbid0IGluY2x1ZGUgdGhlIHdlYmtpdCB0eXBlc1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEZQU0NvbnRyb2xsZXI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEZQU0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmaW5kRnJhZ1dpdGhDQ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBmaW5kRnJhZ1dpdGhDQyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZmluZEZyYWdtZW50QnlQRFRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZmluZEZyYWdtZW50QnlQRFQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImZpbmRGcmFnbWVudEJ5UFRTXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpbmRGcmFnbWVudEJ5UFRTKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3RcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYmluYXJ5X3NlYXJjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCAqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHNcIik7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQuXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtQRFRWYWx1ZSA9IG51bGxdIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfG51bGx9IGZyYWdtZW50IC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoUERUVmFsdWUgPT09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICB2YXIgc3RhcnRQRFQgPSBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPCAoc3RhcnRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgZm9yICh2YXIgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7Kn0gZm91bmRGcmFnIC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHtcbiAgICBidWZmZXJFbmQgPSAwO1xuICB9XG4gIGlmIChtYXhGcmFnTG9va1VwVG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgfVxuICB2YXIgZnJhZ05leHQgPSBudWxsO1xuICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gfHwgbnVsbDtcbiAgfSBlbHNlIGlmIChidWZmZXJFbmQgPT09IDAgJiYgZnJhZ21lbnRzWzBdLnN0YXJ0ID09PSAwKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbMF07XG4gIH1cbiAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICBpZiAoZnJhZ05leHQgJiYgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PSAwKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIC8vIFdlIG1pZ2h0IGJlIHNlZWtpbmcgcGFzdCB0aGUgdG9sZXJhbmNlIHNvIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgdmFyIGZvdW5kRnJhZ21lbnQgPSBfdXRpbHNfYmluYXJ5X3NlYXJjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcbiAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gIH1cbiAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHtcbiAgICBidWZmZXJFbmQgPSAwO1xuICB9XG4gIGlmIChtYXhGcmFnTG9va1VwVG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgfVxuICAvLyBlYWdlcmx5IGFjY2VwdCBhbiBhY2N1cmF0ZSBtYXRjaCAobm8gdG9sZXJhbmNlKVxuICBpZiAoY2FuZGlkYXRlLnN0YXJ0IDw9IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gPiBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BkdEJ1ZmZlckVuZCA9IDBdIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KHBkdEJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcblxuICAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuICB2YXIgZW5kUHJvZ3JhbURhdGVUaW1lID0gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSB8fCAwO1xuICByZXR1cm4gZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICByZXR1cm4gX3V0aWxzX2JpbmFyeV9zZWFyY2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uc2VhcmNoKGZyYWdtZW50cywgZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgIGlmIChjYW5kaWRhdGUuY2MgPCBjYykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBjYykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJGcmFnbWVudFN0YXRlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEZyYWdtZW50U3RhdGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkZyYWdtZW50VHJhY2tlclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBGcmFnbWVudFRyYWNrZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuXG5cbnZhciBGcmFnbWVudFN0YXRlO1xuKGZ1bmN0aW9uIChGcmFnbWVudFN0YXRlKSB7XG4gIEZyYWdtZW50U3RhdGVbXCJOT1RfTE9BREVEXCJdID0gXCJOT1RfTE9BREVEXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJBUFBFTkRJTkdcIl0gPSBcIkFQUEVORElOR1wiO1xuICBGcmFnbWVudFN0YXRlW1wiUEFSVElBTFwiXSA9IFwiUEFSVElBTFwiO1xuICBGcmFnbWVudFN0YXRlW1wiT0tcIl0gPSBcIk9LXCI7XG59KShGcmFnbWVudFN0YXRlIHx8IChGcmFnbWVudFN0YXRlID0ge30pKTtcbnZhciBGcmFnbWVudFRyYWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFnbWVudFRyYWNrZXIoaGxzKSB7XG4gICAgdGhpcy5hY3RpdmVGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVQYXJ0cyA9IG51bGw7XG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZTtcbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSB0aGlzLnRpbWVSYW5nZXMgPSB0aGlzLmFjdGl2ZUZyYWdtZW50ID0gdGhpcy5hY3RpdmVQYXJ0cyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgd2l0aCBhbiBhcHBlbmRlZCByYW5nZSB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqLztcbiAgX3Byb3RvLmdldEFwcGVuZGVkRnJhZyA9IGZ1bmN0aW9uIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgaWYgKGxldmVsVHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHZhciBhY3RpdmVGcmFnbWVudCA9IHRoaXMuYWN0aXZlRnJhZ21lbnQsXG4gICAgICAgIGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0cztcbiAgICAgIGlmICghYWN0aXZlRnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFjdGl2ZVBhcnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gYWN0aXZlUGFydHNbaV07XG4gICAgICAgICAgdmFyIGFwcGVuZGVkUFRTID0gYWN0aXZlUGFydCA/IGFjdGl2ZVBhcnQuZW5kIDogYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFM7XG4gICAgICAgICAgaWYgKGFjdGl2ZVBhcnQuc3RhcnQgPD0gcG9zaXRpb24gJiYgYXBwZW5kZWRQVFMgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbiA8PSBhcHBlbmRlZFBUUykge1xuICAgICAgICAgICAgLy8gOSBpcyBhIG1hZ2ljIG51bWJlci4gcmVtb3ZlIHBhcnRzIGZyb20gbG9va3VwIGFmdGVyIGEgbWF0Y2ggYnV0IGtlZXAgc29tZSBzaG9ydCBzZWVrcyBiYWNrLlxuICAgICAgICAgICAgaWYgKGkgPiA5KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFydHMgPSBhY3RpdmVQYXJ0cy5zbGljZShpIC0gOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlUGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlRnJhZ21lbnQuc3RhcnQgPD0gcG9zaXRpb24gJiYgYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFMgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbiA8PSBhY3RpdmVGcmFnbWVudC5hcHBlbmRlZFBUUykge1xuICAgICAgICByZXR1cm4gYWN0aXZlRnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovO1xuICBfcHJvdG8uZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICB2YXIgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleXNbaV1dO1xuICAgICAgaWYgKChmcmFnbWVudEVudGl0eSA9PT0gbnVsbCB8fCBmcmFnbWVudEVudGl0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlKSA9PT0gbGV2ZWxUeXBlICYmIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi87XG4gIF9wcm90by5kZXRlY3RFdmljdGVkRnJhZ21lbnRzID0gZnVuY3Rpb24gZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMudGltZVJhbmdlcykge1xuICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gX3RoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlc0RhdGEudGltZS5zb21lKGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHZhciBpc05vdEJ1ZmZlcmVkID0gIV90aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgIF90aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05vdEJ1ZmZlcmVkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgKi87XG4gIF9wcm90by5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzID0gZnVuY3Rpb24gZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgIGlmICghdGltZVJhbmdlcyB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50YXJ5U3RyZWFtKSB7XG4gICAgICB2YXIgc3RyZWFtSW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIXN0cmVhbUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICB2YXIgcGFydGlhbCA9IHBhcnQgIT09IG51bGwgfHwgc3RyZWFtSW5mby5wYXJ0aWFsID09PSB0cnVlO1xuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSBfdGhpczIuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGZyYWdtZW50IGlmIG5vdGhpbmcgd2FzIGFwcGVuZGVkXG4gICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIGZyYWdCdWZmZXJlZChmcmFnKSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0QnVmZmVyZWRUaW1lcyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgIHZhciBidWZmZXJlZCA9IHtcbiAgICAgIHRpbWU6IFtdLFxuICAgICAgcGFydGlhbDogcGFydGlhbFxuICAgIH07XG4gICAgdmFyIHN0YXJ0UFRTID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnbWVudC5zdGFydDtcbiAgICB2YXIgZW5kUFRTID0gcGFydCA/IHBhcnQuZW5kIDogZnJhZ21lbnQuZW5kO1xuICAgIHZhciBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgIHZhciBtYXhTdGFydFBUUyA9IGZyYWdtZW50Lm1heFN0YXJ0UFRTIHx8IHN0YXJ0UFRTO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKG1heFN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBtaW5FbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKi87XG4gIF9wcm90by5nZXRQYXJ0aWFsRnJhZ21lbnQgPSBmdW5jdGlvbiBnZXRQYXJ0aWFsRnJhZ21lbnQodGltZSkge1xuICAgIHZhciBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgIHZhciB0aW1lUGFkZGluZztcbiAgICB2YXIgc3RhcnRUaW1lO1xuICAgIHZhciBlbmRUaW1lO1xuICAgIHZhciBiZXN0T3ZlcmxhcCA9IDA7XG4gICAgdmFyIGJ1ZmZlclBhZGRpbmcgPSB0aGlzLmJ1ZmZlclBhZGRpbmcsXG4gICAgICBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnQgLSBidWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmQgKyBidWZmZXJQYWRkaW5nO1xuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG4gICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICB9O1xuICBfcHJvdG8uaXNFbmRMaXN0QXBwZW5kZWQgPSBmdW5jdGlvbiBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgdmFyIGxhc3RGcmFnbWVudEVudGl0eSA9IHRoaXMuZW5kTGlzdEZyYWdtZW50c1t0eXBlXTtcbiAgICByZXR1cm4gbGFzdEZyYWdtZW50RW50aXR5ICE9PSB1bmRlZmluZWQgJiYgKGxhc3RGcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCBpc1BhcnRpYWwobGFzdEZyYWdtZW50RW50aXR5KSk7XG4gIH07XG4gIF9wcm90by5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgIH0gZWxzZSBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG4gIH07XG4gIF9wcm90by5pc1RpbWVCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIHZhciBzdGFydFRpbWU7XG4gICAgdmFyIGVuZFRpbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIC8vIGRvbid0IHRyYWNrIHBhcnRzIGZvciBtZW1vcnkgZWZmaWNpZW5jeVxuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QgfHwgcGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGxvYWRlZDogZGF0YSxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLm9uQnVmZmVyQXBwZW5kZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgdGltZVJhbmdlcyA9IGRhdGEudGltZVJhbmdlcztcbiAgICBpZiAoZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlRnJhZ21lbnQgIT09IGZyYWcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIGZyYWcuYXBwZW5kZWRQVFMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRzO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0cyA9IGFjdGl2ZVBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHRpbWVSYW5nZXMgbG9hZGVkIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgIHZhciB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgX3RoaXMzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKTtcbiAgICAgIGlmICghcGFydCAmJiBmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIHZhciBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlRW5kID0gdGltZVJhbmdlLmVuZChpKTtcbiAgICAgICAgICBpZiAocmFuZ2VFbmQgPD0gc3RyZWFtSW5mby5lbmRQVFMgJiYgcmFuZ2VFbmQgPiBzdHJlYW1JbmZvLnN0YXJ0UFRTKSB7XG4gICAgICAgICAgICBmcmFnLmFwcGVuZGVkUFRTID0gTWF0aC5tYXgocmFuZ2VFbmQsIGZyYWcuYXBwZW5kZWRQVFMgfHwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kZWRQVFMgPSBzdHJlYW1JbmZvLmVuZFBUUztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH07XG4gIF9wcm90by5oYXNGcmFnbWVudCA9IGZ1bmN0aW9uIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH07XG4gIF9wcm90by5yZW1vdmVGcmFnbWVudHNJblJhbmdlID0gZnVuY3Rpb24gcmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydCwgZW5kLCBwbGF5bGlzdFR5cGUpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBfdGhpczQuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICB2YXIgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgIGlmIChmcmFnLnR5cGUgPT09IHBsYXlsaXN0VHlwZSAmJiBmcmFnLnN0YXJ0IDwgZW5kICYmIGZyYWcuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICBfdGhpczQucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLnJlbW92ZUZyYWdtZW50ID0gZnVuY3Rpb24gcmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBmcmFnbWVudC5zdGF0cy5sb2FkZWQgPSAwO1xuICAgIGZyYWdtZW50LmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKTtcbiAgICBmcmFnbWVudC5hcHBlbmRlZFBUUyA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50LmVuZExpc3QpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnQudHlwZV07XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucmVtb3ZlQWxsRnJhZ21lbnRzID0gZnVuY3Rpb24gcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aXZlRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlUGFydHMgPSBudWxsO1xuICB9O1xuICByZXR1cm4gRnJhZ21lbnRUcmFja2VyO1xufSgpO1xuZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gIHZhciBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UsIF9mcmFnbWVudEVudGl0eSRyYW5nZTI7XG4gIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPSBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbykgPT09IG51bGwgfHwgX2ZyYWdtZW50RW50aXR5JHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pID09PSBudWxsIHx8IF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTIucGFydGlhbCkpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpIHtcbiAgcmV0dXJuIGZyYWdtZW50LnR5cGUgKyBcIl9cIiArIGZyYWdtZW50LmxldmVsICsgXCJfXCIgKyBmcmFnbWVudC51cmxJZCArIFwiX1wiICsgZnJhZ21lbnQuc247XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJNQVhfU1RBUlRfR0FQX0pVTVBcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTUFYX1NUQVJUX0dBUF9KVU1QKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EU1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlNUQUxMX01JTklNVU1fRFVSQVRJT05fTVNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBHYXBDb250cm9sbGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG52YXIgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbnZhciBNQVhfU1RBUlRfR0FQX0pVTVAgPSAyLjA7XG52YXIgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG52YXIgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xudmFyIEdhcENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEdhcENvbnRyb2xsZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0Q3VycmVudFRpbWUgUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXG4gICAqLztcbiAgX3Byb3RvLnBvbGwgPSBmdW5jdGlvbiBwb2xsKGxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIHN0YWxsZWQgPSB0aGlzLnN0YWxsZWQ7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgc2Vla2luZyA9IG1lZGlhLnNlZWtpbmc7XG4gICAgdmFyIHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICB2YXIgYmVnaW5TZWVrID0gIXRoaXMuc2Vla2luZyAmJiBzZWVraW5nO1xuICAgIHRoaXMuc2Vla2luZyA9IHNlZWtpbmc7XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgdmFyIF9zdGFsbGVkRHVyYXRpb24gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhbGxlZDtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIgKyBjdXJyZW50VGltZSArIFwiLCBhZnRlciBcIiArIE1hdGgucm91bmQoX3N0YWxsZWREdXJhdGlvbikgKyBcIm1zXCIpO1xuICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhbGxlZCBzdGF0ZSB3aGVuIGJlZ2lubmluZyBvciBmaW5pc2hpbmcgc2Vla2luZyBzbyB0aGF0IHdlIGRvbid0IHJlcG9ydCBzdGFsbHMgY29taW5nIG91dCBvZiBhIHNlZWtcbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICBpZiAobWVkaWEucGF1c2VkICYmICFzZWVraW5nIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fCAhX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICB2YXIgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDtcblxuICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgdmFyIGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgLy8gTmV4dCBidWZmZXJlZCByYW5nZSBpcyB0b28gZmFyIGFoZWFkIHRvIGp1bXAgdG8gd2hpbGUgc3RpbGwgc2Vla2luZ1xuICAgICAgdmFyIG5vQnVmZmVyR2FwID0gIW5leHRTdGFydCB8fCBhY3RpdmVGcmFnICYmIGFjdGl2ZUZyYWcuc3RhcnQgPD0gY3VycmVudFRpbWUgfHwgbmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiYgIXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICBpZiAoaGFzRW5vdWdoQnVmZmVyIHx8IG5vQnVmZmVyR2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IG1vdmVkIHN0YXRlIHdoZW4gc2Vla2luZyB0byBhIHBvaW50IGluIG9yIGJlZm9yZSBhIGdhcFxuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNraXAgc3RhcnQgZ2FwcyBpZiB3ZSBoYXZlbid0IHBsYXllZCwgYnV0IHRoZSBsYXN0IHBvbGwgZGV0ZWN0ZWQgdGhlIHN0YXJ0IG9mIGEgc3RhbGxcbiAgICAvLyBUaGUgYWRkaXRpb24gcG9sbCBnaXZlcyB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byBqdW1wIHRoZSBnYXAgZm9yIHVzXG4gICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgICAgLy8gSnVtcCBzdGFydCBnYXBzIHdpdGhpbiBqdW1wIHRocmVzaG9sZFxuICAgICAgdmFyIHN0YXJ0SnVtcCA9IE1hdGgubWF4KG5leHRTdGFydCwgYnVmZmVySW5mby5zdGFydCB8fCAwKSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgLy8gYSBsYXJnZXIganVtcCBvdmVyIHN0YXJ0IGdhcHMgY2F1c2VkIGJ5IHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBidWZmZXJpbmcgYSBzdGFydCBmcmFnbWVudFxuICAgICAgLy8gdGhhdCBiZWdpbnMgb3ZlciAxIHRhcmdldCBkdXJhdGlvbiBhZnRlciB0aGUgdmlkZW8gc3RhcnQgcG9zaXRpb24uXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHMgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXSA6IG51bGw7XG4gICAgICB2YXIgaXNMaXZlID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09PSBudWxsIHx8IF9sZXZlbCRkZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5saXZlO1xuICAgICAgdmFyIG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgc3RhcnRKdW1wIDw9IG1heFN0YXJ0R2FwSnVtcCkge1xuICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICB2YXIgdG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHN0YWxsZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICBpZiAoIXNlZWtpbmcgJiYgc3RhbGxlZER1cmF0aW9uID49IFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBidWZmZXJlZFdpdGhIb2xlcyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVyZWRXaXRoSG9sZXMsIHN0YWxsZWREdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBidWZmZXJJbmZvIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uTXMgLSBUaGUgYW1vdW50IG9mIHRpbWUgSGxzLmpzIGhhcyBiZWVuIHN0YWxsaW5nIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovO1xuICBfcHJvdG8uX3RyeUZpeEJ1ZmZlclN0YWxsID0gZnVuY3Rpb24gX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbk1zKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgdmFyIHRhcmdldFRpbWUgPSB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICAgIC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgZG9uJ3QgaGFuZGxlIGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgaWYgKHRhcmdldFRpbWUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgIC8vIHdlIG1heSBqdXN0IGhhdmUgdG8gXCJudWRnZVwiIHRoZSBwbGF5bGlzdCBhcyB0aGUgYnJvd3NlciBkZWNvZGluZy9yZW5kZXJpbmcgZW5naW5lXG4gICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci53YXJuKCdUcnlpbmcgdG8gbnVkZ2UgcGxheWhlYWQgb3ZlciBidWZmZXItaG9sZScpO1xuICAgICAgLy8gVHJ5IHRvIG51ZGdlIGN1cnJlbnRUaW1lIG92ZXIgYSBidWZmZXIgaG9sZSBpZiB3ZSd2ZSBiZWVuIHN0YWxsaW5nIGZvciB0aGUgY29uZmlndXJlZCBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgIC8vIFJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi87XG4gIF9wcm90by5fcmVwb3J0U3RhbGwgPSBmdW5jdGlvbiBfcmVwb3J0U3RhbGwoYnVmZmVySW5mbykge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIHN0YWxsUmVwb3J0ZWQgPSB0aGlzLnN0YWxsUmVwb3J0ZWQ7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci53YXJuKFwiUGxheWJhY2sgc3RhbGxpbmcgYXQgQFwiICsgbWVkaWEuY3VycmVudFRpbWUgKyBcIiBkdWUgdG8gbG93IGJ1ZmZlciAoXCIgKyBKU09OLnN0cmluZ2lmeShidWZmZXJJbmZvKSArIFwiKVwiKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlblxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovO1xuICBfcHJvdG8uX3RyeVNraXBCdWZmZXJIb2xlID0gZnVuY3Rpb24gX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgbGFzdEVuZFRpbWUgPSAwO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgdmFyIGJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICAgIGlmIChjdXJyZW50VGltZSArIGNvbmZpZy5tYXhCdWZmZXJIb2xlID49IGxhc3RFbmRUaW1lICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciB0YXJnZXRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lICsgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQsIG1lZGlhLmN1cnJlbnRUaW1lICsgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMpO1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBcImZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUsXG4gICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFRpbWU7XG4gICAgICB9XG4gICAgICBsYXN0RW5kVGltZSA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqLztcbiAgX3Byb3RvLl90cnlOdWRnZUJ1ZmZlciA9IGZ1bmN0aW9uIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIG51ZGdlUmV0cnkgPSB0aGlzLm51ZGdlUmV0cnk7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMubnVkZ2VSZXRyeSsrO1xuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIHZhciB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci53YXJuKFwiTnVkZ2luZyAnY3VycmVudFRpbWUnIGZyb20gXCIgKyBjdXJyZW50VGltZSArIFwiIHRvIFwiICsgdGFyZ2V0VGltZSk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci5lcnJvcihcIlBsYXloZWFkIHN0aWxsIG5vdCBtb3Zpbmcgd2hpbGUgZW5vdWdoIGRhdGEgYnVmZmVyZWQgQFwiICsgY3VycmVudFRpbWUgKyBcIiBhZnRlciBcIiArIGNvbmZpZy5udWRnZU1heFJldHJ5ICsgXCIgbnVkZ2VzXCIpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEdhcENvbnRyb2xsZXI7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZGF0ZS1yYW5nZSAqLyBcIi4vc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9kZW11eGVyICovIFwiLi9zcmMvdHlwZXMvZGVtdXhlci50c1wiKTtcblxuXG5cblxuXG5cbnZhciBNSU5fQ1VFX0RVUkFUSU9OID0gMC4yNTtcbmZ1bmN0aW9uIGdldEN1ZUNsYXNzKCkge1xuICAvLyBBdHRlbXB0IHRvIHJlY3JlYXRlIFNhZmFyaSBmdW5jdGlvbmFsaXR5IGJ5IGNyZWF0aW5nXG4gIC8vIFdlYktpdERhdGFDdWUgb2JqZWN0cyB3aGVuIGF2YWlsYWJsZSBhbmQgc3RvcmUgdGhlIGRlY29kZWRcbiAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcbiAgcmV0dXJuIHNlbGYuV2ViS2l0RGF0YUN1ZSB8fCBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbn1cblxuLy8gVlRUQ3VlIGxhdGVzdCBkcmFmdCBhbGxvd3MgYW4gaW5maW5pdGUgZHVyYXRpb24sIGZhbGxiYWNrXG4vLyB0byBNQVhfVkFMVUUgaWYgbmVjZXNzYXJ5XG52YXIgTUFYX0NVRV9FTkRUSU1FID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn0oKTtcbmZ1bmN0aW9uIGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oc3RyLnJlcGxhY2UoL14weC8sICcnKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJykucmVwbGFjZSgvICskLywgJycpLnNwbGl0KCcgJykpLmJ1ZmZlcjtcbn1cbnZhciBJRDNUcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHZhciBfcHJvdG8gPSBJRDNUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gIDtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5jbGVhckN1cnJlbnRDdWVzKSh0aGlzLmlkM1RyYWNrKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9O1xuICBfcHJvdG8uY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayhtZWRpYSkge1xuICAgIHZhciB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIHJldHVybiB0cmFjaztcbiAgfTtcbiAgX3Byb3RvLmdldElEM1RyYWNrID0gZnVuY3Rpb24gZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICAoMCxfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uc2VuZEFkZFRyYWNrRXZlbnQpKHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH07XG4gIF9wcm90by5vbkZyYWdQYXJzaW5nTWV0YWRhdGEgPSBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIF90aGlzJGhscyRjb25maWcgPSB0aGlzLmhscy5jb25maWcsXG4gICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzID0gX3RoaXMkaGxzJGNvbmZpZy5lbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzID0gX3RoaXMkaGxzJGNvbmZpZy5lbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG4gICAgaWYgKCFlbmFibGVFbXNnTWV0YWRhdGFDdWVzICYmICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNhbXBsZXMgPSBkYXRhLnNhbXBsZXM7XG5cbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICB2YXIgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGZyYW1lcyA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5nZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcbiAgICAgIGlmIChmcmFtZXMpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIHNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgIGlmIChlbmRUaW1lID4gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZURpZmYgPD0gMCkge1xuICAgICAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBNSU5fQ1VFX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcbiAgICAgICAgICBpZiAoIV9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICAgICAgLy8gYWRkIGEgYm91bmRzIHRvIGFueSB1bmJvdW5kZWQgY3Vlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB2YXIgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICAgICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgY3VlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by51cGRhdGVJZDNDdWVFbmRzID0gZnVuY3Rpb24gdXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUpIHtcbiAgICB2YXIgX3RoaXMkaWQzVHJhY2s7XG4gICAgdmFyIGN1ZXMgPSAoX3RoaXMkaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrKSA9PT0gbnVsbCB8fCBfdGhpcyRpZDNUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaWQzVHJhY2suY3VlcztcbiAgICBpZiAoY3Vlcykge1xuICAgICAgZm9yICh2YXIgaSA9IGN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgICBpZiAoY3VlLnN0YXJ0VGltZSA8IHN0YXJ0VGltZSAmJiBjdWUuZW5kVGltZSA9PT0gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgY3VlLmVuZFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgX3JlZikge1xuICAgIHZhciBzdGFydE9mZnNldCA9IF9yZWYuc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQgPSBfcmVmLmVuZE9mZnNldCxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjayxcbiAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfaGxzJGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzID0gX2hscyRjb25maWcuZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyA9IF9obHMkY29uZmlnLmVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICBpZiAoaWQzVHJhY2sgJiYgKGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSkge1xuICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIHByZWRpY2F0ZShjdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3VlLnR5cGUgPT09IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIHByZWRpY2F0ZShjdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3VlLnR5cGUgPT09IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24gcHJlZGljYXRlKGN1ZSkge1xuICAgICAgICAgIHJldHVybiBjdWUudHlwZSA9PT0gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5NZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgfHwgY3VlLnR5cGUgPT09IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLnJlbW92ZUN1ZXNJblJhbmdlKShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmMikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGRldGFpbHMgPSBfcmVmMi5kZXRhaWxzO1xuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXRoaXMuaGxzLmNvbmZpZy5lbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkLFxuICAgICAgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuICAgIHZhciBkYXRlUmFuZ2VzID0gZGV0YWlscy5kYXRlUmFuZ2VzO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgICAvLyBSZW1vdmUgY3VlcyBmcm9tIHRyYWNrIG5vdCBmb3VuZCBpbiBkZXRhaWxzLmRhdGVSYW5nZXNcbiAgICBpZiAoaWQzVHJhY2spIHtcbiAgICAgIHZhciBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCkuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gIWlkcy5pbmNsdWRlcyhpZCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGlkID0gaWRzVG9SZW1vdmVbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3VlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWQzVHJhY2sucmVtb3ZlQ3VlKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3Vlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSBpZHNUb1JlbW92ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuICAgIHZhciBsYXN0RnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCB8fCAhKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShsYXN0RnJhZ21lbnQgPT09IG51bGwgfHwgbGFzdEZyYWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICB2YXIgZGF0ZVRpbWVPZmZzZXQgPSBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lIC8gMTAwMCAtIGxhc3RGcmFnbWVudC5zdGFydDtcbiAgICB2YXIgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKF9pKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbX2ldO1xuICAgICAgdmFyIGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgdmFyIGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICB2YXIgY3VlcyA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT09IG51bGwgfHwgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuY3VlcykgfHwge307XG4gICAgICB2YXIgZHVyYXRpb25Lbm93biA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT09IG51bGwgfHwgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikgfHwgZmFsc2U7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGRhdGVSYW5nZS5zdGFydERhdGUsIGRhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIHZhciBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgdmFyIGVuZERhdGUgPSBkYXRlUmFuZ2UuZW5kRGF0ZTtcbiAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZW5kRGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICB2YXIgbmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MgPSBpZHMucmVkdWNlKGZ1bmN0aW9uIChmaWx0ZXJNYXBBcnJheSwgaWQpIHtcbiAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5jbGFzcyA9PT0gZGF0ZVJhbmdlLmNsYXNzICYmIGNhbmRpZGF0ZS5pZCAhPT0gaWQgJiYgY2FuZGlkYXRlLnN0YXJ0RGF0ZSA+IGRhdGVSYW5nZS5zdGFydERhdGUpIHtcbiAgICAgICAgICAgIGZpbHRlck1hcEFycmF5LnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbHRlck1hcEFycmF5O1xuICAgICAgICB9LCBbXSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBiLnN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzLnN0YXJ0RGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZS5hdHRyKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5ID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgaWYgKGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRGF0ZVJhbmdlQXR0cmlidXRlLklEIHx8IGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRGF0ZVJhbmdlQXR0cmlidXRlLkNMQVNTIHx8IGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRGF0ZVJhbmdlQXR0cmlidXRlLlNUQVJUX0RBVEUgfHwga2V5ID09PSBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5EYXRlUmFuZ2VBdHRyaWJ1dGUuRFVSQVRJT04gfHwga2V5ID09PSBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5EYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX0RBVEUgfHwga2V5ID09PSBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5EYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX09OX05FWFQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VlID0gY3Vlc1trZXldO1xuICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uS25vd24gJiYgIWFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhID0gZGF0ZVJhbmdlLmF0dHJba2V5XTtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgIGlmIChrZXkgPT09IF9sb2FkZXJfZGF0ZV9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkRhdGVSYW5nZUF0dHJpYnV0ZS5TQ1RFMzVfT1VUIHx8IGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRGF0ZVJhbmdlQXR0cmlidXRlLlNDVEUzNV9JTikge1xuICAgICAgICAgICAgZGF0YSA9IGhleFRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ZS52YWx1ZSA9IHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgY3VlLnR5cGUgPSBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLk1ldGFkYXRhU2NoZW1hLmRhdGVSYW5nZTtcbiAgICAgICAgICBfdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICBjdWVzW2tleV0gPSBjdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0gPSB7XG4gICAgICAgIGN1ZXM6IGN1ZXMsXG4gICAgICAgIGRhdGVSYW5nZTogZGF0ZVJhbmdlLFxuICAgICAgICBkdXJhdGlvbktub3duOiBkdXJhdGlvbktub3duXG4gICAgICB9O1xuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGlkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIF9sb29wMihfaSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSUQzVHJhY2tDb250cm9sbGVyO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChJRDNUcmFja0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGF0ZW5jeUNvbnRyb2xsZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5cblxuXG52YXIgTGF0ZW5jeUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXRlbmN5Q29udHJvbGxlcihobHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudGltZXVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gTGF0ZW5jeUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBudWxsO1xuICB9O1xuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgZGV0YWlscyA9IF9yZWYuZGV0YWlscztcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IGRldGFpbHM7XG4gICAgaWYgKGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMudGltZXVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMubGl2ZSAmJiB0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmxvZ2dlci53YXJuKCdbcGxheWJhY2stcmF0ZS1jb250cm9sbGVyXTogU3RhbGwgZGV0ZWN0ZWQsIGFkanVzdGluZyB0YXJnZXQgbGF0ZW5jeScpO1xuICB9O1xuICBfcHJvdG8udGltZXVwZGF0ZSA9IGZ1bmN0aW9uIHRpbWV1cGRhdGUoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7XG5cbiAgICAvLyBBZGFwdCBwbGF5YmFja1JhdGUgdG8gbWVldCB0YXJnZXQgbGF0ZW5jeSBpbiBsb3ctbGF0ZW5jeSBtb2RlXG4gICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgbG93TGF0ZW5jeU1vZGUgPSBfdGhpcyRjb25maWcubG93TGF0ZW5jeU1vZGUsXG4gICAgICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSA9IF90aGlzJGNvbmZpZy5tYXhMaXZlU3luY1BsYXliYWNrUmF0ZTtcbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgIGlmICh0YXJnZXRMYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTtcbiAgICAvLyBPbmx5IGFkanVzdCBwbGF5YmFja1JhdGUgd2hlbiB3aXRoaW4gb25lIHRhcmdldCBkdXJhdGlvbiBvZiB0YXJnZXRMYXRlbmN5XG4gICAgLy8gYW5kIG1vcmUgdGhhbiBvbmUgc2Vjb25kIGZyb20gdW5kZXItYnVmZmVyaW5nLlxuICAgIC8vIFBsYXliYWNrIGZ1cnRoZXIgdGhhbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIGZyb20gdGFyZ2V0IGNhbiBiZSBjb25zaWRlcmVkIERWUiBwbGF5YmFjay5cbiAgICB2YXIgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgdmFyIGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgaW5MaXZlUmFuZ2UgJiYgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJiB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5taW4oMiwgTWF0aC5tYXgoMS4wLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSkpO1xuICAgICAgdmFyIHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZXN0aW1hdGVMaXZlRWRnZSA9IGZ1bmN0aW9uIGVzdGltYXRlTGl2ZUVkZ2UoKSB7XG4gICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmVkZ2UgKyBsZXZlbERldGFpbHMuYWdlO1xuICB9O1xuICBfcHJvdG8uY29tcHV0ZUxhdGVuY3kgPSBmdW5jdGlvbiBjb21wdXRlTGF0ZW5jeSgpIHtcbiAgICB2YXIgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9O1xuICBfY3JlYXRlQ2xhc3MoTGF0ZW5jeUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcImxhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5IHx8IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heExhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWxEZXRhaWxzID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhcmdldExhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaG9sZEJhY2sgPSBsZXZlbERldGFpbHMuaG9sZEJhY2ssXG4gICAgICAgIHBhcnRIb2xkQmFjayA9IGxldmVsRGV0YWlscy5wYXJ0SG9sZEJhY2ssXG4gICAgICAgIHRhcmdldGR1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIF90aGlzJGNvbmZpZzIgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbiA9IF90aGlzJGNvbmZpZzIubGl2ZVN5bmNEdXJhdGlvbixcbiAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50ID0gX3RoaXMkY29uZmlnMi5saXZlU3luY0R1cmF0aW9uQ291bnQsXG4gICAgICAgIGxvd0xhdGVuY3lNb2RlID0gX3RoaXMkY29uZmlnMi5sb3dMYXRlbmN5TW9kZTtcbiAgICAgIHZhciB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gbG93TGF0ZW5jeU1vZGUgPyBwYXJ0SG9sZEJhY2sgfHwgaG9sZEJhY2sgOiBob2xkQmFjaztcbiAgICAgIGlmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gMCkge1xuICAgICAgICB0YXJnZXRMYXRlbmN5ID0gbGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gbGl2ZVN5bmNEdXJhdGlvbiA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgdmFyIG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gdGFyZ2V0ZHVyYXRpb247XG4gICAgICB2YXIgbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSAxLjA7XG4gICAgICByZXR1cm4gdGFyZ2V0TGF0ZW5jeSArIE1hdGgubWluKHRoaXMuc3RhbGxDb3VudCAqIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlLCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgICAgdmFyIHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgICAgdmFyIHN5bmNQb3NpdGlvbiA9IGxpdmVFZGdlIC0gdGFyZ2V0TGF0ZW5jeSAtIHRoaXMuZWRnZVN0YWxsZWQ7XG4gICAgICB2YXIgbWluID0gZWRnZSAtIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgICAgdmFyIG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHN5bmNQb3NpdGlvbiksIG1heCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyaWZ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVN0YWxsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgbWF4TGV2ZWxVcGRhdGVBZ2UgPSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSAqIDM7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobGV2ZWxEZXRhaWxzLmFnZSAtIG1heExldmVsVXBkYXRlQWdlLCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yd2FyZEJ1ZmZlckxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICByZXR1cm4gKGJ1ZmZlcmVkUmFuZ2VzID8gbWVkaWEuYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkUmFuZ2VzIC0gMSkgOiBsZXZlbERldGFpbHMuZWRnZSkgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGF0ZW5jeUNvbnRyb2xsZXI7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBMZXZlbENvbnRyb2xsZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xldmVsICovIFwiLi9zcmMvdHlwZXMvbGV2ZWwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jb2RlY3MgKi8gXCIuL3NyYy91dGlscy9jb2RlY3MudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4gKi9cblxuXG5cblxuXG5cblxuXG52YXIgY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG52YXIgTGV2ZWxDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGV2ZWxDb250cm9sbGVyLCBfQmFzZVBsYXlsaXN0Q29udHJvbGwpO1xuICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW2xldmVsLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5fbGV2ZWxzID0gW107XG4gICAgX3RoaXMuX2ZpcnN0TGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5fc3RhcnRMZXZlbCA9IHZvaWQgMDtcbiAgICBfdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIF90aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICBfdGhpcy5vblBhcnNlZENvbXBsZXRlID0gdm9pZCAwO1xuICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLl9sZXZlbHMubGVuZ3RoID0gMDtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZCgpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgfSk7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5zdGFydExvYWQuY2FsbCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgIHZhciBiaXRyYXRlU3RhcnQ7XG4gICAgdmFyIGxldmVsU2V0ID0ge307XG4gICAgdmFyIGxldmVsRnJvbVNldDtcbiAgICB2YXIgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIHZhciBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcblxuICAgIC8vIHJlZ3JvdXAgcmVkdW5kYW50IGxldmVscyB0b2dldGhlclxuICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsUGFyc2VkKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGxldmVsUGFyc2VkLmF0dHJzO1xuICAgICAgcmVzb2x1dGlvbkZvdW5kID0gcmVzb2x1dGlvbkZvdW5kIHx8ICEhKGxldmVsUGFyc2VkLndpZHRoICYmIGxldmVsUGFyc2VkLmhlaWdodCk7XG4gICAgICB2aWRlb0NvZGVjRm91bmQgPSB2aWRlb0NvZGVjRm91bmQgfHwgISFsZXZlbFBhcnNlZC52aWRlb0NvZGVjO1xuICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gYXVkaW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYztcblxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC5cbiAgICAgIC8vIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXG4gICAgICBpZiAoY2hyb21lT3JGaXJlZm94ICYmIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgJiYgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWxLZXkgPSBsZXZlbFBhcnNlZC5iaXRyYXRlICsgXCItXCIgKyBsZXZlbFBhcnNlZC5hdHRycy5SRVNPTFVUSU9OICsgXCItXCIgKyBsZXZlbFBhcnNlZC5hdHRycy5DT0RFQ1M7XG4gICAgICBsZXZlbEZyb21TZXQgPSBsZXZlbFNldFtsZXZlbEtleV07XG4gICAgICBpZiAoIWxldmVsRnJvbVNldCkge1xuICAgICAgICBsZXZlbEZyb21TZXQgPSBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICBsZXZlbFNldFtsZXZlbEtleV0gPSBsZXZlbEZyb21TZXQ7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsRnJvbVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWxQYXJzZWQudXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLkFVRElPKSB7XG4gICAgICAgICAgKDAsX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmFkZEdyb3VwSWQpKGxldmVsRnJvbVNldCwgJ2F1ZGlvJywgYXR0cmlidXRlcy5BVURJTyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU1VCVElUTEVTKSB7XG4gICAgICAgICAgKDAsX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmFkZEdyb3VwSWQpKGxldmVsRnJvbVNldCwgJ3RleHQnLCBhdHRyaWJ1dGVzLlNVQlRJVExFUyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmlkZW9Db2RlYyA9IF9yZWYudmlkZW9Db2RlYyxcbiAgICAgICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAhIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIG9ubHkga2VlcCBsZXZlbHMgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gX3JlZjIuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IF9yZWYyLnZpZGVvQ29kZWM7XG4gICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8ICgwLF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5pc0NvZGVjU3VwcG9ydGVkSW5NcDQpKGF1ZGlvQ29kZWMsICdhdWRpbycpKSAmJiAoIXZpZGVvQ29kZWMgfHwgKDAsX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCkodmlkZW9Db2RlYywgJ3ZpZGVvJykpO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gIXRyYWNrLmF1ZGlvQ29kZWMgfHwgKDAsX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCkodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJyk7XG4gICAgICB9KTtcbiAgICAgIC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcbiAgICAgICgwLF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5hc3NpZ25UcmFja0lkc0J5R3JvdXApKGF1ZGlvVHJhY2tzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3VidGl0bGVzKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVzO1xuICAgICAgKDAsX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmFzc2lnblRyYWNrSWRzQnlHcm91cCkoc3VidGl0bGVUcmFja3MpO1xuICAgIH1cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcbiAgICAgIC8vIHNvcnQgbGV2ZWxzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3RcbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmF0dHJzWydIRENQLUxFVkVMJ10gIT09IGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSkge1xuICAgICAgICAgIHJldHVybiAoYS5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA+IChiLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmJpdHJhdGUgIT09IGIuYml0cmF0ZSkge1xuICAgICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuYXR0cnMuU0NPUkUgIT09IGIuYXR0cnMuU0NPUkUpIHtcbiAgICAgICAgICByZXR1cm4gYS5hdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnU0NPUkUnKSAtIGIuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1NDT1JFJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdXRpb25Gb3VuZCAmJiBhLmhlaWdodCAhPT0gYi5oZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgIHRoaXMubG9nKFwibWFuaWZlc3QgbG9hZGVkLCBcIiArIGxldmVscy5sZW5ndGggKyBcIiBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTogXCIgKyBiaXRyYXRlU3RhcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnLFxuICAgICAgLy8gYW5kIHRoaXMgaXMgbm90IGFuIGF1ZGlvLW9ubHkgc3RyZWFtIHdoZXJlIGxldmVscyBjb250YWluIGF1ZGlvLW9ubHlcbiAgICAgIHZhciBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICAgIHZhciBlZGF0YSA9IHtcbiAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcyxcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzLFxuICAgICAgICBzZXNzaW9uRGF0YTogZGF0YS5zZXNzaW9uRGF0YSxcbiAgICAgICAgc2Vzc2lvbktleXM6IGRhdGEuc2Vzc2lvbktleXMsXG4gICAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgICBhbHRBdWRpbzogIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICEhdC51cmw7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuXG4gICAgICAvLyBJbml0aWF0ZSBsb2FkaW5nIGFmdGVyIGFsbCBjb250cm9sbGVycyBoYXZlIHJlY2VpdmVkIE1BTklGRVNUX1BBUlNFRFxuICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuaGxzLmZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZCh0aGlzLmhscy5jb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGZyYWcsIF9kYXRhJGxldmVsO1xuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCB0byByZWR1bmRhbnQgbGV2ZWwgd2hlbiB0cmFjayBmYWlscyB0byBsb2FkXG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgIGlmIChjb250ZXh0ICYmIChjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsLmF1ZGlvR3JvdXBJZHMgJiYgY29udGV4dC5ncm91cElkID09PSBsZXZlbC5hdWRpb0dyb3VwSWRzW2xldmVsLnVybElkXSB8fCBjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsLnRleHRHcm91cElkcyAmJiBjb250ZXh0Lmdyb3VwSWQgPT09IGxldmVsLnRleHRHcm91cElkc1tsZXZlbC51cmxJZF0pKSB7XG4gICAgICB0aGlzLnJlZHVuZGFudEZhaWxvdmVyKHRoaXMuY3VycmVudExldmVsSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGV2ZWxFcnJvciA9IGZhbHNlO1xuICAgIHZhciBsZXZlbFN3aXRjaCA9IHRydWU7XG4gICAgdmFyIGxldmVsSW5kZXg7XG5cbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKGRhdGEuZnJhZykge1xuICAgICAgICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICAgICAgICB2YXIgdmFyaWFudExldmVsSW5kZXggPSBkYXRhLmZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBkYXRhLmZyYWcubGV2ZWwgOiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgICAgIHZhciBfbGV2ZWwgPSB0aGlzLl9sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgICAgICAgIC8vIFNldCBsZXZlbEluZGV4IHdoZW4gd2UncmUgb3V0IG9mIGZyYWdtZW50IHJldHJpZXNcbiAgICAgICAgICBpZiAoX2xldmVsKSB7XG4gICAgICAgICAgICBfbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgICAgICAgaWYgKF9sZXZlbC5mcmFnbWVudEVycm9yID4gdGhpcy5obHMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgbGV2ZWxJbmRleCA9IHZhcmlhbnRMZXZlbEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXZlbEluZGV4ID0gdmFyaWFudExldmVsSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlc3RyaWN0ZWRIZGNwTGV2ZWwgPSBsZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5tYXhIZGNwTGV2ZWwgPSBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5IZGNwTGV2ZWxzW190eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkhkY3BMZXZlbHMuaW5kZXhPZihyZXN0cmljdGVkSGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgICAgdGhpcy53YXJuKFwiUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcXFwiXCIgKyB0aGlzLmhscy5tYXhIZGNwTGV2ZWwgKyBcIlxcXCIgb3IgbG93ZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OOlxuICAgICAgICBsZXZlbEluZGV4ID0gKChfZGF0YSRmcmFnID0gZGF0YS5mcmFnKSA9PT0gbnVsbCB8fCBfZGF0YSRmcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRmcmFnLnR5cGUpID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEuZnJhZy5sZXZlbCA6IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgIC8vIERvIG5vdCByZXRyeSBsZXZlbC4gRXNjYWxhdGUgdG8gZmF0YWwgaWYgc3dpdGNoaW5nIGxldmVscyBmYWlscy5cbiAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyBEbyBub3QgcGVyZm9ybSBsZXZlbCBzd2l0Y2ggaWYgYW4gZXJyb3Igb2NjdXJyZWQgdXNpbmcgZGVsaXZlcnkgZGlyZWN0aXZlc1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHJlbG9hZCBsZXZlbCB3aXRob3V0IGRpcmVjdGl2ZXMgZmlyc3RcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGxldmVsU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldmVsSW5kZXggPSBjb250ZXh0LmxldmVsO1xuICAgICAgICB9XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgICAgbGV2ZWxJbmRleCA9IChfZGF0YSRsZXZlbCA9IGRhdGEubGV2ZWwpICE9IG51bGwgPyBfZGF0YSRsZXZlbCA6IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgbGV2ZWxTd2l0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAqIElmIHJlZHVuZGFudCBzdHJlYW0gaXMgbm90IGF2YWlsYWJsZSwgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIEFCUiBtb2RlIGlzIGVuYWJsZWQuXG4gICAqLztcbiAgX3Byb3RvLnJlY292ZXJMZXZlbCA9IGZ1bmN0aW9uIHJlY292ZXJMZXZlbChlcnJvckV2ZW50LCBsZXZlbEluZGV4LCBsZXZlbEVycm9yLCBsZXZlbFN3aXRjaCkge1xuICAgIHZhciBlcnJvckRldGFpbHMgPSBlcnJvckV2ZW50LmRldGFpbHM7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICB2YXIgcmV0cnlpbmcgPSB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KTtcbiAgICAgIGlmIChyZXRyeWluZykge1xuICAgICAgICAvLyBib29sZWFuIHVzZWQgdG8gaW5mb3JtIHN0cmVhbSBjb250cm9sbGVyIG5vdCB0byBzd2l0Y2ggYmFjayB0byBJRExFIG9uIG5vbiBmYXRhbCBlcnJvclxuICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZXZlbFN3aXRjaCkge1xuICAgICAgdmFyIHJlZHVuZGFudExldmVscyA9IGxldmVsLnVybC5sZW5ndGg7XG4gICAgICAvLyBUcnkgcmVkdW5kYW50IGZhaWwtb3ZlciB1bnRpbCBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHNcbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZHVuZGFudEZhaWxvdmVyKGxldmVsSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgbmV4dCBsZXZlbCB0byByZXRyeVxuICAgICAgICB2YXIgbmV4dExldmVsID0gLTE7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IChpICsgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgIT09IHRoaXMuY3VycmVudExldmVsSW5kZXggJiYgbGV2ZWxzW2NhbmRpZGF0ZV0ubG9hZEVycm9yID09PSAwKSB7XG4gICAgICAgICAgICBuZXh0TGV2ZWwgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMZXZlbCA+IC0xICYmIHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG5leHRMZXZlbCkge1xuICAgICAgICAgIHRoaXMud2FybihlcnJvckRldGFpbHMgKyBcIjogc3dpdGNoIHRvIFwiICsgbmV4dExldmVsKTtcbiAgICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JFdmVudC5sZXZlbFJldHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIE5vIGxldmVscyB0byBzd2l0Y2ggdG8gYW5kIG5vIG1vcmUgcmV0cmllc1xuICAgICAgICAgIGVycm9yRXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucmVkdW5kYW50RmFpbG92ZXIgPSBmdW5jdGlvbiByZWR1bmRhbnRGYWlsb3ZlcihsZXZlbEluZGV4KSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHVybCBpZCBvZiBhbGwgbGV2ZWxzIHNvIHRoYXQgd2Ugc3RheSBvbiB0aGUgc2FtZSBzZXQgb2YgdmFyaWFudHMgd2hlbiBsZXZlbCBzd2l0Y2hpbmdcbiAgICAgIHZhciBuZXdVcmxJZCA9IChsZXZlbC51cmxJZCArIDEpICUgcmVkdW5kYW50TGV2ZWxzO1xuICAgICAgdGhpcy53YXJuKFwiU3dpdGNoaW5nIHRvIHJlZHVuZGFudCBVUkwtaWQgXCIgKyBuZXdVcmxJZCk7XG4gICAgICB0aGlzLl9sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSBuZXdVcmxJZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICA7XG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmMy5mcmFnO1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMjtcbiAgICB2YXIgbGV2ZWwgPSBkYXRhLmxldmVsLFxuICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuICAgIGlmICghY3VyTGV2ZWwpIHtcbiAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGk7XG4gICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIGxldmVsIGluZGV4IFwiICsgbGV2ZWwpO1xuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpICE9PSB2b2lkIDAgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgICBpZiAoY3VyTGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChsZXZlbCwgZGF0YSwgY3VyTGV2ZWwuZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkyICE9PSB2b2lkIDAgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMi5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgdmFyIHVybElkID0gLTE7XG4gICAgICB2YXIgYXVkaW9Hcm91cElkID0gdGhpcy5obHMuYXVkaW9UcmFja3NbZGF0YS5pZF0uZ3JvdXBJZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICB1cmxJZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmxvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5sb2FkUGxheWxpc3QuY2FsbCh0aGlzKTtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuICAgIGlmICh0aGlzLmNhbkxvYWQgJiYgY3VycmVudExldmVsICYmIGN1cnJlbnRMZXZlbC51cmwubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGlkID0gY3VycmVudExldmVsLnVybElkO1xuICAgICAgdmFyIHVybCA9IGN1cnJlbnRMZXZlbC51cmxbaWRdO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiQXR0ZW1wdCBsb2FkaW5nIGxldmVsIGluZGV4IFwiICsgbGV2ZWwgKyAoKGhsc1VybFBhcmFtZXRlcnMgPT09IG51bGwgfHwgaGxzVXJsUGFyYW1ldGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJycpICsgXCIgd2l0aCBVUkwtaWQgXCIgKyBpZCArIFwiIFwiICsgdXJsKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWxPYmplY3QuYXR0cnMuQVVESU8sIGxldmVsKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucmVtb3ZlTGV2ZWwgPSBmdW5jdGlvbiByZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCkge1xuICAgIHZhciBmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4ID0gZnVuY3Rpb24gZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCh1cmwsIGlkKSB7XG4gICAgICByZXR1cm4gaWQgIT09IHVybElkO1xuICAgIH07XG4gICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsLnVybC5sZW5ndGggPiAxICYmIHVybElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwudXJsID0gbGV2ZWwudXJsLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcbiAgICAgICAgaWYgKGxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gbGV2ZWwuYXVkaW9Hcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IGxldmVsLnRleHRHcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwgJiYgZGV0YWlscyAhPT0gdm9pZCAwICYmIGRldGFpbHMuZnJhZ21lbnRzKSB7XG4gICAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgZnJhZ21lbnQubGV2ZWwgPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfSk7XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgbGV2ZWxzOiBsZXZlbHNcbiAgICB9KTtcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKExldmVsQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fbGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB2YXIgX2xldmVscyRuZXdMZXZlbDtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiYgKF9sZXZlbHMkbmV3TGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdKSAhPT0gbnVsbCAmJiBfbGV2ZWxzJG5ld0xldmVsICE9PSB2b2lkIDAgJiYgX2xldmVscyRuZXdMZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgaWYgKG5ld0xldmVsIDwgMCB8fCBuZXdMZXZlbCA+PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgdmFyIGZhdGFsID0gbmV3TGV2ZWwgPCAwO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICAgIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHZhciBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICB2YXIgbGFzdExldmVsID0gbGV2ZWxzW2xhc3RMZXZlbEluZGV4XTtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICB0aGlzLmxvZyhcInN3aXRjaGluZyB0byBsZXZlbCBcIiArIG5ld0xldmVsICsgXCIgZnJvbSBcIiArIGxhc3RMZXZlbEluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICAgIHZhciBsZXZlbFN3aXRjaGluZ0RhdGEgPSBfZXh0ZW5kcyh7fSwgbGV2ZWwsIHtcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBtYXhCaXRyYXRlOiBsZXZlbC5tYXhCaXRyYXRlLFxuICAgICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgICAgdXJsSWQ6IGxldmVsLnVybElkXG4gICAgICB9KTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlbGV0ZSBsZXZlbFN3aXRjaGluZ0RhdGEuX3VybElkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkxFVkVMX1NXSVRDSElORywgbGV2ZWxTd2l0Y2hpbmdEYXRhKTtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIHZhciBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXMobGV2ZWwudXJpLCBsYXN0TGV2ZWwgPT09IG51bGwgfHwgbGFzdExldmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRMb2FkTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMZXZlbENvbnRyb2xsZXI7XG59KF9iYXNlX3BsYXlsaXN0X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYWRkR3JvdXBJZFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhZGRHcm91cElkKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJhZGRTbGlkaW5nXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGFkZFNsaWRpbmcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImFkanVzdFNsaWRpbmdcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRqdXN0U2xpZGluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYXNzaWduVHJhY2tJZHNCeUdyb3VwXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGFzc2lnblRyYWNrSWRzQnlHcm91cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY29tcHV0ZVJlbG9hZEludGVydmFsXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNvbXB1dGVSZWxvYWRJbnRlcnZhbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZ2V0RnJhZ21lbnRXaXRoU05cIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0RnJhZ21lbnRXaXRoU04pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImdldFBhcnRXaXRoXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFBhcnRXaXRoKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJtYXBGcmFnbWVudEludGVyc2VjdGlvblwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBtYXBGcmFnbWVudEludGVyc2VjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwibWFwUGFydEludGVyc2VjdGlvblwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBtYXBQYXJ0SW50ZXJzZWN0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJtZXJnZURldGFpbHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWVyZ2VEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ1cGRhdGVGcmFnUFRTRFRTXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZUZyYWdQVFNEVFMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInVwZGF0ZVBUU1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyB1cGRhdGVQVFMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZGF0ZS1yYW5nZSAqLyBcIi4vc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzXCIpO1xuXG5cblxuXG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuLyoqXG4gKiBAbW9kdWxlIExldmVsSGVscGVyXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqICovXG5cblxuXG5mdW5jdGlvbiBhZGRHcm91cElkKGxldmVsLCB0eXBlLCBpZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xuICAgICAgfVxuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcy5wdXNoKGlkKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgICB9XG4gICAgICBsZXZlbC50ZXh0R3JvdXBJZHMucHVzaChpZCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICB2YXIgZ3JvdXBzID0ge307XG4gIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHZhciBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICB0cmFjay5pZCA9IGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXSB8fCAwO1xuICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGZyb21JZHgsIHRvSWR4KSB7XG4gIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XTtcbiAgdmFyIGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF07XG4gIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gIHZhciBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIGlmICgoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgdmFyIGR1cmF0aW9uID0gMDtcbiAgICB2YXIgZnJhZztcbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH1cbiAgICAvLyBUT0RPPyBEcmlmdCBjYW4gZ28gZWl0aGVyIHdheSwgb3IgdGhlIHBsYXlsaXN0IGNvdWxkIGJlIGNvbXBsZXRlbHkgYWNjdXJhdGVcbiAgICAvLyBjb25zb2xlLmFzc2VydChkdXJhdGlvbiA+IDAsXG4gICAgLy8gICBgZHVyYXRpb24gb2YgJHtkdXJhdGlvbn0gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnLnNufSwgbGV2ZWwgJHtmcmFnLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICAgIC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIHZhciBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYztcbiAgICAvLyBUT0RPOiBXaXRoIHBhcnQtbG9hZGluZyBlbmQvZHVyYXRpb25zIHdlIG5lZWQgdG8gY29uZmlybSB0aGUgd2hvbGUgZnJhZ21lbnQgaXMgbG9hZGVkIGJlZm9yZSB1c2luZyAob3Igc2V0dGluZykgbWluRW5kUFRTXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBmcmFnLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKSB7XG4gIHZhciBwYXJzZWRNZWRpYUR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gIGlmIChwYXJzZWRNZWRpYUR1cmF0aW9uIDw9IDApIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ubG9nZ2VyLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIHZhciBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICB2YXIgbWluRW5kUFRTID0gZW5kUFRTO1xuICB2YXIgZnJhZ1N0YXJ0UHRzID0gZnJhZy5zdGFydFBUUztcbiAgdmFyIGZyYWdFbmRQdHMgPSBmcmFnLmVuZFBUUztcbiAgaWYgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIHZhciBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWdTdGFydFB0cyAtIHN0YXJ0UFRTKTtcbiAgICBpZiAoISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG4gICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0RFRTID0gTWF0aC5taW4oc3RhcnREVFMsIGZyYWcuc3RhcnREVFMpO1xuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gIHZhciBzbiA9IGZyYWcuc247IC8vICdpbml0U2VnbWVudCdcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBpO1xuICB2YXIgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIC8vIHVwZGF0ZSBmcmFnIHJlZmVyZW5jZSBpbiBmcmFnbWVudHMgYXJyYXlcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAvLyBpZiB3ZSBkb24ndCB1cGRhdGUgZnJhZywgd2Ugd29uJ3QgYmUgYWJsZSB0byBwcm9wYWdhdGUgUFRTIGluZm8gb24gdGhlIHBsYXlsaXN0XG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cbiAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgLSAxXSk7XG4gIH1cblxuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpICsgMV0pO1xuICB9XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLCBkZXRhaWxzLmZyYWdtZW50SGludCk7XG4gIH1cbiAgZGV0YWlscy5QVFNLbm93biA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICByZXR1cm4gZHJpZnQ7XG59XG5mdW5jdGlvbiBtZXJnZURldGFpbHMob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gIHZhciBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yICh2YXIgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBvbGRJbml0ID0gb2xkRnJhZ21lbnRzW2ldLmluaXRTZWdtZW50O1xuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChvbGREZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICB9XG4gIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gIHZhciBjY09mZnNldCA9IDA7XG4gIHZhciBQVFNGcmFnO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBmdW5jdGlvbiAob2xkRnJhZywgbmV3RnJhZykge1xuICAgIGlmIChvbGRGcmFnLnJlbHVybCkge1xuICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgLy8gSXQgbWF5YmUgYmUgb2ZmIGJ5IDEgaWYgaXQgd2FzIGNyZWF0ZWQgYmVmb3JlIGFueSBwYXJ0cyBvciBkaXNjb250aW51aXR5IHRhZ3Mgd2VyZSBhcHBlbmRlZCB0byB0aGUgZW5kXG4gICAgICAvLyBvZiB0aGUgcGxheWxpc3QuXG4gICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgIH1cbiAgICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShvbGRGcmFnLnN0YXJ0UFRTKSAmJiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKG9sZEZyYWcuZW5kUFRTKSkge1xuICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5zdGFydERUUyA9IG9sZEZyYWcuc3RhcnREVFM7XG4gICAgICBuZXdGcmFnLmFwcGVuZGVkUFRTID0gb2xkRnJhZy5hcHBlbmRlZFBUUztcbiAgICAgIG5ld0ZyYWcubWF4U3RhcnRQVFMgPSBvbGRGcmFnLm1heFN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZW5kUFRTIC0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgIGlmIChuZXdGcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgfVxuXG4gICAgICAvLyBQVFMgaXMga25vd24gd2hlbiBhbnkgc2VnbWVudCBoYXMgc3RhcnRQVFMgYW5kIGVuZFBUU1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBuZXdGcmFnLmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkRnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBuZXdGcmFnLmxvYWRlciA9IG9sZEZyYWcubG9hZGVyO1xuICAgIG5ld0ZyYWcuc3RhdHMgPSBvbGRGcmFnLnN0YXRzO1xuICAgIG5ld0ZyYWcudXJsSWQgPSBvbGRGcmFnLnVybElkO1xuICAgIGlmIChvbGRGcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgIHZhciBmcmFnbWVudHNUb0NoZWNrID0gbmV3RGV0YWlscy5mcmFnbWVudEhpbnQgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIGlmICghZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnLmluaXRTZWdtZW50LnJlbHVybCA9PT0gKChfY3VycmVudEluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfY3VycmVudEluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudEluaXRTZWdtZW50LnJlbHVybCkpIHtcbiAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RGV0YWlscy5mcmFnbWVudHMuc29tZShmdW5jdGlvbiAoZnJhZykge1xuICAgICAgcmV0dXJuICFmcmFnO1xuICAgIH0pO1xuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ubG9nZ2VyLndhcm4oJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCcpO1xuICAgICAgZm9yICh2YXIgX2kgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgbmV3RGV0YWlscy5mcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RldGFpbHMuc3RhcnRTTiA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnNuO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsIG5ld0RldGFpbHMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyk7XG4gICAgfVxuICB9XG4gIHZhciBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmxvZ2dlci53YXJuKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgbmV3RnJhZ21lbnRzW19pMl0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgfVxuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICB9XG5cbiAgLy8gTWVyZ2UgcGFydHNcbiAgbWFwUGFydEludGVyc2VjdGlvbihvbGREZXRhaWxzLnBhcnRMaXN0LCBuZXdEZXRhaWxzLnBhcnRMaXN0LCBmdW5jdGlvbiAob2xkUGFydCwgbmV3UGFydCkge1xuICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICB9KTtcblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnQ7XG4gIHZhciBhZHZhbmNlZERhdGVUaW1lID0gbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZURhdGVSYW5nZXMob2xkRGF0ZVJhbmdlcywgZGVsdGFEYXRlUmFuZ2VzLCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gIHZhciBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICB9KTtcbiAgfVxuICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGRhdGVSYW5nZSA9IG5ldyBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5EYXRlUmFuZ2UoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBkYXRlUmFuZ2VzW2lkXSk7XG4gICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkKSB7XG4gICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmxvZ2dlci53YXJuKFwiSWdub3JpbmcgaW52YWxpZCBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgREFURVJBTkdFIHRhZzogXFxcIlwiICsgSlNPTi5zdHJpbmdpZnkoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyKSArIFwiXFxcIlwiKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0ZVJhbmdlcztcbn1cbmZ1bmN0aW9uIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkUGFydHMsIG5ld1BhcnRzLCBpbnRlcnNlY3Rpb25Gbikge1xuICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvbGRQYXJ0cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBfb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgdmFyIF9uZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcbiAgICAgIGlmIChfb2xkUGFydCAmJiBfbmV3UGFydCAmJiBfb2xkUGFydC5pbmRleCA9PT0gX25ld1BhcnQuaW5kZXggJiYgX29sZFBhcnQuZnJhZ21lbnQuc24gPT09IF9uZXdQYXJ0LmZyYWdtZW50LnNuKSB7XG4gICAgICAgIGludGVyc2VjdGlvbkZuKF9vbGRQYXJ0LCBfbmV3UGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YS0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgdmFyIHNraXBwZWRTZWdtZW50cyA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIHZhciBlbmQgPSAob2xkRGV0YWlscy5mcmFnbWVudEhpbnQgPyAxIDogMCkgKyAoc2tpcHBlZFNlZ21lbnRzID8gbmV3RGV0YWlscy5lbmRTTiA6IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sIG5ld0RldGFpbHMuZW5kU04pKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgdmFyIGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICB2YXIgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgdmFyIG9sZEZyYWdzID0gb2xkRGV0YWlscy5mcmFnbWVudEhpbnQgPyBvbGREZXRhaWxzLmZyYWdtZW50cy5jb25jYXQob2xkRGV0YWlscy5mcmFnbWVudEhpbnQpIDogb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIHZhciBfb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgdmFyIF9uZXdGcmFnID0gbmV3RnJhZ3NbaV07XG4gICAgaWYgKHNraXBwZWRTZWdtZW50cyAmJiAhX25ld0ZyYWcgJiYgaSA8IHNraXBwZWRTZWdtZW50cykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBfbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gX29sZEZyYWc7XG4gICAgfVxuICAgIGlmIChfb2xkRnJhZyAmJiBfbmV3RnJhZykge1xuICAgICAgaW50ZXJzZWN0aW9uRm4oX29sZEZyYWcsIF9uZXdGcmFnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICB2YXIgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gKyBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgdmFyIG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlscywgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0KSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAodmFyIGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gIGlmIChkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9PT0gdm9pZCAwKSB7XG4gICAgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSBJbmZpbml0eTtcbiAgfVxuICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgaWYgKG5ld0RldGFpbHMudXBkYXRlZCkge1xuICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgIHZhciBmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPSA0O1xuICAgIGlmIChmcmFnbWVudHMubGVuZ3RoICYmIHJlbG9hZEludGVydmFsICogbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPiBkaXN0YW5jZVRvTGl2ZUVkZ2VNcykge1xuICAgICAgdmFyIGxhc3RTZWdtZW50RHVyYXRpb24gPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmR1cmF0aW9uICogMTAwMDtcbiAgICAgIGlmIChsYXN0U2VnbWVudER1cmF0aW9uIDwgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICdtaXNzIGhhbGYgYXZlcmFnZSc7XG4gICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgLy8gZHVyYXRpb24gYmVmb3JlIHJldHJ5aW5nLlxuICAgIHJlbG9hZEludGVydmFsIC89IDI7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCkge1xuICBpZiAoIWxldmVsIHx8ICFsZXZlbC5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gIHZhciBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gIGlmIChmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaWYgKHNuIDwgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdDdXJyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgaWYgKCFsZXZlbCB8fCAhbGV2ZWwuZGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwYXJ0TGlzdCA9IGxldmVsLmRldGFpbHMucGFydExpc3Q7XG4gIGlmIChwYXJ0TGlzdCkge1xuICAgIGZvciAodmFyIGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpZiAocGFydC5pbmRleCA9PT0gcGFydEluZGV4ICYmIHBhcnQuZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3RyZWFtQ29udHJvbGxlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzX3N1cHBvcnRlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaXMtc3VwcG9ydGVkICovIFwiLi9zcmMvaXMtc3VwcG9ydGVkLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvdHJhbnNtdXhlciAqLyBcIi4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dhcF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nYXAtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcblxuXG5cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcbnZhciBTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3RyZWFtQ29udHJvbGxlciwgX0Jhc2VTdHJlYW1Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1tzdHJlYW0tY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgX3RoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgX3RoaXMubGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBfdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgIF90aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICAgIF90aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgICBfdGhpcy5vbnZwbGF5aW5nID0gbnVsbDtcbiAgICBfdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgIF90aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgX3RoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICBfdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGZhbHNlO1xuICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH07XG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICB2YXIgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoaGxzLmNvbmZpZy50ZXN0QmFuZHdpZHRoICYmIHRoaXMubGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRMZXZlbCA9IGhscy5uZXh0QXV0b0xldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyk7XG4gIH07XG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTpcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyRsZXZlbDtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbHMgPT09IG51bGwgfHwgbGV2ZWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2xldmVscyRsZXZlbCA9IGxldmVsc1tsZXZlbF0pID09PSBudWxsIHx8IF9sZXZlbHMkbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sZXZlbHMkbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdGhpcy5sZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPT0gbnVsbCAmJiBfdGhpcyRtZWRpYSAhPT0gdm9pZCAwICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGNoZWNrIGJ1ZmZlclxuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfTtcbiAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uVGlja0VuZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH07XG4gIF9wcm90by5kb1RpY2tJZGxlID0gZnVuY3Rpb24gZG9UaWNrSWRsZSgpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICBsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCxcbiAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbDtcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgXCJtYWluXCIgbGV2ZWwgaXMgYXVkaW8tb25seSBidXQgd2UgYXJlIGxvYWRpbmcgYW4gYWx0ZXJuYXRlIHRyYWNrIGluIHRoZSBzYW1lIGdyb3VwLCBkbyBub3QgbG9hZCBhbnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbbGV2ZWxdO1xuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG5cbiAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGFzdERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsYXN0RGV0YWlscyAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsYXN0RGV0YWlscykpIHtcbiAgICAgIHZhciBkYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRU5ERUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5XQUlUSU5HX0xFVkVMIHx8IGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkge1xuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuXG4gICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgIHZhciBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEluZm8ubWF4Qml0cmF0ZSk7XG5cbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0ID4gYnVmZmVySW5mby5lbmQpIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0IDogYnVmZmVySW5mby5lbmQ7XG4gICAgdmFyIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgdmFyIF90aGlzJGJhY2t0cmFja0ZyYWdtZTtcbiAgICAgIHZhciBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgdmFyIGZyYWdJZHggPSBiYWNrdHJhY2tTbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgdmFyIGJhY2t0cmFja0ZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2ZyYWdJZHggLSAxXTtcbiAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgZnJhZyA9IGJhY2t0cmFja0ZyYWc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGJhY2t0cmFja0ZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nXG4gICAgaWYgKGZyYWcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRTdGF0ZS5PSyAmJiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvID8gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyA6IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU87XG4gICAgICB2YXIgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICB9XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGhpcy5uZXh0TG9hZFBvc2l0aW9uLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZyYWcuaW5pdFNlZ21lbnQgJiYgIWZyYWcuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgZnJhZyA9IGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH07XG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgdmFyIGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLmxvZyhcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGlzIGJlaW5nIGRvd25sb2FkZWQgdG8gdGVzdCBiaXRyYXRlIGFuZCB3aWxsIG5vdCBiZSBidWZmZXJlZFwiKTtcbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbERldGFpbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBpZiAodGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpID09PSBudWxsIHx8IF90aGlzJG1lZGlhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWVkaWEyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0QXBwZW5kZWRGcmFnID0gZnVuY3Rpb24gZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uKSB7XG4gICAgdmFyIGZyYWdPclBhcnQgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICBpZiAoZnJhZ09yUGFydCAmJiAnZnJhZ21lbnQnIGluIGZyYWdPclBhcnQpIHtcbiAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ09yUGFydDtcbiAgfTtcbiAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfTtcbiAgX3Byb3RvLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZCArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovO1xuICBfcHJvdG8uaW1tZWRpYXRlTGV2ZWxTd2l0Y2ggPSBmdW5jdGlvbiBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqLztcbiAgX3Byb3RvLm5leHRMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgIT09IG51bGwgJiYgbWVkaWEgIT09IHZvaWQgMCAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICB2YXIgZmV0Y2hkZWxheTtcbiAgICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCA+IDEpIHtcbiAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgICB2YXIgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgdmFyIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICB2YXIgYnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChidWZmZXJlZEZyYWcpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICB2YXIgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIHZhciBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTIDogbmV4dEJ1ZmZlcmVkRnJhZy5zdGFydDtcbiAgICAgICAgICB2YXIgZnJhZ0R1cmF0aW9uID0gbmV4dEJ1ZmZlcmVkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqIDAuNSksIGZyYWdEdXJhdGlvbiAqIDAuNzUpKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFib3J0Q3VycmVudEZyYWcgPSBmdW5jdGlvbiBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLlBBUlNFRDpcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH07XG4gIF9wcm90by5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdGhpcy5hbHRBdWRpbyA/ICd2aWRlbycgOiBudWxsKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpO1xuICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbk1lZGlhUGxheWluZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBfZ2FwX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJkZWZhdWx0XCJdKHRoaXMuY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIHRoaXMub252cGxheWluZyAmJiB0aGlzLm9udnNlZWtlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZ2FwQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZy5jYWxsKHRoaXMpO1xuICB9O1xuICBfcHJvdG8ub25NZWRpYVBsYXlpbmcgPSBmdW5jdGlvbiBvbk1lZGlhUGxheWluZygpIHtcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG4gIF9wcm90by5vbk1lZGlhU2Vla2VkID0gZnVuY3Rpb24gb25NZWRpYVNlZWtlZCgpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgIGlmICgoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5sb2coXCJNZWRpYSBzZWVrZWQgdG8gXCIgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgYWFjID0gZmFsc2U7XG4gICAgdmFyIGhlYWFjID0gZmFsc2U7XG4gICAgdmFyIGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBhYWMgJiYgaGVhYWMgJiYgISgwLF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5jaGFuZ2VUeXBlU3VwcG9ydGVkKSgpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMgfHwgdGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5JRExFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbCA9IGxldmVsc1tkYXRhLmxldmVsXTtcbiAgICBpZiAoIWxldmVsLmRldGFpbHMgfHwgbGV2ZWwuZGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBkYXRhLmxldmVsIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbihsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfY3VyTGV2ZWwkZGV0YWlscztcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHZhciBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCBcIiArIG5ld0xldmVsSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhcIkxldmVsIFwiICsgbmV3TGV2ZWxJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sIGNjIFtcIiArIG5ld0RldGFpbHMuc3RhcnRDQyArIFwiLCBcIiArIG5ld0RldGFpbHMuZW5kQ0MgKyBcIl0gZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRlJBR19MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpKSB7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQubGV2ZWwgIT09IGRhdGEubGV2ZWwgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjdXJMZXZlbCA9IGxldmVsc1tuZXdMZXZlbElkXTtcbiAgICB2YXIgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX2N1ckxldmVsJGRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzKSAhPT0gbnVsbCAmJiBfY3VyTGV2ZWwkZGV0YWlscyAhPT0gdm9pZCAwICYmIF9jdXJMZXZlbCRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIGlmICghbmV3RGV0YWlscy5mcmFnbWVudHNbMF0pIHtcbiAgICAgICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbmV3TGV2ZWxJZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkXG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJEcm9wcGluZyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2aWRlb0NvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG5cbiAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICB2YXIgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgfHwgbmV3IF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXSh0aGlzLmhscywgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIHZhciBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICB2YXIgY2h1bmtNZXRhID0gbmV3IF90eXBlc190cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18uQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgfTtcbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHZhciB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXN0cm95IHRyYW5zbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hdWRpb09ubHkpIHtcbiAgICAgICAgLy8gUmVzZXQgYXVkaW8gdHJhbnNtdXhlciBzbyB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIG1haW4gYXVkaW8gd2UncmUgbm90IHN0aWxsIGFwcGVuZGluZyB3aGVyZSB3ZSBsZWZ0IG9mZlxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgfVxuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaWYgKGZyb21BbHRBdWRpbykge1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB7XG4gICAgICAgIGlkOiB0cmFja0lkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHZhciBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdmFyIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIHZhciBtZWRpYVRyYWNrO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciB0eXBlIGluIHRyYWNrcykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHZhciB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKFwiQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgXCIgKyBuYW1lICsgXCIuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nXCIpO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUsIHNpbmNlIHRoYXQgd2lsbCBpbnRlcmZlcmUgd2l0aCBhIGxldmVsIHN3aXRjaFxuICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLmJ1ZmZlcmluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSk7XG4gICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB9XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfTtcbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOLCBkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5FUlJPUikge1xuICAgICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgICB0aGlzLndhcm4oXCJcIiArIGRhdGEuZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5FUlJPUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCAsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICAgIHZhciBmbHVzaEJ1ZmZlciA9IHRydWU7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICB0aGlzLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBtYWluJyk7XG4gICAgICAgICAgICAvLyBmbHVzaCBtYWluIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVja3MgdGhlIGhlYWx0aCBvZiB0aGUgYnVmZmVyIGFuZCBhdHRlbXB0cyB0byByZXNvbHZlIHBsYXliYWNrIHN0YWxscy5cbiAgO1xuICBfcHJvdG8uY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiBjaGVja0J1ZmZlcigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgZ2FwQ29udHJvbGxlciA9IHRoaXMuZ2FwQ29udHJvbGxlcjtcbiAgICBpZiAoIW1lZGlhIHx8ICFnYXBDb250cm9sbGVyIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgfHwgIV91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICB2YXIgYWN0aXZlRnJhZyA9IHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9O1xuICBfcHJvdG8ub25CdWZmZXJGbHVzaGVkID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgaWYgKHR5cGUgIT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIHZhciBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH07XG4gIF9wcm90by5zd2FwQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqLztcbiAgX3Byb3RvLnNlZWtUb1N0YXJ0UG9zID0gZnVuY3Rpb24gc2Vla1RvU3RhcnRQb3MoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGlmIChzdGFydFBvc2l0aW9uID49IDAgJiYgY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICB0aGlzLmxvZyhcImNvdWxkIG5vdCBzZWVrIHRvIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiLCBhbHJlYWR5IHNlZWtpbmcgYXQgXCIgKyBjdXJyZW50VGltZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIHZhciBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgIHZhciBkZWx0YSA9IGJ1ZmZlclN0YXJ0IC0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmIChkZWx0YSA+IDAgJiYgKGRlbHRhIDwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSB8fCBkZWx0YSA8IHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpKSB7XG4gICAgICAgIHRoaXMubG9nKFwiYWRqdXN0aW5nIHN0YXJ0IHBvc2l0aW9uIGJ5IFwiICsgZGVsdGEgKyBcIiB0byBtYXRjaCBidWZmZXIgc3RhcnRcIik7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcInNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIGZyb20gY3VycmVudCB0aW1lIFwiICsgY3VycmVudFRpbWUpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLl9nZXRBdWRpb0NvZGVjID0gZnVuY3Rpb24gX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKSB7XG4gICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICB9O1xuICBfcHJvdG8uX2xvYWRCaXRyYXRlVGVzdEZyYWcgPSBmdW5jdGlvbiBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbERldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsRGV0YWlscykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGhscyA9IF90aGlzMi5obHM7XG4gICAgICBpZiAoIWRhdGEgfHwgX3RoaXMyLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczIuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBfdGhpczIuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN0YXRlLklETEU7XG4gICAgICBfdGhpczIuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBfdGhpczIuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIHZhciBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG4gICAgdmFyIGlkID0gJ21haW4nO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YSA9IHRyYW5zbXV4UmVzdWx0LmNodW5rTWV0YTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMud2FybihcIlRoZSBsb2FkaW5nIGNvbnRleHQgY2hhbmdlZCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIgKyBjaHVua01ldGEuc24gKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCArIFwiLiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsO1xuICAgIHZhciB2aWRlbyA9IHJlbXV4UmVzdWx0LnZpZGVvLFxuICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICBpZDMgPSByZW11eFJlc3VsdC5pZDMsXG4gICAgICBpbml0U2VnbWVudCA9IHJlbXV4UmVzdWx0LmluaXRTZWdtZW50O1xuICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAvLyBUaGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaGFuZGxlcyBhdWRpbyBidWZmZXJpbmcgaWYgSGxzLmpzIGlzIHBsYXlpbmcgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGF1ZGlvID0gdGhpcy5hbHRBdWRpbyA/IHVuZGVmaW5lZCA6IHJlbXV4UmVzdWx0LmF1ZGlvO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuUEFSU0lORztcbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcbiAgICAgIHZhciBpbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUztcbiAgICAgIHZhciB0aW1lc2NhbGUgPSBpbml0U2VnbWVudC50aW1lc2NhbGU7XG4gICAgICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSBpbml0UFRTO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdm9pZCBidWZmZXJpbmcgaWYgYmFja3RyYWNraW5nIHRoaXMgZnJhZ21lbnRcbiAgICBpZiAodmlkZW8gJiYgcmVtdXhSZXN1bHQuaW5kZXBlbmRlbnQgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICB2YXIgc3RhcnRQVFMgPSB2aWRlby5zdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMgPSB2aWRlby5lbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMgPSB2aWRlby5zdGFydERUUyxcbiAgICAgICAgICBlbmREVFMgPSB2aWRlby5lbmREVFM7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1t2aWRlby50eXBlXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUzogZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFM6IHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTOiBlbmREVFNcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAvLyBCYWNrdHJhY2sgaWYgZHJvcHBlZCBmcmFtZXMgY3JlYXRlIGEgZ2FwIGFmdGVyIGN1cnJlbnRUaW1lXG5cbiAgICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSAoYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIDogdGhpcy5nZXRMb2FkUG9zaXRpb24oKSkgKyB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPyB2aWRlby5maXJzdEtleUZyYW1lUFRTIDogc3RhcnRQVFM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB2aWRlbyBzdHJlYW0gc3RhcnQgdG8gZnJhZ21lbnQgc3RhcnQgc28gdGhhdCB0cnVuY2F0ZWQgc2FtcGxlcyBkbyBub3QgZGlzdG9ydCB0aGUgdGltZWxpbmUsIGFuZCBtYXJrIGl0IHBhcnRpYWxcbiAgICAgICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgZnJhZy5zdGFydCwgZW5kUFRTLCBmcmFnLnN0YXJ0LCBlbmREVFMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCkge1xuICAgICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKHZpZGVvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVtdXhSZXN1bHQuaW5kZXBlbmRlbnQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICB2YXIgX3N0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgIF9lbmRQVFMgPSBhdWRpby5lbmRQVFMsXG4gICAgICAgIF9zdGFydERUUyA9IGF1ZGlvLnN0YXJ0RFRTLFxuICAgICAgICBfZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUzogX3N0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUzogX2VuZFBUUyxcbiAgICAgICAgICBzdGFydERUUzogX3N0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUzogX2VuZERUU1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBfc3RhcnRQVFMsIF9lbmRQVFMsIF9zdGFydERUUywgX2VuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9PSBudWxsICYmIGlkMyAhPT0gdm9pZCAwICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT09IG51bGwgJiYgX2lkMyRzYW1wbGVzICE9PSB2b2lkIDAgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogaWQzLnNhbXBsZXNcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzICYmIHRleHQpIHtcbiAgICAgIHZhciBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiB0ZXh0LnNhbXBsZXNcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLl9idWZmZXJJbml0U2VnbWVudCA9IGZ1bmN0aW9uIF9idWZmZXJJbml0U2VnbWVudChjdXJyZW50TGV2ZWwsIHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgdmFyIGF1ZGlvID0gdHJhY2tzLmF1ZGlvLFxuICAgICAgdmlkZW8gPSB0cmFja3MudmlkZW8sXG4gICAgICBhdWRpb3ZpZGVvID0gdHJhY2tzLmF1ZGlvdmlkZW87XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBpZiAoYXVkaW8ubWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIGF1ZGlvLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRoaXMubG9nKFwiQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gXCIgKyBhdWRpb0NvZGVjKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyAmJiBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyAhPT0gYXVkaW9Db2RlYykge1xuICAgICAgICB0aGlzLmxvZyhcIlN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFxcXCJcIiArIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICsgXCJcXFwiIGZvciBcXFwiXCIgKyBhdWRpb0NvZGVjICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIGF1ZGlvLmNvbnRhaW5lciArIFwiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIgKyAoYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coXCJJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgdmlkZW8uY29udGFpbmVyICsgXCIsIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVtcIiArIChjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIHZpZGVvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cbiAgICBpZiAoYXVkaW92aWRlbykge1xuICAgICAgdGhpcy5sb2coXCJJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyBhdWRpb3ZpZGVvLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyAoY3VycmVudExldmVsLmF0dHJzLkNPREVDUyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvdmlkZW8uY29kZWMgKyBcIl1cIik7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIHZhciBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgaWYgKGluaXRTZWdtZW50ICE9PSBudWxsICYmIGluaXRTZWdtZW50ICE9PSB2b2lkIDAgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgICBfdGhpczMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG4gIF9wcm90by5nZXRNYWluRndkQnVmZmVySW5mbyA9IGZ1bmN0aW9uIGdldE1haW5Gd2RCdWZmZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gIH07XG4gIF9wcm90by5iYWNrdHJhY2sgPSBmdW5jdGlvbiBiYWNrdHJhY2soZnJhZykge1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayB0aHJvdWdoIGZyYWdtZW50cyB0byBmaW5kIHRoZSBrZXlmcmFtZVxuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TdGF0ZS5JRExFO1xuICB9O1xuICBfcHJvdG8uY2hlY2tGcmFnbWVudENoYW5nZWQgPSBmdW5jdGlvbiBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSBudWxsO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmcgPSB0aGlzLmZyYWdQbGF5aW5nO1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZ0N1cnJlbnQuc24gIT09IGZyYWdQbGF5aW5nLnNuIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsIHx8IGZyYWdQbGF5aW5nQ3VycmVudC51cmxJZCAhPT0gZnJhZ1BsYXlpbmcudXJsSWQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWdQbGF5aW5nQ3VycmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkV2ZW50cy5MRVZFTF9TV0lUQ0hFRCwge1xuICAgICAgICAgICAgICBsZXZlbDogZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfY3JlYXRlQ2xhc3MoU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibmV4dExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50RnJhZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudFByb2dyYW1EYXRlVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgICBpZiAoZnJhZyAmJiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGN1cnJlbnRUaW1lKSAmJiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICAgIHZhciBlcG9jTXMgPSBmcmFnLnByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY01zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRCdWZmZXJlZEZyYWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZVN0YXJ0TG9hZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyAqLyBcIi4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5jYWxsKHRoaXMsIGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdbc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5sZXZlbHMgPSBbXTtcbiAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5TdGF0ZS5JRExFO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgfTtcbiAgX3Byb3RvLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkID0gZnVuY3Rpb24gb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3M7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlN0YXRlLklETEU7XG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZS91cGRhdGUgYSBidWZmZXJlZCBhcnJheSBtYXRjaGluZyB0aGUgaW50ZXJmYWNlIHVzZWQgYnkgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mb1xuICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgdmFyIHRpbWVSYW5nZTtcbiAgICB2YXIgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcpO1xuICB9O1xuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBkYXRhLnN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0ID0gZGF0YS5lbmRPZmZzZXQ7XG4gICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICB2YXIgY3VycmVudFRyYWNrSWQgPSB0aGlzLmN1cnJlbnRUcmFja0lkLFxuICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgIGlmICghbGV2ZWxzLmxlbmd0aCB8fCAhbGV2ZWxzW2N1cnJlbnRUcmFja0lkXSB8fCAhbGV2ZWxzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFja0RldGFpbHMgPSBsZXZlbHNbY3VycmVudFRyYWNrSWRdLmRldGFpbHM7XG4gICAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSB0cmFja0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICB2YXIgZW5kT2Zmc2V0U3VidGl0bGVzID0gZW5kT2Zmc2V0IC0gdGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAoZW5kT2Zmc2V0U3VidGl0bGVzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YS5lbmRPZmZzZXRTdWJ0aXRsZXMgPSBNYXRoLm1heCgwLCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXJlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW2ldLnN0YXJ0ID0gZW5kT2Zmc2V0U3VidGl0bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcywgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLlBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGRhdGEuZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgaWYgKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9PSBudWxsICYmIF90aGlzJG1lZGlhICE9PSB2b2lkIDAgJiYgX3RoaXMkbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgO1xuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZXJyb3Igbm90IHJlbGF0ZWQgdG8gc3VidGl0bGUgZnJhZ21lbnRcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5TdGF0ZS5JRExFO1xuICB9XG5cbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgbGV2ZWxzLlxuICA7XG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIHN1YnRpdGxlVHJhY2tzID0gX3JlZi5zdWJ0aXRsZVRyYWNrcztcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uTGV2ZWwobWVkaWFQbGF5bGlzdCk7XG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICBfdGhpczIudHJhY2tzQnVmZmVyZWRbbGV2ZWwuaWRdID0gW107XG4gICAgfSk7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gIH07XG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICBpZiAoIXRoaXMubGV2ZWxzLmxlbmd0aCB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdHJhY2sgaGFzIHRoZSBuZWNlc3NhcnkgZGV0YWlscyB0byBsb2FkIGZyYWdtZW50c1xuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoY3VycmVudFRyYWNrICE9PSBudWxsICYmIGN1cnJlbnRUcmFjayAhPT0gdm9pZCAwICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuICA7XG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICB0cmFja0lkID0gZGF0YS5pZDtcbiAgICB2YXIgY3VycmVudFRyYWNrSWQgPSB0aGlzLmN1cnJlbnRUcmFja0lkLFxuICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKHRyYWNrSWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCB0cmFja0lkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9PSBudWxsICYmIF90cmFjayRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkIHx8ICFtYWluRGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50ID0gbWFpbkRldGFpbHMuZnJhZ21lbnRzWzBdO1xuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAoMCxfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQpKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gbGluZSB1cCBsaXZlIHBsYXlsaXN0IHdpdGggbWFpbiBzbyB0aGF0IGZyYWdtZW50cyBpbiByYW5nZSBhcmUgbG9hZGVkXG4gICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICAoMCxfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uYWRkU2xpZGluZykobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgICBpZiAoc2xpZGluZyA9PT0gMCAmJiBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyByZWFsaWduIHdpdGggbWFpbiB3aGVuIHRoZXJlIGlzIG5vIG92ZXJsYXAgd2l0aCBsYXN0IHJlZnJlc2hcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgICgwLF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5hZGRTbGlkaW5nKShuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrSWQ7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcblxuICAgIC8vIElmIHBsYXlsaXN0IGlzIG1pc2FsaWduZWQgYmVjYXVzZSBvZiBiYWQgUERUIG9yIGRyaWZ0LCBkZWxldGUgZGV0YWlscyB0byByZXN5bmMgd2l0aCBtYWluIG9uIHJlbG9hZFxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgJiYgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlN0YXRlLklETEUpIHtcbiAgICAgIHZhciBmb3VuZEZyYWcgPSAoMCxfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmZpbmRGcmFnbWVudEJ5UFRTKShudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICB0aGlzLndhcm4oJ1N1YnRpdGxlIHBsYXlsaXN0IG5vdCBhbGlnbmVkIHdpdGggcGxheWJhY2snKTtcbiAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWREYXRhLmZyYWcsXG4gICAgICBwYXlsb2FkID0gZnJhZ0xvYWRlZERhdGEucGF5bG9hZDtcbiAgICB2YXIgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICB2YXIgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMzLndhcm4oZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIF90aGlzMy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uU3RhdGUuSURMRTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlN0YXRlLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLlN0YXRlLklETEUpIHtcbiAgICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKCFsZXZlbHMubGVuZ3RoIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHBhbmQgcmFuZ2Ugb2Ygc3VicyBsb2FkZWQgYnkgb25lIHRhcmdldC1kdXJhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uIHRvIG1ha2UgdXAgZm9yIG1pc2FsaWduZWQgcGxheWxpc3RzXG4gICAgICB2YXIgdHJhY2tEZXRhaWxzID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzO1xuICAgICAgdmFyIHRhcmdldER1cmF0aW9uID0gdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIHZhciBidWZmZXJlZEluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgY3VycmVudFRpbWUgLSB0YXJnZXREdXJhdGlvbiwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJlZEluZm8uZW5kLFxuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJlZEluZm8ubGVuO1xuICAgICAgdmFyIG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWEsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIHZhciBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChtYWluQnVmZmVySW5mbyA9PT0gbnVsbCB8fCBtYWluQnVmZmVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFpbkJ1ZmZlckluZm8ubGVuKSArIHRhcmdldER1cmF0aW9uO1xuICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heEJ1Zkxlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zb2xlLmFzc2VydCh0cmFja0RldGFpbHMsICdTdWJ0aXRsZSB0cmFjayBkZXRhaWxzIGFyZSBkZWZpbmVkIG9uIGlkbGUgc3VidGl0bGUgc3RyZWFtIGNvbnRyb2xsZXIgdGljaycpO1xuICAgICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICB2YXIgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZW5kID0gdHJhY2tEZXRhaWxzLmVkZ2U7XG4gICAgICB2YXIgZm91bmRGcmFnID0gbnVsbDtcbiAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgIHZhciBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGZvdW5kRnJhZyA9ICgwLF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZmluZEZyYWdtZW50QnlQVFMpKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBNYXRoLm1heChmcmFnbWVudHNbMF0uc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUpLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgaWYgKCFmb3VuZEZyYWcgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zdGFydCA8IGZyYWdtZW50c1swXS5zdGFydCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvdW5kRnJhZyA9IHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmb3VuZEZyYWcpO1xuICAgICAgaWYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZvdW5kRnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXRNYXhCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgIHZhciBtYXhDb25maWdCdWZmZXIgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heEJ1ZmZlckxlbmd0aC5jYWxsKHRoaXMpO1xuICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1heENvbmZpZ0J1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gIH07XG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbERldGFpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfVxuICB9O1xuICBfY3JlYXRlQ2xhc3MoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogXCJtZWRpYUJ1ZmZlclRpbWVSYW5nZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyYWJsZUluc3RhbmNlKHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xufShfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSk7XG52YXIgQnVmZmVyYWJsZUluc3RhbmNlID0gZnVuY3Rpb24gQnVmZmVyYWJsZUluc3RhbmNlKHRpbWVyYW5nZXMpIHtcbiAgdGhpcy5idWZmZXJlZCA9IHZvaWQgMDtcbiAgdmFyIGdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgIGluZGV4ID0gaW5kZXggPj4+IDA7XG4gICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkZhaWxlZCB0byBleGVjdXRlICdcIiArIG5hbWUgKyBcIicgb24gJ1RpbWVSYW5nZXMnOiBUaGUgaW5kZXggcHJvdmlkZWQgKFwiICsgaW5kZXggKyBcIikgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGJvdW5kIChcIiArIGxlbmd0aCArIFwiKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVyYW5nZXNbaW5kZXhdW25hbWVdO1xuICB9O1xuICB0aGlzLmJ1ZmZlcmVkID0ge1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGltZXJhbmdlcy5sZW5ndGg7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZChpbmRleCkge1xuICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGluZGV4KSB7XG4gICAgICByZXR1cm4gZ2V0UmFuZ2UoJ3N0YXJ0JywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90ZXh0dHJhY2stdXRpbHMgKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG52YXIgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUGxheWxpc3RDb250cm9sbCkge1xuICBfaW5oZXJpdHNMb29zZShTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcbiAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgX3RoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgX3RoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICBfdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgIF90aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIF90aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgX3RoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucG9sbFRyYWNrQ2hhbmdlKDApO1xuICAgIH07XG4gICAgX3RoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9IGZhbHNlO1xuICAgIF90aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgX3RoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9IG51bGw7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXG4gIDtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIH1cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnBvbGxUcmFja0NoYW5nZSA9IGZ1bmN0aW9uIHBvbGxUcmFja0NoYW5nZSh0aW1lb3V0KSB7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lciwgdGltZW91dCk7XG4gIH07XG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIGlmICghdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0aGlzLnRyYWNrSWQ7XG4gICAgfVxuICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAvLyBDbGVhciBsb2FkZWQgY3VlcyBvbiBtZWRpYSBkZXRhY2htZW50IGZyb20gdHJhY2tzXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNsZWFyQ3VycmVudEN1ZXMpKHRyYWNrKTtcbiAgICB9KTtcbiAgICAvLyBEaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MgYmVmb3JlIGRldGFjaG1lbnQgc28gd2hlbiByZWF0dGFjaGVkIG9ubHkgdHJhY2tzIGluIHRoYXQgY29udGVudCBhcmUgZW5hYmxlZC5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgO1xuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH07XG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW3RyYWNrSWRdO1xuICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIHN1YnRpdGxlIHRyYWNrIGlkIFwiICsgaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VyRGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzO1xuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKFwic3VidGl0bGUgdHJhY2sgXCIgKyBpZCArIFwiIGxvYWRlZCBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIi1cIiArIGRldGFpbHMuZW5kU04gKyBcIl1cIik7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfTtcbiAgX3Byb3RvLnN3aXRjaExldmVsID0gZnVuY3Rpb24gc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIHZhciBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKCEobGV2ZWxJbmZvICE9PSBudWxsICYmIGxldmVsSW5mbyAhPT0gdm9pZCAwICYmIGxldmVsSW5mby50ZXh0R3JvdXBJZHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0ZXh0R3JvdXBJZCA9IGxldmVsSW5mby50ZXh0R3JvdXBJZHNbbGV2ZWxJbmZvLnVybElkXTtcbiAgICBpZiAodGhpcy5ncm91cElkICE9PSB0ZXh0R3JvdXBJZCkge1xuICAgICAgdmFyIGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gIXRleHRHcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IHRleHRHcm91cElkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBzdWJ0aXRsZVRyYWNrcztcbiAgICAgIHZhciBpbml0aWFsVHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLm5hbWUpIHx8IHRoaXMuZmluZFRyYWNrSWQoKTtcbiAgICAgIHRoaXMuZ3JvdXBJZCA9IHRleHRHcm91cElkO1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBzdWJ0aXRsZSB0cmFja3MsIFwiICsgc3VidGl0bGVUcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgdGV4dEdyb3VwSWQgKyBcIlxcXCIgZ3JvdXAtaWRcIik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG4gICAgICBpZiAoaW5pdGlhbFRyYWNrSWQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhpbml0aWFsVHJhY2tJZCwgbGFzdFRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5maW5kVHJhY2tJZCA9IGZ1bmN0aW9uIGZpbmRUcmFja0lkKG5hbWUpIHtcbiAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrIHx8IHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5QbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMucmV0cnlMb2FkaW5nT3JGYWlsKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovO1xuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmxvYWRQbGF5bGlzdC5jYWxsKHRoaXMpO1xuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXTtcbiAgICBpZiAodGhpcy5zaG91bGRMb2FkVHJhY2soY3VycmVudFRyYWNrKSkge1xuICAgICAgdmFyIGlkID0gY3VycmVudFRyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBjdXJyZW50VHJhY2suZ3JvdXBJZDtcbiAgICAgIHZhciB1cmwgPSBjdXJyZW50VHJhY2sudXJsO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBzdWJ0aXRsZSBwbGF5bGlzdCBmb3IgaWQgXCIgKyBpZCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqLztcbiAgX3Byb3RvLnRvZ2dsZVRyYWNrTW9kZXMgPSBmdW5jdGlvbiB0b2dnbGVUcmFja01vZGVzKG5ld0lkKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIHZhciBncm91cFRyYWNrcyA9IHRleHRUcmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrLmdyb3VwSWQgPT09IF90aGlzMi5ncm91cElkO1xuICAgIH0pO1xuICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZFRyYWNrID0gZ3JvdXBUcmFja3NbdHJhY2tJZF07XG4gICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgb2xkVHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXh0VHJhY2sgPSBncm91cFRyYWNrc1tuZXdJZF07XG4gICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgbmV4dFRyYWNrLm1vZGUgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgKi87XG4gIF9wcm90by5zZXRTdWJ0aXRsZVRyYWNrID0gZnVuY3Rpb24gc2V0U3VidGl0bGVUcmFjayhuZXdJZCwgbGFzdFRyYWNrKSB7XG4gICAgdmFyIF90cmFja3MkbmV3SWQ7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IG5ld0lkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBuZXdJZCkge1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKG5ld0lkKTtcbiAgICB9XG5cbiAgICAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcbiAgICBpZiAodGhpcy50cmFja0lkID09PSBuZXdJZCAmJiAobmV3SWQgPT09IC0xIHx8IChfdHJhY2tzJG5ld0lkID0gdHJhY2tzW25ld0lkXSkgIT09IG51bGwgJiYgX3RyYWNrcyRuZXdJZCAhPT0gdm9pZCAwICYmIF90cmFja3MkbmV3SWQuZGV0YWlscykgfHwgbmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdmFyIHRyYWNrID0gdHJhY2tzW25ld0lkXTtcbiAgICB0aGlzLmxvZyhcIlN3aXRjaGluZyB0byBzdWJ0aXRsZSB0cmFjayBcIiArIG5ld0lkKTtcbiAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICBfdHJhY2skZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQsXG4gICAgICAgIGdyb3VwSWQgPSBfdHJhY2skZ3JvdXBJZCA9PT0gdm9pZCAwID8gJycgOiBfdHJhY2skZ3JvdXBJZCxcbiAgICAgICAgbmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgICAgIHR5cGUgPSB0cmFjay50eXBlLFxuICAgICAgICB1cmwgPSB0cmFjay51cmw7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH0pO1xuICAgICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PT0gbnVsbCB8fCBsYXN0VHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgICAgaWQ6IG5ld0lkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gb25UZXh0VHJhY2tzQ2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFja0lkID0gLTE7XG4gICAgdmFyIHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgZm9yICh2YXIgaWQgPSAwOyBpZCA8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcbiAgICAgIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgfSBlbHNlIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG4gICAgaWYgKHRoaXMuc3VidGl0bGVUcmFjayAhPT0gdHJhY2tJZCkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgICB9XG4gIH07XG4gIF9jcmVhdGVDbGFzcyhTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwic3VidGl0bGVEaXNwbGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVEaXNwbGF5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2Rlcyh0aGlzLnRyYWNrSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICB9XG5cbiAgICAvKiogZ2V0L3NldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGJhc2VkIG9uIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3SWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwID8gdGhpcy50cmFja3NJbkdyb3VwW3RoaXMudHJhY2tJZF0gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sobmV3SWQsIGxhc3RUcmFjayk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSk7XG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0ZXh0VHJhY2tMaXN0KSB7XG4gIHZhciB0cmFja3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKCh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyB8fCB0cmFjay5raW5kID09PSAnY2FwdGlvbnMnKSAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiVGltZWxpbmVDb250cm9sbGVyXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFRpbWVsaW5lQ29udHJvbGxlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY2VhXzYwOF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NlYS02MDgtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvY2VhLTYwOC1wYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL291dHB1dC1maWx0ZXIgKi8gXCIuL3NyYy91dGlscy9vdXRwdXQtZmlsdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc193ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy93ZWJ2dHQtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90ZXh0dHJhY2stdXRpbHMgKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9pbXNjMS10dG1sLXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUaW1lbGluZUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaW1lbGluZUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnRpbWVzY2FsZSA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdm9pZCAwO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMzoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrNDoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIHZhciBjaGFubmVsMSA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgdmFyIGNoYW5uZWwyID0gbmV3IF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMsICd0ZXh0VHJhY2syJyk7XG4gICAgICB2YXIgY2hhbm5lbDMgPSBuZXcgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcywgJ3RleHRUcmFjazMnKTtcbiAgICAgIHZhciBjaGFubmVsNCA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gbmV3IF91dGlsc19jZWFfNjA4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgxLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IF91dGlsc19jZWFfNjA4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgIH1cbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IG51bGw7XG4gIH07XG4gIF9wcm90by5hZGRDdWVzID0gZnVuY3Rpb24gYWRkQ3Vlcyh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuLCBjdWVSYW5nZXMpIHtcbiAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGN1ZVJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciBjdWVSYW5nZSA9IGN1ZVJhbmdlc1tpXTtcbiAgICAgIHZhciBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBjdWVSYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ZXMgPSB0aGlzLkN1ZXMubmV3Q3VlKG51bGwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnY2FwdGlvbnMnLFxuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgO1xuICBfcHJvdG8ub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChldmVudCwgX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICBpbml0UFRTID0gX3JlZi5pbml0UFRTLFxuICAgICAgdGltZXNjYWxlID0gX3JlZi50aW1lc2NhbGU7XG4gICAgdmFyIHVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3M7XG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IGluaXRQVFM7XG4gICAgICB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSA9IHRpbWVzY2FsZTtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh1bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgX3RoaXMub25GcmFnTG9hZGVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19MT0FERUQsIGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0RXhpc3RpbmdUcmFjayA9IGZ1bmN0aW9uIGdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKHRleHRUcmFja1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLmNyZWF0ZUNhcHRpb25zVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVDYXB0aW9uc1RyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHRoaXMuY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmNyZWF0ZU5hdGl2ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FwdGlvbnNQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3MsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIF9jYXB0aW9uc1Byb3BlcnRpZXMkdCA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdLFxuICAgICAgbGFiZWwgPSBfY2FwdGlvbnNQcm9wZXJ0aWVzJHQubGFiZWwsXG4gICAgICBsYW5ndWFnZUNvZGUgPSBfY2FwdGlvbnNQcm9wZXJ0aWVzJHQubGFuZ3VhZ2VDb2RlO1xuICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgIHZhciBleGlzdGluZ1RyYWNrID0gdGhpcy5nZXRFeGlzdGluZ1RyYWNrKHRyYWNrTmFtZSk7XG4gICAgaWYgKCFleGlzdGluZ1RyYWNrKSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICB0ZXh0VHJhY2tbdHJhY2tOYW1lXSA9IHRydWU7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmNsZWFyQ3VycmVudEN1ZXMpKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnNlbmRBZGRUcmFja0V2ZW50KShjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uY3JlYXRlTm9uTmF0aXZlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYSBzaW5nbGUgdHJhY2sgZm9yIHRoZSBwcm92aWRlciB0byBjb25zdW1lXG4gICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgIHZhciB0cmFjayA9IHtcbiAgICAgIF9pZDogdHJhY2tOYW1lLFxuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAga2luZDogJ2NhcHRpb25zJyxcbiAgICAgIGRlZmF1bHQ6IHRyYWNrUHJvcGVydGllcy5tZWRpYSA/ICEhdHJhY2tQcm9wZXJ0aWVzLm1lZGlhLmRlZmF1bHQgOiBmYWxzZSxcbiAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICB9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmNyZWF0ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfTtcbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmNsZWFyQ3VycmVudEN1ZXMpKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy50aW1lc2NhbGUgPSBbXTtcbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fY2xlYW5UcmFja3MgPSBmdW5jdGlvbiBfY2xlYW5UcmFja3MoKSB7XG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICgwLF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5jbGVhckN1cnJlbnRDdWVzKSh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdmFyIHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgdmFyIGhhc0lNU0MxID0gdHJhY2tzLnNvbWUoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sudGV4dENvZGVjID09PSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5JTVNDMV9DT0RFQztcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUIHx8IGhhc0lNU0MxICYmIHRoaXMuY29uZmlnLmVuYWJsZUlNU0MxKSB7XG4gICAgICB2YXIgc2FtZVRyYWNrcyA9IHRoaXMudHJhY2tzICYmIHRyYWNrcyAmJiB0aGlzLnRyYWNrcy5sZW5ndGggPT09IHRyYWNrcy5sZW5ndGg7XG4gICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcyB8fCBbXTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgdmFyIGluVXNlVHJhY2tzID0gdGhpcy5tZWRpYSA/IHRoaXMubWVkaWEudGV4dFRyYWNrcyA6IFtdO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrO1xuICAgICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGluVXNlVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXVzZSB0cmFja3Mgd2l0aCB0aGUgc2FtZSBsYWJlbCwgYnV0IGRvIG5vdCByZXVzZSA2MDgvNzA4IHRyYWNrc1xuICAgICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmNsZWFyQ3VycmVudEN1ZXMpKHRleHRUcmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VHJhY2tLaW5kID0gX3RoaXMyLl9jYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjayk7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSBfdGhpczIuY3JlYXRlVGV4dFRyYWNrKHRleHRUcmFja0tpbmQsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHRleHRUcmFjay5ncm91cElkID0gdHJhY2suZ3JvdXBJZDtcbiAgICAgICAgICAgIF90aGlzMi50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghc2FtZVRyYWNrcyAmJiB0aGlzLnRyYWNrcyAmJiB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiB0cmFja3MgZm9yIHRoZSBwcm92aWRlciB0byBjb25zdW1lXG4gICAgICAgIHZhciB0cmFja3NMaXN0ID0gdGhpcy50cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogdHJhY2submFtZSxcbiAgICAgICAgICAgIGtpbmQ6IHRyYWNrLnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRyYWNrLmRlZmF1bHQsXG4gICAgICAgICAgICBzdWJ0aXRsZVRyYWNrOiB0cmFja1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzTGlzdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5fY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3MgPSBmdW5jdGlvbiBfY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3ModHJhY2spIHtcbiAgICB2YXIgX3RyYWNrJGF0dHJzO1xuICAgIGlmICgoX3RyYWNrJGF0dHJzID0gdHJhY2suYXR0cnMpICE9PSBudWxsICYmIF90cmFjayRhdHRycyAhPT0gdm9pZCAwICYmIF90cmFjayRhdHRycy5DSEFSQUNURVJJU1RJQ1MpIHtcbiAgICAgIHZhciB0cmFuc2NyaWJlc1Nwb2tlbkRpYWxvZyA9IC90cmFuc2NyaWJlcy1zcG9rZW4tZGlhbG9nL2dpLnRlc3QodHJhY2suYXR0cnMuQ0hBUkFDVEVSSVNUSUNTKTtcbiAgICAgIHZhciBkZXNjcmliZXNNdXNpY0FuZFNvdW5kID0gL2Rlc2NyaWJlcy1tdXNpYy1hbmQtc291bmQvZ2kudGVzdCh0cmFjay5hdHRycy5DSEFSQUNURVJJU1RJQ1MpO1xuICAgICAgaWYgKHRyYW5zY3JpYmVzU3Bva2VuRGlhbG9nICYmIGRlc2NyaWJlc011c2ljQW5kU291bmQpIHtcbiAgICAgICAgcmV0dXJuICdjYXB0aW9ucyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnc3VidGl0bGVzJztcbiAgfTtcbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zICYmIGRhdGEuY2FwdGlvbnMpIHtcbiAgICAgIGRhdGEuY2FwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY2FwdGlvbnNUcmFjaykge1xuICAgICAgICB2YXIgaW5zdHJlYW1JZE1hdGNoID0gLyg/OkNDfFNFUlZJQ0UpKFsxLTRdKS8uZXhlYyhjYXB0aW9uc1RyYWNrLmluc3RyZWFtSWQpO1xuICAgICAgICBpZiAoIWluc3RyZWFtSWRNYXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhY2tOYW1lID0gXCJ0ZXh0VHJhY2tcIiArIGluc3RyZWFtSWRNYXRjaFsxXTtcbiAgICAgICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IF90aGlzMy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhYmVsID0gY2FwdGlvbnNUcmFjay5uYW1lO1xuICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgYXR0cmlidXRlXG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhbmd1YWdlQ29kZSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgfVxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubWVkaWEgPSBjYXB0aW9uc1RyYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbCA9IGZ1bmN0aW9uIGNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICByZXR1cm4gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsLmF0dHJzWydDTE9TRUQtQ0FQVElPTlMnXTtcbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjEsXG4gICAgICBjZWE2MDhQYXJzZXIyID0gdGhpcy5jZWE2MDhQYXJzZXIyLFxuICAgICAgbGFzdFNuID0gdGhpcy5sYXN0U24sXG4gICAgICBsYXN0UGFydEluZGV4ID0gdGhpcy5sYXN0UGFydEluZGV4O1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICEoY2VhNjA4UGFyc2VyMSAmJiBjZWE2MDhQYXJzZXIyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgIGlmIChkYXRhLmZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLlBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHZhciBfZGF0YSRwYXJ0JGluZGV4LCBfZGF0YSRwYXJ0O1xuICAgICAgdmFyIHNuID0gZGF0YS5mcmFnLnNuO1xuICAgICAgdmFyIHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgPT09IG51bGwgfHwgX2RhdGEkcGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkcGFydC5pbmRleCkgIT0gbnVsbCA/IF9kYXRhJHBhcnQkaW5kZXggOiAtMTtcbiAgICAgIGlmICghKHNuID09PSBsYXN0U24gKyAxIHx8IHNuID09PSBsYXN0U24gJiYgcGFydEluZGV4ID09PSBsYXN0UGFydEluZGV4ICsgMSkpIHtcbiAgICAgICAgY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgICBjZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgdGhpcy5sYXN0UGFydEluZGV4ID0gcGFydEluZGV4O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUUyxcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3M7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLlBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXG4gICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkLlxuICAgICAgICBpZiAoISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgaWYgKGluaXRQVFMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2ggdW5zdWNjZXNzZnVsbHksIG90aGVyd2lzZSB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgY291bGQgYmUgYmxvY2tlZCBmcm9tIGxvYWRpbmcgbmV3IGZyYWdzLlxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdNaXNzaW5nIGluaXRpYWwgc3VidGl0bGUgUFRTJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgLy8gZnJhZ21lbnQgYWZ0ZXIgZGVjcnlwdGlvbiBoYXMgYSBzdGF0cyBvYmplY3RcbiAgICAgICAgdmFyIGRlY3J5cHRlZCA9ICgnc3RhdHMnIGluIGRhdGEpO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIHZhciB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcbiAgICAgICAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgICAgICAgdnR0Q0NzW2ZyYWcuY2NdID0ge1xuICAgICAgICAgICAgICBzdGFydDogZnJhZy5zdGFydCxcbiAgICAgICAgICAgICAgcHJldkNDOiB0aGlzLnByZXZDQyxcbiAgICAgICAgICAgICAgbmV3OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tQbGF5bGlzdE1lZGlhICYmIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPT09IF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLklNU0MxX0NPREVDKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCwgdnR0Q0NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0VtcHR5IHN1YnRpdGxlIHBheWxvYWQnKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5fcGFyc2VJTVNDMSA9IGZ1bmN0aW9uIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgKDAsX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ucGFyc2VJTVNDMSkocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSwgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgIF90aGlzNC5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBJTVNDMTogXCIgKyBlcnJvcik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uX3BhcnNlVlRUcyA9IGZ1bmN0aW9uIF9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCwgdnR0Q0NzKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50LFxuICAgICAgX3RoaXM1ID0gdGhpcztcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgIHZhciBwYXlsb2FkV2ViVlRUID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgIT09IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBfZnJhZyRpbml0U2VnbWVudC5kYXRhID8gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmFwcGVuZFVpbnQ4QXJyYXkpKGZyYWcuaW5pdFNlZ21lbnQuZGF0YSwgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpIDogcGF5bG9hZDtcbiAgICAoMCxfdXRpbHNfd2VidnR0X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLnBhcnNlV2ViVlRUKShwYXlsb2FkV2ViVlRULCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudGltZXNjYWxlW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZyYWcuc3RhcnQsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICBfdGhpczUuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3RoaXM1Ll9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwiRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6IFwiICsgZXJyb3IpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLl9mYWxsYmFja1RvSU1TQzEgPSBmdW5jdGlvbiBfZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgIHZhciB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICBpZiAoIXRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMpIHtcbiAgICAgICgwLF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLnBhcnNlSU1TQzEpKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgdGhpcy50aW1lc2NhbGVbZnJhZy5jY10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9IF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLklNU0MxX0NPREVDO1xuICAgICAgICBfdGhpczYuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fYXBwZW5kQ3VlcyA9IGZ1bmN0aW9uIF9hcHBlbmRDdWVzKGN1ZXMsIGZyYWdMZXZlbCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy50ZXh0VHJhY2tzW2ZyYWdMZXZlbF07XG4gICAgICAvLyBXZWJWVFRQYXJzZXIucGFyc2UgaXMgYW4gYXN5bmMgbWV0aG9kIGFuZCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgdHJhY2sgbW9kZSBpcyBzZXQgdG8gXCJkaXNhYmxlZFwiXG4gICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBCZWNhdXNlIHdlIGNoZWNrIGlmIHRoZSBtb2RlIGlzIGRpc2FibGVkLCB3ZSBjYW4gZm9yY2UgY2hlY2sgYGN1ZXNgIGJlbG93LiBUaGV5IGNhbid0IGJlIG51bGwuXG4gICAgICBpZiAoIXRleHRUcmFjayB8fCB0ZXh0VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmFkZEN1ZVRvVHJhY2spKHRleHRUcmFjaywgY3VlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFjayA9IGN1cnJlbnRUcmFjay5kZWZhdWx0ID8gJ2RlZmF1bHQnIDogJ3N1YnRpdGxlcycgKyBmcmFnTGV2ZWw7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdzdWJ0aXRsZXMnLFxuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uRnJhZ0RlY3J5cHRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5QbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgaWYgKCEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25GcmFnTG9hZGVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH07XG4gIF9wcm90by5vbkZyYWdQYXJzaW5nVXNlcmRhdGEgPSBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nVXNlcmRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMSxcbiAgICAgIGNlYTYwOFBhcnNlcjIgPSB0aGlzLmNlYTYwOFBhcnNlcjI7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIShjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcbiAgICBpZiAoZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiB0aGlzLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykgPT09ICdOT05FJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2NCeXRlcyA9IHNhbXBsZXNbaV0uYnl0ZXM7XG4gICAgICBpZiAoY2NCeXRlcykge1xuICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1sxXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gX3JlZjIuc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQgPSBfcmVmMi5lbmRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXRTdWJ0aXRsZXMgPSBfcmVmMi5lbmRPZmZzZXRTdWJ0aXRsZXMsXG4gICAgICB0eXBlID0gX3JlZjIudHlwZTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEuY3VycmVudFRpbWUgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYXIgNjA4IGNhcHRpb24gY3VlcyBmcm9tIHRoZSBjYXB0aW9ucyBUZXh0VHJhY2tzIHdoZW4gdGhlIHZpZGVvIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHJldHVybiAoMCxfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ucmVtb3ZlQ3Vlc0luUmFuZ2UpKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIC8vIENsZWFyIFZUVC9JTVNDMSBzdWJ0aXRsZSBjdWVzIGZyb20gdGhlIHN1YnRpdGxlIFRleHRUcmFja3Mgd2hlbiB0aGUgYmFjayBidWZmZXIgaXMgZmx1c2hlZFxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldFN1YnRpdGxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzO1xuICAgICAgICBPYmplY3Qua2V5cyh0ZXh0VHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgICByZXR1cm4gKDAsX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnJlbW92ZUN1ZXNJblJhbmdlKSh0ZXh0VHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5leHRyYWN0Q2VhNjA4RGF0YSA9IGZ1bmN0aW9uIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgIHZhciBhY3R1YWxDQ0J5dGVzID0gW1tdLCBbXV07XG4gICAgdmFyIGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMHgxZjtcbiAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgdmFyIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMiA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGNjVmFsaWQgPSAoMHgwNCAmIHRtcEJ5dGUpICE9PSAwOyAvLyBTdXBwb3J0IGFsbCBmb3VyIGNoYW5uZWxzXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICB2YXIgY2NUeXBlID0gMHgwMyAmIHRtcEJ5dGU7XG4gICAgICAgIGlmICgweDAwIC8qIENFQTYwOCBmaWVsZDEqLyA9PT0gY2NUeXBlIHx8IDB4MDEgLyogQ0VBNjA4IGZpZWxkMiovID09PSBjY1R5cGUpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9O1xuICByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyO1xufSgpO1xuZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWNyeXB0by50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1jcnlwdG8udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQUVTQ3J5cHRvKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgQUVTQ3J5cHRvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUVTQ3J5cHRvKHN1YnRsZSwgaXYpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFlc0lWID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuICB2YXIgX3Byb3RvID0gQUVTQ3J5cHRvLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgfSwga2V5LCBkYXRhKTtcbiAgfTtcbiAgcmV0dXJuIEFFU0NyeXB0bztcbn0oKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBBRVNEZWNyeXB0b3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInJlbW92ZVBhZGRpbmdcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcmVtb3ZlUGFkZGluZylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdHlwZWQtYXJyYXkgKi8gXCIuL3NyYy91dGlscy90eXBlZC1hcnJheS50c1wiKTtcblxuXG4vLyBQS0NTN1xuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICB2YXIgb3V0cHV0Qnl0ZXMgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICB2YXIgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiAoMCxfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zbGljZVVpbnQ4KShhcnJheSwgMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbnZhciBBRVNEZWNyeXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB2YXIgX3Byb3RvID0gQUVTRGVjcnlwdG9yLnByb3RvdHlwZTtcbiAgX3Byb3RvLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyA9IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH07XG4gIF9wcm90by5pbml0VGFibGUgPSBmdW5jdGlvbiBpbml0VGFibGUoKSB7XG4gICAgdmFyIHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgdmFyIGludlNCb3ggPSB0aGlzLmludlNCb3g7XG4gICAgdmFyIHN1Yk1peCA9IHRoaXMuc3ViTWl4O1xuICAgIHZhciBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgIHZhciBzdWJNaXgxID0gc3ViTWl4WzFdO1xuICAgIHZhciBzdWJNaXgyID0gc3ViTWl4WzJdO1xuICAgIHZhciBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgdmFyIHN4ID0geGkgXiB4aSA8PCAxIF4geGkgPDwgMiBeIHhpIDw8IDMgXiB4aSA8PCA0O1xuICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIHZhciB4MiA9IGRbeF07XG4gICAgICB2YXIgeDQgPSBkW3gyXTtcbiAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdmFyIHQgPSBkW3N4XSAqIDB4MTAxIF4gc3ggKiAweDEwMTAxMDA7XG4gICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgc3ViTWl4Mlt4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cbiAgICB2YXIga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgdmFyIGtzUm93O1xuICAgIHZhciBpbnZLc1JvdztcbiAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIHZhciBzYm94ID0gdGhpcy5zQm94O1xuICAgIHZhciByY29uID0gdGhpcy5yY29uO1xuICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICB2YXIgcHJldjtcbiAgICB2YXIgdDtcbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IHByZXY7XG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSB0IDw8IDggfCB0ID4+PiAyNDtcblxuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uW2tzUm93IC8ga2V5U2l6ZSB8IDBdIDw8IDI0O1xuICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgO1xuICBfcHJvdG8ubmV0d29ya1RvSG9zdE9yZGVyU3dhcCA9IGZ1bmN0aW9uIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gIH07XG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWKSB7XG4gICAgdmFyIG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgdmFyIGludlNCT1ggPSB0aGlzLmludlNCb3g7XG4gICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIHZhciBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIHZhciBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xuICAgIHZhciBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgdmFyIGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICB2YXIgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xuICAgIHZhciBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgdmFyIGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICB2YXIgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG4gICAgdmFyIHQwLCB0MSwgdDIsIHQzO1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcbiAgICB2YXIgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG4gICAgdmFyIGtzUm93LCBpO1xuICAgIHZhciBzd2FwV29yZCA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgIGtzUm93ID0gNDtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbczEgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczIgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbczIgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczMgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMCA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMSA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdDAgPSBpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MxID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MyID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9IGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczAgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczEgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICB9O1xuICByZXR1cm4gQUVTRGVjcnlwdG9yO1xufSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGVjcnlwdGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Flc19jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWVzLWNyeXB0byAqLyBcIi4vc3JjL2NyeXB0L2Flcy1jcnlwdG8udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zhc3RfYWVzX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mYXN0LWFlcy1rZXkgKi8gXCIuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWVzLWRlY3J5cHRvciAqLyBcIi4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG5cblxuXG5cblxuXG52YXIgQ0hVTktfU0laRSA9IDE2OyAvLyAxNiBieXRlcywgMTI4IGJpdHNcbnZhciBEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIoY29uZmlnLCBfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPSBfcmVmLnJlbW92ZVBLQ1M3UGFkZGluZyxcbiAgICAgIHJlbW92ZVBLQ1M3UGFkZGluZyA9IF9yZWYkcmVtb3ZlUEtDUzdQYWRkaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkcmVtb3ZlUEtDUzdQYWRkaTtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN1YnRsZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHZhciBfcHJvdG8gPSBEZWNyeXB0ZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gIH07XG4gIF9wcm90by5pc1N5bmMgPSBmdW5jdGlvbiBpc1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlU29mdHdhcmU7XG4gIH07XG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICBpZiAoIWN1cnJlbnRSZXN1bHQgfHwgcmVtYWluZGVyRGF0YSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFJlc3VsdCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgcmV0dXJuICgwLF9hZXNfZGVjcnlwdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ucmVtb3ZlUGFkZGluZykoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy51c2VTb2Z0d2FyZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuc29mdHdhcmVEZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgICAgICAgdmFyIGRlY3J5cHRSZXN1bHQgPSBfdGhpcy5mbHVzaCgpO1xuICAgICAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgICAgIHJlc29sdmUoZGVjcnlwdFJlc3VsdC5idWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1tzb2Z0d2FyZURlY3J5cHRdIEZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgfVxuXG4gIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gIDtcbiAgX3Byb3RvLnNvZnR3YXJlRGVjcnlwdCA9IGZ1bmN0aW9uIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgdmFyIGN1cnJlbnRJViA9IHRoaXMuY3VycmVudElWLFxuICAgICAgY3VycmVudFJlc3VsdCA9IHRoaXMuY3VycmVudFJlc3VsdCxcbiAgICAgIHJlbWFpbmRlckRhdGEgPSB0aGlzLnJlbWFpbmRlckRhdGE7XG4gICAgdGhpcy5sb2dPbmNlKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgIC8vIFRoZSBvdXRwdXQgaXMgc3RhZ2dlcmVkIGR1cmluZyBwcm9ncmVzc2l2ZSBwYXJzaW5nIC0gdGhlIGN1cnJlbnQgcmVzdWx0IGlzIGNhY2hlZCwgYW5kIGVtaXR0ZWQgb24gdGhlIG5leHQgY2FsbFxuICAgIC8vIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBzdHJpcCBQS0NTNyBwYWRkaW5nLCB3aGljaCBpcyBmb3VuZCBhdCB0aGUgZW5kIG9mIGVhY2ggc2VnbWVudC4gV2Ugb25seSBrbm93IHdlJ3ZlIHJlYWNoZWRcbiAgICAvLyB0aGUgZW5kIG9uIGZsdXNoKCksIGJ1dCBieSB0aGF0IHRpbWUgd2UgaGF2ZSBhbHJlYWR5IHJlY2VpdmVkIGFsbCBieXRlcyBmb3IgdGhlIHNlZ21lbnQuXG4gICAgLy8gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggV2ViQ3J5cHRvXG5cbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5hcHBlbmRVaW50OEFycmF5KShyZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2IChBRVMtMTI4ID0gMTI4IGJpdCBibG9ja3MgPSAxNiBieXRlcylcbiAgICB2YXIgY3VycmVudENodW5rID0gdGhpcy5nZXRWYWxpZENodW5rKGRhdGEpO1xuICAgIGlmICghY3VycmVudENodW5rLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cbiAgICB2YXIgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyO1xuICAgIGlmICghc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBfYWVzX2RlY3J5cHRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgpO1xuICAgIH1cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9ICgwLF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnNsaWNlVWludDgpKGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfcHJvdG8ud2ViQ3J5cHRvRGVjcnlwdCA9IGZ1bmN0aW9uIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBfZmFzdF9hZXNfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKHN1YnRsZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKS50aGVuKGZ1bmN0aW9uIChhZXNLZXkpIHtcbiAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgaWYgKCFzdWJ0bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignd2ViIGNyeXB0byBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgICB9XG4gICAgICBfdGhpczIubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICB2YXIgY3J5cHRvID0gbmV3IF9hZXNfY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKHN1YnRsZSwgbmV3IFVpbnQ4QXJyYXkoaXYpKTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oXCJbZGVjcnlwdGVyXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEksIFwiICsgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gX3RoaXMyLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5vbldlYkNyeXB0b0Vycm9yID0gZnVuY3Rpb24gb25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2KSB7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KTtcbiAgICB2YXIgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkNyeXB0byBhbmQgc29mdHdhcmVEZWNyeXB0OiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH07XG4gIF9wcm90by5nZXRWYWxpZENodW5rID0gZnVuY3Rpb24gZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgdmFyIHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcbiAgICBpZiAoc3BsaXRQb2ludCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnRDaHVuayA9ICgwLF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnNsaWNlVWludDgpKGRhdGEsIDAsIHNwbGl0UG9pbnQpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gKDAsX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uc2xpY2VVaW50OCkoZGF0YSwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH07XG4gIF9wcm90by5sb2dPbmNlID0gZnVuY3Rpb24gbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLmxvZyhcIltkZWNyeXB0ZXJdOiBcIiArIG1zZyk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH07XG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBGYXN0QUVTS2V5KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuICB2YXIgX3Byb3RvID0gRmFzdEFFU0tleS5wcm90b3R5cGU7XG4gIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJ1xuICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfTtcbiAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvYWFjZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2FhY2RlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuXG5cblxuXG52YXIgQUFDRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuICBmdW5jdGlvbiBBQUNEZW11eGVyKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfQmFzZUF1ZGlvRGVtdXhlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIF90aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgX3RoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gQUFDRGVtdXhlci5wcm90b3R5cGU7XG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9hZHRzJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ2FhYycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgO1xuICBBQUNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICB2YXIgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICBmb3IgKHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kRnJhbWUgPSBmdW5jdGlvbiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5pbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgdmFyIGZyYW1lID0gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLm1pc3NpbmcgPT09IDApIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBQUNEZW11eGVyO1xufShfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoQUFDRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9hZHRzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJhcHBlbmRGcmFtZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhcHBlbmRGcmFtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY2FuR2V0RnJhbWVMZW5ndGhcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2FuR2V0RnJhbWVMZW5ndGgpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImNhblBhcnNlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNhblBhcnNlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRBdWRpb0NvbmZpZ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRBdWRpb0NvbmZpZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZ2V0RnJhbWVEdXJhdGlvblwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRGcmFtZUR1cmF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRGdWxsRnJhbWVMZW5ndGhcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0RnVsbEZyYW1lTGVuZ3RoKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRIZWFkZXJMZW5ndGhcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0SGVhZGVyTGVuZ3RoKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJpbml0VHJhY2tDb25maWdcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW5pdFRyYWNrQ29uZmlnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJpc0hlYWRlclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc0hlYWRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaXNIZWFkZXJQYXR0ZXJuXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzSGVhZGVyUGF0dGVybiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicGFyc2VGcmFtZUhlYWRlclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJzZUZyYW1lSGVhZGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwcm9iZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcm9iZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cblxuXG5cbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgdmFyIGFkdHNPYmplY3RUeXBlO1xuICB2YXIgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg7XG4gIHZhciBhZHRzQ2hhbm5lbENvbmZpZztcbiAgdmFyIGNvbmZpZztcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjO1xuICB2YXIgYWR0c1NhbXBsaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhjMCkgPj4+IDYpICsgMTtcbiAgdmFyIGFkdHNTYW1wbGluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcbiAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gYWR0c1NhbXBsaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgcmVhc29uOiBcImludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDpcIiArIGFkdHNTYW1wbGluZ0luZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkdHNDaGFubmVsQ29uZmlnID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyO1xuICAvLyBieXRlIDNcbiAgYWR0c0NoYW5uZWxDb25maWcgfD0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweGMwKSA+Pj4gNjtcbiAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvZ2dlci5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIiArIGF1ZGlvQ29kZWMgKyBcIiwgQURUUyB0eXBlOlwiICsgYWR0c09iamVjdFR5cGUgKyBcIiwgc2FtcGxpbmdJbmRleDpcIiArIGFkdHNTYW1wbGluZ0luZGV4KTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEgfHwgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFubmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdLFxuICAgIGNoYW5uZWxDb3VudDogYWR0c0NoYW5uZWxDb25maWcsXG4gICAgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSxcbiAgICBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjXG4gIH07XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxID8gNyA6IDk7XG59XG5mdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNTtcbn1cbmZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbml0VHJhY2tDb25maWcodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgdmFyIGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5sb2dnZXIubG9nKFwicGFyc2VkIGNvZGVjOlwiICsgdHJhY2suY29kZWMgKyBcIiwgcmF0ZTpcIiArIGNvbmZpZy5zYW1wbGVyYXRlICsgXCIsIGNoYW5uZWxzOlwiICsgY29uZmlnLmNoYW5uZWxDb3VudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24oc2FtcGxlcmF0ZSkge1xuICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICB2YXIgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgLSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGZyYW1lTGVuZ3RoID4gMCkge1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsXG4gICAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICB2YXIgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICB2YXIgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICB2YXIgdW5pdDtcbiAgaWYgKGhlYWRlcikge1xuICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aCxcbiAgICAgIGhlYWRlckxlbmd0aCA9IGhlYWRlci5oZWFkZXJMZW5ndGg7XG4gICAgdmFyIF9sZW5ndGggPSBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aDtcbiAgICB2YXIgbWlzc2luZyA9IE1hdGgubWF4KDAsIG9mZnNldCArIF9sZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShfbGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKTtcbiAgICAgIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBkYXRhLmxlbmd0aCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0ID0gZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIF9sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgX3NhbXBsZSA9IHtcbiAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICBwdHM6IHN0YW1wXG4gICAgfTtcbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChfc2FtcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogX3NhbXBsZSxcbiAgICAgIGxlbmd0aDogX2xlbmd0aCxcbiAgICAgIG1pc3Npbmc6IG1pc3NpbmdcbiAgICB9O1xuICB9XG4gIC8vIG92ZXJmbG93IGluY29tcGxldGUgaGVhZGVyXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICB2YXIgc2FtcGxlID0ge1xuICAgIHVuaXQ6IHVuaXQsXG4gICAgcHRzOiBzdGFtcFxuICB9O1xuICByZXR1cm4ge1xuICAgIHNhbXBsZTogc2FtcGxlLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIG1pc3Npbmc6IC0xXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYmFzZS1hdWRpby1kZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJpbml0UFRTRm5cIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW5pdFBUU0ZuKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9kZW11eGVyICovIFwiLi9zcmMvdHlwZXMvZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdW1teS1kZW11eGVkLXRyYWNrICovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxuXG52YXIgQmFzZUF1ZGlvRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VBdWRpb0RlbXV4ZXIoKSB7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYW1lSW5kZXggPSAwO1xuICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmluaXRQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gIH1cbiAgdmFyIF9wcm90byA9IEJhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlO1xuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9O1xuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcChkZWF1bHRUaW1lc3RhbXApIHtcbiAgICB0aGlzLmluaXRQVFMgPSBkZWF1bHRUaW1lc3RhbXA7XG4gICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgfTtcbiAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfTtcbiAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kRnJhbWUgPSBmdW5jdGlvbiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7fVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgO1xuICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgZGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5hcHBlbmRVaW50OEFycmF5KSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGlkM0RhdGEgPSBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICB2YXIgbGFzdERhdGFJbmRleDtcbiAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIHZhciBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIHZhciB0aW1lc3RhbXAgPSBpZDNEYXRhID8gX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmdldFRpbWVTdGFtcChpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKSh0aW1lc3RhbXApKSB7XG4gICAgICB0aGlzLmJhc2VQVFMgPSBpbml0UFRTRm4odGltZXN0YW1wLCB0aW1lT2Zmc2V0LCB0aGlzLmluaXRQVFMpO1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0UFRTID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuXG4gICAgLy8gbW9yZSBleHByZXNzaXZlIHRoYW4gYWx0ZXJuYXRpdmU6IGlkM0RhdGE/Lmxlbmd0aFxuICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICB0eXBlOiBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLk1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICB9KTtcbiAgICB9XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgrKztcbiAgICAgICAgICB0aGlzLmxhc3RQVFMgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNhblBhcnNlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgICB0eXBlOiBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLk1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoICYmIGxhc3REYXRhSW5kZXggIT09IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFydGlhbERhdGEgPSAoMCxfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5zbGljZVVpbnQ4KShkYXRhLCBsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5hcHBlbmRVaW50OEFycmF5KSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiAoMCxfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmR1bW15VHJhY2spKCksXG4gICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6ICgwLF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZHVtbXlUcmFjaykoKVxuICAgIH07XG4gIH07XG4gIF9wcm90by5kZW11eFNhbXBsZUFlcyA9IGZ1bmN0aW9uIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiW1wiICsgdGhpcyArIFwiXSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25cIikpO1xuICB9O1xuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCh0aW1lT2Zmc2V0KSB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIHZhciBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kZW11eChjYWNoZWREYXRhLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiAoMCxfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmR1bW15VHJhY2spKCksXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6ICgwLF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZHVtbXlUcmFjaykoKVxuICAgIH07XG4gIH07XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuICByZXR1cm4gQmFzZUF1ZGlvRGVtdXhlcjtcbn0oKTtcbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xudmFyIGluaXRQVFNGbiA9IGZ1bmN0aW9uIGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgaWYgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikodGltZXN0YW1wKSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAgKiA5MDtcbiAgfVxuICByZXR1cm4gdGltZU9mZnNldCAqIDkwMDAwICsgKGluaXRQVFMgfHwgMCk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChCYXNlQXVkaW9EZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIENodW5rQ2FjaGUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbnZhciBDaHVua0NhY2hlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2h1bmtDYWNoZSgpIHtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbiAgdmFyIF9wcm90byA9IENodW5rQ2FjaGUucHJvdG90eXBlO1xuICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9O1xuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgY2h1bmtzID0gdGhpcy5jaHVua3MsXG4gICAgICBkYXRhTGVuZ3RoID0gdGhpcy5kYXRhTGVuZ3RoO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKCFjaHVua3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaHVua3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH07XG4gIHJldHVybiBDaHVua0NhY2hlO1xufSgpO1xuXG5mdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9kdW1teS1kZW11eGVkLXRyYWNrLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkdW1teVRyYWNrXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGR1bW15VHJhY2spXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmZ1bmN0aW9uIGR1bW15VHJhY2sodHlwZSwgaW5wdXRUaW1lU2NhbGUpIHtcbiAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgIHR5cGUgPSAnJztcbiAgfVxuICBpZiAoaW5wdXRUaW1lU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGlucHV0VGltZVNjYWxlID0gOTAwMDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlOiBpbnB1dFRpbWVTY2FsZSxcbiAgICBzZXF1ZW5jZU51bWJlcjogLTEsXG4gICAgc2FtcGxlczogW10sXG4gICAgZHJvcHBlZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5cblxudmFyIEV4cEdvbG9tYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cEdvbG9tYihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgdmFyIF9wcm90byA9IEV4cEdvbG9tYi5wcm90b3R5cGU7XG4gIF9wcm90by5sb2FkV29yZCA9IGZ1bmN0aW9uIGxvYWRXb3JkKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgdmFyIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGU7XG4gICAgdmFyIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIHZhciBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgO1xuICBfcHJvdG8uc2tpcEJpdHMgPSBmdW5jdGlvbiBza2lwQml0cyhjb3VudCkge1xuICAgIHZhciBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmJ5dGVzQXZhaWxhYmxlICogOCArIHRoaXMuYml0c0F2YWlsYWJsZSk7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gc2tpcEJ5dGVzIDw8IDM7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIDtcbiAgX3Byb3RvLnJlYWRCaXRzID0gZnVuY3Rpb24gcmVhZEJpdHMoc2l6ZSkge1xuICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICB2YXIgdmFsdSA9IHRoaXMud29yZCA+Pj4gMzIgLSBiaXRzOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5sb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBiaXRzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgO1xuICBfcHJvdG8uc2tpcExaID0gZnVuY3Rpb24gc2tpcExaKCkge1xuICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKCh0aGlzLndvcmQgJiAweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgO1xuICBfcHJvdG8uc2tpcFVFRyA9IGZ1bmN0aW9uIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIDtcbiAgX3Byb3RvLnNraXBFRyA9IGZ1bmN0aW9uIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgO1xuICBfcHJvdG8ucmVhZFVFRyA9IGZ1bmN0aW9uIHJlYWRVRUcoKSB7XG4gICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIDtcbiAgX3Byb3RvLnJlYWRFRyA9IGZ1bmN0aW9uIHJlYWRFRygpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIDtcbiAgX3Byb3RvLnJlYWRCb29sZWFuID0gZnVuY3Rpb24gcmVhZEJvb2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgO1xuICBfcHJvdG8ucmVhZFVCeXRlID0gZnVuY3Rpb24gcmVhZFVCeXRlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIDtcbiAgX3Byb3RvLnJlYWRVU2hvcnQgPSBmdW5jdGlvbiByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICA7XG4gIF9wcm90by5yZWFkVUludCA9IGZ1bmN0aW9uIHJlYWRVSW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqLztcbiAgX3Byb3RvLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgIHZhciBsYXN0U2NhbGUgPSA4O1xuICAgIHZhciBuZXh0U2NhbGUgPSA4O1xuICAgIHZhciBkZWx0YVNjYWxlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgfVxuICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi87XG4gIF9wcm90by5yZWFkU1BTID0gZnVuY3Rpb24gcmVhZFNQUygpIHtcbiAgICB2YXIgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgdmFyIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICB2YXIgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIHZhciBzY2FsaW5nTGlzdENvdW50O1xuICAgIHZhciBpO1xuICAgIHZhciByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpO1xuICAgIHZhciByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKTtcbiAgICB2YXIgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpO1xuICAgIHZhciByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyk7XG4gICAgdmFyIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyk7XG4gICAgdmFyIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICByZWFkVUJ5dGUoKTtcbiAgICB2YXIgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICBza2lwRUcoKTtcbiAgICAgIH0gLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgIH1cblxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIHZhciBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xuICAgIHZhciBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIHZhciBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTgsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE1LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYwLCA5OV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0LCAzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMiwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSxcbiAgICAgIGhlaWdodDogKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLnJlYWRTbGljZVR5cGUgPSBmdW5jdGlvbiByZWFkU2xpY2VUeXBlKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH07XG4gIHJldHVybiBFeHBHb2xvbWI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEV4cEdvbG9tYik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvaWQzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImNhblBhcnNlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNhblBhcnNlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWNvZGVGcmFtZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBkZWNvZGVGcmFtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZ2V0SUQzRGF0YVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRJRDNEYXRhKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRJRDNGcmFtZXNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0SUQzRnJhbWVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRUaW1lU3RhbXBcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0VGltZVN0YW1wKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJpc0Zvb3RlclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc0Zvb3RlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaXNIZWFkZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNIZWFkZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImlzVGltZVN0YW1wRnJhbWVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNUaW1lU3RhbXBGcmFtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidGVzdGFibGVzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHRlc3RhYmxlcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidXRmOEFycmF5VG9TdHJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdXRmOEFycmF5VG9TdHIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIGJyZWFraW5nIHVwIHRob3NlIHR3byB0eXBlcyBpbiBvcmRlciB0byBjbGFyaWZ5IHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoZSBkZWNvZGluZyBwYXRoLlxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gKi9cbnZhciBpc0hlYWRlciA9IGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvKlxuICAgKiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAgICogWzBdICAgICA9ICdJJ1xuICAgKiBbMV0gICAgID0gJ0QnXG4gICAqIFsyXSAgICAgPSAnMydcbiAgICogWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgKiBbNi05XSAgID0ge0lEMyBTaXplfVxuICAgKlxuICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgKiAgJDQ5IDQ0IDMzIHl5IHl5IHh4IHp6IHp6IHp6IHp6XG4gICAqIFdoZXJlIHl5IGlzIGxlc3MgdGhhbiAkRkYsIHh4IGlzIHRoZSAnZmxhZ3MnIGJ5dGUgYW5kIHp6IGlzIGxlc3MgdGhhbiAkODBcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzMykge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gKi9cbnZhciBpc0Zvb3RlciA9IGZ1bmN0aW9uIGlzRm9vdGVyKGRhdGEsIG9mZnNldCkge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfSAtIFRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gKiBvciAqdW5kZWZpbmVkKiBpZiBubyBoZWFkZXIgaXMgZm91bmQgYXQgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICovXG52YXIgZ2V0SUQzRGF0YSA9IGZ1bmN0aW9uIGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBmcm9udCA9IG9mZnNldDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHdoaWxlIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgIGxlbmd0aCArPSAxMDtcbiAgICB2YXIgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuICAgIGlmIChpc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG52YXIgcmVhZFNpemUgPSBmdW5jdGlvbiByZWFkU2l6ZShkYXRhLCBvZmZzZXQpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQ7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICByZXR1cm4gc2l6ZTtcbn07XG52YXIgY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn07XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqIEByZXR1cm4ge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgdGltZXN0YW1wXG4gKi9cbnZhciBnZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAoZGF0YSkge1xuICB2YXIgZnJhbWVzID0gZ2V0SUQzRnJhbWVzKGRhdGEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICBpZiAoaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiByZWFkVGltZVN0YW1wKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKiBAcGFyYW0ge0lEMyBmcmFtZX0gZnJhbWVcbiAqL1xudmFyIGlzVGltZVN0YW1wRnJhbWUgPSBmdW5jdGlvbiBpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiBmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnO1xufTtcbnZhciBnZXRGcmFtZURhdGEgPSBmdW5jdGlvbiBnZXRGcmFtZURhdGEoZGF0YSkge1xuICAvKlxuICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAqL1xuICB2YXIgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gIHZhciBzaXplID0gcmVhZFNpemUoZGF0YSwgNCk7XG5cbiAgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG4gIHZhciBvZmZzZXQgPSAxMDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNpemU6IHNpemUsXG4gICAgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICogQHJldHVybiB7SUQzLkZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAqL1xudmFyIGdldElEM0ZyYW1lcyA9IGZ1bmN0aW9uIGdldElEM0ZyYW1lcyhpZDNEYXRhKSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgZnJhbWVzID0gW107XG4gIHdoaWxlIChpc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgdmFyIHNpemUgPSByZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAvLyBza2lwIHBhc3QgSUQzIGhlYWRlclxuICAgIG9mZnNldCArPSAxMDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgIHZhciBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIHZhciBmcmFtZSA9IGRlY29kZUZyYW1lKGZyYW1lRGF0YSk7XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIGZyYW1lIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxuICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgfVxuICAgIGlmIChpc0Zvb3RlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgICBvZmZzZXQgKz0gMTA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcmFtZXM7XG59O1xudmFyIGRlY29kZUZyYW1lID0gZnVuY3Rpb24gZGVjb2RlRnJhbWUoZnJhbWUpIHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xudmFyIGRlY29kZVByaXZGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZVByaXZGcmFtZShmcmFtZSkge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIG93bmVyID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSwgdHJ1ZSk7XG4gIHZhciBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiBvd25lcixcbiAgICBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXJcbiAgfTtcbn07XG52YXIgZGVjb2RlVGV4dEZyYW1lID0gZnVuY3Rpb24gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICovXG4gICAgdmFyIGluZGV4ID0gMTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICB2YXIgdmFsdWUgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgIGluZm86IGRlc2NyaXB0aW9uLFxuICAgICAgZGF0YTogdmFsdWVcbiAgICB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgWzEtP10gPSB7VmFsdWV9XG4gICovXG4gIHZhciB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHRleHRcbiAgfTtcbn07XG52YXIgZGVjb2RlVVJMRnJhbWUgPSBmdW5jdGlvbiBkZWNvZGVVUkxGcmFtZShmcmFtZSkge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAxO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIHZhciB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIHZhciB1cmwgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgZGF0YTogdXJsXG4gIH07XG59O1xudmFyIHJlYWRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZWFkVGltZVN0YW1wKHRpbWVTdGFtcEZyYW1lKSB7XG4gIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICB2YXIgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgIHZhciB0aW1lc3RhbXAgPSAoZGF0YVs0XSA8PCAyMykgKyAoZGF0YVs1XSA8PCAxNSkgKyAoZGF0YVs2XSA8PCA3KSArIGRhdGFbN107XG4gICAgdGltZXN0YW1wIC89IDQ1O1xuICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0O1xuICAgIH0gLy8gMl4zMiAvIDkwXG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xudmFyIHV0ZjhBcnJheVRvU3RyID0gZnVuY3Rpb24gdXRmOEFycmF5VG9TdHIoYXJyYXksIGV4aXRPbk51bGwpIHtcbiAgaWYgKGV4aXRPbk51bGwgPT09IHZvaWQgMCkge1xuICAgIGV4aXRPbk51bGwgPSBmYWxzZTtcbiAgfVxuICB2YXIgZGVjb2RlciA9IGdldFRleHREZWNvZGVyKCk7XG4gIGlmIChkZWNvZGVyKSB7XG4gICAgdmFyIGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIHZhciBpZHggPSBkZWNvZGVkLmluZGV4T2YoJ1xcMCcpO1xuICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBkZWNvZGVkLnN1YnN0cmluZygwLCBpZHgpIDogZGVjb2RlZDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IG51bGwgY2hhcmFjdGVyc1xuICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGM7XG4gIHZhciBjaGFyMjtcbiAgdmFyIGNoYXIzO1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjID0gYXJyYXlbaSsrXTtcbiAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDFmKSA8PCA2IHwgY2hhcjIgJiAweDNmKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MGYpIDw8IDEyIHwgKGNoYXIyICYgMHgzZikgPDwgNiB8IChjaGFyMyAmIDB4M2YpIDw8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xudmFyIHRlc3RhYmxlcyA9IHtcbiAgZGVjb2RlVGV4dEZyYW1lOiBkZWNvZGVUZXh0RnJhbWVcbn07XG52YXIgZGVjb2RlcjtcbmZ1bmN0aW9uIGdldFRleHREZWNvZGVyKCkge1xuICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXAzZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2UtYXVkaW8tZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzXCIpO1xuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuLyoqXG4gKiBNUDMgZGVtdXhlclxuICovXG5cblxuXG5cbnZhciBNUDNEZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUF1ZGlvRGVtdXhlcikge1xuICBfaW5oZXJpdHNMb29zZShNUDNEZW11eGVyLCBfQmFzZUF1ZGlvRGVtdXhlcik7XG4gIGZ1bmN0aW9uIE1QM0RlbXV4ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlQXVkaW9EZW11eGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gTVAzRGVtdXhlci5wcm90b3R5cGU7XG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ21wMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9O1xuICBNUDNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICB2YXIgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICBmb3IgKHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5sb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by5jYW5QYXJzZSA9IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gIH07XG4gIHJldHVybiBNUDNEZW11eGVyO1xufShfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoTVAzRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L21wNGRlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9kZW11eGVyICovIFwiLi9zcmMvdHlwZXMvZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHVtbXktZGVtdXhlZC10cmFjayAqLyBcIi4vc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHNcIik7XG5cbi8qKlxuICogTVA0IGRlbXV4ZXJcbiAqL1xuXG5cblxudmFyIGVtc2dTY2hlbWVQYXR0ZXJuID0gL1xcL2Vtc2dbLS9dSUQzL2k7XG52YXIgTVA0RGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1QNERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuaWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy50eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICB2YXIgX3Byb3RvID0gTVA0RGVtdXhlci5wcm90b3R5cGU7XG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge307XG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrID0gKDAsX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kdW1teVRyYWNrKSgndmlkZW8nLCAxKTtcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9ICgwLF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZHVtbXlUcmFjaykoJ2F1ZGlvJywgMSk7XG4gICAgdmFyIGNhcHRpb25UcmFjayA9IHRoaXMudHh0VHJhY2sgPSAoMCxfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmR1bW15VHJhY2spKCd0ZXh0JywgMSk7XG4gICAgdGhpcy5pZDNUcmFjayA9ICgwLF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZHVtbXlUcmFjaykoJ2lkMycsIDEpO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgaWYgKCFpbml0U2VnbWVudCB8fCAhaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5pdERhdGEgPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ucGFyc2VJbml0U2VnbWVudCkoaW5pdFNlZ21lbnQpO1xuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdmFyIF9pbml0RGF0YSR2aWRlbyA9IGluaXREYXRhLnZpZGVvLFxuICAgICAgICBpZCA9IF9pbml0RGF0YSR2aWRlby5pZCxcbiAgICAgICAgdGltZXNjYWxlID0gX2luaXREYXRhJHZpZGVvLnRpbWVzY2FsZSxcbiAgICAgICAgY29kZWMgPSBfaW5pdERhdGEkdmlkZW8uY29kZWM7XG4gICAgICB2aWRlb1RyYWNrLmlkID0gaWQ7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGNhcHRpb25UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgdmFyIF9pbml0RGF0YSRhdWRpbyA9IGluaXREYXRhLmF1ZGlvLFxuICAgICAgICBfaWQgPSBfaW5pdERhdGEkYXVkaW8uaWQsXG4gICAgICAgIF90aW1lc2NhbGUgPSBfaW5pdERhdGEkYXVkaW8udGltZXNjYWxlLFxuICAgICAgICBfY29kZWMgPSBfaW5pdERhdGEkYXVkaW8uY29kZWM7XG4gICAgICBhdWRpb1RyYWNrLmlkID0gX2lkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBfdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IF9jb2RlYztcbiAgICB9XG4gICAgY2FwdGlvblRyYWNrLmlkID0gX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmlkZW9UcmFjay5kdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9O1xuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge307XG4gIE1QNERlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcbiAgICBkYXRhID0gZGF0YS5sZW5ndGggPiAxNjM4NCA/IGRhdGEuc3ViYXJyYXkoMCwgMTYzODQpIDogZGF0YTtcbiAgICByZXR1cm4gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmZpbmRCb3gpKGRhdGEsIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICB9O1xuICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgdmFyIHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgdmFyIHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2s7XG4gICAgdmFyIHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmFwcGVuZFVpbnQ4QXJyYXkpKHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2VnbWVudGVkRGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5zZWdtZW50VmFsaWRSYW5nZSkodmlkZW9TYW1wbGVzKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNlZ21lbnRlZERhdGEucmVtYWluZGVyO1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gc2VnbWVudGVkRGF0YS52YWxpZCB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1NhbXBsZXM7XG4gICAgfVxuICAgIHZhciBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLnBhcnNlU2FtcGxlcykodGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2s6IHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IHRoaXMudHh0VHJhY2tcbiAgICB9O1xuICB9O1xuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgdGltZU9mZnNldCA9IHRoaXMudGltZU9mZnNldDtcbiAgICB2YXIgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHZhciBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRoaXMudGltZU9mZnNldCk7XG4gICAgdGV4dFRyYWNrLnNhbXBsZXMgPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ucGFyc2VTYW1wbGVzKSh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6ICgwLF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZHVtbXlUcmFjaykoKSxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogKDAsX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kdW1teVRyYWNrKSgpXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLmV4dHJhY3RJRDNUcmFjayA9IGZ1bmN0aW9uIGV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaztcbiAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVtc2dzID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmZpbmRCb3gpKHZpZGVvVHJhY2suc2FtcGxlcywgWydlbXNnJ10pO1xuICAgICAgaWYgKGVtc2dzKSB7XG4gICAgICAgIGVtc2dzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZW1zZ0luZm8gPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ucGFyc2VFbXNnKShkYXRhKTtcbiAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgIHZhciBwdHMgPSAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSAvIGVtc2dJbmZvLnRpbWVTY2FsZSA6IHRpbWVPZmZzZXQgKyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBlbXNnSW5mby5ldmVudER1cmF0aW9uID09PSAweGZmZmZmZmZmID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogZW1zZ0luZm8uZXZlbnREdXJhdGlvbiAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSB0YWtlcyBhbnl0aGluZyA8PSAwLjAwMSBzZWNvbmRzIGFuZCBtYXBzIGl0IHRvIEluZmluaXR5XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICB0eXBlOiBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLk1ldGFkYXRhU2NoZW1hLmVtc2csXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkM1RyYWNrO1xuICB9O1xuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICB9O1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgcmV0dXJuIE1QNERlbXV4ZXI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKE1QNERlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcGVnYXVkaW8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wZWdhdWRpby50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJhcHBlbmRGcmFtZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhcHBlbmRGcmFtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY2FuUGFyc2VcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2FuUGFyc2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImlzSGVhZGVyXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzSGVhZGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJpc0hlYWRlclBhdHRlcm5cIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNIZWFkZXJQYXR0ZXJuKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZUhlYWRlclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJzZUhlYWRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicHJvYmVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcHJvYmUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5cbnZhciBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbnZhciBCaXRyYXRlc01hcCA9IFszMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdO1xudmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xudmFyIFNhbXBsZXNDb2VmZmljaWVudHMgPSBbXG4vLyBNUEVHIDIuNVxuWzAsXG4vLyBSZXNlcnZlZFxuNzIsXG4vLyBMYXllcjNcbjE0NCxcbi8vIExheWVyMlxuMTIgLy8gTGF5ZXIxXG5dLFxuLy8gUmVzZXJ2ZWRcblswLFxuLy8gUmVzZXJ2ZWRcbjAsXG4vLyBMYXllcjNcbjAsXG4vLyBMYXllcjJcbjAgLy8gTGF5ZXIxXG5dLFxuLy8gTVBFRyAyXG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDFcblswLFxuLy8gUmVzZXJ2ZWRcbjE0NCxcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl1dO1xuXG52YXIgQnl0ZXNJblNsb3QgPSBbMCxcbi8vIFJlc2VydmVkXG4xLFxuLy8gTGF5ZXIzXG4xLFxuLy8gTGF5ZXIyXG40IC8vIExheWVyMVxuXTtcblxuZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBpZiAoaGVhZGVyICYmIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgdmFyIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgdmFyIHNhbXBsZSA9IHtcbiAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXBcbiAgICB9O1xuICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGU6IHNhbXBsZSxcbiAgICAgIGxlbmd0aDogaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgbWlzc2luZzogMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICB2YXIgbXBlZ1ZlcnNpb24gPSBkYXRhW29mZnNldCArIDFdID4+IDMgJiAzO1xuICB2YXIgbXBlZ0xheWVyID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAxICYgMztcbiAgdmFyIGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICB2YXIgc2FtcGxlUmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAyICYgMztcbiAgaWYgKG1wZWdWZXJzaW9uICE9PSAxICYmIGJpdFJhdGVJbmRleCAhPT0gMCAmJiBiaXRSYXRlSW5kZXggIT09IDE1ICYmIHNhbXBsZVJhdGVJbmRleCAhPT0gMykge1xuICAgIHZhciBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICB2YXIgY2hhbm5lbE1vZGUgPSBkYXRhW29mZnNldCArIDNdID4+IDY7XG4gICAgdmFyIGNvbHVtbkluQml0cmF0ZXMgPSBtcGVnVmVyc2lvbiA9PT0gMyA/IDMgLSBtcGVnTGF5ZXIgOiBtcGVnTGF5ZXIgPT09IDMgPyAzIDogNDtcbiAgICB2YXIgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMCA6IG1wZWdWZXJzaW9uID09PSAyID8gMSA6IDI7XG4gICAgdmFyIHNhbXBsZVJhdGUgPSBTYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBzYW1wbGVSYXRlSW5kZXhdO1xuICAgIHZhciBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgdmFyIHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICB2YXIgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIHZhciBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICB2YXIgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqIGJ5dGVzSW5TbG90O1xuICAgIGlmIChjaHJvbWVWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIHZhciByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgdmFyIG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8PSA4NztcbiAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBDaHJvbWl1bSBieSBzZXR0aW5nIGNoYW5uZWxNb2RlIHRvIGR1YWwtY2hhbm5lbCAoMDEpIGluc3RlYWQgb2Ygc3RlcmVvICgwMClcbiAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdIHwgMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXG4gICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudCxcbiAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgIHNhbXBsZXNQZXJGcmFtZTogc2FtcGxlc1BlckZyYW1lXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBoZWFkZXJTaXplID0gNDtcbiAgcmV0dXJuIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmIGhlYWRlclNpemUgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGhlYWRlciAhPT0gbnVsbCAmJiBoZWFkZXIgIT09IHZvaWQgMCAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3NhbXBsZS1hZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9zYW1wbGUtYWVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4gKi9cblxuXG5cbnZhciBTYW1wbGVBZXNEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTYW1wbGVBZXNEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywga2V5RGF0YSkge1xuICAgIHRoaXMua2V5RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleURhdGEgPSBrZXlEYXRhO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdmFyIF9wcm90byA9IFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGU7XG4gIF9wcm90by5kZWNyeXB0QnVmZmVyID0gZnVuY3Rpb24gZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIpO1xuICB9XG5cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgO1xuICBfcHJvdG8uZGVjcnlwdEFhY1NhbXBsZSA9IGZ1bmN0aW9uIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAvLyBObyBlbmNyeXB0ZWQgcG9ydGlvbiBpbiB0aGlzIHNhbXBsZSAoZmlyc3QgMTYgYnl0ZXMgaXMgbm90XG4gICAgICAvLyBlbmNyeXB0ZWQsIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vQXVkaW9WaWRlby9Db25jZXB0dWFsL0hMU19TYW1wbGVfRW5jcnlwdGlvbi9FbmNyeXB0aW9uL0VuY3J5cHRpb24uaHRtbCksXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcbiAgICB2YXIgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkQnVmZmVyKSB7XG4gICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG4gICAgICBpZiAoIV90aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICBfdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmRlY3J5cHRBYWNTYW1wbGVzID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gIDtcbiAgX3Byb3RvLmdldEF2Y0VuY3J5cHRlZERhdGEgPSBmdW5jdGlvbiBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgdmFyIGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgdmFyIG91dHB1dFBvcyA9IDA7XG4gICAgZm9yICh2YXIgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH07XG4gIF9wcm90by5nZXRBdmNEZWNyeXB0ZWRVbml0ID0gZnVuY3Rpb24gZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgIHZhciB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICB2YXIgaW5wdXRQb3MgPSAwO1xuICAgIGZvciAodmFyIG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTYpIHtcbiAgICAgIGRlY29kZWREYXRhLnNldCh1aW50OERlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH07XG4gIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBkZWNvZGVkRGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5kaXNjYXJkRVBCKShjdXJVbml0LmRhdGEpO1xuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZEJ1ZmZlcikge1xuICAgICAgY3VyVW5pdC5kYXRhID0gX3RoaXMyLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBpZiAoIV90aGlzMi5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgX3RoaXMyLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlcyA9IGZ1bmN0aW9uIGRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNhbXBsZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcbiAgICAgICAgaWYgKGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHwgY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCk7XG4gICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBTYW1wbGVBZXNEZWNyeXB0ZXI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFNhbXBsZUFlc0RlY3J5cHRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBUcmFuc211eGVySW50ZXJmYWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93ZWJ3b3JraWZ5LXdlYnBhY2sgKi8gXCIuL3NyYy9kZW11eC93ZWJ3b3JraWZ5LXdlYnBhY2suanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90cmFuc211eGVyICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBldmVudGVtaXR0ZXIzICovIFwiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fKTtcblxuXG5cblxuXG5cblxudmFyIE1lZGlhU291cmNlID0gKDAsX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmdldE1lZGlhU291cmNlKSgpIHx8IHtcbiAgaXNUeXBlU3VwcG9ydGVkOiBmdW5jdGlvbiBpc1R5cGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIFRyYW5zbXV4ZXJJbnRlcmZhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc211eGVySW50ZXJmYWNlKGhscywgaWQsIG9uVHJhbnNtdXhDb21wbGV0ZSwgb25GbHVzaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ud21zZyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gdm9pZCAwO1xuICAgIHRoaXMub25GbHVzaCA9IHZvaWQgMDtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy51c2VXb3JrZXIgPSAhIWNvbmZpZy5lbmFibGVXb3JrZXI7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiBmb3J3YXJkTWVzc2FnZShldiwgZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSBfdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IF90aGlzLmlkO1xuICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHZhciB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTtcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgdmFyIHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XG4gICAgaWYgKHRoaXMudXNlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICB2YXIgd29ya2VyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd29ya2VyID0gdGhpcy53b3JrZXIgPSAoMCxfd2Vid29ya2lmeV93ZWJwYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKSgvKnJlcXVpcmUucmVzb2x2ZSovKC8qISAuLi9kZW11eC90cmFuc211eGVyLXdvcmtlci50cyAqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItd29ya2VyLnRzXCIpKTtcbiAgICAgICAgdGhpcy5vbndtc2cgPSB0aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpcy51c2VXb3JrZXIgPSBmYWxzZTtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oJ0V4Y2VwdGlvbiBpbiB3ZWJ3b3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZScpO1xuICAgICAgICAgIF90aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5FcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihldmVudC5tZXNzYWdlICsgXCIgIChcIiArIGV2ZW50LmZpbGVuYW1lICsgXCI6XCIgKyBldmVudC5saW5lbm8gKyBcIilcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgICB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLFxuICAgICAgICAgIHZlbmRvcjogdmVuZG9yLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci53YXJuKCdFcnJvciBpbiB3b3JrZXI6JywgZXJyKTtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZScpO1xuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXIub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKTtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXJJbnRlcmZhY2UucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmtlcjtcbiAgICBpZiAodykge1xuICAgICAgdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgIHRoaXMub253bXNnID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH07XG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsXG4gICAgICBfbGFzdEZyYWckaW5pdFNlZ21lbnQsXG4gICAgICBfdGhpczIgPSB0aGlzO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICB3b3JrZXIgPSB0aGlzLndvcmtlcjtcbiAgICB2YXIgdGltZU9mZnNldCA9IHBhcnQgPyBwYXJ0LnN0YXJ0IDogZnJhZy5zdGFydDtcbiAgICAvLyBUT0RPOiBwdXNoIFwiY2xlYXItbGVhZFwiIGRlY3J5cHQgZGF0YSBmb3IgdW5lbmNyeXB0ZWQgZnJhZ21lbnRzIGluIHN0cmVhbXMgd2l0aCBlbmNyeXB0ZWQgb25lc1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgdmFyIGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIHZhciBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgdmFyIHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICB2YXIgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIHZhciBwYXJ0RGlmZiA9IHRoaXMucGFydCA/IGNodW5rTWV0YS5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogLTE7XG4gICAgdmFyIHByb2dyZXNzaXZlID0gc25EaWZmID09PSAwICYmIGNodW5rTWV0YS5pZCA+IDEgJiYgY2h1bmtNZXRhLmlkID09PSAobGFzdEZyYWcgPT09IG51bGwgfHwgbGFzdEZyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RGcmFnLnN0YXRzLmNodW5rQ291bnQpO1xuICAgIHZhciBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIChzbkRpZmYgPT09IDEgfHwgc25EaWZmID09PSAwICYmIChwYXJ0RGlmZiA9PT0gMSB8fCBwcm9ncmVzc2l2ZSAmJiBwYXJ0RGlmZiA8PSAwKSk7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHRyYWNrU3dpdGNoIHx8IHNuRGlmZiB8fCBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgaWYgKHBhcnQgJiYgKHBhcnREaWZmIHx8ICFjb250aWd1b3VzKSkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICB2YXIgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2xhc3RGcmFnJGluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgdmFyIHN0YXRlID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uVHJhbnNtdXhTdGF0ZShkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5sb2dnZXIubG9nKFwiW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCBcIiArIGZyYWcudHlwZSArIFwiXTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiBcIiArIGNodW5rTWV0YS5zbiArIFwiIHA6IFwiICsgY2h1bmtNZXRhLnBhcnQgKyBcIiBsZXZlbDogXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIiBpZDogXCIgKyBjaHVua01ldGEuaWQgKyBcIlxcbiAgICAgICAgZGlzY29udGludWl0eTogXCIgKyBkaXNjb250aW51aXR5ICsgXCJcXG4gICAgICAgIHRyYWNrU3dpdGNoOiBcIiArIHRyYWNrU3dpdGNoICsgXCJcXG4gICAgICAgIGNvbnRpZ3VvdXM6IFwiICsgY29udGlndW91cyArIFwiXFxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IFwiICsgYWNjdXJhdGVUaW1lT2Zmc2V0ICsgXCJcXG4gICAgICAgIHRpbWVPZmZzZXQ6IFwiICsgdGltZU9mZnNldCArIFwiXFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogXCIgKyBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgICB2YXIgY29uZmlnID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uVHJhbnNtdXhDb25maWcoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcblxuICAgIC8vIEZyYWdzIHdpdGggc24gb2YgJ2luaXRTZWdtZW50JyBhcmUgbm90IHRyYW5zbXV4ZWRcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHZhciBfdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpO1xuICAgICAgaWYgKCgwLF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uaXNQcm9taXNlKShfdHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuYXN5bmMgPSB0cnVlO1xuICAgICAgICBfdHJhbnNtdXhSZXN1bHQudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIF90aGlzMi5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczIudHJhbnNtdXhlckVycm9yKGVycm9yLCBjaHVua01ldGEsICd0cmFuc211eGVyLWludGVyZmFjZSBwdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoX3RyYW5zbXV4UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICB3b3JrZXIgPSB0aGlzLndvcmtlcjtcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICAxO1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZmx1c2gnLFxuICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0MiA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIHZhciBhc3luY0ZsdXNoID0gKDAsX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5pc1Byb21pc2UpKF90cmFuc211eFJlc3VsdDIpO1xuICAgICAgaWYgKGFzeW5jRmx1c2ggfHwgdHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICBpZiAoISgwLF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uaXNQcm9taXNlKShfdHJhbnNtdXhSZXN1bHQyKSkge1xuICAgICAgICAgIF90cmFuc211eFJlc3VsdDIgPSBQcm9taXNlLnJlc29sdmUoX3RyYW5zbXV4UmVzdWx0Mik7XG4gICAgICAgIH1cbiAgICAgICAgX3RyYW5zbXV4UmVzdWx0Mi50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgX3RoaXMzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzMy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChfdHJhbnNtdXhSZXN1bHQyLCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRyYW5zbXV4ZXJFcnJvciA9IGZ1bmN0aW9uIHRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCByZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5oYW5kbGVGbHVzaFJlc3VsdCA9IGZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBfdGhpczQuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIHRoaXMub25GbHVzaChjaHVua01ldGEpO1xuICB9O1xuICBfcHJvdG8ub25Xb3JrZXJNZXNzYWdlID0gZnVuY3Rpb24gb25Xb3JrZXJNZXNzYWdlKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLndvcmtlci5vYmplY3RVUkwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgIGlmIChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5sb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uY29uZmlndXJlVHJhbnNtdXhlciA9IGZ1bmN0aW9uIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2VyLFxuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdjb25maWd1cmUnLFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyLmNvbmZpZ3VyZShjb25maWcpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBoYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCkge1xuICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICB9O1xuICByZXR1cm4gVHJhbnNtdXhlckludGVyZmFjZTtcbn0oKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLXdvcmtlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90cmFuc211eGVyLXdvcmtlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVHJhbnNtdXhlcldvcmtlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90cmFuc211eGVyICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcblxuXG5cblxuXG5mdW5jdGlvbiBUcmFuc211eGVyV29ya2VyKHNlbGYpIHtcbiAgdmFyIG9ic2VydmVyID0gbmV3IGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudEVtaXR0ZXIoKTtcbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIGV2ZW50OiBldixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBmb3J3YXJkIGxvZ2dlciBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgdmFyIGZvcndhcmRXb3JrZXJMb2dzID0gZnVuY3Rpb24gZm9yd2FyZFdvcmtlckxvZ3MoKSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobG9nRm4pIHtcbiAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYyhtZXNzYWdlKSB7XG4gICAgICAgIGZvcndhcmRNZXNzYWdlKCd3b3JrZXJMb2cnLCB7XG4gICAgICAgICAgbG9nVHlwZTogbG9nRm4sXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyW2xvZ0ZuXSA9IGZ1bmM7XG4gICAgfTtcbiAgICBmb3IgKHZhciBsb2dGbiBpbiBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyKSB7XG4gICAgICBfbG9vcChsb2dGbik7XG4gICAgfVxuICB9O1xuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgZGF0YSA9IGV2LmRhdGE7XG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgICAgc2VsZi50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IsIGRhdGEuaWQpO1xuICAgICAgICAgICgwLF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5lbmFibGVMb2dzKShjb25maWcuZGVidWcsIGRhdGEuaWQpO1xuICAgICAgICAgIGZvcndhcmRXb3JrZXJMb2dzKCk7XG4gICAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnY29uZmlndXJlJzpcbiAgICAgICAge1xuICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5jb25maWd1cmUoZGF0YS5jb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHJhbnNtdXhSZXN1bHQgPSBzZWxmLnRyYW5zbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuY2h1bmtNZXRhLCBkYXRhLnN0YXRlKTtcbiAgICAgICAgICBpZiAoKDAsX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc1Byb21pc2UpKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgICAgc2VsZi50cmFuc211eGVyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgZm9yd2FyZE1lc3NhZ2UoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgICAgIGNodW5rTWV0YTogZGF0YS5jaHVua01ldGEsXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJ0cmFuc211eGVyLXdvcmtlciBwdXNoIGVycm9yXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi50cmFuc211eGVyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCB0cmFuc211eFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhLmNodW5rTWV0YTtcbiAgICAgICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0ID0gc2VsZi50cmFuc211eGVyLmZsdXNoKGlkKTtcbiAgICAgICAgICB2YXIgYXN5bmNGbHVzaCA9ICgwLF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNQcm9taXNlKShfdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgIGlmIChhc3luY0ZsdXNoIHx8IHNlbGYudHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICAgICAgaWYgKCEoMCxfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzUHJvbWlzZSkoX3RyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgICAgICBfdHJhbnNtdXhSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoX3RyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGlkKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZShfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICAgICAgY2h1bmtNZXRhOiBkYXRhLmNodW5rTWV0YSxcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInRyYW5zbXV4ZXItd29ya2VyIGZsdXNoIGVycm9yXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgX3RyYW5zbXV4UmVzdWx0LCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpIHtcbiAgaWYgKGlzRW1wdHlSZXN1bHQodHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgdmFyIF90cmFuc211eFJlc3VsdCRyZW11eCA9IHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0LFxuICAgIGF1ZGlvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LmF1ZGlvLFxuICAgIHZpZGVvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LnZpZGVvO1xuICBpZiAoYXVkaW8pIHtcbiAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIGF1ZGlvKTtcbiAgfVxuICBpZiAodmlkZW8pIHtcbiAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHZpZGVvKTtcbiAgfVxuICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgIGRhdGE6IHRyYW5zbXV4UmVzdWx0XG4gIH0sIHRyYW5zZmVyYWJsZSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBDb252ZXJ0cyBkYXRhIHRvIGEgdHJhbnNmZXJhYmxlIG9iamVjdCBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KVxuLy8gaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkXG5mdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHRyYWNrKSB7XG4gIGlmICh0cmFjay5kYXRhMSkge1xuICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGExLmJ1ZmZlcik7XG4gIH1cbiAgaWYgKHRyYWNrLmRhdGEyKSB7XG4gICAgdHJhbnNmZXJhYmxlLnB1c2godHJhY2suZGF0YTIuYnVmZmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgcmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gIHZhciBwYXJzZWQgPSByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCByZXN1bHQpIHtcbiAgICByZXR1cm4gZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgcmVzdWx0KSB8fCBwYXJzZWQ7XG4gIH0sIGZhbHNlKTtcbiAgaWYgKCFwYXJzZWQpIHtcbiAgICAvLyBFbWl0IGF0IGxlYXN0IG9uZSBcInRyYW5zbXV4Q29tcGxldGVcIiBtZXNzYWdlIGV2ZW4gaWYgbWVkaWEgaXMgbm90IGZvdW5kIHRvIHVwZGF0ZSBzdHJlYW0tY29udHJvbGxlciBzdGF0ZSB0byBQQVJTSU5HXG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgICAgZGF0YTogcmVzdWx0c1swXVxuICAgIH0pO1xuICB9XG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiAnZmx1c2gnLFxuICAgIGRhdGE6IGNodW5rTWV0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlSZXN1bHQocmVtdXhSZXN1bHQpIHtcbiAgcmV0dXJuICFyZW11eFJlc3VsdC5hdWRpbyAmJiAhcmVtdXhSZXN1bHQudmlkZW8gJiYgIXJlbXV4UmVzdWx0LnRleHQgJiYgIXJlbXV4UmVzdWx0LmlkMyAmJiAhcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90cmFuc211eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJUcmFuc211eENvbmZpZ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBUcmFuc211eENvbmZpZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiVHJhbnNtdXhTdGF0ZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBUcmFuc211eFN0YXRlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFRyYW5zbXV4ZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImlzUHJvbWlzZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc1Byb21pc2UpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfYWFjZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvYWFjZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2FhY2RlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X21wNGRlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L21wNGRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90c2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfbXAzZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvbXAzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L21wM2RlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9tcDQtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW11eF9wYXNzdGhyb3VnaF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIChlcnIpIHtcbiAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBzZWxmLkRhdGUubm93O1xufVxudmFyIG11eENvbmZpZyA9IFt7XG4gIGRlbXV4OiBfZGVtdXhfbXA0ZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9wYXNzdGhyb3VnaF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdXG59LCB7XG4gIGRlbXV4OiBfZGVtdXhfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLFxuICByZW11eDogX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdXG59LCB7XG4gIGRlbXV4OiBfZGVtdXhfYWFjZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXVxufSwge1xuICBkZW11eDogX2RlbXV4X21wM2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0sXG4gIHJlbXV4OiBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl1cbn1dO1xudmFyIFRyYW5zbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc211eGVyKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpIHtcbiAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMucHJvYmUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuICB2YXIgX3Byb3RvID0gVHJhbnNtdXhlci5wcm90b3R5cGU7XG4gIF9wcm90by5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgdmFyIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgIHRyYW5zbXV4Q29uZmlnID0gdGhpcy50cmFuc211eENvbmZpZztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgdmFyIF9yZWYgPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgIGNvbnRpZ3VvdXMgPSBfcmVmLmNvbnRpZ3VvdXMsXG4gICAgICBkaXNjb250aW51aXR5ID0gX3JlZi5kaXNjb250aW51aXR5LFxuICAgICAgdHJhY2tTd2l0Y2ggPSBfcmVmLnRyYWNrU3dpdGNoLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gX3JlZi5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0ID0gX3JlZi50aW1lT2Zmc2V0LFxuICAgICAgaW5pdFNlZ21lbnRDaGFuZ2UgPSBfcmVmLmluaXRTZWdtZW50Q2hhbmdlO1xuICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMgPSB0cmFuc211eENvbmZpZy52aWRlb0NvZGVjLFxuICAgICAgZGVmYXVsdEluaXRQdHMgPSB0cmFuc211eENvbmZpZy5kZWZhdWx0SW5pdFB0cyxcbiAgICAgIGR1cmF0aW9uID0gdHJhbnNtdXhDb25maWcuZHVyYXRpb24sXG4gICAgICBpbml0U2VnbWVudERhdGEgPSB0cmFuc211eENvbmZpZy5pbml0U2VnbWVudERhdGE7XG4gICAgdmFyIGtleURhdGEgPSBnZXRFbmNyeXB0aW9uVHlwZSh1aW50RGF0YSwgZGVjcnlwdGRhdGEpO1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmdldERlY3J5cHRlcigpO1xuICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpO1xuICAgICAgICAvLyBGb3IgTG93LUxhdGVuY3kgSExTIFBhcnRzLCBkZWNyeXB0IGluIHBsYWNlLCBzaW5jZSBwYXJ0IHBhcnNpbmcgaXMgZXhwZWN0ZWQgb24gcHVzaCBwcm9ncmVzc1xuICAgICAgICB2YXIgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIC8vIENhbGxpbmcgcHVzaCBoZXJlIGlzIGltcG9ydGFudDsgaWYgZmx1c2goKSBpcyBjYWxsZWQgd2hpbGUgdGhpcyBpcyBzdGlsbCByZXNvbHZpbmcsIHRoaXMgZW5zdXJlcyB0aGF0XG4gICAgICAgICAgLy8gdGhlIGRlY3J5cHRlZCBkYXRhIGhhcyBiZWVuIHRyYW5zbXV4ZWRcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpO1xuICAgICAgICAgIF90aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXNldE11eGVycyA9IHRoaXMubmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKTtcbiAgICBpZiAocmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSk7XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoIHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnRyYW5zbXV4KHVpbnREYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY3VycmVudFN0YXRlLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGN1cnJlbnRTdGF0ZS5kaXNjb250aW51aXR5ID0gZmFsc2U7XG4gICAgY3VycmVudFN0YXRlLnRyYWNrU3dpdGNoID0gZmFsc2U7XG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICA7XG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIsXG4gICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICBkZWNyeXB0aW9uUHJvbWlzZSA9IHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdHJhbnNtdXhSZXN1bHRzID0gW107XG4gICAgdmFyIHRpbWVPZmZzZXQgPSBjdXJyZW50VHJhbnNtdXhTdGF0ZS50aW1lT2Zmc2V0O1xuICAgIGlmIChkZWNyeXB0ZXIpIHtcbiAgICAgIC8vIFRoZSBkZWNyeXB0ZXIgbWF5IGhhdmUgZGF0YSBjYWNoZWQsIHdoaWNoIG5lZWRzIHRvIGJlIGRlbXV4ZWQuIEluIHRoaXMgY2FzZSB3ZSdsbCBoYXZlIHR3byBUcmFuc211eFJlc3VsdHNcbiAgICAgIC8vIFRoaXMgaGFwcGVucyBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlY2VpdmUgb25seSAxIHB1c2ggY2FsbCBmb3IgYSBzZWdtZW50IChlaXRoZXIgZm9yIG5vbi1wcm9ncmVzc2l2ZSBkb3dubG9hZHMsXG4gICAgICAvLyBvciBmb3IgcHJvZ3Jlc3NpdmUgZG93bmxvYWRzIHdpdGggc21hbGwgc2VnbWVudHMpXG4gICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaCh0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCB0aGVuIEhscy5qcyBoYXMgYmVlbiBnaXZlbiBjb250ZW50IGl0cyBub3QgYWJsZSB0byBoYW5kbGVcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCdcbiAgICAgIH0pO1xuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICB9XG4gICAgdmFyIGRlbXV4UmVzdWx0T3JQcm9taXNlID0gZGVtdXhlci5mbHVzaCh0aW1lT2Zmc2V0KTtcbiAgICBpZiAoaXNQcm9taXNlKGRlbXV4UmVzdWx0T3JQcm9taXNlKSkge1xuICAgICAgLy8gRGVjcnlwdCBmaW5hbCBTQU1QTEUtQUVTIHNhbXBsZXNcbiAgICAgIHJldHVybiBkZW11eFJlc3VsdE9yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkZW11eFJlc3VsdCkge1xuICAgICAgICBfdGhpczIuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH07XG4gIF9wcm90by5mbHVzaFJlbXV4ID0gZnVuY3Rpb24gZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrID0gZGVtdXhSZXN1bHQudmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2sgPSBkZW11eFJlc3VsdC50ZXh0VHJhY2s7XG4gICAgdmFyIF90aGlzJGN1cnJlbnRUcmFuc211eCA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBfdGhpcyRjdXJyZW50VHJhbnNtdXguYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdGltZU9mZnNldCA9IF90aGlzJGN1cnJlbnRUcmFuc211eC50aW1lT2Zmc2V0O1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwiW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgKGNodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHA6ICcgKyBjaHVua01ldGEucGFydCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgY2h1bmtNZXRhLmxldmVsKTtcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cnVlLCB0aGlzLmlkKTtcbiAgICB0cmFuc211eFJlc3VsdHMucHVzaCh7XG4gICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgIH0pO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gIH07XG4gIF9wcm90by5yZXNldEluaXRpYWxUaW1lc3RhbXAgPSBmdW5jdGlvbiByZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9O1xuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICByZW11eGVyLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICB9O1xuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uLCBkZWNyeXB0ZGF0YSkge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICB9O1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIF9wcm90by50cmFuc211eCA9IGZ1bmN0aW9uIHRyYW5zbXV4KGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoa2V5RGF0YSAmJiBrZXlEYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFVuZW5jcnlwdGVkKGRhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgX3Byb3RvLnRyYW5zbXV4VW5lbmNyeXB0ZWQgPSBmdW5jdGlvbiB0cmFuc211eFVuZW5jcnlwdGVkKGRhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF9kZW11eCA9IHRoaXMuZGVtdXhlci5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSxcbiAgICAgIGF1ZGlvVHJhY2sgPSBfZGVtdXguYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2sgPSBfZGVtdXgudmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrID0gX2RlbXV4LmlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrID0gX2RlbXV4LnRleHRUcmFjaztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbXV4UmVzdWx0OiByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLnRyYW5zbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZGVtdXhlci5kZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCkudGhlbihmdW5jdGlvbiAoZGVtdXhSZXN1bHQpIHtcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IF90aGlzMy5yZW11eGVyLnJlbXV4KGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssIGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssIGRlbXV4UmVzdWx0LmlkM1RyYWNrLCBkZW11eFJlc3VsdC50ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIF90aGlzMy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uY29uZmlndXJlVHJhbnNtdXhlciA9IGZ1bmN0aW9uIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcbiAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICB2ZW5kb3IgPSB0aGlzLnZlbmRvcjtcbiAgICAvLyBwcm9iZSBmb3IgY29udGVudCB0eXBlXG4gICAgdmFyIG11eDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXV4Q29uZmlnLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobXV4Q29uZmlnW2ldLmRlbXV4LnByb2JlKGRhdGEpKSB7XG4gICAgICAgIG11eCA9IG11eENvbmZpZ1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbXV4KSB7XG4gICAgICAvLyBJZiBwcm9iaW5nIHByZXZpb3VzIGNvbmZpZ3MgZmFpbCwgdXNlIG1wNCBwYXNzdGhyb3VnaFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmxvZ2dlci53YXJuKCdGYWlsZWQgdG8gZmluZCBkZW11eGVyIGJ5IHByb2JpbmcgZnJhZywgdHJlYXRpbmcgYXMgbXA0IHBhc3N0aHJvdWdoJyk7XG4gICAgICBtdXggPSB7XG4gICAgICAgIGRlbXV4OiBfZGVtdXhfbXA0ZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgcmVtdXg6IF9yZW11eF9wYXNzdGhyb3VnaF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICB2YXIgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICB2YXIgUmVtdXhlciA9IG11eC5yZW11eDtcbiAgICB2YXIgRGVtdXhlciA9IG11eC5kZW11eDtcbiAgICBpZiAoIXJlbXV4ZXIgfHwgIShyZW11eGVyIGluc3RhbmNlb2YgUmVtdXhlcikpIHtcbiAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcik7XG4gICAgfVxuICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICB0aGlzLnByb2JlID0gRGVtdXhlci5wcm9iZTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5uZWVkc1Byb2JpbmcgPSBmdW5jdGlvbiBuZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgIHJldHVybiAhdGhpcy5kZW11eGVyIHx8ICF0aGlzLnJlbXV4ZXIgfHwgZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaDtcbiAgfTtcbiAgX3Byb3RvLmdldERlY3J5cHRlciA9IGZ1bmN0aW9uIGdldERlY3J5cHRlcigpIHtcbiAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5jb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGVyO1xuICB9O1xuICByZXR1cm4gVHJhbnNtdXhlcjtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgdmFyIGVuY3J5cHRpb25UeXBlID0gbnVsbDtcbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5rZXkgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5pdiAhPT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5tZXRob2QgIT0gbnVsbCkge1xuICAgIGVuY3J5cHRpb25UeXBlID0gZGVjcnlwdERhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY3J5cHRpb25UeXBlO1xufVxudmFyIGVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKSB7XG4gIHJldHVybiB7XG4gICAgcmVtdXhSZXN1bHQ6IHt9LFxuICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gIH07XG59O1xuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuICd0aGVuJyBpbiBwICYmIHAudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxudmFyIFRyYW5zbXV4Q29uZmlnID0gZnVuY3Rpb24gVHJhbnNtdXhDb25maWcoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQdHMpIHtcbiAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gdm9pZCAwO1xuICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICB0aGlzLmRlZmF1bHRJbml0UHRzID0gdm9pZCAwO1xuICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IGluaXRTZWdtZW50RGF0YTtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB0aGlzLmRlZmF1bHRJbml0UHRzID0gZGVmYXVsdEluaXRQdHM7XG59O1xudmFyIFRyYW5zbXV4U3RhdGUgPSBmdW5jdGlvbiBUcmFuc211eFN0YXRlKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gIHRoaXMuZGlzY29udGludWl0eSA9IHZvaWQgMDtcbiAgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwO1xuICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IHZvaWQgMDtcbiAgdGhpcy50cmFja1N3aXRjaCA9IHZvaWQgMDtcbiAgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwO1xuICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gdm9pZCAwO1xuICB0aGlzLmRpc2NvbnRpbnVpdHkgPSBkaXNjb250aW51aXR5O1xuICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgdGhpcy50cmFja1N3aXRjaCA9IHRyYWNrU3dpdGNoO1xuICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gaW5pdFNlZ21lbnRDaGFuZ2U7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC90c2RlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RzZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkdHMgKi8gXCIuL3NyYy9kZW11eC9hZHRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9leHBfZ29sb21iX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4cC1nb2xvbWIgKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zYW1wbGVfYWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NhbXBsZS1hZXMgKi8gXCIuL3NyYy9kZW11eC9zYW1wbGUtYWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvZGVtdXhlciAqLyBcIi4vc3JjL3R5cGVzL2RlbXV4ZXIudHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFBBQ0tFVF9MRU5HVEggPSAxODg7XG52YXIgVFNEZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVFNEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gIH1cbiAgVFNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIHZhciBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSk7XG4gICAgaWYgKHN5bmNPZmZzZXQgPiAwKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLndhcm4oXCJNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0IFwiICsgc3luY09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBzeW5jT2Zmc2V0ICE9PSAtMTtcbiAgfTtcbiAgVFNEZW11eGVyLnN5bmNPZmZzZXQgPSBmdW5jdGlvbiBzeW5jT2Zmc2V0KGRhdGEpIHtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIHNjYW53aW5kb3cgPSBNYXRoLm1pbihQQUNLRVRfTEVOR1RIICogNSwgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgLy8gYSBUUyBpbml0IHNlZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMiBUUyBwYWNrZXRzOiBQQVQgYW5kIFBNVCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIHZhciBmb3VuZFBhdCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBsZW5ndGg7IGogKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICBpZiAoZGF0YVtqXSA9PT0gMHg0Nykge1xuICAgICAgICAgIGlmICghZm91bmRQYXQgJiYgcGFyc2VQSUQoZGF0YSwgaikgPT09IDApIHtcbiAgICAgICAgICAgIGZvdW5kUGF0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kUGF0ICYmIGogKyBQQUNLRVRfTEVOR1RIID4gc2NhbndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB0eXBlICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCdcbiAgICogQHBhcmFtIGR1cmF0aW9uXG4gICAqIEByZXR1cm4gVFNEZW11eGVyJ3MgaW50ZXJuYWwgdHJhY2sgbW9kZWxcbiAgICovO1xuICBUU0RlbXV4ZXIuY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayh0eXBlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovO1xuICB2YXIgX3Byb3RvID0gVFNEZW11eGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0Jyk7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9O1xuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge1xuICAgIHZhciBfYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICBfYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgIF9pZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGlmIChfYXVkaW9UcmFjaykge1xuICAgICAgX2F1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfYXZjVHJhY2spIHtcbiAgICAgIF9hdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgX2lkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMsIGZsdXNoKSB7XG4gICAgaWYgKGlzU2FtcGxlQWVzID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2FtcGxlQWVzID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmbHVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICBmbHVzaCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBwZXM7XG4gICAgdmFyIHZpZGVvVHJhY2sgPSB0aGlzLl9hdmNUcmFjaztcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgdmFyIHRleHRUcmFjayA9IHRoaXMuX3R4dFRyYWNrO1xuICAgIHZhciBhdmNJZCA9IHZpZGVvVHJhY2sucGlkO1xuICAgIHZhciBhdmNEYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIHZhciBhdWRpb0lkID0gYXVkaW9UcmFjay5waWQ7XG4gICAgdmFyIGlkM0lkID0gaWQzVHJhY2sucGlkO1xuICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIHZhciB1bmtub3duUElEID0gbnVsbDtcbiAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQ7XG4gICAgdmFyIHBtdElkID0gdGhpcy5fcG10SWQ7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSAoMCxfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uYXBwZW5kVWludDhBcnJheSkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2s6IGlkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRleHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN5bmNPZmZzZXQgPSBNYXRoLm1heCgwLCBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKSk7XG4gICAgbGVuIC09IChsZW4gLSBzeW5jT2Zmc2V0KSAlIFBBQ0tFVF9MRU5HVEg7XG4gICAgaWYgKGxlbiA8IGRhdGEuYnl0ZUxlbmd0aCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBsZW4sIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW4pO1xuICAgIH1cblxuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgdmFyIHRzUGFja2V0RXJyb3JzID0gMDtcbiAgICBmb3IgKHZhciBzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcbiAgICAgICAgdmFyIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICB2YXIgcGlkID0gcGFyc2VQSUQoZGF0YSwgc3RhcnQpO1xuICAgICAgICB2YXIgYXRmID0gKGRhdGFbc3RhcnQgKyAzXSAmIDB4MzApID4+IDQ7XG5cbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIHZhciBvZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBpZCkge1xuICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXZjRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKTtcblxuICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG4gICAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG4gICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IGF2Y0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRDb2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5sb2dnZXIud2FybihcIk1QRUctVFMgUE1UIGZvdW5kIGF0IFwiICsgc3RhcnQgKyBcIiBhZnRlciB1bmtub3duIFBJRCAnXCIgKyB1bmtub3duUElEICsgXCInLiBCYWNrdHJhY2tpbmcgdG8gc3luYyBieXRlIEBcIiArIHN5bmNPZmZzZXQgKyBcIiB0byBwYXJzZSBhbGwgVFMgcGFja2V0cy5cIik7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEID0gcGlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXZlbnRzLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICByZWFzb246IFwiRm91bmQgXCIgKyB0c1BhY2tldEVycm9ycyArIFwiIFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlkZW9UcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgdmFyIGRlbXV4UmVzdWx0ID0ge1xuICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IHRleHRUcmFja1xuICAgIH07XG4gICAgaWYgKGZsdXNoKSB7XG4gICAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICB9O1xuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZGVtdXgocmVtYWluZGVyRGF0YSwgLTEsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB2aWRlb1RyYWNrOiB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHJlc3VsdCwgdGhpcy5zYW1wbGVBZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfcHJvdG8uZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMgPSBmdW5jdGlvbiBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgIHZhciBhdWRpb1RyYWNrID0gZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2sgPSBkZW11eFJlc3VsdC52aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2sgPSBkZW11eFJlc3VsdC5pZDNUcmFjayxcbiAgICAgIHRleHRUcmFjayA9IGRlbXV4UmVzdWx0LnRleHRUcmFjaztcbiAgICB2YXIgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIHZhciBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIHZhciBwZXM7XG4gICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgdGhpcy5wYXJzZUFWQ1BFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgdHJ1ZSk7XG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIH1cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YSAhPT0gbnVsbCAmJiBhdWRpb0RhdGEgIT09IHZvaWQgMCAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICB9XG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5kZW11eFNhbXBsZUFlcyA9IGZ1bmN0aW9uIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgdmFyIHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IF9zYW1wbGVfYWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9O1xuICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSBkZW11eFJlc3VsdC5hdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrID0gZGVtdXhSZXN1bHQudmlkZW9UcmFjaztcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9O1xuICBfcHJvdG8ucGFyc2VBVkNQRVMgPSBmdW5jdGlvbiBwYXJzZUFWQ1BFUyh0cmFjaywgdGV4dFRyYWNrLCBwZXMsIGxhc3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciB1bml0cyA9IHRoaXMucGFyc2VBVkNOQUx1KHRyYWNrLCBwZXMuZGF0YSk7XG4gICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIHZhciBwdXNoO1xuICAgIHZhciBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKGF2Y1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgfVxuICAgIHVuaXRzLmZvckVhY2goZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgIC8vIE5EUlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgdmFyIHNsaWNlVHlwZSA9IG5ldyBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXShkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IF90aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5wYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSkodW5pdC5kYXRhLCAxLCBwZXMucHRzLCB0ZXh0VHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFNQU1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHJhY2suc3BzKSB7XG4gICAgICAgICAgICB2YXIgZXhwR29sb21iRGVjb2RlciA9IG5ldyBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSh1bml0LmRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgLy8gVE9ETzogYHRyYWNrLnNwc2AgaXMgZGVmaW5lZCBhcyBhIGBudW1iZXJbXWAsIGJ1dCB3ZSdyZSBzZXR0aW5nIGl0IHRvIGEgYFVpbnQ4QXJyYXlbXWAuXG4gICAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gX3RoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUFBTXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgLy8gVE9ETzogYHRyYWNrLnBzc2AgaXMgZGVmaW5lZCBhcyBhIGBudW1iZXJbXWAsIGJ1dCB3ZSdyZSBzZXR0aW5nIGl0IHRvIGEgYFVpbnQ4QXJyYXlbXWAuXG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICB2YXIgX3VuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICBfdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0TGFzdE5hbFVuaXQgPSBmdW5jdGlvbiBnZXRMYXN0TmFsVW5pdChzYW1wbGVzKSB7XG4gICAgdmFyIF9hdmNTYW1wbGU7XG4gICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIHZhciBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoKF9hdmNTYW1wbGUgPSBhdmNTYW1wbGUpICE9PSBudWxsICYmIF9hdmNTYW1wbGUgIT09IHZvaWQgMCAmJiBfYXZjU2FtcGxlLnVuaXRzKSB7XG4gICAgICB2YXIgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFVuaXQ7XG4gIH07XG4gIF9wcm90by5wYXJzZUFWQ05BTHUgPSBmdW5jdGlvbiBwYXJzZUFWQ05BTHUodHJhY2ssIGFycmF5KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgdmFyIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgdmFyIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIHZhciB1bml0cyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciB1bml0VHlwZTtcbiAgICB2YXIgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIHZhciBsYXN0VW5pdFR5cGUgPSAwO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLFxuICAgICAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIHZhciBsYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgb3ZlcmZsb3cgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIHZhciBfdW5pdCA9IHtcbiAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICB1bml0cy5wdXNoKF91bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgdmFyIF9sYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICBpZiAoX2xhc3RVbml0KSB7XG4gICAgICAgIHZhciBfdG1wID0gbmV3IFVpbnQ4QXJyYXkoX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICBfdG1wLnNldChfbGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgIF90bXAuc2V0KGFycmF5LCBfbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgX2xhc3RVbml0LmRhdGEgPSBfdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH07XG4gIF9wcm90by5wYXJzZUFBQ1BFUyA9IGZ1bmN0aW9uIHBhcnNlQUFDUEVTKHRyYWNrLCBwZXMpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAwO1xuICAgIHZhciBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3c7XG4gICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgdmFyIGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIHZhciBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHtzYW1wbGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBpZiAoZnJhbWVNaXNzaW5nQnl0ZXMgPT09IC0xKSB7XG4gICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShzYW1wbGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGFhY092ZXJGbG93LnNhbXBsZS51bml0LCAwKTtcbiAgICAgICAgdG1wLnNldChkYXRhLCBzYW1wbGVMZW5ndGgpO1xuICAgICAgICBkYXRhID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZyYW1lT3ZlcmZsb3dCeXRlcyA9IHNhbXBsZUxlbmd0aCAtIGZyYW1lTWlzc2luZ0J5dGVzO1xuICAgICAgICBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5zZXQoZGF0YS5zdWJhcnJheSgwLCBmcmFtZU1pc3NpbmdCeXRlcyksIGZyYW1lT3ZlcmZsb3dCeXRlcyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpO1xuICAgICAgICBzdGFydE9mZnNldCA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgbGVuO1xuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgdmFyIHJlYXNvbjtcbiAgICAgIHZhciBmYXRhbDtcbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IFwiQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OlwiICsgb2Zmc2V0O1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLndhcm4oXCJwYXJzaW5nIGVycm9yOlwiICsgcmVhc29uKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXZlbnRzLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgIHZhciBwdHM7XG4gICAgaWYgKHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHRzID0gcGVzLnB0cztcbiAgICB9IGVsc2UgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucGFyc2VNUEVHUEVTID0gZnVuY3Rpb24gcGFyc2VNUEVHUEVTKHRyYWNrLCBwZXMpIHtcbiAgICB2YXIgZGF0YSA9IHBlcy5kYXRhO1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgaWYgKHB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5wYXJzZUlEM1BFUyA9IGZ1bmN0aW9uIHBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpIHtcbiAgICBpZiAocGVzLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZDNTYW1wbGUgPSBfZXh0ZW5kcyh7fSwgcGVzLCB7XG4gICAgICB0eXBlOiB0aGlzLl9hdmNUcmFjayA/IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uTWV0YWRhdGFTY2hlbWEuZW1zZyA6IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfSk7XG4gICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKGlkM1NhbXBsZSk7XG4gIH07XG4gIHJldHVybiBUU0RlbXV4ZXI7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVBVkNTYW1wbGUoa2V5LCBwdHMsIGR0cywgZGVidWcpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBmcmFtZTogZmFsc2UsXG4gICAgcHRzOiBwdHMsXG4gICAgZHRzOiBkdHMsXG4gICAgdW5pdHM6IFtdLFxuICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICBsZW5ndGg6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUElEKGRhdGEsIG9mZnNldCkge1xuICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG59XG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xufVxuZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIGF1ZGlvOiAtMSxcbiAgICBhdmM6IC0xLFxuICAgIGlkMzogLTEsXG4gICAgc2VnbWVudENvZGVjOiAnYWFjJ1xuICB9O1xuICB2YXIgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gIHZhciB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gIHZhciBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgdmFyIHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5sb2dnZXIubG9nKCdBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5sb2dnZXIubG9nKCdILjI2NCB3aXRoIEFFUy0xMjgtQ0JDIHNsaWNlIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnICE9PSB0cnVlICYmIHR5cGVTdXBwb3J0ZWQubXAzICE9PSB0cnVlKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudENvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5sb2dnZXIud2FybignVW5zdXBwb3J0ZWQgSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ3Vua25vd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVBFUyhzdHJlYW0pIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZnJhZztcbiAgdmFyIHBlc0xlbjtcbiAgdmFyIHBlc0hkckxlbjtcbiAgdmFyIHBlc1B0cztcbiAgdmFyIHBlc0R0cztcbiAgdmFyIGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgLy8gc2FmZXR5IGNoZWNrXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMV0sIGRhdGFbMF0ubGVuZ3RoKTtcbiAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgfVxuICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgZnJhZyA9IGRhdGFbMF07XG4gIHZhciBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG4gIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgIC8vIDEgPDwgMjlcbiAgICAgIChmcmFnWzEwXSAmIDB4ZmYpICogNDE5NDMwNCArXG4gICAgICAvLyAxIDw8IDIyXG4gICAgICAoZnJhZ1sxMV0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgIC8vIDEgPDwgMTRcbiAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICtcbiAgICAgIC8vIDEgPDwgN1xuICAgICAgKGZyYWdbMTNdICYgMHhmZSkgLyAyO1xuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAgIC8vIDEgPDwgMjlcbiAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgICAgLy8gMSA8PCAyMlxuICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgICAgLy8gMSA8PCAxNFxuICAgICAgICAoZnJhZ1sxN10gJiAweGZmKSAqIDEyOCArXG4gICAgICAgIC8vIDEgPDwgN1xuICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmxvZ2dlci53YXJuKE1hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCkgKyBcInMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbVwiKTtcbiAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICB2YXIgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcbiAgICBpZiAoc3RyZWFtLnNpemUgPD0gcGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgIHZhciBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgIGZvciAodmFyIGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgdmFyIGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgIGkgKz0gbGVuO1xuICAgIH1cbiAgICBpZiAocGVzTGVuKSB7XG4gICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcGVzRGF0YSxcbiAgICAgIHB0czogcGVzUHRzLFxuICAgICAgZHRzOiBwZXNEdHMsXG4gICAgICBsZW46IHBlc0xlblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIGF2Y1RyYWNrKSB7XG4gIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgIC8vIGlmIHNhbXBsZSBkb2VzIG5vdCBoYXZlIFBUUy9EVFMsIHBhdGNoIHdpdGggbGFzdCBzYW1wbGUgUFRTL0RUU1xuICAgIGlmIChhdmNTYW1wbGUucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBzYW1wbGVzW25iU2FtcGxlcyAtIDFdO1xuICAgICAgICBhdmNTYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgIGF2Y1NhbXBsZS5kdHMgPSBsYXN0U2FtcGxlLmR0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyb3BwaW5nIHNhbXBsZXMsIG5vIHRpbWVzdGFtcCBmb3VuZFxuICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgYXZjVHJhY2suc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gIH1cbiAgaWYgKGF2Y1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18ubG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gIH1cbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoVFNEZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvd2Vid29ya2lmeS13ZWJwYWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC93ZWJ3b3JraWZ5LXdlYnBhY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogZXhwb3J0IGRlZmF1bHQgYmluZGluZyAqLyBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLypcbiAqIEZvcmsgb2Ygd2Vid29ya2lmeS13ZWJwYWNrIHdpdGggc3VwcG9ydCBmb3IgV2VicGFjayA1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vd3VwZW5nLWVuZ2luZWVyL3dlYndvcmtpZnktd2VicGFjay9ibG9iL2RiMGRlNy9pbmRleC5qc1xuKi9cblxudmFyIHdlYnBhY2tCb290c3RyYXBGdW5jID0gZnVuY3Rpb24gd2VicGFja0Jvb3RzdHJhcEZ1bmMoKSB7XG4gIC8vIHdlYnBhY2tCb290c3RyYXBcbiAgLyoqKioqKi9cbiAgdmFyIF9fd2VicGFja19tb2R1bGVzX18gPSBFTlRSWV9NT0RVTEU7XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbiAgLyoqKioqKi9cbiAgdmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuICAvKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAvKioqKioqL1xuICB2YXIgX19uZXN0ZWRfd2VicGFja19yZXF1aXJlXzQ5N19fID0gZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgIC8qKioqKiovIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuICAgIC8qKioqKiovdmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4gICAgLyoqKioqKi9cbiAgICBpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKioqKiovcmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi8gLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiAgICAvKioqKioqL1xuICAgIHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuICAgICAgLyoqKioqKi8gLy8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuICAgICAgLyoqKioqKi8gLy8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gIC8qKioqKiovXG4gIF9fbmVzdGVkX3dlYnBhY2tfcmVxdWlyZV80OTdfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcbiAgLyoqKioqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbiAgLyoqKioqKi9cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqLyAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuICAgIC8qKioqKiovX19uZXN0ZWRfd2VicGFja19yZXF1aXJlXzQ5N19fLm4gPSBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAvKioqKioqL3ZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyAvKioqKioqL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddO1xuICAgICAgfSA6IC8qKioqKiovZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgfTtcbiAgICAgIC8qKioqKiovXG4gICAgICBfX25lc3RlZF93ZWJwYWNrX3JlcXVpcmVfNDk3X18uZChnZXR0ZXIsIHtcbiAgICAgICAgYTogZ2V0dGVyXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgICByZXR1cm4gZ2V0dGVyO1xuICAgICAgLyoqKioqKi9cbiAgICB9O1xuICAgIC8qKioqKiovXG4gIH0pKCk7XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuICAvKioqKioqL1xuICAoZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKiovIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbiAgICAvKioqKioqL19fbmVzdGVkX3dlYnBhY2tfcmVxdWlyZV80OTdfXy5kID0gZnVuY3Rpb24gKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbiAgICAgIC8qKioqKiovZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgICAgLyoqKioqKi9pZiAoX19uZXN0ZWRfd2VicGFja19yZXF1aXJlXzQ5N19fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX19uZXN0ZWRfd2VicGFja19yZXF1aXJlXzQ5N19fLm8oZXhwb3J0cywga2V5KSkge1xuICAgICAgICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZGVmaW5pdGlvbltrZXldXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfVxuICAgICAgICAvKioqKioqL1xuICAgICAgfVxuICAgICAgLyoqKioqKi9cbiAgICB9O1xuICAgIC8qKioqKiovXG4gIH0pKCk7XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbiAgLyoqKioqKi9cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqL19fbmVzdGVkX3dlYnBhY2tfcmVxdWlyZV80OTdfXy5vID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgIH07XG4gICAgLyoqKioqKi9cbiAgfSkoKTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuICAvKioqKioqL1xuICAoZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiAgICAvKioqKioqL19fbmVzdGVkX3dlYnBhY2tfcmVxdWlyZV80OTdfXy5yID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAgIC8qKioqKiovaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgICAgICAvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICB2YWx1ZTogJ01vZHVsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKioqKiovXG4gICAgICB9XG4gICAgICAvKioqKioqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvKioqKioqL1xuICAgIH07XG4gICAgLyoqKioqKi9cbiAgfSkoKTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gbW9kdWxlIGZhY3RvcmllcyBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuICAvKioqKioqLyAvLyBzdGFydHVwXG4gIC8qKioqKiovIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuICAvKioqKioqL1xuICB2YXIgcmVzdWx0ID0gX19uZXN0ZWRfd2VicGFja19yZXF1aXJlXzQ5N19fKEVOVFJZX01PRFVMRSk7XG4gIC8qKioqKiovXG4gIHJldHVybiByZXN1bHQuZGVmYXVsdCB8fCByZXN1bHQ7XG59O1xudmFyIHdlYnBhY2tCb290c3RyYXBGdW5jQXJyID0gd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5zcGxpdCgnRU5UUllfTU9EVUxFJyk7XG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8XFwvfEBdKyc7XG52YXIgZGVwZW5kZW5jeVJlZ0V4cCA9ICdcXFxcKFxcXFxzKihcXC9cXFxcKi4qP1xcXFwqXFwvKT9cXFxccyouKj8oJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKS4qP1xcXFwpJztcbmZ1bmN0aW9uIHF1b3RlUmVnRXhwKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiAhaXNOYU4oMSAqIG4pO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIG1vZHVsZSwgcXVldWVOYW1lKSB7XG4gIHZhciByZXR2YWwgPSB7fTtcbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXTtcbiAgdmFyIGZuU3RyaW5nID0gbW9kdWxlLnRvU3RyaW5nKCkucmVwbGFjZSgvXlwiW15cIl0rXCIvLCAnZnVuY3Rpb24nKTtcbiAgO1xuICB2YXIgd3JhcHBlclNpZ25hdHVyZSA9IGZuU3RyaW5nLm1hdGNoKC9eZnVuY3Rpb25cXHM/XFx3KlxcKFxcdyssXFxzKlxcdyssXFxzKihcXHcrKVxcKS8pIHx8IGZuU3RyaW5nLm1hdGNoKC9eXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpXFxzP1xcPVxccz9cXD4vKTtcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsO1xuICB2YXIgd2VicGFja1JlcXVpcmVOYW1lID0gd3JhcHBlclNpZ25hdHVyZVsxXTtcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKFxcXFxcXFxcbnxcXFxcVyknICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArIGRlcGVuZGVuY3lSZWdFeHAsICdnJyk7XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpIHtcbiAgICBpZiAobWF0Y2hbM10gPT09ICdkbGwtcmVmZXJlbmNlJykgY29udGludWU7XG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSk7XG4gIH1cbiAgcmUgPSBuZXcgUmVnRXhwKCdcXFxcKCcgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgJ1xcXFwoXCIoZGxsLXJlZmVyZW5jZVxcXFxzKCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykpXCJcXFxcKVxcXFwpJyArIGRlcGVuZGVuY3lSZWdFeHAsICdnJyk7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSB7XG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSk7XG4gICAgICBzb3VyY2VzW21hdGNoWzJdXSA9IF9fd2VicGFja19yZXF1aXJlX18obWF0Y2hbMV0pLm07XG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdO1xuICAgIHJldHZhbFttYXRjaFsyXV0ucHVzaChtYXRjaFs0XSk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXR2YWw7XG59XG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyhxdWV1ZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhxdWV1ZXMpO1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwO1xuICB9LCBmYWxzZSk7XG59XG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpIHtcbiAgdmFyIG1vZHVsZXNRdWV1ZSA9IHtcbiAgICBtYWluOiBbbW9kdWxlSWRdXG4gIH07XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfTtcbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xuICAgIG1haW46IHt9XG4gIH07XG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV07XG4gICAgICB2YXIgcXVldWUgPSBtb2R1bGVzUXVldWVbcXVldWVOYW1lXTtcbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKCk7XG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fTtcbiAgICAgIGlmIChzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdIHx8ICFzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10pIGNvbnRpbnVlO1xuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWU7XG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdO1xuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0ucHVzaChtb2R1bGVUb0NoZWNrKTtcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKTtcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdNb2R1bGVzS2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSB8fCBbXTtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcXVpcmVkTW9kdWxlcztcbn1cbmZ1bmN0aW9uIGdldFdlYnBhY2tTdHJpbmcocmVxdWlyZWRNb2R1bGVzLCBzb3VyY2VzLCBlbnRyeU1vZHVsZSwga2V5KSB7XG4gIHZhciBtb2R1bGVTdHJpbmcgPSByZXF1aXJlZE1vZHVsZXNba2V5XS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiICsgaWQgKyBcIlxcXCI6IFwiICsgc291cmNlc1trZXldW2lkXS50b1N0cmluZygpLnJlcGxhY2UoL15cIlteXCJdK1wiLywgJ2Z1bmN0aW9uJyk7XG4gIH0pLmpvaW4oXCIsXCIpO1xuICByZXR1cm4gd2VicGFja0Jvb3RzdHJhcEZ1bmNBcnJbMF0gKyBcIntcIiArIG1vZHVsZVN0cmluZyArIFwifVwiICsgd2VicGFja0Jvb3RzdHJhcEZ1bmNBcnJbMV0gKyBcIlxcXCJcIiArIGVudHJ5TW9kdWxlICsgXCJcXFwiXCIgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuY0FyclsyXTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gZnVuY3Rpb24gX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18obW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzb3VyY2VzID0ge1xuICAgIG1haW46IF9fd2VicGFja19yZXF1aXJlX18ubVxuICB9O1xuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0gb3B0aW9ucy5hbGwgPyB7XG4gICAgbWFpbjogT2JqZWN0LmtleXMoc291cmNlcy5tYWluKVxuICB9IDogZ2V0UmVxdWlyZWRNb2R1bGVzKHNvdXJjZXMsIG1vZHVsZUlkKTtcbiAgdmFyIHNyYyA9ICcnO1xuICBPYmplY3Qua2V5cyhyZXF1aXJlZE1vZHVsZXMpLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBtICE9PSAnbWFpbic7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBlbnRyeU1vZHVsZSA9IDA7XG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrKztcbiAgICB9XG4gICAgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ucHVzaChlbnRyeU1vZHVsZSk7XG4gICAgc291cmNlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSA9ICcoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSknO1xuICAgIHNyYyA9IHNyYyArIChcInZhciBcIiArIG1vZHVsZSArIFwiID0gKFwiICsgZ2V0V2VicGFja1N0cmluZyhyZXF1aXJlZE1vZHVsZXMsIHNvdXJjZXMsIGVudHJ5TW9kdWxlLCBtb2R1bGVzKSArIFwiKSgpO1xcblwiKTtcbiAgfSk7XG4gIHNyYyA9IHNyYyArIChcIm5ldyAoKFwiICsgZ2V0V2VicGFja1N0cmluZyhyZXF1aXJlZE1vZHVsZXMsIHNvdXJjZXMsIG1vZHVsZUlkLCAnbWFpbicpICsgXCIpKCkpKHNlbGYpO1wiKTtcbiAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3NyY10sIHtcbiAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICB9KTtcbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIHZhciB3b3JrZXIgPSBuZXcgd2luZG93Lldvcmtlcih3b3JrZXJVcmwpO1xuICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICByZXR1cm4gd29ya2VyO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lcnJvcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Vycm9ycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJFcnJvckRldGFpbHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRXJyb3JEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJFcnJvclR5cGVzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEVycm9yVHlwZXMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbnZhciBFcnJvclR5cGVzO1xuXG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG4oZnVuY3Rpb24gKEVycm9yVHlwZXMpIHtcbiAgRXJyb3JUeXBlc1tcIk5FVFdPUktfRVJST1JcIl0gPSBcIm5ldHdvcmtFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiTUVESUFfRVJST1JcIl0gPSBcIm1lZGlhRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIktFWV9TWVNURU1fRVJST1JcIl0gPSBcImtleVN5c3RlbUVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNVVhfRVJST1JcIl0gPSBcIm11eEVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJPVEhFUl9FUlJPUlwiXSA9IFwib3RoZXJFcnJvclwiO1xufSkoRXJyb3JUeXBlcyB8fCAoRXJyb3JUeXBlcyA9IHt9KSk7XG52YXIgRXJyb3JEZXRhaWxzO1xuKGZ1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFXCJdID0gXCJrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2Vzc2lvblVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRFwiXSA9IFwia2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUlwiXSA9IFwia2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX0VSUk9SXCJdID0gXCJtYW5pZmVzdExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX1RJTUVPVVRcIl0gPSBcIm1hbmlmZXN0TG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfVElNRU9VVFwiXSA9IFwibGV2ZWxMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9TV0lUQ0hfRVJST1JcIl0gPSBcImxldmVsU3dpdGNoRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUlwiXSA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfREVDUllQVF9FUlJPUlwiXSA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX1BBUlNJTkdfRVJST1JcIl0gPSBcImZyYWdQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9FUlJPUlwiXSA9IFwia2V5TG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX1RJTUVPVVRcIl0gPSBcImtleUxvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BRERfQ09ERUNfRVJST1JcIl0gPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcImJ1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xufSkoRXJyb3JEZXRhaWxzIHx8IChFcnJvckRldGFpbHMgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9ldmVudHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2V2ZW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJFdmVudHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRXZlbnRzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEV2ZW50cztcbihmdW5jdGlvbiAoRXZlbnRzKSB7XG4gIEV2ZW50c1tcIk1FRElBX0FUVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFBdHRhY2hpbmdcIjtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNIRURcIl0gPSBcImhsc01lZGlhQXR0YWNoZWRcIjtcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNISU5HXCJdID0gXCJobHNNZWRpYURldGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFEZXRhY2hlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfUkVTRVRcIl0gPSBcImhsc0J1ZmZlclJlc2V0XCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DT0RFQ1NcIl0gPSBcImhsc0J1ZmZlckNvZGVjc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQ1JFQVRFRFwiXSA9IFwiaGxzQnVmZmVyQ3JlYXRlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ESU5HXCJdID0gXCJobHNCdWZmZXJBcHBlbmRpbmdcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0FQUEVOREVEXCJdID0gXCJobHNCdWZmZXJBcHBlbmRlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfRU9TXCJdID0gXCJobHNCdWZmZXJFb3NcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0ZMVVNISU5HXCJdID0gXCJobHNCdWZmZXJGbHVzaGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hFRFwiXSA9IFwiaGxzQnVmZmVyRmx1c2hlZFwiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FESU5HXCJdID0gXCJobHNNYW5pZmVzdExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BREVEXCJdID0gXCJobHNNYW5pZmVzdExvYWRlZFwiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9QQVJTRURcIl0gPSBcImhsc01hbmlmZXN0UGFyc2VkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1NXSVRDSElOR1wiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENIRURcIl0gPSBcImhsc0xldmVsU3dpdGNoZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BRElOR1wiXSA9IFwiaGxzTGV2ZWxMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkxFVkVMX0xPQURFRFwiXSA9IFwiaGxzTGV2ZWxMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1BUU19VUERBVEVEXCJdID0gXCJobHNMZXZlbFB0c1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxTX1VQREFURURcIl0gPSBcImhsc0xldmVsc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc0F1ZGlvVHJhY2tzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hpbmdcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfU1dJVENIRURcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FESU5HXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FERURcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NDbGVhcmVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX1NXSVRDSFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja1N3aXRjaFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FESU5HXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FERURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfRlJBR19QUk9DRVNTRURcIl0gPSBcImhsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZFwiO1xuICBFdmVudHNbXCJDVUVTX1BBUlNFRFwiXSA9IFwiaGxzQ3Vlc1BhcnNlZFwiO1xuICBFdmVudHNbXCJOT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5EXCJdID0gXCJobHNOb25OYXRpdmVUZXh0VHJhY2tzRm91bmRcIjtcbiAgRXZlbnRzW1wiSU5JVF9QVFNfRk9VTkRcIl0gPSBcImhsc0luaXRQdHNGb3VuZFwiO1xuICBFdmVudHNbXCJGUkFHX0xPQURJTkdcIl0gPSBcImhsc0ZyYWdMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRFwiXSA9IFwiaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BREVEXCJdID0gXCJobHNGcmFnTG9hZGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfREVDUllQVEVEXCJdID0gXCJobHNGcmFnRGVjcnlwdGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlRcIl0gPSBcImhsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX1VTRVJEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19NRVRBREFUQVwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YVwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNFRFwiXSA9IFwiaGxzRnJhZ1BhcnNlZFwiO1xuICBFdmVudHNbXCJGUkFHX0JVRkZFUkVEXCJdID0gXCJobHNGcmFnQnVmZmVyZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19DSEFOR0VEXCJdID0gXCJobHNGcmFnQ2hhbmdlZFwiO1xuICBFdmVudHNbXCJGUFNfRFJPUFwiXSA9IFwiaGxzRnBzRHJvcFwiO1xuICBFdmVudHNbXCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HXCJdID0gXCJobHNGcHNEcm9wTGV2ZWxDYXBwaW5nXCI7XG4gIEV2ZW50c1tcIkVSUk9SXCJdID0gXCJobHNFcnJvclwiO1xuICBFdmVudHNbXCJERVNUUk9ZSU5HXCJdID0gXCJobHNEZXN0cm95aW5nXCI7XG4gIEV2ZW50c1tcIktFWV9MT0FESU5HXCJdID0gXCJobHNLZXlMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIktFWV9MT0FERURcIl0gPSBcImhsc0tleUxvYWRlZFwiO1xuICBFdmVudHNbXCJMSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRURcIl0gPSBcImhsc0xpdmVCYWNrQnVmZmVyUmVhY2hlZFwiO1xuICBFdmVudHNbXCJCQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNCYWNrQnVmZmVyUmVhY2hlZFwiO1xufSkoRXZlbnRzIHx8IChFdmVudHMgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9obHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2hscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEhscylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfcGxheWxpc3RfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2lkM190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xhdGVuY3lfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGF0ZW5jeS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xldmVsX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfa2V5X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIva2V5LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3VwcG9ydGVkICovIFwiLi9zcmMvaXMtc3VwcG9ydGVkLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmZpZyAqLyBcIi4vc3JjL2NvbmZpZy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEBtb2R1bGUgSGxzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgSGxzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICgwLF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5pc1N1cHBvcnRlZCkoKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKlxuICAgKiBAY29uc3RydWN0cyBIbHNcbiAgICogQHBhcmFtIHtIbHNDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgZnVuY3Rpb24gSGxzKHVzZXJDb25maWcpIHtcbiAgICBpZiAodXNlckNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICB1c2VyQ29uZmlnID0ge307XG4gICAgfVxuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5FdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSAoMCxfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLm1lcmdlQ29uZmlnKShIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG4gICAgdGhpcy51c2VyQ29uZmlnID0gdXNlckNvbmZpZztcbiAgICAoMCxfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18uZW5hYmxlTG9ncykoY29uZmlnLmRlYnVnLCAnSGxzIGluc3RhbmNlJyk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgICgwLF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uZW5hYmxlU3RyZWFtaW5nTW9kZSkoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICB2YXIgQ29uZmlnQWJyQ29udHJvbGxlciA9IGNvbmZpZy5hYnJDb250cm9sbGVyLFxuICAgICAgQ29uZmlnQnVmZmVyQ29udHJvbGxlciA9IGNvbmZpZy5idWZmZXJDb250cm9sbGVyLFxuICAgICAgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyID0gY29uZmlnLmNhcExldmVsQ29udHJvbGxlcixcbiAgICAgIENvbmZpZ0Zwc0NvbnRyb2xsZXIgPSBjb25maWcuZnBzQ29udHJvbGxlcjtcbiAgICB2YXIgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBDb25maWdBYnJDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBidWZmZXJDb250cm9sbGVyID0gdGhpcy5idWZmZXJDb250cm9sbGVyID0gbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB2YXIgZnBzQ29udHJvbGxlciA9IG5ldyBDb25maWdGcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBwbGF5TGlzdExvYWRlciA9IG5ldyBfbG9hZGVyX3BsYXlsaXN0X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSh0aGlzKTtcbiAgICB2YXIgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IF9jb250cm9sbGVyX2lkM190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMpO1xuXG4gICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xuICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBfY29udHJvbGxlcl9sZXZlbF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKHRoaXMpO1xuICAgIC8vIEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBfY29udHJvbGxlcl9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgIHZhciBrZXlMb2FkZXIgPSBuZXcgX2xvYWRlcl9rZXlfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdKHRoaXMuY29uZmlnKTtcbiAgICB2YXIgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBfY29udHJvbGxlcl9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcik7XG5cbiAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIC8vIGZwc0NvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIHN3aXRjaCB3aGVuIGZyYW1lcyBhcmUgYmVpbmcgZHJvcHBlZFxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICB2YXIgbmV0d29ya0NvbnRyb2xsZXJzID0gW3BsYXlMaXN0TG9hZGVyLCBsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFthYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICB2YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSk7XG4gICAgfVxuICAgIC8vIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIHZhciBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICBrZXlMb2FkZXIuZW1lQ29udHJvbGxlciA9IHRoaXMuZW1lQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuZW1lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmNtY2RDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihfY29udHJvbGxlcl9sYXRlbmN5X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEhscy5wcm90b3R5cGU7XG4gIF9wcm90by5jcmVhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbGxlcihDb250cm9sbGVyQ2xhc3MsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gIDtcbiAgX3Byb3RvLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfTtcbiAgX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfTtcbiAgX3Byb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgfTtcbiAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgfTtcbiAgX3Byb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gIH07XG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH07XG4gIF9wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcihldmVudCwgZXZlbnRPYmplY3QpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIuZXJyb3IoJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgKyBldmVudCArICcuIEVycm9yIG1lc3NhZ2U6IFwiJyArIGUubWVzc2FnZSArICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JywgZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLkV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8ubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi87XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLkV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgSGxzLmpzIHRvIGEgbWVkaWEgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhXG4gICAqLztcbiAgX3Byb3RvLmF0dGFjaE1lZGlhID0gZnVuY3Rpb24gYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLkV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHtcbiAgICAgIG1lZGlhOiBtZWRpYVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBIbHMuanMgZnJvbSB0aGUgbWVkaWFcbiAgICovO1xuICBfcHJvdG8uZGV0YWNoTWVkaWEgPSBmdW5jdGlvbiBkZXRhY2hNZWRpYSgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICB0aGlzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXy5FdmVudHMuTUVESUFfREVUQUNISU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi87XG4gIF9wcm90by5sb2FkU291cmNlID0gZnVuY3Rpb24gbG9hZFNvdXJjZSh1cmwpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgbG9hZGVkU291cmNlID0gdGhpcy51cmw7XG4gICAgdmFyIGxvYWRpbmdTb3VyY2UgPSB0aGlzLnVybCA9IHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYnVpbGRBYnNvbHV0ZVVSTChzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmxvZ2dlci5sb2coXCJsb2FkU291cmNlOlwiICsgbG9hZGluZ1NvdXJjZSk7XG4gICAgaWYgKG1lZGlhICYmIGxvYWRlZFNvdXJjZSAmJiBsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgJiYgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpIHtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgdGhpcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgIHVybDogdXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc2l0aW9uIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb21cbiAgICogQGRlZmF1bHQgLTEgTm9uZSAoZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICovO1xuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgfVxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwic3RhcnRMb2FkKFwiICsgc3RhcnRQb3NpdGlvbiArIFwiKVwiKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi87XG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKCdzdG9wTG9hZCcpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqLztcbiAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi87XG4gIF9wcm90by5yZWNvdmVyTWVkaWFFcnJvciA9IGZ1bmN0aW9uIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIHZhciBtZWRpYSA9IHRoaXMuX21lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpIHtcbiAgICBpZiAodXJsSWQgPT09IHZvaWQgMCkge1xuICAgICAgdXJsSWQgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0xldmVsW119XG4gICAqLztcbiAgX2NyZWF0ZUNsYXNzKEhscywgW3tcbiAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgY3VycmVudGx5IHBsYXllZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseSAuXG4gICAgICogVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuXG4gICAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAgICovLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZyhcInNldCBjdXJyZW50TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5hYnJDb250cm9sbGVyLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwic2V0IG5leHRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWwgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwic2V0IGxvYWRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5leHRMb2FkTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAgICogQHR5cGUge251bWJlcn0gbGV2ZWxcbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5sb2dnZXIubG9nKFwic2V0IGZpcnN0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbFxuICAgICAqLyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLmxvZ2dlci5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG4gICAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc2V0dGluZyBmb3IgY2FwTGV2ZWxUb1BsYXllclNpemVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhcExldmVsVG9QbGF5ZXJTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0ICBkeW5hbWljYWxseSBzZXQgY2FwTGV2ZWxUb1BsYXllclNpemUgYWdhaW5zdCAoYENhcExldmVsQ29udHJvbGxlcmApXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2hvdWxkU3RhcnRDYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgPSAhIXNob3VsZFN0YXJ0Q2FwcGluZztcbiAgICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSAhPT0gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTsgLy8gTm93IHdlJ3JlIHVuY2FwcGVkLCBnZXQgdGhlIG5leHQgbGV2ZWwgYXNhcC5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXV0b0xldmVsQ2FwcGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGJhbmR3aWR0aCBlc3RpbWF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovLFxuICAgIHNldDpcbiAgICAvKipcbiAgICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ubG9nZ2VyLmxvZyhcInNldCBhdXRvTGV2ZWxDYXBwaW5nOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhbmR3aWR0aEVzdGltYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLmFickNvbnRyb2xsZXIuYndFc3RpbWF0b3I7XG4gICAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4SGRjcExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmIChfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18uSGRjcExldmVscy5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdXRvTGV2ZWxFbmFibGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWFudWFsTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWluQXV0b0xldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1pbkF1dG9CaXRyYXRlID0gdGhpcy5jb25maWcubWluQXV0b0JpdHJhdGU7XG4gICAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG4gICAgICB2YXIgbGVuID0gbGV2ZWxzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID49IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWF4QXV0b0xldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIGF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmF1dG9MZXZlbENhcHBpbmcsXG4gICAgICAgIG1heEhkY3BMZXZlbCA9IHRoaXMubWF4SGRjcExldmVsO1xuICAgICAgdmFyIG1heEF1dG9MZXZlbDtcbiAgICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgICBpZiAobWF4SGRjcExldmVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGktLTspIHtcbiAgICAgICAgICB2YXIgaGRjcExldmVsID0gbGV2ZWxzW2ldLmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgICAgaWYgKGhkY3BMZXZlbCAmJiBoZGNwTGV2ZWwgPD0gbWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5leHRBdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCksIHRoaXMubWF4QXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqLyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgodGhpcy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBkYXRldGltZSB2YWx1ZSByZWxhdGl2ZSB0byBtZWRpYS5jdXJyZW50VGltZSBmb3IgdGhlIGFjdGl2ZSBsZXZlbCBQcm9ncmFtIERhdGUgVGltZSBpZiBwcmVzZW50XG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheWluZ0RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudFByb2dyYW1EYXRlVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFpbkZvcndhcmRCdWZmZXJJbmZvXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb1RyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi8sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYXVkaW9UcmFja0lkKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAgICogQHR5cGUge01lZGlhUGxheWxpc3RbXX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gICAgfSxcbiAgICBzZXQ6XG4gICAgLyoqXG4gICAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtZWRpYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZURpc3BsYXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqLyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb3dMYXRlbmN5TW9kZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIExvdy1MYXRlbmN5IEhMUyBwYXJ0IHBsYXlsaXN0IGFuZCBzZWdtZW50IGxvYWRpbmcsIGFuZCBzdGFydCBsaXZlIHN0cmVhbXMgYXQgcGxheWxpc3QgUEFSVC1IT0xELUJBQ0sgcmF0aGVyIHRoYW4gSE9MRC1CQUNLLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqLyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChtb2RlKSB7XG4gICAgICB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSA9IG1vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgc3luYyBwb2ludCAoaWUgZWRnZSBvZiBsaXZlIHBvc2l0aW9uIG1pbnVzIHNhZmV0eSBkZWxheSBkZWZpbmVkIGJ5IGBgYGhscy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbmBgYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZXN0aW1hdGVkIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIGVkZ2UgKGllIGVkZ2Ugb2YgbGl2ZSBwbGF5bGlzdCBwbHVzIHRpbWUgc3luYyBwbGF5bGlzdCBhZHZhbmNlZClcbiAgICAgKiByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgICAqIGNvbmZpZ3VyZWQgdXNpbmcgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50YGBgIChtdWx0aXBsZSBvZiB0YXJnZXQgZHVyYXRpb24pIG9yIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25gYGBcbiAgICAgKiByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRhcmdldExhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmlmdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZVN0YXJ0TG9hZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCIxLjMuNVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFdmVudHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLkV2ZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRXJyb3JUeXBlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uRXJyb3JUeXBlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRXJyb3JEZXRhaWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXy5FcnJvckRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRlZmF1bHRDb25maWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uaGxzRGVmYXVsdENvbmZpZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SGxzQ29uZmlnfVxuICAgICAqLyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIbHM7XG59KCk7XG5IbHMuZGVmYXVsdENvbmZpZyA9IHZvaWQgMDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2lzLXN1cHBvcnRlZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJjaGFuZ2VUeXBlU3VwcG9ydGVkXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNoYW5nZVR5cGVTdXBwb3J0ZWQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImlzU3VwcG9ydGVkXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzU3VwcG9ydGVkKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIik7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpIHtcbiAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IHNlbGYuV2ViS2l0U291cmNlQnVmZmVyO1xufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIHZhciBtZWRpYVNvdXJjZSA9ICgwLF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRNZWRpYVNvdXJjZSkoKTtcbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHZhciBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJiB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpO1xuXG4gIC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgdmFyIHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fCBzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiAhIWlzVHlwZVN1cHBvcnRlZCAmJiAhIXNvdXJjZUJ1ZmZlclZhbGlkQVBJO1xufVxuZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpIHtcbiAgdmFyIF9zb3VyY2VCdWZmZXIkcHJvdG90eTtcbiAgdmFyIHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gdHlwZW9mIChzb3VyY2VCdWZmZXIgPT09IG51bGwgfHwgc291cmNlQnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZUJ1ZmZlciRwcm90b3R5ID0gc291cmNlQnVmZmVyLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX3NvdXJjZUJ1ZmZlciRwcm90b3R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlQnVmZmVyJHByb3RvdHkuY2hhbmdlVHlwZSkgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiRGF0ZVJhbmdlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIERhdGVSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiRGF0ZVJhbmdlQXR0cmlidXRlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIERhdGVSYW5nZUF0dHJpYnV0ZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2F0dHItbGlzdCAqLyBcIi4vc3JjL3V0aWxzL2F0dHItbGlzdC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5cblxudmFyIERhdGVSYW5nZUF0dHJpYnV0ZTtcbihmdW5jdGlvbiAoRGF0ZVJhbmdlQXR0cmlidXRlKSB7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIklEXCJdID0gXCJJRFwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJDTEFTU1wiXSA9IFwiQ0xBU1NcIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiU1RBUlRfREFURVwiXSA9IFwiU1RBUlQtREFURVwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJEVVJBVElPTlwiXSA9IFwiRFVSQVRJT05cIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiRU5EX0RBVEVcIl0gPSBcIkVORC1EQVRFXCI7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIkVORF9PTl9ORVhUXCJdID0gXCJFTkQtT04tTkVYVFwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJQTEFOTkVEX0RVUkFUSU9OXCJdID0gXCJQTEFOTkVELURVUkFUSU9OXCI7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIlNDVEUzNV9PVVRcIl0gPSBcIlNDVEUzNS1PVVRcIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiU0NURTM1X0lOXCJdID0gXCJTQ1RFMzUtSU5cIjtcbn0pKERhdGVSYW5nZUF0dHJpYnV0ZSB8fCAoRGF0ZVJhbmdlQXR0cmlidXRlID0ge30pKTtcbnZhciBEYXRlUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgIHRoaXMuYXR0ciA9IHZvaWQgMDtcbiAgICB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW5kRGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IHZvaWQgMDtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgdmFyIHByZXZpb3VzQXR0ciA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuYXR0cjtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcmV2aW91c0F0dHIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRlUmFuZ2VBdHRyLCBrZXkpICYmIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV0pIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ubG9nZ2VyLndhcm4oXCJEQVRFUkFOR0UgdGFnIGF0dHJpYnV0ZTogXFxcIlwiICsga2V5ICsgXCJcXFwiIGRvZXMgbm90IG1hdGNoIGZvciB0YWdzIHdpdGggSUQ6IFxcXCJcIiArIGRhdGVSYW5nZUF0dHIuSUQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBfZXh0ZW5kcyhuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkF0dHJMaXN0KHt9KSwgcHJldmlvdXNBdHRyLCBkYXRlUmFuZ2VBdHRyKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyID0gZGF0ZVJhbmdlQXR0cjtcbiAgICB0aGlzLl9zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlUmFuZ2VBdHRyW0RhdGVSYW5nZUF0dHJpYnV0ZS5TVEFSVF9EQVRFXSk7XG4gICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfREFURSBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIHZhciBlbmREYXRlID0gbmV3IERhdGUodGhpcy5hdHRyW0RhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfREFURV0pO1xuICAgICAgaWYgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoZW5kRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRoaXMuX2VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY3JlYXRlQ2xhc3MoRGF0ZVJhbmdlLCBbe1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhc3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0RGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kRGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gICAgICB9XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgaWYgKGR1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTik7XG4gICAgICAgIGlmICgoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGR1cmF0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxhbm5lZER1cmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoRGF0ZVJhbmdlQXR0cmlidXRlLlBMQU5ORURfRFVSQVRJT04gaW4gdGhpcy5hdHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoRGF0ZVJhbmdlQXR0cmlidXRlLlBMQU5ORURfRFVSQVRJT04pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9uTmV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfT05fTkVYVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaWQgJiYgIXRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkICYmICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERhdGVSYW5nZTtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkxvYWRFcnJvclwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb2FkRXJyb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRnJhZ21lbnRMb2FkZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcbnZhciBGcmFnbWVudExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYWdtZW50TG9hZGVyKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnBhcnRMb2FkVGltZW91dCA9IC0xO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIHZhciBfcHJvdG8gPSBGcmFnbWVudExvYWRlci5wcm90b3R5cGU7XG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgLy8gQWJvcnQgdGhlIGxvYWRlciBmb3IgY3VycmVudCBmcmFnbWVudC4gT25seSBvbmUgbWF5IGxvYWQgYXQgYW55IGdpdmVuIHRpbWVcbiAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoZnJhZywgX29uUHJvZ3Jlc3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciB1cmwgPSBmcmFnLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgfSwgXCJGcmFnbWVudCBkb2VzIG5vdCBoYXZlIGEgXCIgKyAodXJsID8gJ3BhcnQgbGlzdCcgOiAndXJsJykpKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgdmFyIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKF90aGlzLmxvYWRlcikge1xuICAgICAgICBfdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxvYWRlciA9IF90aGlzLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnID8gSW5maW5pdHkgOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChjb250ZXh0LnJlc2V0SVYgJiYgZnJhZy5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAgICAgZnJhZy5kZWNyeXB0ZGF0YS5pdiA9IG5ldyBVaW50OEFycmF5KHBheWxvYWQuc2xpY2UoMCwgMTYpKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLnNsaWNlKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKF9vblByb2dyZXNzKSB7XG4gICAgICAgICAgICBfb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmxvYWRQYXJ0ID0gZnVuY3Rpb24gbG9hZFBhcnQoZnJhZywgcGFydCwgb25Qcm9ncmVzcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIHZhciBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChfdGhpczIubG9hZGVyKSB7XG4gICAgICAgIF90aGlzMi5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxvYWRlciA9IF90aGlzMi5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpO1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogTUlOX0NIVU5LX1NJWkVcbiAgICAgIH07XG4gICAgICAvLyBBc3NpZ24gcGFydCBzdGF0cyB0byB0aGUgbG9hZGVyJ3Mgc3RhdHMgcmVmZXJlbmNlXG4gICAgICBwYXJ0LnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICBfdGhpczIudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICB2YXIgcGFydExvYWRlZERhdGEgPSB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIHJlc29sdmUocGFydExvYWRlZERhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiBmdW5jdGlvbiBvbkFib3J0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIGZyYWcuc3RhdHMuYWJvcnRlZCA9IHBhcnQuc3RhdHMuYWJvcnRlZDtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8udXBkYXRlU3RhdHNGcm9tUGFydCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgIHZhciBmcmFnU3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgIHZhciBwYXJ0U3RhdHMgPSBwYXJ0LnN0YXRzO1xuICAgIHZhciBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuICAgIGlmIChwYXJ0VG90YWwpIHtcbiAgICAgIHZhciBlc3RUb3RhbFBhcnRzID0gTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uIC8gcGFydC5kdXJhdGlvbik7XG4gICAgICB2YXIgZXN0TG9hZGVkUGFydHMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBwYXJ0VG90YWwpLCBlc3RUb3RhbFBhcnRzKTtcbiAgICAgIHZhciBlc3RSZW1haW5pbmdQYXJ0cyA9IGVzdFRvdGFsUGFydHMgLSBlc3RMb2FkZWRQYXJ0cztcbiAgICAgIHZhciBlc3RSZW1haW5pbmdCeXRlcyA9IGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gZnJhZ1N0YXRzLmxvYWRlZCArIGVzdFJlbWFpbmluZ0J5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgIH1cbiAgICB2YXIgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICB2YXIgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICBpZiAoZnJhZ0xvYWRpbmcuc3RhcnQpIHtcbiAgICAgIC8vIGFkZCB0byBmcmFnbWVudCBsb2FkZXIgbGF0ZW5jeVxuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ0xvYWRpbmcuc3RhcnQgPSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgfVxuICAgIGZyYWdMb2FkaW5nLmVuZCA9IHBhcnRMb2FkaW5nLmVuZDtcbiAgfTtcbiAgX3Byb3RvLnJlc2V0TG9hZGVyID0gZnVuY3Rpb24gcmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGxvYWRlci5kZXN0cm95KCk7XG4gIH07XG4gIHJldHVybiBGcmFnbWVudExvYWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KSB7XG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gbnVsbDtcbiAgfVxuICB2YXIgc2VnbWVudCA9IHBhcnQgfHwgZnJhZztcbiAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZzogZnJhZyxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDBcbiAgfTtcbiAgdmFyIHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgdmFyIGVuZCA9IHNlZ21lbnQuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShzdGFydCkgJiYgKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShlbmQpKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhO1xuICAgIHZhciBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgIHZhciBieXRlUmFuZ2VFbmQgPSBlbmQ7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgJiYgKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09PSBudWxsIHx8IF9mcmFnJGRlY3J5cHRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5tZXRob2QpID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIC8vIE1BUCBzZWdtZW50IGVuY3J5cHRlZCB3aXRoIG1ldGhvZCAnQUVTLTEyOCcsIHdoZW4gc2VydmVkIHdpdGggSFRUUCBSYW5nZSxcbiAgICAgIC8vIGhhcyB0aGUgdW5lbmNyeXB0ZWQgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWhscy1yZmM4MjE2YmlzLTA4I3NlY3Rpb24tNi4zLjZcbiAgICAgIHZhciBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gZnJhZ21lbnRMZW4gJSAxNik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yZXNldElWID0gdHJ1ZTtcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydCAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBieXRlUmFuZ2VTdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICB9XG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxudmFyIExvYWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvYWRFcnJvciwgX0Vycm9yKTtcbiAgZnVuY3Rpb24gTG9hZEVycm9yKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMzID0gX0Vycm9yLmNhbGwuYXBwbHkoX0Vycm9yLCBbdGhpc10uY29uY2F0KHBhcmFtcykpIHx8IHRoaXM7XG4gICAgX3RoaXMzLmRhdGEgPSB2b2lkIDA7XG4gICAgX3RoaXMzLmRhdGEgPSBkYXRhO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cbiAgcmV0dXJuIExvYWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkJhc2VTZWdtZW50XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZWdtZW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRWxlbWVudGFyeVN0cmVhbVR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJGcmFnbWVudFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBGcmFnbWVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiUGFydFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJ0KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHVybC10b29sa2l0ICovIFwiLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9hZC1zdGF0cyAqLyBcIi4vc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5cblxudmFyIEVsZW1lbnRhcnlTdHJlYW1UeXBlcztcbihmdW5jdGlvbiAoRWxlbWVudGFyeVN0cmVhbVR5cGVzKSB7XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlc1tcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBFbGVtZW50YXJ5U3RyZWFtVHlwZXNbXCJWSURFT1wiXSA9IFwidmlkZW9cIjtcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzW1wiQVVESU9WSURFT1wiXSA9IFwiYXVkaW92aWRlb1wiO1xufSkoRWxlbWVudGFyeVN0cmVhbVR5cGVzIHx8IChFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7fSkpO1xudmFyIEJhc2VTZWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gYmFzZXVybCBpcyB0aGUgVVJMIHRvIHRoZSBwbGF5bGlzdFxuXG4gIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuXG4gIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcblxuICBmdW5jdGlvbiBCYXNlU2VnbWVudChiYXNldXJsKSB7XG4gICAgdmFyIF90aGlzJGVsZW1lbnRhcnlTdHJlYTtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSAoX3RoaXMkZWxlbWVudGFyeVN0cmVhID0ge30sIF90aGlzJGVsZW1lbnRhcnlTdHJlYVtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsLCBfdGhpcyRlbGVtZW50YXJ5U3RyZWFbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhKTtcbiAgICB0aGlzLmJhc2V1cmwgPSBiYXNldXJsO1xuICB9XG5cbiAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgdmFyIF9wcm90byA9IEJhc2VTZWdtZW50LnByb3RvdHlwZTtcbiAgX3Byb3RvLnNldEJ5dGVSYW5nZSA9IGZ1bmN0aW9uIHNldEJ5dGVSYW5nZSh2YWx1ZSwgcHJldmlvdXMpIHtcbiAgICB2YXIgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICB2YXIgYnl0ZVJhbmdlID0gW107XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHByZXZpb3VzID8gcHJldmlvdXMuYnl0ZVJhbmdlRW5kT2Zmc2V0IDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG4gICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBieXRlUmFuZ2U7XG4gIH07XG4gIF9jcmVhdGVDbGFzcyhCYXNlU2VnbWVudCwgW3tcbiAgICBrZXk6IFwiYnl0ZVJhbmdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2J5dGVSYW5nZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VTdGFydE9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VFbmRPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gKDAsdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5idWlsZEFic29sdXRlVVJMKSh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhc2VTZWdtZW50O1xufSgpO1xudmFyIEZyYWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVNlZ21lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRnJhZ21lbnQsIF9CYXNlU2VnbWVudCk7XG4gIC8vIEVYVElORiBoYXMgdG8gYmUgcHJlc2VudCBmb3IgYSBtM3U4IHRvIGJlIGNvbnNpZGVyZWQgdmFsaWRcblxuICAvLyBzbiBub3RhdGVzIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIGEgc2VnbWVudCwgYW5kIGlmIHNldCB0byBhIHN0cmluZyBjYW4gYmUgJ2luaXRTZWdtZW50J1xuXG4gIC8vIGxldmVsa2V5cyBhcmUgdGhlIEVYVC1YLUtFWSB0YWdzIHRoYXQgYXBwbHkgdG8gdGhpcyBzZWdtZW50IGZvciBkZWNyeXB0aW9uXG4gIC8vIGNvcmUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcml2YXRlIGZpZWxkIF9kZWNyeXB0ZGF0YSBpcyB0aGUgbGFjayBvZiB0aGUgaW5pdGlhbGl6ZWQgSVZcbiAgLy8gX2RlY3J5cHRkYXRhIHdpbGwgc2V0IHRoZSBJViBmb3IgdGhpcyBzZWdtZW50IGJhc2VkIG9uIHRoZSBzZWdtZW50IG51bWJlciBpbiB0aGUgZnJhZ21lbnRcblxuICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBrZXkgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGtleSBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGtleSBsb2FkaW5nXG5cbiAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG5cbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcblxuICAvLyBUaGUgc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG5cbiAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cblxuICAvLyBUaGUgbGF0ZXN0IFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIGFwcGVuZGVkIHRvIHRoZSBidWZmZXIuXG5cbiAgLy8gVGhlIHN0YXJ0aW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuXG4gIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG5cbiAgLy8gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGZyYWdtZW50LCBhcyBsaXN0ZWQgaW4gdGhlIG1hbmlmZXN0LiBVcGRhdGVkIGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuXG4gIC8vIFNldCBieSBgdXBkYXRlRnJhZ1BUU0RUU2AgaW4gbGV2ZWwtaGVscGVyXG5cbiAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG5cbiAgLy8gVGhlIG1pbmltdW0gZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuXG4gIC8vIExvYWQvcGFyc2UgdGltaW5nIGluZm9ybWF0aW9uXG5cbiAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG5cbiAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuXG4gIC8vIFRoZSBNZWRpYSBJbml0aWFsaXphdGlvbiBTZWN0aW9uIGZvciB0aGlzIHNlZ21lbnRcblxuICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcblxuICBmdW5jdGlvbiBGcmFnbWVudCh0eXBlLCBiYXNldXJsKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Jhc2VTZWdtZW50LmNhbGwodGhpcywgYmFzZXVybCkgfHwgdGhpcztcbiAgICBfdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIF90aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgX3RoaXMucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBfdGhpcy50YWdMaXN0ID0gW107XG4gICAgX3RoaXMuZHVyYXRpb24gPSAwO1xuICAgIF90aGlzLnNuID0gMDtcbiAgICBfdGhpcy5sZXZlbGtleXMgPSB2b2lkIDA7XG4gICAgX3RoaXMudHlwZSA9IHZvaWQgMDtcbiAgICBfdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIF90aGlzLmtleUxvYWRlciA9IG51bGw7XG4gICAgX3RoaXMubGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5jYyA9IDA7XG4gICAgX3RoaXMuc3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5kUFRTID0gdm9pZCAwO1xuICAgIF90aGlzLmFwcGVuZGVkUFRTID0gdm9pZCAwO1xuICAgIF90aGlzLnN0YXJ0RFRTID0gdm9pZCAwO1xuICAgIF90aGlzLmVuZERUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5zdGFydCA9IDA7XG4gICAgX3RoaXMuZGVsdGFQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMubWF4U3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMubWluRW5kUFRTID0gdm9pZCAwO1xuICAgIF90aGlzLnN0YXRzID0gbmV3IF9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uTG9hZFN0YXRzKCk7XG4gICAgX3RoaXMudXJsSWQgPSAwO1xuICAgIF90aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgX3RoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgX3RoaXMuaW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIF90aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8yID0gRnJhZ21lbnQucHJvdG90eXBlO1xuICBfcHJvdG8yLnNldEtleUZvcm1hdCA9IGZ1bmN0aW9uIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIHZhciBfa2V5ID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0XTtcbiAgICAgIGlmIChfa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IF9rZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8yLmFib3J0UmVxdWVzdHMgPSBmdW5jdGlvbiBhYm9ydFJlcXVlc3RzKCkge1xuICAgIHZhciBfdGhpcyRsb2FkZXIsIF90aGlzJGtleUxvYWRlcjtcbiAgICAoX3RoaXMkbG9hZGVyID0gdGhpcy5sb2FkZXIpID09PSBudWxsIHx8IF90aGlzJGxvYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRrZXlMb2FkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGtleUxvYWRlci5hYm9ydCgpO1xuICB9O1xuICBfcHJvdG8yLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvID0gZnVuY3Rpb24gc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCkge1xuICAgIGlmIChwYXJ0aWFsID09PSB2b2lkIDApIHtcbiAgICAgIHBhcnRpYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRhcnlTdHJlYW1zID0gdGhpcy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICB2YXIgaW5mbyA9IGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgIGlmICghaW5mbykge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPSB7XG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluZm8uc3RhcnRQVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0UFRTLCBzdGFydFBUUyk7XG4gICAgaW5mby5lbmRQVFMgPSBNYXRoLm1heChpbmZvLmVuZFBUUywgZW5kUFRTKTtcbiAgICBpbmZvLnN0YXJ0RFRTID0gTWF0aC5taW4oaW5mby5zdGFydERUUywgc3RhcnREVFMpO1xuICAgIGluZm8uZW5kRFRTID0gTWF0aC5tYXgoaW5mby5lbmREVFMsIGVuZERUUyk7XG4gIH07XG4gIF9wcm90bzIuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbyA9IGZ1bmN0aW9uIGNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKSB7XG4gICAgdmFyIGVsZW1lbnRhcnlTdHJlYW1zID0gdGhpcy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10gPSBudWxsO1xuICB9O1xuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcImRlY3J5cHRkYXRhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxrZXlzID0gdGhpcy5sZXZlbGtleXM7XG4gICAgICBpZiAoIWxldmVsa2V5cyAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhICYmIHRoaXMubGV2ZWxrZXlzICYmICF0aGlzLmxldmVsa2V5cy5OT05FKSB7XG4gICAgICAgIHZhciBfa2V5MiA9IHRoaXMubGV2ZWxrZXlzLmlkZW50aXR5O1xuICAgICAgICBpZiAoX2tleTIpIHtcbiAgICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IF9rZXkyLmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgICAgIGlmIChrZXlGb3JtYXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE11bHRpcGxlIGtleXMuIGtleS1sb2FkZXIgdG8gY2FsbCBGcmFnbWVudC5zZXRLZXlGb3JtYXQgYmFzZWQgb24gc2VsZWN0ZWQga2V5LXN5c3RlbS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFByb2dyYW1EYXRlVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9ICEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHRoaXMuZHVyYXRpb24pID8gMCA6IHRoaXMuZHVyYXRpb247XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyBkdXJhdGlvbiAqIDEwMDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuY3J5cHRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJF9kZWNyeXB0ZGF0YTtcbiAgICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgICAvLyBDdXJyZW50bHksIGtleUZvcm1hdCB3aWxsIG9ubHkgYmUgc2V0IGZvciBpZGVudGl0eSBrZXlzXG4gICAgICBpZiAoKF90aGlzJF9kZWNyeXB0ZGF0YSA9IHRoaXMuX2RlY3J5cHRkYXRhKSAhPT0gbnVsbCAmJiBfdGhpcyRfZGVjcnlwdGRhdGEgIT09IHZvaWQgMCAmJiBfdGhpcyRfZGVjcnlwdGRhdGEuZW5jcnlwdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgICB2YXIga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID4gMSB8fCBsZW4gPT09IDEgJiYgdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZyYWdtZW50O1xufShCYXNlU2VnbWVudCk7XG52YXIgUGFydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTZWdtZW50Mikge1xuICBfaW5oZXJpdHNMb29zZShQYXJ0LCBfQmFzZVNlZ21lbnQyKTtcbiAgZnVuY3Rpb24gUGFydChwYXJ0QXR0cnMsIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91cykge1xuICAgIHZhciBfdGhpczI7XG4gICAgX3RoaXMyID0gX0Jhc2VTZWdtZW50Mi5jYWxsKHRoaXMsIGJhc2V1cmwpIHx8IHRoaXM7XG4gICAgX3RoaXMyLmZyYWdPZmZzZXQgPSAwO1xuICAgIF90aGlzMi5kdXJhdGlvbiA9IDA7XG4gICAgX3RoaXMyLmdhcCA9IGZhbHNlO1xuICAgIF90aGlzMi5pbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgIF90aGlzMi5yZWx1cmwgPSB2b2lkIDA7XG4gICAgX3RoaXMyLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIF90aGlzMi5pbmRleCA9IHZvaWQgMDtcbiAgICBfdGhpczIuc3RhdHMgPSBuZXcgX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5Mb2FkU3RhdHMoKTtcbiAgICBfdGhpczIuZHVyYXRpb24gPSBwYXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0RVUkFUSU9OJyk7XG4gICAgX3RoaXMyLmdhcCA9IHBhcnRBdHRycy5ib29sKCdHQVAnKTtcbiAgICBfdGhpczIuaW5kZXBlbmRlbnQgPSBwYXJ0QXR0cnMuYm9vbCgnSU5ERVBFTkRFTlQnKTtcbiAgICBfdGhpczIucmVsdXJsID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1VSSScpO1xuICAgIF90aGlzMi5mcmFnbWVudCA9IGZyYWc7XG4gICAgX3RoaXMyLmluZGV4ID0gaW5kZXg7XG4gICAgdmFyIGJ5dGVSYW5nZSA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdCWVRFUkFOR0UnKTtcbiAgICBpZiAoYnl0ZVJhbmdlKSB7XG4gICAgICBfdGhpczIuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIF90aGlzMi5mcmFnT2Zmc2V0ID0gcHJldmlvdXMuZnJhZ09mZnNldCArIHByZXZpb3VzLmR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQYXJ0LCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuc3RhcnQgKyB0aGlzLmZyYWdPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQYXJ0O1xufShCYXNlU2VnbWVudCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBLZXlMb2FkZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLnRzXCIpO1xuXG5cbnZhciBLZXlMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlMb2FkZXIoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIHZhciBfcHJvdG8gPSBLZXlMb2FkZXIucHJvdG90eXBlO1xuICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBmb3IgKHZhciB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGZvciAodmFyIHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgdmFyIGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgLy8gUmVtb3ZlIGNhY2hlZCBFTUUga2V5cyBvbiBkZXRhY2hcbiAgICAgIGlmIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBmb3IgKHZhciB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgfTtcbiAgX3Byb3RvLmNyZWF0ZUtleUxvYWRFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBkZXRhaWxzLCBuZXR3b3JrRGV0YWlscywgbWVzc2FnZSkge1xuICAgIGlmIChkZXRhaWxzID09PSB2b2lkIDApIHtcbiAgICAgIGRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5Mb2FkRXJyb3Ioe1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5sb2FkQ2xlYXIgPSBmdW5jdGlvbiBsb2FkQ2xlYXIobG9hZGluZ0ZyYWcsIGVuY3J5cHRlZEZyYWdtZW50cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBhY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FpZG5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICB2YXIgc24gPSBsb2FkaW5nRnJhZy5zbixcbiAgICAgICAgY2MgPSBsb2FkaW5nRnJhZy5jYztcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBlbmNyeXB0ZWRGcmFnbWVudHNbaV07XG4gICAgICAgIGlmIChjYyA8PSBmcmFnLmNjICYmIChzbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBzbiA8IGZyYWcuc24pKSB7XG4gICAgICAgICAgX3RoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihmdW5jdGlvbiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICAgICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKGkpO1xuICAgICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChmcmFnKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZW5jcnlwdGVkICYmIHRoaXMuZW1lQ29udHJvbGxlcikge1xuICAgICAgLy8gTXVsdGlwbGUga2V5cywgYnV0IG5vbmUgc2VsZWN0ZWQsIHJlc29sdmUgaW4gZW1lLWNvbnRyb2xsZXJcbiAgICAgIHJldHVybiB0aGlzLmVtZUNvbnRyb2xsZXIuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpLnRoZW4oZnVuY3Rpb24gKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnKTtcbiAgfTtcbiAgX3Byb3RvLmxvYWRJbnRlcm5hbCA9IGZ1bmN0aW9uIGxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICB2YXIgX2tleUluZm8sIF9rZXlJbmZvMjtcbiAgICBpZiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgIH1cbiAgICB2YXIgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBrZXlTeXN0ZW1Gb3JtYXQgPyBcIkV4cGVjdGVkIGZyYWcuZGVjcnlwdGRhdGEgdG8gYmUgZGVmaW5lZCBhZnRlciBzZXR0aW5nIGZvcm1hdCBcIiArIGtleVN5c3RlbUZvcm1hdCA6ICdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG51bGwsIGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICB2YXIgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgIGlmICghdXJpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbnVsbCwgXCJJbnZhbGlkIGtleSBVUkk6IFxcXCJcIiArIHVyaSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICAgIHZhciBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICBpZiAoKF9rZXlJbmZvID0ga2V5SW5mbykgIT09IG51bGwgJiYgX2tleUluZm8gIT09IHZvaWQgMCAmJiBfa2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkpIHtcbiAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4ga2V5IGxvYWQgcHJvbWlzZSBhcyBsb25nIGFzIGl0IGRvZXMgbm90IGhhdmUgYSBtZWRpYWtleSBzZXNzaW9uIHdpdGggYW4gdW51c2FibGUga2V5IHN0YXR1c1xuICAgIGlmICgoX2tleUluZm8yID0ga2V5SW5mbykgIT09IG51bGwgJiYgX2tleUluZm8yICE9PSB2b2lkIDAgJiYgX2tleUluZm8yLmtleUxvYWRQcm9taXNlKSB7XG4gICAgICB2YXIgX2tleUluZm8kbWVkaWFLZXlTZXNzO1xuICAgICAgc3dpdGNoICgoX2tleUluZm8kbWVkaWFLZXlTZXNzID0ga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0KSA9PT0gbnVsbCB8fCBfa2V5SW5mbyRtZWRpYUtleVNlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rZXlJbmZvJG1lZGlhS2V5U2Vzcy5rZXlTdGF0dXMpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ3N0YXR1cy1wZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndXNhYmxlJzpcbiAgICAgICAgY2FzZSAndXNhYmxlLWluLWZ1dHVyZSc6XG4gICAgICAgICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5TG9hZGVkRGF0YSkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGggdXBkYXRlZCBkZWNyeXB0ZGF0YSBrZXkgYW5kIGxvYWRlZCBrZXlJbmZvXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlMb2FkZWREYXRhLmtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAga2V5SW5mbzoga2V5SW5mb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAvLyBUaGlzIHdpbGwgZ28gYmFjayB0byB0aGUgZW1lLWNvbnRyb2xsZXIgZm9yIGV4cGlyZWQga2V5cyB0byBnZXQgYSBuZXcga2V5TG9hZFByb21pc2VcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSA9IHtcbiAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChkZWNyeXB0ZGF0YS5tZXRob2QpIHtcbiAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DRU5DJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIGxvYWRLZXlIVFRQIGhhbmRsZXMgaHR0cChzKSBhbmQgZGF0YSBVUkxzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBudWxsLCBcIktleSBzdXBwbGllZCB3aXRoIHVuc3VwcG9ydGVkIE1FVEhPRDogXFxcIlwiICsgZGVjcnlwdGRhdGEubWV0aG9kICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5sb2FkS2V5RU1FID0gZnVuY3Rpb24gbG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKSB7XG4gICAgdmFyIGtleUxvYWRlZERhdGEgPSB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAga2V5SW5mbzoga2V5SW5mb1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5lbWVDb250cm9sbGVyLmxvYWRLZXkoa2V5TG9hZGVkRGF0YSk7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiAoa2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgICAgIGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGtleVNlc3Npb25Db250ZXh0O1xuICAgICAgICAgIHJldHVybiBrZXlMb2FkZWREYXRhO1xuICAgICAgICB9KSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfTtcbiAgX3Byb3RvLmxvYWRLZXlIVFRQID0gZnVuY3Rpb24gbG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICB2YXIga2V5TG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGZyYWcua2V5TG9hZGVyID0ga2V5SW5mby5sb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAga2V5SW5mbzoga2V5SW5mbyxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmw6IGtleUluZm8uZGVjcnlwdGRhdGEudXJpXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAwXG4gICAgICB9O1xuICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICAgICAga2V5SW5mbyA9IGNvbnRleHQua2V5SW5mbyxcbiAgICAgICAgICAgIHVyaSA9IGNvbnRleHQudXJsO1xuICAgICAgICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSB8fCBrZXlJbmZvICE9PSBfdGhpczMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoX3RoaXMzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXR3b3JrRGV0YWlscywgJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCBvciBjaGFuZ2VkJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSk7XG5cbiAgICAgICAgICAvLyBkZXRhY2ggZnJhZ21lbnQga2V5IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICAgICAga2V5SW5mby5sb2FkZXIgPSBudWxsO1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvciwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KF90aGlzMy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdChfdGhpczMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KF90aGlzMy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAga2V5TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVzZXRMb2FkZXIgPSBmdW5jdGlvbiByZXNldExvYWRlcihjb250ZXh0KSB7XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICBrZXlJbmZvID0gY29udGV4dC5rZXlJbmZvLFxuICAgICAgdXJpID0gY29udGV4dC51cmw7XG4gICAgdmFyIGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgIGlmIChmcmFnLmtleUxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gS2V5TG9hZGVyO1xufSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiTGV2ZWxEZXRhaWxzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIExldmVsRGV0YWlscylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OID0gMTA7XG52YXIgTGV2ZWxEZXRhaWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gTWFuaWZlc3QgcmVsb2FkIHN5bmNocm9uaXphdGlvblxuXG4gIGZ1bmN0aW9uIExldmVsRGV0YWlscyhiYXNlVXJsKSB7XG4gICAgdGhpcy5QVFNLbm93biA9IGZhbHNlO1xuICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZENDID0gMDtcbiAgICB0aGlzLmVuZFNOID0gMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50SGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICB0aGlzLmFnZUhlYWRlciA9IDA7XG4gICAgdGhpcy5hZHZhbmNlZERhdGVUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgdGhpcy5hdmFpbGFiaWxpdHlEZWxheSA9IHZvaWQgMDtcbiAgICB0aGlzLm1pc3NlcyA9IDA7XG4gICAgdGhpcy5zdGFydENDID0gMDtcbiAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5tM3U4ID0gJyc7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLmNhbkJsb2NrUmVsb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5Ta2lwVW50aWwgPSAwO1xuICAgIHRoaXMuY2FuU2tpcERhdGVSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDA7XG4gICAgdGhpcy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMucGFydEhvbGRCYWNrID0gMDtcbiAgICB0aGlzLmhvbGRCYWNrID0gMDtcbiAgICB0aGlzLnBhcnRUYXJnZXQgPSAwO1xuICAgIHRoaXMucHJlbG9hZEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwO1xuICAgIHRoaXMudHVuZUluR29hbCA9IDA7XG4gICAgdGhpcy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRyaWZ0U3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRyaWZ0RW5kVGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0ID0gMDtcbiAgICB0aGlzLmRyaWZ0RW5kID0gMDtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0ge307XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICB9XG4gIHZhciBfcHJvdG8gPSBMZXZlbERldGFpbHMucHJvdG90eXBlO1xuICBfcHJvdG8ucmVsb2FkZWQgPSBmdW5jdGlvbiByZWxvYWRlZChwcmV2aW91cykge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIHZhciBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fCAhIXBhcnRJbmRleERpZmYgfHwgISFwYXJ0U25EaWZmO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKExldmVsRGV0YWlscywgW3tcbiAgICBrZXk6IFwiaGFzUHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxldmVsVGFyZ2V0RHVyYXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCB0aGlzLnRhcmdldGR1cmF0aW9uIHx8IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmlmdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgICBpZiAocnVuVGltZSA+IDApIHtcbiAgICAgICAgdmFyIHJ1bkR1cmF0aW9uID0gdGhpcy5kcmlmdEVuZCAtIHRoaXMuZHJpZnRTdGFydDtcbiAgICAgICAgcmV0dXJuIHJ1bkR1cmF0aW9uICogMTAwMCAvIHJ1blRpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJ0RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG4gICAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QgIT09IHZvaWQgMCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJhZ21lbnRFbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRmcmFnbWVudHM7XG4gICAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMgIT09IHZvaWQgMCAmJiBfdGhpcyRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5hZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChEYXRlLm5vdygpIC0gdGhpcy5hZHZhbmNlZERhdGVUaW1lLCAwKSAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdFBhcnRJbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHBhcnRMaXN0MjtcbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QyID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QyICE9PSB2b2lkIDAgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0UGFydFNuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuICAgICAgaWYgKChfdGhpcyRwYXJ0TGlzdDMgPSB0aGlzLnBhcnRMaXN0KSAhPT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdDMgIT09IHZvaWQgMCAmJiBfdGhpcyRwYXJ0TGlzdDMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbmRTTjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExldmVsRGV0YWlscztcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9sZXZlbC1rZXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkxldmVsS2V5XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIExldmVsS2V5KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2tleXN5c3RlbV91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9rZXlzeXN0ZW0tdXRpbCAqLyBcIi4vc3JjL3V0aWxzL2tleXN5c3RlbS11dGlsLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYWtleXMtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19udW1lcmljX2VuY29kaW5nX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9udW1lcmljLWVuY29kaW5nLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvbnVtZXJpYy1lbmNvZGluZy11dGlscy50c1wiKTtcblxuXG5cblxuXG52YXIga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xudmFyIExldmVsS2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgTGV2ZWxLZXkuY2xlYXJLZXlVcmlUb0tleUlkTWFwID0gZnVuY3Rpb24gY2xlYXJLZXlVcmlUb0tleUlkTWFwKCkge1xuICAgIGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbiAgfTtcbiAgZnVuY3Rpb24gTGV2ZWxLZXkobWV0aG9kLCB1cmksIGZvcm1hdCwgZm9ybWF0dmVyc2lvbnMsIGl2KSB7XG4gICAgaWYgKGZvcm1hdHZlcnNpb25zID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdHZlcnNpb25zID0gWzFdO1xuICAgIH1cbiAgICBpZiAoaXYgPT09IHZvaWQgMCkge1xuICAgICAgaXYgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnVyaSA9IHZvaWQgMDtcbiAgICB0aGlzLm1ldGhvZCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUZvcm1hdCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuZW5jcnlwdGVkID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDb21tb25FbmNyeXB0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmtleUlkID0gbnVsbDtcbiAgICB0aGlzLnBzc2ggPSBudWxsO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSBmb3JtYXR2ZXJzaW9ucztcbiAgICB0aGlzLml2ID0gaXY7XG4gICAgdGhpcy5lbmNyeXB0ZWQgPSBtZXRob2QgPyBtZXRob2QgIT09ICdOT05FJyA6IGZhbHNlO1xuICAgIHRoaXMuaXNDb21tb25FbmNyeXB0aW9uID0gdGhpcy5lbmNyeXB0ZWQgJiYgbWV0aG9kICE9PSAnQUVTLTEyOCc7XG4gIH1cbiAgdmFyIF9wcm90byA9IExldmVsS2V5LnByb3RvdHlwZTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgLy8gSWYgaXQncyBTZWdtZW50IGVuY3J5cHRpb24gb3IgTm8gZW5jcnlwdGlvbiwganVzdCBzZWxlY3QgdGhhdCBrZXkgc3lzdGVtXG4gICAgaWYgKHRoaXMubWV0aG9kKSB7XG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyB8fCB0aGlzLm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICBjYXNlICdpZGVudGl0eSc6XG4gICAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnO1xuICAgICAgICBjYXNlIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLktleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgIGNhc2UgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5LZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLktleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICAgICAgcmV0dXJuIFsnSVNPLTIzMDAxLTcnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnLCAnU0FNUExFLUFFUy1DVFInXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmdldERlY3J5cHREYXRhID0gZnVuY3Rpb24gZ2V0RGVjcnlwdERhdGEoc24pIHtcbiAgICBpZiAoIXRoaXMuZW5jcnlwdGVkIHx8ICF0aGlzLnVyaSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmIHRoaXMudXJpICYmICF0aGlzLml2KSB7XG4gICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjhcbiAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oXCJtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiIC0gY29tcGxpYW5jZSBpc3N1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCBzbiB0byByZXN1bHRpbmcgdmFsdWUgZnJvbSBpbXBsaWNpdCBjb252ZXJzaW9ucyAnaW5pdFNlZ21lbnQnIHZhbHVlcyBmb3IgSVYgZ2VuZXJhdGlvbi5cbiAgICAgICAgc24gPSAwO1xuICAgICAgfVxuICAgICAgdmFyIGl2ID0gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc24pO1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgJ2lkZW50aXR5JywgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucywgaXYpO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUga2V5SWQgaWYgcG9zc2libGVcbiAgICB2YXIga2V5Qnl0ZXMgPSAoMCxfdXRpbHNfa2V5c3lzdGVtX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5jb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcykodGhpcy51cmkpO1xuICAgIGlmIChrZXlCeXRlcykge1xuICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICBjYXNlIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICB0aGlzLnBzc2ggPSBrZXlCeXRlcztcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIHdpZGV2aW5lIGtleUlEIGlzIGVtYmVkZGVkIGluIFBTU0ggYm94LiBSZWFkIEtleSBJRC5cbiAgICAgICAgICBpZiAoa2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5Qnl0ZXMuc3ViYXJyYXkoa2V5Qnl0ZXMubGVuZ3RoIC0gMjIsIGtleUJ5dGVzLmxlbmd0aCAtIDYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLktleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBQbGF5UmVhZHlLZXlTeXN0ZW1VVUlEID0gbmV3IFVpbnQ4QXJyYXkoWzB4OWEsIDB4MDQsIDB4ZjAsIDB4NzksIDB4OTgsIDB4NDAsIDB4NDIsIDB4ODYsIDB4YWIsIDB4OTIsIDB4ZTYsIDB4NWIsIDB4ZTAsIDB4ODgsIDB4NWYsIDB4OTVdKTtcbiAgICAgICAgICAgIHRoaXMucHNzaCA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5tcDRwc3NoKShQbGF5UmVhZHlLZXlTeXN0ZW1VVUlELCBudWxsLCBrZXlCeXRlcyk7XG4gICAgICAgICAgICB2YXIga2V5Qnl0ZXNVdGYxNiA9IG5ldyBVaW50MTZBcnJheShrZXlCeXRlcy5idWZmZXIsIGtleUJ5dGVzLmJ5dGVPZmZzZXQsIGtleUJ5dGVzLmJ5dGVMZW5ndGggLyAyKTtcbiAgICAgICAgICAgIHZhciBrZXlCeXRlU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGtleUJ5dGVzVXRmMTYpKTtcblxuICAgICAgICAgICAgLy8gUGFyc2UgUGxheXJlYWR5IFdSTUhlYWRlciBYTUxcbiAgICAgICAgICAgIHZhciB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKGtleUJ5dGVTdHIuaW5kZXhPZignPCcpLCBrZXlCeXRlU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgdmFyIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sS2V5Qnl0ZXMsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgdmFyIGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleURhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIGtleUlkID0ga2V5RGF0YS5jaGlsZE5vZGVzWzBdID8ga2V5RGF0YS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA6IGtleURhdGEuZ2V0QXR0cmlidXRlKCdWQUxVRScpO1xuICAgICAgICAgICAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5SWRBcnJheSA9ICgwLF91dGlsc19udW1lcmljX2VuY29kaW5nX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uYmFzZTY0RGVjb2RlKShrZXlJZCkuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiBQUk8gaXMgYSBiYXNlNjQtZW5jb2RlZCBsaXR0bGUgZW5kaWFuIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiDigJh0ZW5j4oCZIGlzIGEgYmlnIGVuZGlhbiBVVUlEIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAgICgwLF91dGlsc19rZXlzeXN0ZW1fdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNoYW5nZUVuZGlhbm5lc3MpKGtleUlkQXJyYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlJZEFycmF5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGtleWRhdGEgPSBrZXlCeXRlcy5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgIHZhciBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgIHBhZGRlZC5zZXQoa2V5ZGF0YSwgMTYgLSBrZXlkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGtleWRhdGEgPSBwYWRkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5ZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBhc3NpZ24gYSBuZXcga2V5SWQgZm9yIGVhY2ggdXJpXG4gICAgaWYgKCF0aGlzLmtleUlkIHx8IHRoaXMua2V5SWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHZhciBfa2V5SWQgPSBrZXlVcmlUb0tleUlkTWFwW3RoaXMudXJpXTtcbiAgICAgIGlmICghX2tleUlkKSB7XG4gICAgICAgIHZhciB2YWwgPSBPYmplY3Qua2V5cyhrZXlVcmlUb0tleUlkTWFwKS5sZW5ndGggJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgX2tleUlkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoX2tleUlkLmJ1ZmZlciwgMTIsIDQpOyAvLyBKdXN0IHNldCB0aGUgbGFzdCA0IGJ5dGVzXG4gICAgICAgIGR2LnNldFVpbnQzMigwLCB2YWwpO1xuICAgICAgICBrZXlVcmlUb0tleUlkTWFwW3RoaXMudXJpXSA9IF9rZXlJZDtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5SWQgPSBfa2V5SWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4gTGV2ZWxLZXk7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKSB7XG4gIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAodmFyIGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICB1aW50OFZpZXdbaV0gPSBzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4Vmlldztcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJMb2FkU3RhdHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9hZFN0YXRzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgTG9hZFN0YXRzID0gZnVuY3Rpb24gTG9hZFN0YXRzKCkge1xuICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5sb2FkZWQgPSAwO1xuICB0aGlzLnJldHJ5ID0gMDtcbiAgdGhpcy50b3RhbCA9IDA7XG4gIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gIHRoaXMuYndFc3RpbWF0ZSA9IDA7XG4gIHRoaXMubG9hZGluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbiAgdGhpcy5wYXJzaW5nID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xuICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTTNVOFBhcnNlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGUtcmFuZ2UgKi8gXCIuL3NyYy9sb2FkZXIvZGF0ZS1yYW5nZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2RldGFpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtZGV0YWlscyAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hdHRyLWxpc3QgKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiKTtcblxuXG5cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuXG5cblxuXG5cblxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbnZhciBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLVNFU1NJT04tREFUQTooW15cXHJcXG5dKilbXFxyXFxuXSt8I0VYVC1YLVNFU1NJT04tS0VZOihbXlxcblxccl0qKVtcXHJcXG5dKy9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbi8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbi8oPyEjKSAqKFxcU1tcXFMgXSopLy5zb3VyY2UsXG4vLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuLyNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSxcbi8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4vI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSxcbi8vIG5leHQgc2VnbWVudCdzIHByb2dyYW0gZGF0ZS90aW1lIGdyb3VwIDUgPT4gdGhlIGRhdGV0aW1lIHNwZWNcbi8jLiovLnNvdXJjZSAvLyBBbGwgb3RoZXIgbm9uLXNlZ21lbnQgb3JpZW50ZWQgdGFncyB3aWxsIG1hdGNoIHdpdGggYWxsIGdyb3VwcyBlbXB0eVxuXS5qb2luKCd8JyksICdnJyk7XG52YXIgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IG5ldyBSZWdFeHAoWy8jKEVYVE0zVSkvLnNvdXJjZSwgLyNFWFQtWC0oREFURVJBTkdFfEtFWXxNQVB8UEFSVHxQQVJULUlORnxQTEFZTElTVC1UWVBFfFBSRUxPQUQtSElOVHxSRU5ESVRJT04tUkVQT1JUfFNFUlZFUi1DT05UUk9MfFNLSVB8U1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oQklUUkFURXxESVNDT05USU5VSVRZLVNFUVVFTkNFfE1FRElBLVNFUVVFTkNFfFRBUkdFVERVUkFUSU9OfFZFUlNJT04pOiAqKFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKERJU0NPTlRJTlVJVFl8RU5ETElTVHxHQVApLy5zb3VyY2UsIC8oIykoW146XSopOiguKikvLnNvdXJjZSwgLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlXS5qb2luKCd8JykpO1xudmFyIE0zVThQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNM1U4UGFyc2VyKCkge31cbiAgTTNVOFBhcnNlci5maW5kR3JvdXAgPSBmdW5jdGlvbiBmaW5kR3JvdXAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJID0gZnVuY3Rpb24gY29udmVydEFWQzFUb0FWQ09USShjb2RlYykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgdmFyIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYztcbiAgfTtcbiAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gKDAsdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5idWlsZEFic29sdXRlVVJMKShiYXNlVXJsLCB1cmwsIHtcbiAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgbGV2ZWxzV2l0aEtub3duQ29kZWNzID0gW107XG4gICAgdmFyIHNlc3Npb25EYXRhID0ge307XG4gICAgdmFyIHNlc3Npb25LZXlzID0gW107XG4gICAgdmFyIGhhc1Nlc3Npb25EYXRhID0gZmFsc2U7XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgICAgdmFyIF9sZXZlbCR1bmtub3duQ29kZWNzO1xuICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgdmFyIGF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5BdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgICB2YXIgbGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FLFxuICAgICAgICAgIHVybDogTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2RlY3MoKGF0dHJzLkNPREVDUyB8fCAnJykuc3BsaXQoL1sgLF0rLykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pLCBsZXZlbCk7XG4gICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjICYmIGxldmVsLnZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF9sZXZlbCR1bmtub3duQ29kZWNzID0gbGV2ZWwudW5rbm93bkNvZGVjcykgIT09IG51bGwgJiYgX2xldmVsJHVua25vd25Db2RlY3MgIT09IHZvaWQgMCAmJiBfbGV2ZWwkdW5rbm93bkNvZGVjcy5sZW5ndGgpKSB7XG4gICAgICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vICcjRVhULVgtU0VTU0lPTi1EQVRBJyBpcyBmb3VuZCwgcGFyc2Ugc2Vzc2lvbiBkYXRhIGluIGdyb3VwIDNcbiAgICAgICAgdmFyIHNlc3Npb25BdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uQXR0ckxpc3QocmVzdWx0WzNdKTtcbiAgICAgICAgaWYgKHNlc3Npb25BdHRyc1snREFUQS1JRCddKSB7XG4gICAgICAgICAgaGFzU2Vzc2lvbkRhdGEgPSB0cnVlO1xuICAgICAgICAgIHNlc3Npb25EYXRhW3Nlc3Npb25BdHRyc1snREFUQS1JRCddXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHtcbiAgICAgICAgLy8gJyNFWFQtWC1TRVNTSU9OLUtFWScgaXMgZm91bmRcbiAgICAgICAgdmFyIGtleVRhZyA9IHJlc3VsdFs0XTtcbiAgICAgICAgdmFyIHNlc3Npb25LZXkgPSBwYXJzZUtleShrZXlUYWcsIGJhc2V1cmwpO1xuICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgc2Vzc2lvbktleXMucHVzaChzZXNzaW9uS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18ubG9nZ2VyLndhcm4oXCJbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1TRVNTSU9OLUtFWSB0YWc6IFxcXCJcIiArIGtleVRhZyArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaWx0ZXIgb3V0IGxldmVscyB3aXRoIHVua25vd24gY29kZWNzIGlmIGl0IGRvZXMgbm90IHJlbW92ZSBhbGwgbGV2ZWxzXG4gICAgdmFyIHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzID0gbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA8IGxldmVscy5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPyBsZXZlbHNXaXRoS25vd25Db2RlY3MgOiBsZXZlbHMsXG4gICAgICBzZXNzaW9uRGF0YTogaGFzU2Vzc2lvbkRhdGEgPyBzZXNzaW9uRGF0YSA6IG51bGwsXG4gICAgICBzZXNzaW9uS2V5czogc2Vzc2lvbktleXMubGVuZ3RoID8gc2Vzc2lvbktleXMgOiBudWxsXG4gICAgfTtcbiAgfTtcbiAgTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlLCBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzID09PSB2b2lkIDApIHtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBtZWRpYXMgPSBbXTtcbiAgICB2YXIgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgIGlmIChhdHRycy5UWVBFID09PSB0eXBlKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHtcbiAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgICBncm91cElkOiBhdHRyc1snR1JPVVAtSUQnXSxcbiAgICAgICAgICBpbnN0cmVhbUlkOiBhdHRyc1snSU5TVFJFQU0tSUQnXSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGF0dHJzLkxBTkdVQUdFIHx8ICcnLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGF0dHJzLmJvb2woJ0FVVE9TRUxFQ1QnKSxcbiAgICAgICAgICBmb3JjZWQ6IGF0dHJzLmJvb2woJ0ZPUkNFRCcpLFxuICAgICAgICAgIGxhbmc6IGF0dHJzLkxBTkdVQUdFLFxuICAgICAgICAgIHVybDogYXR0cnMuVVJJID8gTTNVOFBhcnNlci5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCkgOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgdGhlIHRyYWNrIHNpZ25hbGxlZCwgbGV0cyB1c2UgdGhlIGZpcnN0IGF1ZGlvIGdyb3VwcyBjb2RlYyB3ZSBoYXZlXG4gICAgICAgICAgLy8gQWN0aW5nIGFzIGEgYmVzdCBndWVzc1xuICAgICAgICAgIHZhciBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICdhdWRpb0NvZGVjJyk7XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICd0ZXh0Q29kZWMnKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWRpYXM7XG4gIH07XG4gIE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0ID0gZnVuY3Rpb24gcGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgYmFzZXVybCwgaWQsIHR5cGUsIGxldmVsVXJsSWQpIHtcbiAgICB2YXIgbGV2ZWwgPSBuZXcgX2xldmVsX2RldGFpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5MZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50cztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgaW5pdCBzZWdtZW50IHNlZW4gKGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMpXG4gICAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdmFyIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICB2YXIgcHJldkZyYWcgPSBudWxsO1xuICAgIHZhciBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxldmVsa2V5cztcbiAgICB2YXIgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIHZhciBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3JlYXRlTmV4dEZyYWcpIHtcbiAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgICAgZnJhZyA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5GcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICAgICAgLy8gc2V0dXAgdGhlIG5leHQgZnJhZ21lbnQgZm9yIHBhcnQgbG9hZGluZ1xuICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgdmFyIHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY3VycmVudFNOKys7XG4gICAgICAgICAgY3VycmVudFBhcnQgPSAwO1xuICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHtcbiAgICAgICAgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgdmFyIGRhdGEgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5sb2dnZXIud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIHZhciB0YWcgPSAoJyAnICsgcmVzdWx0W2ldKS5zbGljZSgxKTtcbiAgICAgICAgdmFyIHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgdmFyIHZhbHVlMiA9IHJlc3VsdFtpICsgMl0gPyAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSkgOiAnJztcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU0tJUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBza2lwQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBza2lwcGVkU2VnbWVudHMgPSBza2lwQXR0cnMuZGVjaW1hbEludGVnZXIoJ1NLSVBQRUQtU0VHTUVOVFMnKTtcbiAgICAgICAgICAgICAgaWYgKCgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVzdWx0IGluIGZyYWdtZW50c1tdIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggd2Ugd2lsbCBmaWxsIGluIHdpdGggYG1lcmdlRGV0YWlsc2BcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gc2tpcEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGVSYW5nZUF0dHIgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2UgPSBuZXcgX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5EYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VBdHRyLklEXSk7XG4gICAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCB8fCBsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZS5pZF0gPSBkYXRlUmFuZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmxvZ2dlci53YXJuKFwiSWdub3JpbmcgaW52YWxpZCBEQVRFUkFOR0UgdGFnOiBcXFwiXCIgKyB2YWx1ZTEgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWRkIHRvIGZyYWdtZW50IHRhZyBsaXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoPCB2MS4yLjApXG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRVhULVgtREFURVJBTkdFJywgdmFsdWUxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRVUVOQ0UnOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsa2V5cykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSkge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gX2V4dGVuZHMoe30sIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdID0gbGV2ZWxLZXk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmxvZ2dlci53YXJuKFwiW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtS0VZIHRhZzogXFxcIlwiICsgdmFsdWUxICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0QXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgICAgICAvLyBUSU1FLU9GRlNFVCBjYW4gYmUgMFxuICAgICAgICAgICAgICBpZiAoKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBtYXBBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgaWYgKGZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGFmdGVyIHNlZ21lbnQgZHVyYXRpb24gdGFnLlxuICAgICAgICAgICAgICAgIC8vICAgI0VYVElORjogNi4wXG4gICAgICAgICAgICAgICAgLy8gICAjRVhULVgtTUFQOlVSST1cImluaXQubXA0XG4gICAgICAgICAgICAgICAgdmFyIGluaXQgPSBuZXcgX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoaW5pdCwgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSAmJiAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgc2VydmVyQ29udHJvbEF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5BdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5CbG9ja1JlbG9hZCA9IHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tQkxPQ0stUkVMT0FEJyk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdDQU4tU0tJUC1VTlRJTCcsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGxldmVsLmNhblNraXBVbnRpbCA+IDAgJiYgc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1TS0lQLURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydEhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ1BBUlQtSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0hPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0SW5mQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRUYXJnZXQgPSBwYXJ0SW5mQXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1BBUlQtVEFSR0VUJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdDtcbiAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNGcmFnbWVudFBhcnQgPSBjdXJyZW50UGFydCA+IDAgPyBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBuZXcgX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uUGFydChuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSksIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gKz0gcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUFJFTE9BRC1ISU5UJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHByZWxvYWRIaW50QXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyA9IGxldmVsLnJlbmRpdGlvblJlcG9ydHMgfHwgW107XG4gICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMucHVzaChyZW5kaXRpb25SZXBvcnRBdHRycyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18ubG9nZ2VyLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2RnJhZyAmJiAhcHJldkZyYWcucmVsdXJsKSB7XG4gICAgICBmcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IHByZXZGcmFnLmR1cmF0aW9uO1xuICAgICAgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IHByZXZGcmFnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBmcmFnO1xuICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIHZhciBmaXJzdEZyYWdtZW50ID0gZnJhZ21lbnRzWzBdO1xuICAgIHZhciBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmICh0b3RhbGR1cmF0aW9uID4gMCAmJiBmcmFnbWVudExlbmd0aCAmJiBsYXN0RnJhZ21lbnQpIHtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgIHZhciBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICBsZXZlbC5lbmRTTiA9IGxhc3RTbiAhPT0gJ2luaXRTZWdtZW50JyA/IGxhc3RTbiA6IDA7XG4gICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbDtcbiAgfTtcbiAgcmV0dXJuIE0zVThQYXJzZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHBhcnNlS2V5KGtleVRhZywgYmFzZXVybCkge1xuICB2YXIgX2tleUF0dHJzJGVudW1lcmF0ZWRTLCBfa2V5QXR0cnMkZW51bWVyYXRlZFMyO1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODIxNiNzZWN0aW9uLTQuMy4yLjRcbiAgdmFyIGtleUF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5BdHRyTGlzdChrZXlUYWcpO1xuICB2YXIgZGVjcnlwdG1ldGhvZCA9IChfa2V5QXR0cnMkZW51bWVyYXRlZFMgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKSkgIT0gbnVsbCA/IF9rZXlBdHRycyRlbnVtZXJhdGVkUyA6ICcnO1xuICB2YXIgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgdmFyIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgdmFyIGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0tFWUZPUk1BVFZFUlNJT05TJyk7XG4gIC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cbiAgdmFyIGRlY3J5cHRrZXlmb3JtYXQgPSAoX2tleUF0dHJzJGVudW1lcmF0ZWRTMiA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0tFWUZPUk1BVCcpKSAhPSBudWxsID8gX2tleUF0dHJzJGVudW1lcmF0ZWRTMiA6ICdpZGVudGl0eSc7XG4gIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18ubG9nZ2VyLmVycm9yKFwiSW52YWxpZCBJVjogXCIgKyBrZXlBdHRycy5JVik7XG4gIH1cbiAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gIC8vIE5vIHVyaSBpcyBhbGxvd2VkIHdoZW4gTUVUSE9EIGlzIE5PTkVcbiAgdmFyIHJlc29sdmVkVXJpID0gZGVjcnlwdHVyaSA/IE0zVThQYXJzZXIucmVzb2x2ZShkZWNyeXB0dXJpLCBiYXNldXJsKSA6ICcnO1xuICB2YXIga2V5Rm9ybWF0VmVyc2lvbnMgPSAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID8gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIDogJzEnKS5zcGxpdCgnLycpLm1hcChOdW1iZXIpLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuICByZXR1cm4gbmV3IF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5MZXZlbEtleShkZWNyeXB0bWV0aG9kLCByZXNvbHZlZFVyaSwgZGVjcnlwdGtleWZvcm1hdCwga2V5Rm9ybWF0VmVyc2lvbnMsIGRlY3J5cHRpdik7XG59XG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzLCBsZXZlbCkge1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiAoMCxfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uaXNDb2RlY1R5cGUpKGNvZGVjLCB0eXBlKTtcbiAgICB9KTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcHJlZmVycmVkID0gZmlsdGVyZWQuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgfSk7XG4gICAgICBsZXZlbFt0eXBlICsgXCJDb2RlY1wiXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07XG5cbiAgICAgIC8vIHJlbW92ZSBmcm9tIGxpc3RcbiAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5pbmRleE9mKGNvZGVjKSA9PT0gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xufVxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICB2YXIgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpIHtcbiAgdmFyIGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICBmb3IgKHZhciBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIC8vIEV4aXQgb24gZGVsdGEtcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSAtIGZyYWcuZHVyYXRpb24gKiAxMDAwO1xuICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKSB7XG4gIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZShmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gIH0gZWxzZSBpZiAocHJldkZyYWcgIT09IG51bGwgJiYgcHJldkZyYWcgIT09IHZvaWQgMCAmJiBwcmV2RnJhZy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgfVxuICBpZiAoISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpIHtcbiAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG4gIGZyYWcubGV2ZWwgPSBpZDtcbiAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gIGlmIChsZXZlbGtleXMpIHtcbiAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgfVxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCkge1xuICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgdmFyIGVuY3J5cHRlZEZyYWdtZW50cyA9IGxldmVsLmVuY3J5cHRlZEZyYWdtZW50cztcbiAgaWYgKCghZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCB8fCBlbmNyeXB0ZWRGcmFnbWVudHNbZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT0gbGV2ZWxrZXlzKSAmJiBPYmplY3Qua2V5cyhsZXZlbGtleXMpLnNvbWUoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBsZXZlbGtleXNbZm9ybWF0XS5pc0NvbW1vbkVuY3J5cHRpb247XG4gIH0pKSB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL20zdTgtcGFyc2VyICovIFwiLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hdHRyLWxpc3QgKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIik7XG5cblxuLyoqXG4gKiBQbGF5bGlzdExvYWRlciAtIGRlbGVnYXRlIGZvciBtZWRpYSBtYW5pZmVzdC9wbGF5bGlzdCBsb2FkaW5nIHRhc2tzLiBUYWtlcyBjYXJlIG9mIHBhcnNpbmcgbWVkaWEgdG8gaW50ZXJuYWwgZGF0YS1tb2RlbHMuXG4gKlxuICogT25jZSBsb2FkZWQsIGRpc3BhdGNoZXMgZXZlbnRzIHdpdGggcGFyc2VkIGRhdGEtbW9kZWxzIG9mIG1hbmlmZXN0L2xldmVscy9hdWRpby9zdWJ0aXRsZSB0cmFja3MuXG4gKlxuICogVXNlcyBsb2FkZXIocykgc2V0IGluIGNvbmZpZyB0byBkbyBhY3R1YWwgaW50ZXJuYWwgbG9hZGluZyBvZiByZXNvdXJjZSB0YXNrcy5cbiAqXG4gKiBAbW9kdWxlXG4gKlxuICovXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KSB7XG4gIHZhciB0eXBlID0gY29udGV4dC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCkge1xuICB2YXIgdXJsID0gcmVzcG9uc2UudXJsO1xuICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxudmFyIFBsYXlsaXN0TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxheWxpc3RMb2FkZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgdmFyIF9wcm90byA9IFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fTtcbiAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH07XG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH07XG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHRzIG9yIGNvbmZpZ3VyZWQgbG9hZGVyLXR5cGUgb3ZlcmxvYWRzIChwTG9hZGVyIGFuZCBsb2FkZXIgY29uZmlnIHBhcmFtcylcbiAgICovO1xuICBfcHJvdG8uY3JlYXRlSW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICB2YXIgUExvYWRlciA9IGNvbmZpZy5wTG9hZGVyO1xuICAgIHZhciBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHZhciBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcbiAgICBjb250ZXh0LmxvYWRlciA9IGxvYWRlcjtcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9O1xuICBfcHJvdG8uZ2V0SW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9O1xuICBfcHJvdG8ucmVzZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqLztcbiAgX3Byb3RvLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMgPSBmdW5jdGlvbiBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCkge1xuICAgIGZvciAodmFyIGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9O1xuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciB1cmwgPSBkYXRhLnVybDtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBncm91cElkOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG51bGxcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgbGV2ZWwgPSBkYXRhLmxldmVsLFxuICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogbnVsbCxcbiAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICBncm91cElkID0gZGF0YS5ncm91cElkLFxuICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja0xvYWRpbmcgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICB1cmwgPSBkYXRhLnVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoY29udGV4dCkge1xuICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmU7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLnRyYWNlKCdbcGxheWxpc3QtbG9hZGVyXTogcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5sb2dnZXIubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogXCIgKyBjb250ZXh0LnR5cGUpO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHZhciBtYXhSZXRyeTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgcmV0cnlEZWxheTtcbiAgICB2YXIgbWF4UmV0cnlEZWxheTtcblxuICAgIC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIC8vIE1hbmFnZSByZXRyaWVzIGluIExldmVsL1RyYWNrIENvbnRyb2xsZXJcbiAgICAgICAgbWF4UmV0cnkgPSAwO1xuICAgICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAvLyAodGhlIGRlZmF1bHQgb2YgMTAwMDBtcyBpcyBjb3VudGVyIHByb2R1Y3RpdmUgdG8gYmxvY2tpbmcgcGxheWxpc3QgcmVsb2FkIHJlcXVlc3RzKVxuICAgIGlmICgoX2NvbnRleHQkZGVsaXZlcnlEaXJlID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpICE9PSBudWxsICYmIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZSAhPT0gdm9pZCAwICYmIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZS5wYXJ0KSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzO1xuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICB2YXIgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIGlmIChwYXJ0VGFyZ2V0ICYmIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgdGltZW91dCA9IE1hdGgubWluKE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIG1heFJldHJ5OiBtYXhSZXRyeSxcbiAgICAgIHJldHJ5RGVsYXk6IHJldHJ5RGVsYXksXG4gICAgICBtYXhSZXRyeURlbGF5OiBtYXhSZXRyeURlbGF5LFxuICAgICAgaGlnaFdhdGVyTWFyazogMFxuICAgIH07XG4gICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH07XG4gIF9wcm90by5sb2Fkc3VjY2VzcyA9IGZ1bmN0aW9uIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgbmV0d29ya0RldGFpbHMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcblxuICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBFWFRNM1UgZGVsaW1pdGVyJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gQ2hlY2sgaWYgY2h1bmstbGlzdCBvciBtYXN0ZXIuIGhhbmRsZSBlbXB0eSBjaHVuayBsaXN0IGNhc2UgKGZpcnN0IEVYVElORiBub3Qgc2lnbmFsZWQsIGJ1dCBUQVJHRVREVVJBVElPTiBwcmVzZW50KVxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDAgfHwgc3RyaW5nLmluZGV4T2YoJyNFWFQtWC1UQVJHRVREVVJBVElPTjonKSA+IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubG9hZGVycm9yID0gZnVuY3Rpb24gbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXR3b3JrRGV0YWlscyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UpO1xuICB9O1xuICBfcHJvdG8ubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgbmV0d29ya0RldGFpbHMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSk7XG4gIH07XG4gIF9wcm90by5oYW5kbGVNYXN0ZXJQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICB2YXIgX00zVThQYXJzZXIkcGFyc2VNYXN0ID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpLFxuICAgICAgbGV2ZWxzID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LmxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LnNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMgPSBfTTNVOFBhcnNlciRwYXJzZU1hc3Quc2Vzc2lvbktleXM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cbiAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzdWJ0aXRsZUdyb3VwcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlY1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0ucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nLCBhdWRpb0dyb3Vwcyk7XG4gICAgdmFyIHN1YnRpdGxlcyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXS5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnLCBzdWJ0aXRsZUdyb3Vwcyk7XG4gICAgdmFyIGNhcHRpb25zID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0NMT1NFRC1DQVBUSU9OUycpO1xuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgcmV0dXJuICFhdWRpb1RyYWNrLnVybDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICBpZiAoIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5sb2dnZXIubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgYXR0cnM6IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uQXR0ckxpc3Qoe30pLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgdXJsOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVsczogbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzOiBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9uczogY2FwdGlvbnMsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHNlc3Npb25EYXRhOiBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzOiBzZXNzaW9uS2V5c1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QgPSBmdW5jdGlvbiBoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBpZCA9IGNvbnRleHQuaWQsXG4gICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuICAgIHZhciB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgdmFyIGxldmVsVXJsSWQgPSAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGlkKSA/IGlkIDogMDtcbiAgICB2YXIgbGV2ZWxJZCA9ICgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikobGV2ZWwpID8gbGV2ZWwgOiBsZXZlbFVybElkO1xuICAgIHZhciBsZXZlbFR5cGUgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgdmFyIGxldmVsRGV0YWlscyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXS5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIGxldmVsVXJsSWQpO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gZnJhZ21lbnRzIGZvdW5kIGluIGxldmVsJyxcbiAgICAgICAgbGV2ZWw6IHR5cGVvZiBjb250ZXh0LmxldmVsID09PSAnbnVtYmVyJyA/IGNvbnRleHQubGV2ZWwgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICB2YXIgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgIGF0dHJzOiBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkF0dHJMaXN0KHt9KSxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgc2Vzc2lvbktleXM6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgc3RhdHMucGFyc2luZy5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XG4gICAgY29udGV4dC5sZXZlbERldGFpbHMgPSBsZXZlbERldGFpbHM7XG4gICAgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgfTtcbiAgX3Byb3RvLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIHJlYXNvbiwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5oYW5kbGVOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGltZW91dCA9IGZhbHNlO1xuICAgIH1cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ubG9nZ2VyLndhcm4oXCJbcGxheWxpc3QtbG9hZGVyXTogQSBuZXR3b3JrIFwiICsgKHRpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InKSArIFwiIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgXCIgKyBjb250ZXh0LnR5cGUgKyBcIiBsZXZlbDogXCIgKyBjb250ZXh0LmxldmVsICsgXCIgaWQ6IFwiICsgY29udGV4dC5pZCArIFwiIGdyb3VwLWlkOiBcXFwiXCIgKyBjb250ZXh0Lmdyb3VwSWQgKyBcIlxcXCJcIik7XG4gICAgdmFyIGRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLlVOS05PV047XG4gICAgdmFyIGZhdGFsID0gZmFsc2U7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUIDogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5FcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cbiAgICB2YXIgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICBmYXRhbDogZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgfTtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gIH07XG4gIF9wcm90by5oYW5kbGVQbGF5bGlzdExvYWRlZCA9IGZ1bmN0aW9uIGhhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcbiAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgIGdyb3VwSWQgPSBjb250ZXh0Lmdyb3VwSWQsXG4gICAgICBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcixcbiAgICAgIGxldmVsRGV0YWlscyA9IGNvbnRleHQubGV2ZWxEZXRhaWxzLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgaWYgKCEobGV2ZWxEZXRhaWxzICE9PSBudWxsICYmIGxldmVsRGV0YWlscyAhPT0gdm9pZCAwICYmIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdpbnZhbGlkIHRhcmdldCBkdXJhdGlvbicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBpZiAobG9hZGVyLmdldENhY2hlQWdlKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSBsb2FkZXIuZ2V0Q2FjaGVBZ2UoKSB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKCFsb2FkZXIuZ2V0Q2FjaGVBZ2UgfHwgaXNOYU4obGV2ZWxEZXRhaWxzLmFnZUhlYWRlcikpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLlBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkV2ZW50cy5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5QbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5FdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFBsYXlsaXN0TG9hZGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BvbHlmaWxscy9udW1iZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIk1BWF9TQUZFX0lOVEVHRVJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTUFYX1NBRkVfSU5URUdFUiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaXNGaW5pdGVOdW1iZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNGaW5pdGVOdW1iZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbnZhciBpc0Zpbml0ZU51bWJlciA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvYWFjLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L2FhYy1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqICBBQUMgaGVscGVyXG4gKi9cbnZhciBBQUMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBQUMoKSB7fVxuICBBQUMuZ2V0U2lsZW50RnJhbWUgPSBmdW5jdGlvbiBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuICByZXR1cm4gQUFDO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChBQUMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuICovXG5cbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBNUDQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDQoKSB7fVxuICBNUDQuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sXG4gICAgICAvLyBjb2RpbmduYW1lXG4gICAgICBhdmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICAnLm1wMyc6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHBhc3A6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSwgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICB2aWRlbzogdmlkZW9IZGxyLFxuICAgICAgYXVkaW86IGF1ZGlvSGRsclxuICAgIH07XG4gICAgdmFyIGRyZWYgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBlbnRyeV9jb3VudFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsXG4gICAgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgLy8gJ3VybCcgdHlwZVxuICAgIDB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuXG4gICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgXSk7XG5cbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBiYWxhbmNlXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuXG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICB2YXIgYXZjMUJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzk3LCAxMTgsIDk5LCA0OV0pOyAvLyBhdmMxXG4gICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH07XG4gIE1QNC5ib3ggPSBmdW5jdGlvbiBib3godHlwZSkge1xuICAgIHZhciBzaXplID0gODtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF5bG9hZCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXlsb2FkW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICB2YXIgbGVuID0gaTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgTVA0LmhkbHIgPSBmdW5jdGlvbiBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9O1xuICBNUDQubWRhdCA9IGZ1bmN0aW9uIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfTtcbiAgTVA0Lm1kaGQgPSBmdW5jdGlvbiBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHZhciBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHg1NSwgMHhjNCxcbiAgICAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgIDB4MDAsIDB4MDBdKSk7XG4gIH07XG4gIE1QNC5tZGlhID0gZnVuY3Rpb24gbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH07XG4gIE1QNC5tZmhkID0gZnVuY3Rpb24gbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9O1xuICBNUDQubWluZiA9IGZ1bmN0aW9uIG1pbmYodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH1cbiAgfTtcbiAgTVA0Lm1vb2YgPSBmdW5jdGlvbiBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHRyYWNrcy4uLiAob3B0aW9uYWwpIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICAgKi87XG4gIE1QNC5tb292ID0gZnVuY3Rpb24gbW9vdih0cmFja3MpIHtcbiAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgdmFyIGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfTtcbiAgTVA0Lm12ZXggPSBmdW5jdGlvbiBtdmV4KHRyYWNrcykge1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICB2YXIgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH07XG4gIE1QNC5tdmhkID0gZnVuY3Rpb24gbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAvLyAxLjAgcmF0ZVxuICAgIDB4MDEsIDB4MDAsXG4gICAgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH07XG4gIE1QNC5zZHRwID0gZnVuY3Rpb24gc2R0cCh0cmFjaykge1xuICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIHZhciBpO1xuICAgIHZhciBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH07XG4gIE1QNC5zdGJsID0gZnVuY3Rpb24gc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH07XG4gIE1QNC5hdmMxID0gZnVuY3Rpb24gYXZjMSh0cmFjaykge1xuICAgIHZhciBzcHMgPSBbXTtcbiAgICB2YXIgcHBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgIC8vIFNQU1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBwcHMucHVzaChsZW4gJiAweGZmKTtcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cbiAgICB2YXIgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb25cbiAgICBzcHNbM10sXG4gICAgLy8gcHJvZmlsZVxuICAgIHNwc1s0XSxcbiAgICAvLyBwcm9maWxlIGNvbXBhdFxuICAgIHNwc1s1XSxcbiAgICAvLyBsZXZlbFxuICAgIDB4ZmMgfCAzLFxuICAgIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcbiAgICB2YXIgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIHZhciBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgdmFyIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgLy8gaGVpZ2h0XG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLFxuICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAweDAwLCAweDE4LFxuICAgIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksXG4gICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksXG4gICAgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAvLyBoU3BhY2luZ1xuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9O1xuICBNUDQuZXNkcyA9IGZ1bmN0aW9uIGVzZHModHJhY2spIHtcbiAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuXG4gICAgMHgwMyxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDE3ICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZXNfaWRcbiAgICAweDAwLFxuICAgIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgMHgwNCxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDBmICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4NDAsXG4gICAgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsXG4gICAgLy8gc3RyZWFtX3R5cGVcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBhdmdCaXRyYXRlXG5cbiAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfTtcbiAgTVA0Lm1wNGEgPSBmdW5jdGlvbiBtcDRhKHRyYWNrKSB7XG4gICAgdmFyIHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCxcbiAgICAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLFxuICAgIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZDJcbiAgICBzYW1wbGVyYXRlID4+IDggJiAweGZmLCBzYW1wbGVyYXRlICYgMHhmZixcbiAgICAvL1xuICAgIDB4MDAsIDB4MDBdKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH07XG4gIE1QNC5tcDMgPSBmdW5jdGlvbiBtcDModHJhY2spIHtcbiAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgIC8vIGNoYW5uZWxjb3VudFxuICAgIDB4MDAsIDB4MTAsXG4gICAgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgIC8vXG4gICAgMHgwMCwgMHgwMF0pKTtcbiAgfTtcbiAgTVA0LnN0c2QgPSBmdW5jdGlvbiBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfTtcbiAgTVA0LnRraGQgPSBmdW5jdGlvbiB0a2hkKHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGU7XG4gICAgdmFyIHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDA3LFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIGlkID4+IDI0ICYgMHhmZiwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLFxuICAgIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGxheWVyXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgMHgwMCwgMHgwMCxcbiAgICAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH07XG4gIE1QNC50cmFmID0gZnVuY3Rpb24gdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiAvLyB0cmFja19JRFxuICAgIF0pKSwgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmXSkpLCBNUDQudHJ1bih0cmFjaywgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIDE2ICtcbiAgICAvLyB0ZmhkXG4gICAgMjAgK1xuICAgIC8vIHRmZHRcbiAgICA4ICtcbiAgICAvLyB0cmFmIGhlYWRlclxuICAgIDE2ICtcbiAgICAvLyBtZmhkXG4gICAgOCArXG4gICAgLy8gbW9vZiBoZWFkZXJcbiAgICA4KSxcbiAgICAvLyBtZGF0IGhlYWRlclxuICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgKi87XG4gIE1QNC50cmFrID0gZnVuY3Rpb24gdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9O1xuICBNUDQudHJleCA9IGZ1bmN0aW9uIHRyZXgodHJhY2spIHtcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH07XG4gIE1QNC50cnVuID0gZnVuY3Rpb24gdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIHZhciBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICB2YXIgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2FtcGxlO1xuICAgIHZhciBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgZmxhZ3M7XG4gICAgdmFyIGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IDB4MDEgOiAweDAwLFxuICAgIC8vIHZlcnNpb24gMSBmb3IgdmlkZW8gd2l0aCBzaWduZWQtaW50IHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgIDB4MDAsIDB4MGYsIDB4MDEsXG4gICAgLy8gZmxhZ3NcbiAgICBsZW4gPj4+IDI0ICYgMHhmZiwgbGVuID4+PiAxNiAmIDB4ZmYsIGxlbiA+Pj4gOCAmIDB4ZmYsIGxlbiAmIDB4ZmYsXG4gICAgLy8gc2FtcGxlX2NvdW50XG4gICAgb2Zmc2V0ID4+PiAyNCAmIDB4ZmYsIG9mZnNldCA+Pj4gMTYgJiAweGZmLCBvZmZzZXQgPj4+IDggJiAweGZmLCBvZmZzZXQgJiAweGZmIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwgMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICBzaXplID4+PiAyNCAmIDB4ZmYsIHNpemUgPj4+IDE2ICYgMHhmZiwgc2l6ZSA+Pj4gOCAmIDB4ZmYsIHNpemUgJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX3NpemVcbiAgICAgIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxIHwgZmxhZ3MuaXNOb25TeW5jLCBmbGFncy5kZWdyYWRQcmlvICYgMHhmMCA8PCA4LCBmbGFncy5kZWdyYWRQcmlvICYgMHgwZixcbiAgICAgIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9O1xuICBNUDQuaW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiBNUDQ7XG59KCk7XG5NUDQudHlwZXMgPSB2b2lkIDA7XG5NUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbk1QNC5TVFRTID0gdm9pZCAwO1xuTVA0LlNUU0MgPSB2b2lkIDA7XG5NUDQuU1RDTyA9IHZvaWQgMDtcbk1QNC5TVFNaID0gdm9pZCAwO1xuTVA0LlZNSEQgPSB2b2lkIDA7XG5NUDQuU01IRCA9IHZvaWQgMDtcbk1QNC5TVFNEID0gdm9pZCAwO1xuTVA0LkZUWVAgPSB2b2lkIDA7XG5NUDQuRElORiA9IHZvaWQgMDtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoTVA0KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIE1QNFJlbXV4ZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwibm9ybWFsaXplUHRzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG5vcm1hbGl6ZVB0cylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhYy1oZWxwZXIgKi8gXCIuL3NyYy9yZW11eC9hYWMtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC1nZW5lcmF0b3IgKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5cblxuXG5cblxuXG52YXIgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xudmFyIEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG52YXIgTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FID0gMTE1MjtcbnZhciBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbnZhciBzYWZhcmlXZWJraXRWZXJzaW9uID0gbnVsbDtcbnZhciBNUDRSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0UmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcbiAgICBpZiAodmVuZG9yID09PSB2b2lkIDApIHtcbiAgICAgIHZlbmRvciA9ICcnO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdFBUUyA9IHZvaWQgMDtcbiAgICB0aGlzLl9pbml0RFRTID0gdm9pZCAwO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG51bGw7XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBudWxsO1xuICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdmFyIF9yZXN1bHQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKykvaSk7XG4gICAgICBzYWZhcmlXZWJraXRWZXJzaW9uID0gX3Jlc3VsdCA/IHBhcnNlSW50KF9yZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcm90byA9IE1QNFJlbXV4ZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBpbml0UFRTICYgaW5pdERUUyByZXNldCcpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfTtcbiAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogcmVzZXQgbmV4dCB0aW1lc3RhbXAnKTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICB9O1xuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH07XG4gIF9wcm90by5nZXRWaWRlb1N0YXJ0UHRzID0gZnVuY3Rpb24gZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpIHtcbiAgICB2YXIgcm9sbG92ZXJEZXRlY3RlZCA9IGZhbHNlO1xuICAgIHZhciBzdGFydFBUUyA9IHZpZGVvU2FtcGxlcy5yZWR1Y2UoZnVuY3Rpb24gKG1pblBUUywgc2FtcGxlKSB7XG4gICAgICB2YXIgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUHRzKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIuZGVidWcoJ1BUUyByb2xsb3ZlciBkZXRlY3RlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRQVFM7XG4gIH07XG4gIF9wcm90by5yZW11eCA9IGZ1bmN0aW9uIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIHZhciB2aWRlbztcbiAgICB2YXIgYXVkaW87XG4gICAgdmFyIGluaXRTZWdtZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBpZDM7XG4gICAgdmFyIGluZGVwZW5kZW50O1xuICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHZhciB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICB2YXIgaGFzQXVkaW8gPSBhdWRpb1RyYWNrLnBpZCA+IC0xO1xuICAgIHZhciBoYXNWaWRlbyA9IHZpZGVvVHJhY2sucGlkID4gLTE7XG4gICAgdmFyIGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgdmFyIGVub3VnaEF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggPiAwO1xuICAgIHZhciBlbm91Z2hWaWRlb1NhbXBsZXMgPSBmbHVzaCAmJiBsZW5ndGggPiAwIHx8IGxlbmd0aCA+IDE7XG4gICAgdmFyIGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgdmFyIGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lSW5kZXggPSAtMTtcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG4gICAgICAgICAgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIud2FybihcIlttcDQtcmVtdXhlcl06IERyb3BwZWQgXCIgKyBmaXJzdEtleUZyYW1lSW5kZXggKyBcIiBvdXQgb2YgXCIgKyBsZW5ndGggKyBcIiB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVcIik7XG4gICAgICAgICAgICB2YXIgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5zbGljZShmaXJzdEtleUZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkICs9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSAodmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHN0YXJ0UFRTKSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICBmaXJzdEtleUZyYW1lUFRTID0gdmlkZW9UaW1lT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci53YXJuKFwiW21wNC1yZW11eGVyXTogTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlc1wiKTtcbiAgICAgICAgICAgIGluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgIHZhciBfc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICB2YXIgdHNEZWx0YSA9IG5vcm1hbGl6ZVB0cyhhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzLCBfc3RhcnRQVFMpIC0gX3N0YXJ0UFRTO1xuICAgICAgICAgIHZhciBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEgPSB0c0RlbHRhIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICBhdWRpb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCBhdWRpbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF1ZGlvID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgdGhpcy5pc0F1ZGlvQ29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBoYXNWaWRlbyB8fCBlbm91Z2hWaWRlb1NhbXBsZXMgfHwgcGxheWxpc3RUeXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gPyB2aWRlb1RpbWVPZmZzZXQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW8gPyBhdWRpby5lbmRQVFMgLSBhdWRpby5zdGFydFBUUyA6IDA7XG4gICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lUFRTID0gZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IElEMyBhbmQgdGV4dCB0byByZW11eCwgZXZlbiBpZiBtb3JlIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgYXJlIHJlcXVpcmVkXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBpZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUywgdGhpcy5faW5pdERUUyk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuX2luaXRQVFMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGF1ZGlvLFxuICAgICAgdmlkZW86IHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgaW5kZXBlbmRlbnQ6IGluZGVwZW5kZW50LFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlkMzogaWQzXG4gICAgfTtcbiAgfTtcbiAgX3Byb3RvLmdlbmVyYXRlSVMgPSBmdW5jdGlvbiBnZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzO1xuICAgIHZhciB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgdmFyIHRyYWNrcyA9IHt9O1xuICAgIHZhciBjb21wdXRlUFRTRFRTID0gISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikodGhpcy5faW5pdFBUUyk7XG4gICAgdmFyIGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIHZhciBpbml0UFRTO1xuICAgIHZhciBpbml0RFRTO1xuICAgIHZhciB0aW1lc2NhbGU7XG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCBub3JtYWxpemVQdHModmlkZW9TYW1wbGVzWzBdLmR0cywgc3RhcnRQVFMpIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3M6IHRyYWNrcyxcbiAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucmVtdXhWaWRlbyA9IGZ1bmN0aW9uIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICB2YXIgdGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgdmFyIG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICB2YXIgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgdmFyIG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgdmFyIG9mZnNldCA9IDg7XG4gICAgdmFyIG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uO1xuICAgIHZhciBmaXJzdERUUztcbiAgICB2YXIgbGFzdERUUztcbiAgICB2YXIgbWluUFRTID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhQVFMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdmNEdHMgPT09IG51bGwpIHtcbiAgICAgIHZhciBwdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgdmFyIGN0cyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBub3JtYWxpemVQdHMoaW5wdXRTYW1wbGVzWzBdLmR0cywgaW5wdXRTYW1wbGVzWzBdLnB0cyk7XG4gICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICBuZXh0QXZjRHRzID0gcHRzIC0gY3RzO1xuICAgIH1cblxuICAgIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgICAvLyBQVFNOb3JtYWxpemUgd2lsbCBtYWtlIFBUUy9EVFMgdmFsdWUgbW9ub3RvbmljLCB3ZSB1c2UgbGFzdCBrbm93biBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlIHZhbHVlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgICBpZiAoc2FtcGxlLmR0cyA8IGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzKSB7XG4gICAgICAgIHNvcnRTYW1wbGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICBpZiAoc29ydFNhbXBsZXMpIHtcbiAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIHZhciBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBmaXJzdC9sYXN0IERUU1xuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAvLyBTYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIHZhciBpbnB1dER1cmF0aW9uID0gbGFzdERUUyAtIGZpcnN0RFRTO1xuICAgIHZhciBhdmVyYWdlU2FtcGxlRHVyYXRpb24gPSBpbnB1dER1cmF0aW9uID8gTWF0aC5yb3VuZChpbnB1dER1cmF0aW9uIC8gKG5iU2FtcGxlcyAtIDEpKSA6IG1wNFNhbXBsZUR1cmF0aW9uIHx8IHRyYWNrLmlucHV0VGltZVNjYWxlIC8gMzA7XG5cbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgICB2YXIgZGVsdGEgPSBmaXJzdERUUyAtIG5leHRBdmNEdHM7XG4gICAgICB2YXIgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICB2YXIgZm91bmRPdmVybGFwID0gZGVsdGEgPCAtMTtcbiAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubG9nZ2VyLndhcm4oXCJBVkM6IFwiICsgKDAsX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18udG9Nc0Zyb21NcGVnVHNDbG9jaykoZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubG9nZ2VyLndhcm4oXCJBVkM6IFwiICsgKDAsX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18udG9Nc0Zyb21NcGVnVHNDbG9jaykoLWRlbHRhLCB0cnVlKSArIFwiIG1zIChcIiArIGRlbHRhICsgXCJkdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRPdmVybGFwIHx8IG5leHRBdmNEdHMgPiBpbnB1dFNhbXBsZXNbMF0ucHRzKSB7XG4gICAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICAgIHZhciBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIubG9nKFwiVmlkZW86IEZpcnN0IFBUUy9EVFMgYWRqdXN0ZWQ6IFwiICsgKDAsX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18udG9Nc0Zyb21NcGVnVHNDbG9jaykoZmlyc3RQVFMsIHRydWUpICsgXCIvXCIgKyAoMCxfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy50b01zRnJvbU1wZWdUc0Nsb2NrKShmaXJzdERUUywgdHJ1ZSkgKyBcIiwgZGVsdGE6IFwiICsgKDAsX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18udG9Nc0Zyb21NcGVnVHNDbG9jaykoZGVsdGEsIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBmaXJzdERUUyk7XG4gICAgdmFyIG5iTmFsdSA9IDA7XG4gICAgdmFyIG5hbHVMZW4gPSAwO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuYlNhbXBsZXM7IF9pKyspIHtcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgdmFyIF9zYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2ldO1xuICAgICAgdmFyIHVuaXRzID0gX3NhbXBsZS51bml0cztcbiAgICAgIHZhciBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgdmFyIHNhbXBsZUxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgX3NhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgX3NhbXBsZS5kdHMgPSBNYXRoLm1heChfc2FtcGxlLmR0cywgZmlyc3REVFMpO1xuICAgICAgbWluUFRTID0gTWF0aC5taW4oX3NhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgdmFyIG1kYXRTaXplID0gbmFsdUxlbiArIDQgKiBuYk5hbHUgKyA4O1xuICAgIHZhciBtZGF0O1xuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yVHlwZXMuTVVYX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0IFwiICsgbWRhdFNpemVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgIG1kYXQuc2V0KF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLnR5cGVzLm1kYXQsIDQpO1xuICAgIHZhciBzdHJldGNoZWRMYXN0RnJhbWUgPSBmYWxzZTtcbiAgICB2YXIgbWluRHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pblB0c0RlbHRhID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhEdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4UHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmJTYW1wbGVzOyBfaTIrKykge1xuICAgICAgdmFyIGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTJdO1xuICAgICAgdmFyIGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgdmFyIG1wNFNhbXBsZUxlbmd0aCA9IDA7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9uYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBfaiA8IF9uYlVuaXRzOyBfaisrKSB7XG4gICAgICAgIHZhciB1bml0ID0gYXZjU2FtcGxlVW5pdHNbX2pdO1xuICAgICAgICB2YXIgdW5pdERhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIHZhciB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgdmFyIHB0c0RlbHRhID0gdm9pZCAwO1xuICAgICAgaWYgKF9pMiA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbX2kyICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbX2kyICsgMV0ucHRzIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIGxhc3RGcmFtZUR1cmF0aW9uID0gX2kyID4gMCA/IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbX2kyIC0gMV0uZHRzIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBwdHNEZWx0YSA9IF9pMiA+IDAgPyBhdmNTYW1wbGUucHRzIC0gaW5wdXRTYW1wbGVzW19pMiAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrICYmIHRoaXMubmV4dEF1ZGlvUHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgIHZhciBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKGNvbmZpZy5tYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKTtcbiAgICAgICAgICB2YXIgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci5sb2coXCJbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5IFwiICsgZGVsdGFUb0ZyYW1lRW5kIC8gOTAgKyBcIiBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiBcIiArIG1wNFNhbXBsZUR1cmF0aW9uIC8gOTAgKyBcIiBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cyk7XG4gICAgICBtaW5EdHNEZWx0YSA9IE1hdGgubWluKG1pbkR0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtYXhEdHNEZWx0YSA9IE1hdGgubWF4KG1heER0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtaW5QdHNEZWx0YSA9IE1hdGgubWluKG1pblB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBtYXhQdHNEZWx0YSA9IE1hdGgubWF4KG1heFB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZShhdmNTYW1wbGUua2V5LCBtcDRTYW1wbGVEdXJhdGlvbiwgbXA0U2FtcGxlTGVuZ3RoLCBjb21wb3NpdGlvblRpbWVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCAoa2V5ZnJhbWUpIHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbikge1xuICAgICAgICAvLyBGaXggZm9yIFwiQ05OIHNwZWNpYWwgcmVwb3J0LCB3aXRoIENDXCIgaW4gdGVzdC1zdHJlYW1zIChTYWZhcmkgYnJvd3NlciBvbmx5KVxuICAgICAgICAvLyBJZ25vcmUgRFRTIHdoZW4gZnJhbWUgZHVyYXRpb25zIGFyZSBpcnJlZ3VsYXIuIFNhZmFyaSBNU0UgZG9lcyBub3QgaGFuZGxlIHRoaXMgbGVhZGluZyB0byBnYXBzLlxuICAgICAgICBpZiAobWF4UHRzRGVsdGEgLSBtaW5QdHNEZWx0YSA8IG1heER0c0RlbHRhIC0gbWluRHRzRGVsdGEgJiYgYXZlcmFnZVNhbXBsZUR1cmF0aW9uIC8gbWF4RHRzRGVsdGEgPCAwLjAyNSAmJiBvdXRwdXRTYW1wbGVzWzBdLmN0cyA9PT0gMCkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIud2FybignRm91bmQgaXJyZWd1bGFyIGdhcHMgaW4gc2FtcGxlIGR1cmF0aW9uLiBVc2luZyBQVFMgaW5zdGVhZCBvZiBEVFMgdG8gZGV0ZXJtaW5lIE1QNCBzYW1wbGUgZHVyYXRpb24uJyk7XG4gICAgICAgICAgdmFyIGR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIGxlbiA9IG91dHB1dFNhbXBsZXMubGVuZ3RoOyBfaTMgPCBsZW47IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbX2kzXS5kdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBfcHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tfaTNdLmN0cztcbiAgICAgICAgICAgIGlmIChfaTMgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbX2kzICsgMV0uY3RzO1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW19pM10uZHVyYXRpb24gPSBuZXh0UHRzIC0gX3B0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbX2kzXS5kdXJhdGlvbiA9IF9pMyA/IG91dHB1dFNhbXBsZXNbX2kzIC0gMV0uZHVyYXRpb24gOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRTYW1wbGVzW19pM10uY3RzID0gMDtcbiAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuYXNzZXJ0KG1wNFNhbXBsZUR1cmF0aW9uICE9PSBudWxsLCAnbXA0U2FtcGxlRHVyYXRpb24gbXVzdCBiZSBjb21wdXRlZCcpO1xuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gc3RyZXRjaGVkTGFzdEZyYW1lIHx8ICFtcDRTYW1wbGVEdXJhdGlvbiA/IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA6IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgdmFyIG1vb2YgPSBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG4gICAgdmFyIHR5cGUgPSAndmlkZW8nO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IG5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIF9wcm90by5yZW11eEF1ZGlvID0gZnVuY3Rpb24gcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB2aWRlb1RpbWVPZmZzZXQpIHtcbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnID8gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FIDogTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgIHZhciBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgdmFyIHJhd01QRUcgPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgdmFyIGFsaWduZWRXaXRoVmlkZW8gPSB2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB2YXIgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgIHZhciBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyB8fCAtMTtcblxuICAgIC8vIHdpbmRvdy5hdWRpb1NhbXBsZXMgPyB3aW5kb3cuYXVkaW9TYW1wbGVzLnB1c2goaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKSkgOiAod2luZG93LmF1ZGlvU2FtcGxlcyA9IFtpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpXSk7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgdmFyIHRpbWVPZmZzZXRNcGVnVFMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPSBjb250aWd1b3VzIHx8IGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzID4gMCAmJiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXRNcGVnVFMgLSBuZXh0QXVkaW9QdHMpIDwgOTAwMCB8fCBNYXRoLmFicyhub3JtYWxpemVQdHMoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXRNcGVnVFMpIC0gbmV4dEF1ZGlvUHRzKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgfSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1B0cyA8IDApIHtcbiAgICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHMgPj0gMDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgICAgaWYgKCFpbnB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2aWRlb1RpbWVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBzdGFydCB0byAwIHRvIG1hdGNoIHZpZGVvIHNvIHRoYXQgc3RhcnQgZ2FwcyBsYXJnZXIgdGhhbiBpbnB1dFNhbXBsZUR1cmF0aW9uIGFyZSBmaWxsZWQgd2l0aCBzaWxlbmNlXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiAhYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAvLyBXaGVuIG5vdCBzZWVraW5nLCBub3QgbGl2ZSwgYW5kIExldmVsRGV0YWlscy5QVFNLbm93biwgdXNlIGZyYWdtZW50IHN0YXJ0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBNYXRoLm1heCgwLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGZyYWdzIGFyZSBub3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAvLyBmcmFtZS5cblxuICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICB2YXIgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgdmFyIHB0cyA9IHNhbXBsZS5wdHM7XG4gICAgICAgIHZhciBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKTtcblxuICAgICAgICAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci53YXJuKFwiQXVkaW8gZnJhbWUgQCBcIiArIChwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKSArIFwiIG1zLlwiKTtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAvLyA0OiByZW11eGluZyB3aXRoIHZpZGVvICh2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICB2YXIgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cbiAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaWYgKG5leHRQdHMgPCAwKSB7XG4gICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5sb2dnZXIud2FybihcIlttcDQtcmVtdXhlcl06IEluamVjdGluZyBcIiArIG1pc3NpbmcgKyBcIiBhdWRpbyBmcmFtZSBAIFwiICsgKG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBkdWUgdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKSArIFwiIG1zIGdhcC5cIik7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgdmFyIGZpbGxGcmFtZSA9IF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgICAgICAgdW5pdDogZmlsbEZyYW1lLFxuICAgICAgICAgICAgICBwdHM6IG5ld1N0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlLnB0cyA9IG5leHRQdHM7XG4gICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpcnN0UFRTID0gbnVsbDtcbiAgICB2YXIgbGFzdFBUUyA9IG51bGw7XG4gICAgdmFyIG1kYXQ7XG4gICAgdmFyIG1kYXRTaXplID0gMDtcbiAgICB2YXIgc2FtcGxlTGVuZ3RoID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgX2oyID0gMCwgX25iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IF9qMiA8IF9uYlNhbXBsZXM7IF9qMisrKSB7XG4gICAgICB2YXIgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2oyXTtcbiAgICAgIHZhciB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIHZhciBfcHRzMiA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgdmFyIHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW19qMiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoX3B0czIgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgX3B0czIgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBfcHRzMjtcbiAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5FcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgICAgICAgIHJlYXNvbjogXCJmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCBcIiArIG1kYXRTaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIHZhciB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvLyBEZWZhdWx0IHRoZSBzYW1wbGUncyBkdXJhdGlvbiB0byB0aGUgY29tcHV0ZWQgbXA0U2FtcGxlRHVyYXRpb24sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIDEwMjQgZm9yIEFBQyBvciAxMTUyIGZvciBNUEVHXG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgMSBzYW1wbGUsIHRoaXMgd2lsbCBiZSB0aGUgZHVyYXRpb24uIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHRoZSBkdXJhdGlvblxuICAgICAgLy8gYmVjb21lcyB0aGUgUFRTIGRpZmYgd2l0aCB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IF9wdHMyO1xuICAgIH1cblxuICAgIC8vIFdlIGNvdWxkIGVuZCB1cCB3aXRoIG5vIGF1ZGlvIHNhbXBsZXMgaWYgYWxsIGlucHV0IHNhbXBsZXMgd2VyZSBvdmVybGFwcGluZyB3aXRoIHRoZSBwcmV2aW91c2x5IHJlbXV4ZWQgb25lc1xuICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5iU2FtcGxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgdmFyIGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlLmR1cmF0aW9uO1xuXG4gICAgLy8gU2V0IHRoZSB0cmFjayBzYW1wbGVzIGZyb20gaW5wdXRTYW1wbGVzIHRvIG91dHB1dFNhbXBsZXMgYmVmb3JlIHJlbXV4aW5nXG4gICAgdmFyIG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcblxuICAgIC8vIENsZWFyIHRoZSB0cmFjayBzYW1wbGVzLiBUaGlzIGFsc28gY2xlYXJzIHRoZSBzYW1wbGVzIGFycmF5IGluIHRoZSBkZW11eGVyLCBzaW5jZSB0aGUgcmVmZXJlbmNlIGlzIHNoYXJlZFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgIHZhciBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgdHlwZSA9ICdhdWRpbyc7XG4gICAgdmFyIGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlc1xuICAgIH07XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IHRydWU7XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfTtcbiAgX3Byb3RvLnJlbXV4RW1wdHlBdWRpbyA9IGZ1bmN0aW9uIHJlbXV4RW1wdHlBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgdmFyIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xuICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgIHZhciBzdGFydERUUyA9IChuZXh0QXVkaW9QdHMgIT09IG51bGwgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyB0aGlzLl9pbml0RFRTO1xuICAgIHZhciBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTO1xuICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgIHZhciBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pO1xuICAgIC8vIHNpbGVudCBmcmFtZVxuICAgIHZhciBzaWxlbnRGcmFtZSA9IF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZW11eCBlbXB0eSBBdWRpbycpO1xuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmxvZ2dlci50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgIHVuaXQ6IHNpbGVudEZyYW1lLFxuICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICBkdHM6IHN0YW1wXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgZmFsc2UpO1xuICB9O1xuICByZXR1cm4gTVA0UmVtdXhlcjtcbn0oKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplUHRzKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgdmFyIG9mZnNldDtcbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdERUUykge1xuICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXREVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzOiBzYW1wbGVzXG4gIH07XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUykge1xuICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcbiAgfSk7XG4gIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgfTtcbn1cbnZhciBNcDRTYW1wbGUgPSBmdW5jdGlvbiBNcDRTYW1wbGUoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gIHRoaXMuY3RzID0gdm9pZCAwO1xuICB0aGlzLmZsYWdzID0gdm9pZCAwO1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIHRoaXMuc2l6ZSA9IHNpemU7XG4gIHRoaXMuY3RzID0gY3RzO1xuICB0aGlzLmZsYWdzID0gbmV3IE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpO1xufTtcbnZhciBNcDRTYW1wbGVGbGFncyA9IGZ1bmN0aW9uIE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpIHtcbiAgdGhpcy5pc0xlYWRpbmcgPSAwO1xuICB0aGlzLmlzRGVwZW5kZWRPbiA9IDA7XG4gIHRoaXMuaGFzUmVkdW5kYW5jeSA9IDA7XG4gIHRoaXMuZGVncmFkUHJpbyA9IDA7XG4gIHRoaXMuZGVwZW5kc09uID0gMTtcbiAgdGhpcy5pc05vblN5bmMgPSAxO1xuICB0aGlzLmRlcGVuZHNPbiA9IGlzS2V5ZnJhbWUgPyAyIDogMTtcbiAgdGhpcy5pc05vblN5bmMgPSBpc0tleWZyYW1lID8gMCA6IDE7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXA0LXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5cblxudmFyIFBhc3NUaHJvdWdoUmVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhc3NUaHJvdWdoUmVtdXhlcigpIHtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRQVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIHZhciBfcHJvdG8gPSBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpIHtcbiAgICB0aGlzLmluaXRQVFMgPSBkZWZhdWx0SW5pdFBUUztcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLnBhdGNoRW5jeXB0aW9uRGF0YSkoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKSk7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICB9O1xuICBfcHJvdG8uZ2VuZXJhdGVJbml0U2VnbWVudCA9IGZ1bmN0aW9uIGdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMgPSB0aGlzLnZpZGVvQ29kZWM7XG4gICAgaWYgKCFpbml0U2VnbWVudCB8fCAhaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9ICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5wYXJzZUluaXRTZWdtZW50KShpbml0U2VnbWVudCk7XG5cbiAgICAvLyBHZXQgY29kZWMgZnJvbSBpbml0U2VnbWVudCBvciBmYWxsYmFjayB0byBkZWZhdWx0XG4gICAgaWYgKCFhdWRpb0NvZGVjKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgfVxuICAgIGlmICghdmlkZW9Db2RlYykge1xuICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoaW5pdERhdGEudmlkZW8sIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pO1xuICAgIH1cbiAgICB2YXIgdHJhY2tzID0ge307XG4gICAgaWYgKGluaXREYXRhLmF1ZGlvICYmIGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXI6ICdhdWRpby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ2F1ZGlvJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5sb2dnZXIud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBpbml0U2VnbWVudCBkb2VzIG5vdCBjb250YWluIG1vb3Ygb3IgdHJhayBib3hlcy4nKTtcbiAgICB9XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdHJhY2tzO1xuICB9O1xuICBfcHJvdG8ucmVtdXggPSBmdW5jdGlvbiByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIF90aGlzJGluaXRQVFM7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICBsYXN0RW5kVGltZSA9IHRoaXMubGFzdEVuZFRpbWU7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICB2aWRlbzogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGV4dFRyYWNrLFxuICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgIGluaXRTZWdtZW50OiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgIC8vIGxhc3RFbmREVFMgb3ZlciB0aW1lT2Zmc2V0IHdoZW5ldmVyIHBvc3NpYmxlOyBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGxheWJhY2ssIHRoZSBtZWRpYSBzb3VyY2Ugd2lsbCBub3QgdXBkYXRlXG4gICAgLy8gdGhlIG1lZGlhIGR1cmF0aW9uICh3aGljaCBpcyB3aGF0IHRpbWVPZmZzZXQgaXMgcHJvdmlkZWQgYXMpIGJlZm9yZSB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5leHQgY2h1bmsuXG4gICAgaWYgKCEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGxhc3RFbmRUaW1lKSkge1xuICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgIHZhciBkYXRhID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBpbml0U2VnbWVudCA9IHtcbiAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzY2FsZTogMVxuICAgIH07XG4gICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoIWluaXREYXRhIHx8ICFpbml0RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgaWYgKCFpbml0RGF0YSB8fCAhaW5pdERhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IEZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzO1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RFRTID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmdldFN0YXJ0RFRTKShpbml0RGF0YSwgZGF0YSk7XG4gICAgaWYgKCEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGluaXRQVFMpKSB7XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTID0gaW5pdFBUUyA9IHN0YXJ0RFRTIC0gdGltZU9mZnNldDtcbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gKDAsX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmdldER1cmF0aW9uKShkYXRhLCBpbml0RGF0YSk7XG4gICAgdmFyIHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2sgPyBzdGFydERUUyAtIGluaXRQVFMgOiBsYXN0RW5kVGltZTtcbiAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgICgwLF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5vZmZzZXRTdGFydERUUykoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18ubG9nZ2VyLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuICAgIHZhciBoYXNBdWRpbyA9ICEhaW5pdERhdGEuYXVkaW87XG4gICAgdmFyIGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcbiAgICB2YXIgdHlwZSA9ICcnO1xuICAgIGlmIChoYXNBdWRpbykge1xuICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgIH1cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG4gICAgdmFyIHRyYWNrID0ge1xuICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICBzdGFydFBUUzogc3RhcnRUaW1lLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgIGVuZERUUzogZW5kVGltZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBoYXNBdWRpbzogaGFzQXVkaW8sXG4gICAgICBoYXNWaWRlbzogaGFzVmlkZW8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICAgIHJlc3VsdC5hdWRpbyA9IHRyYWNrLnR5cGUgPT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgdmFyIGluaXRQdHNOdW0gPSAoX3RoaXMkaW5pdFBUUyA9IHRoaXMuaW5pdFBUUykgIT0gbnVsbCA/IF90aGlzJGluaXRQVFMgOiAwO1xuICAgIHJlc3VsdC5pZDMgPSAoMCxfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5mbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcykoaWQzVHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQdHNOdW0sIGluaXRQdHNOdW0pO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gKDAsX21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMpKHRleHRUcmFjaywgdGltZU9mZnNldCwgaW5pdFB0c051bSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG59KCk7XG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKSB7XG4gIHZhciBwYXJzZWRDb2RlYyA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5jb2RlYztcbiAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjLmxlbmd0aCA+IDQpIHtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gIH1cbiAgLy8gU2luY2UgbXA0LXRvb2xzIGNhbm5vdCBwYXJzZSBmdWxsIGNvZGVjIHN0cmluZyAoc2VlICdUT0RPOiBQYXJzZSBjb2RlYyBkZXRhaWxzJy4uLiBpbiBtcDQtdG9vbHMpXG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLmMuTDEyMC45MCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG4gIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2F2YzEnIHx8IHR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICByZXR1cm4gJ2F2YzEuNDJlMDFlJztcbiAgfVxuICByZXR1cm4gJ21wNGEuNDAuNSc7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFBhc3NUaHJvdWdoUmVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3Rhc2stbG9vcC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGFzay1sb29wLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGFza0xvb3ApXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbnZhciBUYXNrTG9vcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRhc2tMb29wKCkge1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHZvaWQgMDtcbiAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cbiAgdmFyIF9wcm90byA9IFRhc2tMb29wLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH07XG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH07XG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95ZWQgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovO1xuICBfcHJvdG8uaGFzSW50ZXJ2YWwgPSBmdW5jdGlvbiBoYXNJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqLztcbiAgX3Byb3RvLmhhc05leHRUaWNrID0gZnVuY3Rpb24gaGFzTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXMgSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqLztcbiAgX3Byb3RvLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi87XG4gIF9wcm90by5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovO1xuICBfcHJvdG8uY2xlYXJOZXh0VGljayA9IGZ1bmN0aW9uIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi87XG4gIF9wcm90by50aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRpY2tJbW1lZGlhdGUgPSBmdW5jdGlvbiB0aWNrSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovO1xuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge307XG4gIHJldHVybiBUYXNrTG9vcDtcbn0oKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy9jbWNkLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHlwZXMvY21jZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiQ01DRE9iamVjdFR5cGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ01DRE9iamVjdFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkNNQ0RTdHJlYW1UeXBlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIENNQ0RTdHJlYW1UeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJDTUNEU3RyZWFtaW5nRm9ybWF0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIENNQ0RTdHJlYW1pbmdGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkNNQ0RWZXJzaW9uXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIENNQ0RWZXJzaW9uKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqIENNQ0Qgc3BlYyB2ZXJzaW9uXG4gKi9cbnZhciBDTUNEVmVyc2lvbiA9IDE7XG5cbi8qKlxuICogQ01DRCBPYmplY3QgVHlwZVxuICovXG52YXIgQ01DRE9iamVjdFR5cGU7XG5cbi8qKlxuICogQ01DRCBTdHJlYW1pbmcgRm9ybWF0XG4gKi9cbihmdW5jdGlvbiAoQ01DRE9iamVjdFR5cGUpIHtcbiAgQ01DRE9iamVjdFR5cGVbXCJNQU5JRkVTVFwiXSA9IFwibVwiO1xuICBDTUNET2JqZWN0VHlwZVtcIkFVRElPXCJdID0gXCJhXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiVklERU9cIl0gPSBcInZcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJNVVhFRFwiXSA9IFwiYXZcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJJTklUXCJdID0gXCJpXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiQ0FQVElPTlwiXSA9IFwiY1wiO1xuICBDTUNET2JqZWN0VHlwZVtcIlRJTUVEX1RFWFRcIl0gPSBcInR0XCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiS0VZXCJdID0gXCJrXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiT1RIRVJcIl0gPSBcIm9cIjtcbn0pKENNQ0RPYmplY3RUeXBlIHx8IChDTUNET2JqZWN0VHlwZSA9IHt9KSk7XG52YXIgQ01DRFN0cmVhbWluZ0Zvcm1hdDtcblxuLyoqXG4gKiBDTUNEIFN0cmVhbWluZyBUeXBlXG4gKi9cbihmdW5jdGlvbiAoQ01DRFN0cmVhbWluZ0Zvcm1hdCkge1xuICBDTUNEU3RyZWFtaW5nRm9ybWF0W1wiREFTSFwiXSA9IFwiZFwiO1xuICBDTUNEU3RyZWFtaW5nRm9ybWF0W1wiSExTXCJdID0gXCJoXCI7XG4gIENNQ0RTdHJlYW1pbmdGb3JtYXRbXCJTTU9PVEhcIl0gPSBcInNcIjtcbiAgQ01DRFN0cmVhbWluZ0Zvcm1hdFtcIk9USEVSXCJdID0gXCJvXCI7XG59KShDTUNEU3RyZWFtaW5nRm9ybWF0IHx8IChDTUNEU3RyZWFtaW5nRm9ybWF0ID0ge30pKTtcbnZhciBDTUNEU3RyZWFtVHlwZTtcblxuLyoqXG4gKiBDTUNEIEhlYWRlcnNcbiAqL1xuKGZ1bmN0aW9uIChDTUNEU3RyZWFtVHlwZSkge1xuICBDTUNEU3RyZWFtVHlwZVtcIlZPRFwiXSA9IFwidlwiO1xuICBDTUNEU3RyZWFtVHlwZVtcIkxJVkVcIl0gPSBcImxcIjtcbn0pKENNQ0RTdHJlYW1UeXBlIHx8IChDTUNEU3RyZWFtVHlwZSA9IHt9KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2RlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9kZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJNZXRhZGF0YVNjaGVtYVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBNZXRhZGF0YVNjaGVtYSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xudmFyIE1ldGFkYXRhU2NoZW1hO1xuKGZ1bmN0aW9uIChNZXRhZGF0YVNjaGVtYSkge1xuICBNZXRhZGF0YVNjaGVtYVtcImF1ZGlvSWQzXCJdID0gXCJvcmcuaWQzXCI7XG4gIE1ldGFkYXRhU2NoZW1hW1wiZGF0ZVJhbmdlXCJdID0gXCJjb20uYXBwbGUucXVpY2t0aW1lLkhMU1wiO1xuICBNZXRhZGF0YVNjaGVtYVtcImVtc2dcIl0gPSBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIjtcbn0pKE1ldGFkYXRhU2NoZW1hIHx8IChNZXRhZGF0YVNjaGVtYSA9IHt9KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL2xldmVsLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiSGRjcExldmVsc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBIZGNwTGV2ZWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJIbHNTa2lwXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEhsc1NraXApLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkhsc1VybFBhcmFtZXRlcnNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSGxzVXJsUGFyYW1ldGVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiTGV2ZWxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGV2ZWwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImdldFNraXBWYWx1ZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRTa2lwVmFsdWUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgSGRjcExldmVscyA9IFsnTk9ORScsICdUWVBFLTAnLCAnVFlQRS0xJywgJ1RZUEUtMicsIG51bGxdO1xudmFyIEhsc1NraXA7XG4oZnVuY3Rpb24gKEhsc1NraXApIHtcbiAgSGxzU2tpcFtcIk5vXCJdID0gXCJcIjtcbiAgSGxzU2tpcFtcIlllc1wiXSA9IFwiWUVTXCI7XG4gIEhsc1NraXBbXCJ2MlwiXSA9IFwidjJcIjtcbn0pKEhsc1NraXAgfHwgKEhsc1NraXAgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U2tpcFZhbHVlKGRldGFpbHMsIG1zbikge1xuICB2YXIgY2FuU2tpcFVudGlsID0gZGV0YWlscy5jYW5Ta2lwVW50aWwsXG4gICAgY2FuU2tpcERhdGVSYW5nZXMgPSBkZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzLFxuICAgIGVuZFNOID0gZGV0YWlscy5lbmRTTjtcbiAgdmFyIHNuQ2hhbmdlR29hbCA9IG1zbiAhPT0gdW5kZWZpbmVkID8gbXNuIC0gZW5kU04gOiAwO1xuICBpZiAoY2FuU2tpcFVudGlsICYmIHNuQ2hhbmdlR29hbCA8IGNhblNraXBVbnRpbCkge1xuICAgIGlmIChjYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuICByZXR1cm4gSGxzU2tpcC5Obztcbn1cbnZhciBIbHNVcmxQYXJhbWV0ZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQsIHNraXApIHtcbiAgICB0aGlzLm1zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5za2lwID0gdm9pZCAwO1xuICAgIHRoaXMubXNuID0gbXNuO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5za2lwID0gc2tpcDtcbiAgfVxuICB2YXIgX3Byb3RvID0gSGxzVXJsUGFyYW1ldGVycy5wcm90b3R5cGU7XG4gIF9wcm90by5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICB2YXIgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgaWYgKHRoaXMubXNuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX21zbicsIHRoaXMubXNuLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhcnQnLCB0aGlzLnBhcnQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH07XG4gIHJldHVybiBIbHNVcmxQYXJhbWV0ZXJzO1xufSgpO1xudmFyIExldmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGV2ZWwoZGF0YSkge1xuICAgIHRoaXMuYXR0cnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGVjU2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvR3JvdXBJZHMgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgdGhpcy5sb2FkRXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZGVkID0gdm9pZCAwO1xuICAgIHRoaXMucmVhbEJpdHJhdGUgPSAwO1xuICAgIHRoaXMudGV4dEdyb3VwSWRzID0gdm9pZCAwO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMuX3VybElkID0gMDtcbiAgICB0aGlzLnVybCA9IFtkYXRhLnVybF07XG4gICAgdGhpcy5hdHRycyA9IGRhdGEuYXR0cnM7XG4gICAgdGhpcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlO1xuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG4gICAgdGhpcy5pZCA9IGRhdGEuaWQgfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGggfHwgMDtcbiAgICB0aGlzLmhlaWdodCA9IGRhdGEuaGVpZ2h0IHx8IDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gZGF0YS5hdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICB0aGlzLnVua25vd25Db2RlY3MgPSBkYXRhLnVua25vd25Db2RlY3M7XG4gICAgdGhpcy5jb2RlY1NldCA9IFtkYXRhLnZpZGVvQ29kZWMsIGRhdGEuYXVkaW9Db2RlY10uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9KS5qb2luKCcsJykucmVwbGFjZSgvXFwuW14uLF0rL2csICcnKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTGV2ZWwsIFt7XG4gICAga2V5OiBcIm1heEJpdHJhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJlYWxCaXRyYXRlLCB0aGlzLmJpdHJhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cmlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVybFt0aGlzLl91cmxJZF0gfHwgJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVybElkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUgJSB0aGlzLnVybC5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdXJsSWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXJsSWQgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExldmVsO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL2xvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJQbGF5bGlzdENvbnRleHRUeXBlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFBsYXlsaXN0Q29udGV4dFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlBsYXlsaXN0TGV2ZWxUeXBlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFBsYXlsaXN0TGV2ZWxUeXBlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgUGxheWxpc3RDb250ZXh0VHlwZTtcbihmdW5jdGlvbiAoUGxheWxpc3RDb250ZXh0VHlwZSkge1xuICBQbGF5bGlzdENvbnRleHRUeXBlW1wiTUFOSUZFU1RcIl0gPSBcIm1hbmlmZXN0XCI7XG4gIFBsYXlsaXN0Q29udGV4dFR5cGVbXCJMRVZFTFwiXSA9IFwibGV2ZWxcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIkFVRElPX1RSQUNLXCJdID0gXCJhdWRpb1RyYWNrXCI7XG4gIFBsYXlsaXN0Q29udGV4dFR5cGVbXCJTVUJUSVRMRV9UUkFDS1wiXSA9IFwic3VidGl0bGVUcmFja1wiO1xufSkoUGxheWxpc3RDb250ZXh0VHlwZSB8fCAoUGxheWxpc3RDb250ZXh0VHlwZSA9IHt9KSk7XG52YXIgUGxheWxpc3RMZXZlbFR5cGU7XG4oZnVuY3Rpb24gKFBsYXlsaXN0TGV2ZWxUeXBlKSB7XG4gIFBsYXlsaXN0TGV2ZWxUeXBlW1wiTUFJTlwiXSA9IFwibWFpblwiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIlNVQlRJVExFXCJdID0gXCJzdWJ0aXRsZVwiO1xufSkoUGxheWxpc3RMZXZlbFR5cGUgfHwgKFBsYXlsaXN0TGV2ZWxUeXBlID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkNodW5rTWV0YWRhdGFcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ2h1bmtNZXRhZGF0YSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xudmFyIENodW5rTWV0YWRhdGEgPSBmdW5jdGlvbiBDaHVua01ldGFkYXRhKGxldmVsLCBzbiwgaWQsIHNpemUsIHBhcnQsIHBhcnRpYWwpIHtcbiAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgIHNpemUgPSAwO1xuICB9XG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gLTE7XG4gIH1cbiAgaWYgKHBhcnRpYWwgPT09IHZvaWQgMCkge1xuICAgIHBhcnRpYWwgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmxldmVsID0gdm9pZCAwO1xuICB0aGlzLnNuID0gdm9pZCAwO1xuICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gIHRoaXMuaWQgPSB2b2lkIDA7XG4gIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgdGhpcy5wYXJ0aWFsID0gdm9pZCAwO1xuICB0aGlzLnRyYW5zbXV4aW5nID0gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgYXVkaW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgYXVkaW92aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKVxuICB9O1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMuc24gPSBzbjtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLnNpemUgPSBzaXplO1xuICB0aGlzLnBhcnQgPSBwYXJ0O1xuICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xufTtcbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2F0dHItbGlzdC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJBdHRyTGlzdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBBdHRyTGlzdClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xudmFyIERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG52YXIgQVRUUl9MSVNUX1JFR0VYID0gL1xccyooLis/KVxccyo9KCg/OlxcXCIuKj9cXFwiKXwuKj8pKD86LHwkKS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbnZhciBBdHRyTGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJMaXN0KGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBfcHJvdG8gPSBBdHRyTGlzdC5wcm90b3R5cGU7XG4gIF9wcm90by5kZWNpbWFsSW50ZWdlciA9IGZ1bmN0aW9uIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH07XG4gIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXJBc051bWJlciA9IGZ1bmN0aW9uIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XG4gICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH07XG4gIF9wcm90by5kZWNpbWFsRmxvYXRpbmdQb2ludCA9IGZ1bmN0aW9uIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9O1xuICBfcHJvdG8ub3B0aW9uYWxGbG9hdCA9IGZ1bmN0aW9uIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgIHJldHVybiB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICB9O1xuICBfcHJvdG8uZW51bWVyYXRlZFN0cmluZyA9IGZ1bmN0aW9uIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gIH07XG4gIF9wcm90by5ib29sID0gZnVuY3Rpb24gYm9vbChhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXSA9PT0gJ1lFUyc7XG4gIH07XG4gIF9wcm90by5kZWNpbWFsUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgdmFyIHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH07XG4gIEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QgPSBmdW5jdGlvbiBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIHZhciBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH07XG4gIHJldHVybiBBdHRyTGlzdDtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgQmluYXJ5U2VhcmNoID0ge1xuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtCaW5hcnlTZWFyY2hDb21wYXJpc29uPFQ+fSBjb21wYXJpc29uRm5cbiAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7VCB8IG51bGx9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChsaXN0LCBjb21wYXJpc29uRm4pIHtcbiAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgIHZhciBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgIHZhciBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZuKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEJpbmFyeVNlYXJjaCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJCdWZmZXJIZWxwZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQnVmZmVySGVscGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKipcbiAqIEBtb2R1bGUgQnVmZmVySGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxuICpcbiAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gKlxuICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4gKi9cblxuXG52YXIgbm9vcEJ1ZmZlcmVkID0ge1xuICBsZW5ndGg6IDAsXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgQnVmZmVySGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVySGVscGVyKCkge31cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICogQHBhcmFtIHtCdWZmZXJhYmxlfSBtZWRpYVxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzQnVmZmVyZWQobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgQnVmZmVySGVscGVyLmJ1ZmZlckluZm8gPSBmdW5jdGlvbiBidWZmZXJJbmZvKG1lZGlhLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IFtdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSxcbiAgICAgICAgICAgIGVuZDogdmJ1ZmZlcmVkLmVuZChpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiAwLFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zLFxuICAgICAgbmV4dFN0YXJ0OiB1bmRlZmluZWRcbiAgICB9O1xuICB9O1xuICBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvID0gZnVuY3Rpb24gYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBidWZmZXJlZDIgPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlcmVkMiA9IGJ1ZmZlcmVkO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyTGVuID0gMDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0TmV4dCBjYW4gcG9zc2libHkgYmUgdW5kZWZpbmVkIGJhc2VkIG9uIHRoZSBjb25kaXRpb25hbCBsb2dpYyBiZWxvd1xuICAgIHZhciBidWZmZXJTdGFydE5leHQ7XG5cbiAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgIHZhciBidWZmZXJTdGFydCA9IHBvcztcbiAgICB2YXIgYnVmZmVyRW5kID0gcG9zO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBidWZmZXJlZDIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZDJbX2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkMltfaV0uZW5kO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgIHN0YXJ0OiBidWZmZXJTdGFydCB8fCAwLFxuICAgICAgZW5kOiBidWZmZXJFbmQgfHwgMCxcbiAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqLztcbiAgQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWQobWVkaWEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5sb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEJ1ZmZlckhlbHBlcjtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY2VhLTYwOC1wYXJzZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY2VhLTYwOC1wYXJzZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJDYXB0aW9uU2NyZWVuXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIENhcHRpb25TY3JlZW4pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlJvd1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBSb3cpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbnZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbiBnZXRDaGFyRm9yQnl0ZShfYnl0ZSkge1xuICB2YXIgY2hhckNvZGUgPSBfYnl0ZTtcbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KF9ieXRlKSkge1xuICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbX2J5dGVdO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG52YXIgTlJfUk9XUyA9IDE1O1xudmFyIE5SX0NPTFMgPSAxMDA7XG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxudmFyIHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG52YXIgcm93c0hpZ2hDaDEgPSB7XG4gIDB4MTE6IDIsXG4gIDB4MTI6IDQsXG4gIDB4MTU6IDYsXG4gIDB4MTY6IDgsXG4gIDB4MTc6IDEwLFxuICAweDEzOiAxMyxcbiAgMHgxNDogMTVcbn07XG52YXIgcm93c0xvd0NoMiA9IHtcbiAgMHgxOTogMSxcbiAgMHgxYTogMyxcbiAgMHgxZDogNSxcbiAgMHgxZTogNyxcbiAgMHgxZjogOSxcbiAgMHgxODogMTEsXG4gIDB4MWI6IDEyLFxuICAweDFjOiAxNFxufTtcbnZhciByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG52YXIgVmVyYm9zZUxldmVsO1xuKGZ1bmN0aW9uIChWZXJib3NlTGV2ZWwpIHtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIkVSUk9SXCJdID0gMF0gPSBcIkVSUk9SXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJURVhUXCJdID0gMV0gPSBcIlRFWFRcIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIldBUk5JTkdcIl0gPSAyXSA9IFwiV0FSTklOR1wiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJERUJVR1wiXSA9IDNdID0gXCJERUJVR1wiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiREFUQVwiXSA9IDNdID0gXCJEQVRBXCI7XG59KShWZXJib3NlTGV2ZWwgfHwgKFZlcmJvc2VMZXZlbCA9IHt9KSk7XG52YXIgQ2FwdGlvbnNMb2dnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXB0aW9uc0xvZ2dlcigpIHtcbiAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZUxldmVsID0gVmVyYm9zZUxldmVsLkVSUk9SO1xuICB9XG4gIHZhciBfcHJvdG8gPSBDYXB0aW9uc0xvZ2dlci5wcm90b3R5cGU7XG4gIF9wcm90by5sb2cgPSBmdW5jdGlvbiBsb2coc2V2ZXJpdHksIG1zZykge1xuICAgIGlmICh0aGlzLnZlcmJvc2VMZXZlbCA+PSBzZXZlcml0eSkge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2c7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubG9nZ2VyLmxvZyh0aGlzLnRpbWUgKyBcIiBbXCIgKyBzZXZlcml0eSArIFwiXSBcIiArIG0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENhcHRpb25zTG9nZ2VyO1xufSgpO1xudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uIG51bUFycmF5VG9IZXhBcnJheShudW1BcnJheSkge1xuICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xudmFyIFBlblN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IHZvaWQgMDtcbiAgICB0aGlzLnVuZGVybGluZSA9IHZvaWQgMDtcbiAgICB0aGlzLml0YWxpY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgfVxuICB2YXIgX3Byb3RvMiA9IFBlblN0YXRlLnByb3RvdHlwZTtcbiAgX3Byb3RvMi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvMi5zZXRTdHlsZXMgPSBmdW5jdGlvbiBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgdmFyIGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90bzIuaXNEZWZhdWx0ID0gZnVuY3Rpb24gaXNEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoO1xuICB9O1xuICBfcHJvdG8yLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQgJiYgdGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSAmJiB0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kICYmIHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoO1xuICB9O1xuICBfcHJvdG8yLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9O1xuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoO1xuICB9O1xuICByZXR1cm4gUGVuU3RhdGU7XG59KCk7XG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3R5bGVkVW5pY29kZUNoYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZWRVbmljb2RlQ2hhcih1Y2hhciwgZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMudWNoYXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wZW5TdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XG4gIH1cbiAgdmFyIF9wcm90bzMgPSBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGU7XG4gIF9wcm90bzMucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgfTtcbiAgX3Byb3RvMy5zZXRDaGFyID0gZnVuY3Rpb24gc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfTtcbiAgX3Byb3RvMy5zZXRQZW5TdGF0ZSA9IGZ1bmN0aW9uIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfTtcbiAgX3Byb3RvMy5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICB9O1xuICBfcHJvdG8zLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH07XG4gIF9wcm90bzMuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICB9O1xuICByZXR1cm4gU3R5bGVkVW5pY29kZUNoYXI7XG59KCk7XG4vKipcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdyhsb2dnZXIpIHtcbiAgICB0aGlzLmNoYXJzID0gdm9pZCAwO1xuICAgIHRoaXMucG9zID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cbiAgdmFyIF9wcm90bzQgPSBSb3cucHJvdG90eXBlO1xuICBfcHJvdG80LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG4gIF9wcm90bzQuY29weSA9IGZ1bmN0aW9uIGNvcHkob3RoZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICB9XG4gIH07XG4gIF9wcm90bzQuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICovO1xuICBfcHJvdG80LnNldEN1cnNvciA9IGZ1bmN0aW9uIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvcyA8IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqLztcbiAgX3Byb3RvNC5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gIH1cblxuICAvKipcbiAgICogQmFja3NwYWNlLCBtb3ZlIG9uZSBzdGVwIGJhY2sgYW5kIGNsZWFyIGNoYXJhY3Rlci5cbiAgICovO1xuICBfcHJvdG80LmJhY2tTcGFjZSA9IGZ1bmN0aW9uIGJhY2tTcGFjZSgpIHtcbiAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH07XG4gIF9wcm90bzQuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2J5dGUyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoX2J5dGUyID49IDB4OTApIHtcbiAgICAgIC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgfVxuICAgIHZhciBfY2hhciA9IGdldENoYXJGb3JCeXRlKF9ieXRlMik7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuRVJST1IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYW5ub3QgaW5zZXJ0ICcgKyBfYnl0ZTIudG9TdHJpbmcoMTYpICsgJyAoJyArIF9jaGFyICsgJykgYXQgcG9zaXRpb24gJyArIF90aGlzLnBvcyArICcuIFNraXBwaW5nIGl0ISc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihfY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfTtcbiAgX3Byb3RvNC5jbGVhckZyb21Qb3MgPSBmdW5jdGlvbiBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvNC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICB9O1xuICBfcHJvdG80LmNsZWFyVG9FbmRPZlJvdyA9IGZ1bmN0aW9uIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gIH07XG4gIF9wcm90bzQuZ2V0VGV4dFN0cmluZyA9IGZ1bmN0aW9uIGdldFRleHRTdHJpbmcoKSB7XG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdmFyIF9jaGFyMiA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICBpZiAoX2NoYXIyICE9PSAnICcpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goX2NoYXIyKTtcbiAgICB9XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH07XG4gIF9wcm90bzQuc2V0UGVuU3R5bGVzID0gZnVuY3Rpb24gc2V0UGVuU3R5bGVzKHN0eWxlcykge1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfTtcbiAgcmV0dXJuIFJvdztcbn0oKTtcblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2FwdGlvblNjcmVlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhcHRpb25TY3JlZW4obG9nZ2VyKSB7XG4gICAgdGhpcy5yb3dzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIHZhciBfcHJvdG81ID0gQ2FwdGlvblNjcmVlbi5wcm90b3R5cGU7XG4gIF9wcm90bzUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICB9O1xuICBfcHJvdG81LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9O1xuICBfcHJvdG81LmNvcHkgPSBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvNS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfTtcbiAgX3Byb3RvNS5iYWNrU3BhY2UgPSBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgfTtcbiAgX3Byb3RvNS5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgKi87XG4gIF9wcm90bzUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2NoYXIzKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKF9jaGFyMyk7XG4gIH07XG4gIF9wcm90bzUuc2V0UGVuID0gZnVuY3Rpb24gc2V0UGVuKHN0eWxlcykge1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gIH07XG4gIF9wcm90bzUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH07XG4gIF9wcm90bzUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgfTtcbiAgX3Byb3RvNS5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpO1xuICAgIH0pO1xuICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICB2YXIgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgdGltZSAhPT0gbnVsbCAmJiBwcmV2TGluZVRpbWUgPCB0aW1lKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBfaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgX2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50IC0gMSwgMCk7XG4gICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqLztcbiAgX3Byb3RvNS5zZXRCa2dEYXRhID0gZnVuY3Rpb24gc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSk7XG4gICAgfSk7XG4gICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vIFNwYWNlXG4gIH07XG4gIF9wcm90bzUuc2V0Um9sbFVwUm93cyA9IGZ1bmN0aW9uIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gIH07XG4gIF9wcm90bzUucm9sbFVwID0gZnVuY3Rpb24gcm9sbFVwKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZ2V0RGlzcGxheVRleHQoKTtcbiAgICB9KTtcbiAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgdmFyIHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1JvbGxpbmcgdXAnKTtcbiAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqLztcbiAgX3Byb3RvNS5nZXREaXNwbGF5VGV4dCA9IGZ1bmN0aW9uIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICB2YXIgZGlzcGxheVRleHQgPSBbXTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciByb3dOciA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICByb3dOciA9IGkgKyAxO1xuICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBfcHJvdG81LmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH07XG4gIHJldHVybiBDYXB0aW9uU2NyZWVuO1xufSgpO1xuXG4vLyB2YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xudmFyIENlYTYwOENoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZWE2MDhDaGFubmVsKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlciwgbG9nZ2VyKSB7XG4gICAgdGhpcy5jaE5yID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZlcmJvc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgdmFyIF9wcm90bzYgPSBDZWE2MDhDaGFubmVsLnByb3RvdHlwZTtcbiAgX3Byb3RvNi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9O1xuICBfcHJvdG82LmdldEhhbmRsZXIgPSBmdW5jdGlvbiBnZXRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgfTtcbiAgX3Byb3RvNi5zZXRIYW5kbGVyID0gZnVuY3Rpb24gc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICB9O1xuICBfcHJvdG82LnNldFBBQyA9IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH07XG4gIF9wcm90bzYuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfTtcbiAgX3Byb3RvNi5zZXRNb2RlID0gZnVuY3Rpb24gc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdNT0RFPScgKyBuZXdNb2RlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH07XG4gIF9wcm90bzYuaW5zZXJ0Q2hhcnMgPSBmdW5jdGlvbiBpbnNlcnRDaGFycyhjaGFycykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuICAgIHZhciBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2NyZWVuICsgJzogJyArIF90aGlzMy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5URVhULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRElTUExBWUVEOiAnICsgX3RoaXMzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG82LmNjUkNMID0gZnVuY3Rpb24gY2NSQ0woKSB7XG4gICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH07XG4gIF9wcm90bzYuY2NCUyA9IGZ1bmN0aW9uIGNjQlMoKSB7XG4gICAgLy8gQmFja1NwYWNlXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG82LmNjQU9GID0gZnVuY3Rpb24gY2NBT0YoKSB7XG4gICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcbiAgfTtcbiAgX3Byb3RvNi5jY0FPTiA9IGZ1bmN0aW9uIGNjQU9OKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgfTtcbiAgX3Byb3RvNi5jY0RFUiA9IGZ1bmN0aW9uIGNjREVSKCkge1xuICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH07XG4gIF9wcm90bzYuY2NSVSA9IGZ1bmN0aW9uIGNjUlUobnJSb3dzKSB7XG4gICAgLy8gUm9sbC1VcCBDYXB0aW9ucy0yLDMsb3IgNCBSb3dzXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICB9O1xuICBfcHJvdG82LmNjRk9OID0gZnVuY3Rpb24gY2NGT04oKSB7XG4gICAgLy8gRmxhc2ggT25cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgIGZsYXNoOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIF9wcm90bzYuY2NSREMgPSBmdW5jdGlvbiBjY1JEQygpIHtcbiAgICAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH07XG4gIF9wcm90bzYuY2NUUiA9IGZ1bmN0aW9uIGNjVFIoKSB7XG4gICAgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdUUicpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH07XG4gIF9wcm90bzYuY2NSVEQgPSBmdW5jdGlvbiBjY1JURCgpIHtcbiAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSVEQnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9O1xuICBfcHJvdG82LmNjRURNID0gZnVuY3Rpb24gY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcbiAgX3Byb3RvNi5jY0NSID0gZnVuY3Rpb24gY2NDUigpIHtcbiAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9O1xuICBfcHJvdG82LmNjRU5NID0gZnVuY3Rpb24gY2NFTk0oKSB7XG4gICAgLy8gRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH07XG4gIF9wcm90bzYuY2NFT0MgPSBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RJU1A6ICcgKyBfdGhpczQuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9O1xuICBfcHJvdG82LmNjVE8gPSBmdW5jdGlvbiBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gIH07XG4gIF9wcm90bzYuY2NNSURST1cgPSBmdW5jdGlvbiBjY01JRFJPVyhzZWNvbmRCeXRlKSB7XG4gICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgZmxhc2g6IGZhbHNlXG4gICAgfTtcbiAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgc3R5bGVzLml0YWxpY3MgPSBzZWNvbmRCeXRlID49IDB4MmU7XG4gICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICB2YXIgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9O1xuICBfcHJvdG82Lm91dHB1dERhdGFVcGRhdGUgPSBmdW5jdGlvbiBvdXRwdXREYXRhVXBkYXRlKGRpc3BhdGNoKSB7XG4gICAgaWYgKGRpc3BhdGNoID09PSB2b2lkIDApIHtcbiAgICAgIGRpc3BhdGNoID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0aW1lLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLmNvcHkodGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvNi5jdWVTcGxpdEF0VGltZSA9IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gQ2VhNjA4Q2hhbm5lbDtcbn0oKTtcbnZhciBDZWE2MDhQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZWE2MDhQYXJzZXIoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB2YXIgbG9nZ2VyID0gbmV3IENhcHRpb25zTG9nZ2VyKCk7XG4gICAgdGhpcy5jaGFubmVscyA9IFtudWxsLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCwgb3V0MSwgbG9nZ2VyKSwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQgKyAxLCBvdXQyLCBsb2dnZXIpXTtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgdmFyIF9wcm90bzcgPSBDZWE2MDhQYXJzZXIucHJvdG90eXBlO1xuICBfcHJvdG83LmdldEhhbmRsZXIgPSBmdW5jdGlvbiBnZXRIYW5kbGVyKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5nZXRIYW5kbGVyKCk7XG4gIH07XG4gIF9wcm90bzcuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAqLztcbiAgX3Byb3RvNy5hZGREYXRhID0gZnVuY3Rpb24gYWRkRGF0YSh0aW1lLCBieXRlTGlzdCkge1xuICAgIHZhciBjbWRGb3VuZDtcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICB2YXIgY2hhcnNGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VyLnRpbWUgPSB0aW1lO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XG4gICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRBVEEsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG4gICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICB2YXIgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgIGlmIChjdXJyQ2hOciAmJiBjdXJyQ2hOciA+IDApIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjdXJyQ2hOcl07XG4gICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLldBUk5JTkcsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCAmJiAhY2hhcnNGb3VuZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLldBUk5JTkcsIFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIENvbW1hbmQuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAqLztcbiAgX3Byb3RvNy5wYXJzZUNtZCA9IGZ1bmN0aW9uIHBhcnNlQ21kKGEsIGIpIHtcbiAgICB2YXIgY21kSGlzdG9yeSA9IHRoaXMuY21kSGlzdG9yeTtcbiAgICB2YXIgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxZCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MjEgJiYgYiA8PSAweDIzO1xuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjaE5yID0gYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MTcgPyAxIDogMjtcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MWQpIHtcbiAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJhKSB7XG4gICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJiKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYykge1xuICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmUpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi87XG4gIF9wcm90bzcucGFyc2VNaWRyb3cgPSBmdW5jdGlvbiBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgdmFyIGNoTnIgPSAwO1xuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5FUlJPUiwgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXG4gICAqLztcbiAgX3Byb3RvNy5wYXJzZVBBQyA9IGZ1bmN0aW9uIHBhcnNlUEFDKGEsIGIpIHtcbiAgICB2YXIgcm93O1xuICAgIHZhciBjbWRIaXN0b3J5ID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgIHZhciBjYXNlMSA9IChhID49IDB4MTEgJiYgYSA8PSAweDE3IHx8IGEgPj0gMHgxOSAmJiBhIDw9IDB4MWYpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4N2Y7XG4gICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg1ZjtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cblxuICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NWYpIHtcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYW5uZWwuc2V0UEFDKHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYikpO1xuICAgIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSk7XG4gICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAqLztcbiAgX3Byb3RvNy5pbnRlcnByZXRQQUMgPSBmdW5jdGlvbiBpbnRlcnByZXRQQUMocm93LCBfYnl0ZTMpIHtcbiAgICB2YXIgcGFjSW5kZXg7XG4gICAgdmFyIHBhY0RhdGEgPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6IGZhbHNlLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgIHJvdzogcm93XG4gICAgfTtcbiAgICBpZiAoX2J5dGUzID4gMHg1Zikge1xuICAgICAgcGFjSW5kZXggPSBfYnl0ZTMgLSAweDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNJbmRleCA9IF9ieXRlMyAtIDB4NDA7XG4gICAgfVxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgIH1cbiAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqLztcbiAgX3Byb3RvNy5wYXJzZUNoYXJzID0gZnVuY3Rpb24gcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgdmFyIGNoYW5uZWxOcjtcbiAgICB2YXIgY2hhckNvZGVzID0gbnVsbDtcbiAgICB2YXIgY2hhckNvZGUxID0gbnVsbDtcbiAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICBjaGFyQ29kZTEgPSBhO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICB2YXIgb25lQ29kZTtcbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCBcIlNwZWNpYWwgY2hhciAnXCIgKyBnZXRDaGFyRm9yQnl0ZShvbmVDb2RlKSArIFwiJyBpbiBjaGFubmVsIFwiICsgY2hhbm5lbE5yKTtcbiAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgIGNoYXJDb2RlcyA9IGIgPT09IDAgPyBbYV0gOiBbYSwgYl07XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgIHZhciBoZXhDb2RlcyA9IG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAqLztcbiAgX3Byb3RvNy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKSB7XG4gICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MmQgJiYgYiA8PSAweDJmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW5kZXg7XG4gICAgdmFyIGJrZ0RhdGEgPSB7fTtcbiAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGIgLSAweDIwKSAvIDIpO1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAqLztcbiAgX3Byb3RvNy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5jaGFubmVscykubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAqLztcbiAgX3Byb3RvNy5jdWVTcGxpdEF0VGltZSA9IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gQ2VhNjA4UGFyc2VyO1xufSgpO1xuZnVuY3Rpb24gc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIGNtZEhpc3RvcnkuYSA9IGE7XG4gIGNtZEhpc3RvcnkuYiA9IGI7XG59XG5mdW5jdGlvbiBoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xufVxuZnVuY3Rpb24gY3JlYXRlQ21kSGlzdG9yeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBhOiBudWxsLFxuICAgIGI6IG51bGxcbiAgfTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoQ2VhNjA4UGFyc2VyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY29kZWNzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jb2RlY3MudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaXNDb2RlY1N1cHBvcnRlZEluTXA0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiaXNDb2RlY1R5cGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNDb2RlY1R5cGUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxudmFyIHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgYTNkczogdHJ1ZSxcbiAgICAnYWMtMyc6IHRydWUsXG4gICAgJ2FjLTQnOiB0cnVlLFxuICAgIGFsYWM6IHRydWUsXG4gICAgYWxhdzogdHJ1ZSxcbiAgICBkcmExOiB0cnVlLFxuICAgICdkdHMrJzogdHJ1ZSxcbiAgICAnZHRzLSc6IHRydWUsXG4gICAgZHRzYzogdHJ1ZSxcbiAgICBkdHNlOiB0cnVlLFxuICAgIGR0c2g6IHRydWUsXG4gICAgJ2VjLTMnOiB0cnVlLFxuICAgIGVuY2E6IHRydWUsXG4gICAgZzcxOTogdHJ1ZSxcbiAgICBnNzI2OiB0cnVlLFxuICAgIG00YWU6IHRydWUsXG4gICAgbWhhMTogdHJ1ZSxcbiAgICBtaGEyOiB0cnVlLFxuICAgIG1obTE6IHRydWUsXG4gICAgbWhtMjogdHJ1ZSxcbiAgICBtbHBhOiB0cnVlLFxuICAgIG1wNGE6IHRydWUsXG4gICAgJ3JhdyAnOiB0cnVlLFxuICAgIE9wdXM6IHRydWUsXG4gICAgb3B1czogdHJ1ZSxcbiAgICAvLyBicm93c2VycyBleHBlY3QgdGhpcyB0byBiZSBsb3dlcmNhc2UgZGVzcGl0ZSBNUDRSQSBzYXlzICdPcHVzJ1xuICAgIHNhbXI6IHRydWUsXG4gICAgc2F3YjogdHJ1ZSxcbiAgICBzYXdwOiB0cnVlLFxuICAgIHNldmM6IHRydWUsXG4gICAgc3FjcDogdHJ1ZSxcbiAgICBzc212OiB0cnVlLFxuICAgIHR3b3M6IHRydWUsXG4gICAgdWxhdzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgIGF2YzE6IHRydWUsXG4gICAgYXZjMjogdHJ1ZSxcbiAgICBhdmMzOiB0cnVlLFxuICAgIGF2YzQ6IHRydWUsXG4gICAgYXZjcDogdHJ1ZSxcbiAgICBhdjAxOiB0cnVlLFxuICAgIGRyYWM6IHRydWUsXG4gICAgZHZhMTogdHJ1ZSxcbiAgICBkdmF2OiB0cnVlLFxuICAgIGR2aDE6IHRydWUsXG4gICAgZHZoZTogdHJ1ZSxcbiAgICBlbmN2OiB0cnVlLFxuICAgIGhldjE6IHRydWUsXG4gICAgaHZjMTogdHJ1ZSxcbiAgICBtanAyOiB0cnVlLFxuICAgIG1wNHY6IHRydWUsXG4gICAgbXZjMTogdHJ1ZSxcbiAgICBtdmMyOiB0cnVlLFxuICAgIG12YzM6IHRydWUsXG4gICAgbXZjNDogdHJ1ZSxcbiAgICByZXN2OiB0cnVlLFxuICAgIHJ2NjA6IHRydWUsXG4gICAgczI2MzogdHJ1ZSxcbiAgICBzdmMxOiB0cnVlLFxuICAgIHN2YzI6IHRydWUsXG4gICAgJ3ZjLTEnOiB0cnVlLFxuICAgIHZwMDg6IHRydWUsXG4gICAgdnAwOTogdHJ1ZVxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogdHJ1ZSxcbiAgICB3dnR0OiB0cnVlXG4gIH1cbn07XG5mdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICB2YXIgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoY29kZWMsIHR5cGUpIHtcbiAgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgodHlwZSB8fCAndmlkZW8nKSArIFwiL21wNDtjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIik7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2N1ZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jdWVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0cGFyc2VyICovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnZ0dC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuXG5cblxudmFyIFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xudmFyIEN1ZXMgPSB7XG4gIG5ld0N1ZTogZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHJvdztcbiAgICAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgQ3VlID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgaWYgKFdISVRFU1BBQ0VfQ0hBUi50ZXN0KHJvdy5jaGFyc1tjXS51Y2hhcikgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1ZVRleHQgPSAoMCxfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZml4TGluZUJyZWFrcykodGV4dC50cmltKCkpO1xuICAgICAgICB2YXIgaWQgPSAoMCxfd2VidnR0X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmdlbmVyYXRlQ3VlSWQpKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHRyYWNrIGRvIG5vdCBwdXNoIGl0XG4gICAgICAgIGlmICghdHJhY2sgfHwgIXRyYWNrLmN1ZXMgfHwgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChpZCkpIHtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMTAgYW5kIDgwIHBlcmNlbnQgKENFQS02MDggUEFDIGluZGVudCBjb2RlKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvdGV4dC10cmFja3MvcmF3LWZpbGUvZGVmYXVsdC82MDh0b1ZUVC82MDh0b1ZUVC5odG1sI3Bvc2l0aW9uaW5nLWluLWNlYS02MDhcbiAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrIHdpdGggb3V0IG9mIGJvdW5kcyAwLTEwMCB2YWx1ZXNcbiAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhY2sgJiYgcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgLy8gU29ydCBib3R0b20gY3VlcyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gbGluZSBvcmRlciB3aGVuIG92ZXJsYXBwaW5nIGluIENocm9tZVxuICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGN1ZUEsIGN1ZUIpIHtcbiAgICAgICAgaWYgKGN1ZUEubGluZSA9PT0gJ2F1dG8nIHx8IGN1ZUIubGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ZUEubGluZSA+IDggJiYgY3VlQi5saW5lID4gOCkge1xuICAgICAgICAgIHJldHVybiBjdWVCLmxpbmUgLSBjdWVBLmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gKDAsX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmFkZEN1ZVRvVHJhY2spKHRyYWNrLCBjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEN1ZXMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJhZGp1c3RTbGlkaW5nU3RhcnRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRqdXN0U2xpZGluZ1N0YXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJhbGlnbk1lZGlhUGxheWxpc3RCeVBEVFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYWxpZ25QRFRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWxpZ25QRFQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImFsaWduU3RyZWFtXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGFsaWduU3RyZWFtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWdcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmaW5kRmlyc3RGcmFnV2l0aENDXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpbmRGaXJzdEZyYWdXaXRoQ0MpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29udHJvbGxlci9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcblxuXG5cblxuZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIHZhciBmaXJzdEZyYWcgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdEZyYWc7XG59XG5mdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgaWYgKGxhc3RMZXZlbC5kZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHwgbGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscywgcmVmZXJlbmNlSW5kZXgpIHtcbiAgaWYgKHJlZmVyZW5jZUluZGV4ID09PSB2b2lkIDApIHtcbiAgICByZWZlcmVuY2VJbmRleCA9IDA7XG4gIH1cbiAgdmFyIHByZXZGcmFncyA9IHByZXZEZXRhaWxzLmZyYWdtZW50cztcbiAgdmFyIGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCBwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSB7XG4gICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWcsIHNsaWRpbmcpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnbWVudHNbaV0sIHNsaWRpbmcpO1xuICB9XG4gIC8vIFVwZGF0ZSBMTC1ITFMgcGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cbiAgZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5mdW5jdGlvbiBhbGlnblN0cmVhbShsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGlmICghbGFzdExldmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpO1xuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBsYXN0TGV2ZWwuZGV0YWlscyAmJiAhZGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAvLyBUcnkgdG8gYWxpZ24gb24gc24gc28gdGhhdCB3ZSBwaWNrIGEgYmV0dGVyIHN0YXJ0IGZyYWdtZW50LlxuICAgIC8vIERvIG5vdCBwZXJmb3JtIHRoaXMgb24gcGxheWxpc3RzIHdpdGggZGVsdGEgdXBkYXRlcyBhcyB0aGlzIGlzIG9ubHkgdG8gYWxpZ24gbGV2ZWxzIG9uIHN3aXRjaFxuICAgIC8vIGFuZCBhZGp1c3RTbGlkaW5nIG9ubHkgYWRqdXN0cyBmcmFnbWVudHMgYWZ0ZXIgc2tpcHBlZFNlZ21lbnRzLlxuICAgICgwLF9jb250cm9sbGVyX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmFkanVzdFNsaWRpbmcpKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCkge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgIHZhciByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgICBpZiAocmVmZXJlbmNlRnJhZyAmJiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHJlZmVyZW5jZUZyYWcuc3RhcnQpKSB7XG4gICAgICBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ubG9nZ2VyLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgXCIgKyBkZXRhaWxzLnVybCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBvZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgZGlmZmVyZW5jZSBpbiBQcm9ncmFtIERhdGUgVGltZSBmcm9tIHRoZSBsYXN0IGxldmVsLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKiBAcGFyYW0gbGFzdERldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25QRFQoZGV0YWlscywgbGFzdERldGFpbHMpIHtcbiAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB0aGUgdW5zYWZlIFwiIVwiIHVzYWdlIGJlbG93IGZvciBudWxsIHByb2dyYW0gZGF0ZSB0aW1lIGFjY2Vzcy5cbiAgaWYgKCFsYXN0RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIHx8ICFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhbGFzdERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIGxhc3QgbGV2ZWwgc2xpZGluZyBpcyAxMDAwIGFuZCBpdHMgZmlyc3QgZnJhZyBQUk9HUkFNLURBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDAgQU1cbiAgLy8gYW5kIGlmIG5ldyBkZXRhaWxzIGZpcnN0IGZyYWcgUFJPR1JBTSBEQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjA4IEFNXG4gIC8vIHRoZW4gd2UgY2FuIGRlZHVjZSB0aGF0IHBsYXlsaXN0IEIgc2xpZGluZyBpcyAxMDAwKzggPSAxMDA4c1xuICB2YXIgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG4gIHZhciBuZXdQRFQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIC8vIGRhdGUgZGlmZiBpcyBpbiBtcy4gZnJhZy5zdGFydCBpcyBpbiBzZWNvbmRzXG4gIHZhciBzbGlkaW5nID0gKG5ld1BEVCAtIGxhc3RQRFQpIC8gMTAwMCArIGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgaWYgKHNsaWRpbmcgJiYgKDAsX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzRmluaXRlTnVtYmVyKShzbGlkaW5nKSkge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5sb2dnZXIubG9nKFwiQWRqdXN0aW5nIFBUUyB1c2luZyBwcm9ncmFtRGF0ZVRpbWUgZGVsdGEgXCIgKyAobmV3UERUIC0gbGFzdFBEVCkgKyBcIm1zLCBzbGlkaW5nOlwiICsgc2xpZGluZy50b0ZpeGVkKDMpICsgXCIgXCIgKyBkZXRhaWxzLnVybCArIFwiIFwiKTtcbiAgICBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIGFwcHJvcHJpYXRlIHRpbWUtYWxpZ25tZW50IGJldHdlZW4gcmVuZGl0aW9ucyBiYXNlZCBvbiBQRFQuIFVubGlrZSBgYWxpZ25QRFRgLCB3aGljaCBhZGp1c3RzXG4gKiB0aGUgdGltZWxpbmUgYmFzZWQgb24gdGhlIGRlbHRhIGJldHdlZW4gUERUcyBvZiB0aGUgMHRoIGZyYWdtZW50IG9mIHR3byBwbGF5bGlzdHMvYExldmVsRGV0YWlsc2AsXG4gKiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIHRpbWVsaW5lcyByZXByZXNlbnRlZCBpbiBgcmVmRGV0YWlsc2AgYXJlIGFjY3VyYXRlLCBpbmNsdWRpbmcgdGhlIFBEVHMsXG4gKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAqIEdpdmVuIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIGZldGNoZXMgYW5kIGluaXRpYWwgbG9hZHMgb2YgbGl2ZSBgbWFpbmAgYW5kIGF1ZGlvL3N1YnRpdGxlIHRyYWNrcyxcbiAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICogYmUgY29uc2lzdGVudCBhY3Jvc3MgcGxheWxpc3RzLCBwZXIgdGhlIEhMUyBzcGVjLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgcmVmRGV0YWlscykge1xuICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIHZhciByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICB2YXIgbWlkZGxlRnJhZyA9IE1hdGgucm91bmQocmVmRnJhZ21lbnRzLmxlbmd0aCAvIDIpIC0gMTtcbiAgdmFyIHJlZkZyYWcgPSByZWZGcmFnbWVudHNbbWlkZGxlRnJhZ107XG4gIHZhciBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHJlZkZyYWcuY2MpIHx8IGZyYWdtZW50c1tNYXRoLnJvdW5kKGZyYWdtZW50cy5sZW5ndGggLyAyKSAtIDFdO1xuICB2YXIgcmVmUERUID0gcmVmRnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIHZhciB0YXJnZXRQRFQgPSBmcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKHJlZlBEVCA9PT0gbnVsbCB8fCB0YXJnZXRQRFQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRlbHRhID0gKHRhcmdldFBEVCAtIHJlZlBEVCkgLyAxMDAwIC0gKGZyYWcuc3RhcnQgLSByZWZGcmFnLnN0YXJ0KTtcbiAgYWRqdXN0U2xpZGluZ1N0YXJ0KGRlbHRhLCBkZXRhaWxzKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZXdtYSAqLyBcIi4vc3JjL3V0aWxzL2V3bWEudHNcIik7XG4vKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cblxudmFyIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbldlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3dfID0gdm9pZCAwO1xuICAgIHRoaXMuZmFzdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgX3V0aWxzX2V3bWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oZmFzdCk7XG4gIH1cbiAgdmFyIF9wcm90byA9IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IucHJvdG90eXBlO1xuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICB2YXIgc2xvd18gPSB0aGlzLnNsb3dfLFxuICAgICAgZmFzdF8gPSB0aGlzLmZhc3RfO1xuICAgIGlmICh0aGlzLnNsb3dfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKHNsb3csIHNsb3dfLmdldEVzdGltYXRlKCksIHNsb3dfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShmYXN0LCBmYXN0Xy5nZXRFc3RpbWF0ZSgpLCBmYXN0Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgdmFyIG51bUJpdHMgPSA4ICogbnVtQnl0ZXM7XG4gICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICB2YXIgZHVyYXRpb25TID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgLy8gdmFsdWUgaXMgYmFuZHdpZHRoIGluIGJpdHMvc1xuICAgIHZhciBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH07XG4gIF9wcm90by5jYW5Fc3RpbWF0ZSA9IGZ1bmN0aW9uIGNhbkVzdGltYXRlKCkge1xuICAgIHZhciBmYXN0ID0gdGhpcy5mYXN0XztcbiAgICByZXR1cm4gZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfO1xuICB9O1xuICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG4gIHJldHVybiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChFd21hQmFuZFdpZHRoRXN0aW1hdG9yKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2V3bWEudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG52YXIgRVdNQSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGZ1bmN0aW9uIEVXTUEoaGFsZkxpZmUsIGVzdGltYXRlLCB3ZWlnaHQpIHtcbiAgICBpZiAoZXN0aW1hdGUgPT09IHZvaWQgMCkge1xuICAgICAgZXN0aW1hdGUgPSAwO1xuICAgIH1cbiAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIHdlaWdodCA9IDA7XG4gICAgfVxuICAgIHRoaXMuaGFsZkxpZmUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHBoYV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5oYWxmTGlmZSA9IGhhbGZMaWZlO1xuICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSBlc3RpbWF0ZTtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHdlaWdodDtcbiAgfVxuICB2YXIgX3Byb3RvID0gRVdNQS5wcm90b3R5cGU7XG4gIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgIHZhciBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9O1xuICBfcHJvdG8uZ2V0VG90YWxXZWlnaHQgPSBmdW5jdGlvbiBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH07XG4gIF9wcm90by5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgdmFyIHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIGlmICh6ZXJvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgfTtcbiAgcmV0dXJuIEVXTUE7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKEVXTUEpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9mZXRjaC1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZmV0Y2hTdXBwb3J0ZWRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZmV0Y2hTdXBwb3J0ZWQpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9sb2FkLXN0YXRzICovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChcbiAgLy8gQHRzLWlnbm9yZVxuICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIEZldGNoTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmV0Y2hMb2FkZXIoY29uZmlnIC8qIEhsc0NvbmZpZyAqLykge1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlc3BvbnNlID0gdm9pZCAwO1xuICAgIHRoaXMuY29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCB8fCBnZXRSZXF1ZXN0O1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBzZWxmLkFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uTG9hZFN0YXRzKCk7XG4gIH1cbiAgdmFyIF9wcm90byA9IEZldGNoTG9hZGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICB9O1xuICBfcHJvdG8uYWJvcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcbiAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5vaykge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3MgIT09IHZvaWQgMCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHZhciBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgdmFyIG9uUHJvZ3Jlc3MgPSBjYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgIHZhciBMRU5HVEggPSBpc0FycmF5QnVmZmVyID8gJ2J5dGVMZW5ndGgnIDogJ2xlbmd0aCc7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmZldGNoU2V0dXAoY29udGV4dCwgaW5pdFBhcmFtcyk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBfdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgX3RoaXMucmVzcG9uc2UgPSBfdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3Ioc3RhdHVzVGV4dCB8fCAnZmV0Y2gsIGJhZCBuZXR3b3JrIHJlc3BvbnNlJywgc3RhdHVzLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICBzdGF0cy50b3RhbCA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpIHx8ICcwJyk7XG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiAoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICByZXR1cm4gX3RoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSBfdGhpcy5yZXNwb25zZTtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KF90aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICB2YXIgdG90YWwgPSByZXNwb25zZURhdGFbTEVOR1RIXTtcbiAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IHRvdGFsO1xuICAgICAgfVxuICAgICAgdmFyIGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhXG4gICAgICB9O1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLm9uU3VjY2Vzcyhsb2FkZXJSZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KF90aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAvLyB3aGVuIGRlc3Ryb3lpbmcsICdlcnJvcicgaXRzZWxmIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgIHZhciBjb2RlID0gIWVycm9yID8gMCA6IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIHZhciB0ZXh0ID0gIWVycm9yID8gbnVsbCA6IGVycm9yLm1lc3NhZ2U7XG4gICAgICBjYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH0sIGNvbnRleHQsIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZ2V0Q2FjaGVBZ2UgPSBmdW5jdGlvbiBnZXRDYWNoZUFnZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgdmFyIGFnZUhlYWRlciA9IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgX3Byb3RvLmxvYWRQcm9ncmVzc2l2ZWx5ID0gZnVuY3Rpb24gbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHZvaWQgMCkge1xuICAgICAgaGlnaFdhdGVyTWFyayA9IDA7XG4gICAgfVxuICAgIHZhciBjaHVua0NhY2hlID0gbmV3IF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgpO1xuICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIHZhciBwdW1wID0gZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZG9uZSkge1xuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcbiAgICAgICAgaWYgKGxlbiA8IGhpZ2hXYXRlck1hcmsgfHwgY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2h1bmsgaXMgdG9vIHNtYWxsIHRvIHRvIGJlIGVtaXR0ZWQgb3IgdGhlIGNhY2hlIGFscmVhZHkgaGFzIGRhdGFcbiAgICAgICAgICAvLyBQdXNoIGl0IHRvIHRoZSBjYWNoZVxuICAgICAgICAgIGNodW5rQ2FjaGUucHVzaChjaHVuayk7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBpbiBvcmRlciB0byBqb2luIHRoZSB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgY2FjaGVkIGFscmVhZHksIGFuZCB0aGUgY2hhY2hlIGlzIGxhcmdlIGVub3VnaFxuICAgICAgICAgIC8vIGp1c3QgZW1pdCB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuaywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGFib3J0ZWQgKi9cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBwdW1wKCk7XG4gIH07XG4gIHJldHVybiBGZXRjaExvYWRlcjtcbn0oKTtcbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICB2YXIgaW5pdFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWw6IHNpZ25hbCxcbiAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICB9O1xuICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgfVxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dCwgaW5pdFBhcmFtcykge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChjb250ZXh0LnVybCwgaW5pdFBhcmFtcyk7XG59XG52YXIgRmV0Y2hFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZldGNoRXJyb3IsIF9FcnJvcik7XG4gIGZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgIHZhciBfdGhpczI7XG4gICAgX3RoaXMyID0gX0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpczIuY29kZSA9IHZvaWQgMDtcbiAgICBfdGhpczIuZGV0YWlscyA9IHZvaWQgMDtcbiAgICBfdGhpczIuY29kZSA9IGNvZGU7XG4gICAgX3RoaXMyLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgcmV0dXJuIEZldGNoRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChGZXRjaExvYWRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2hleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvaGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAqL1xuXG52YXIgSGV4ID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiBoZXhEdW1wKGFycmF5KSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoID0gYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBoO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChIZXgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIklNU0MxX0NPREVDXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIElNU0MxX0NPREVDKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZUlNU0MxXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlSU1TQzEpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dGN1ZSAqLyBcIi4vc3JjL3V0aWxzL3Z0dGN1ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vd2VidnR0LXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIudHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuXG5cblxuXG5cbnZhciBJTVNDMV9DT0RFQyA9ICdzdHBwLnR0bWwuaW0xdCc7XG5cbi8vIFRpbWUgZm9ybWF0OiBoOm06czpmcmFtZXMoLnN1YmZyYW1lcylcbnZhciBITVNGX1JFR0VYID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvO1xuXG4vLyBUaW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgZnJhbWVzLCB0aWNrc1xudmFyIFRJTUVfVU5JVF9SRUdFWCA9IC9eKFxcZCooPzpcXC5cXGQqKT8pKGh8bXxzfG1zfGZ8dCkkLztcbnZhciB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgdGltZXNjYWxlLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICB2YXIgcmVzdWx0cyA9ICgwLF9tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5maW5kQm94KShuZXcgVWludDhBcnJheShwYXlsb2FkKSwgWydtZGF0J10pO1xuICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICBlcnJvckNhbGxCYWNrKG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlIElNU0MxIG1kYXQnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0dG1sTGlzdCA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uIChtZGF0KSB7XG4gICAgcmV0dXJuICgwLF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy51dGY4QXJyYXlUb1N0cikobWRhdCk7XG4gIH0pO1xuICB2YXIgc3luY1RpbWUgPSAoMCxfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy50b1RpbWVzY2FsZUZyb21TY2FsZSkoaW5pdFBUUywgMSwgdGltZXNjYWxlKTtcbiAgdHJ5IHtcbiAgICB0dG1sTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0dG1sKSB7XG4gICAgICByZXR1cm4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJyb3JDYWxsQmFjayhlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkge1xuICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICB2YXIgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0dG1sLCAndGV4dC94bWwnKTtcbiAgdmFyIHR0ID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0dCcpWzBdO1xuICBpZiAoIXR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR0bWwnKTtcbiAgfVxuICB2YXIgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgdGlja1JhdGU6IDBcbiAgfTtcbiAgdmFyIHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB0dC5nZXRBdHRyaWJ1dGUoXCJ0dHA6XCIgKyBrZXkpIHx8IGRlZmF1bHRSYXRlSW5mb1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgdmFyIHRyaW0gPSB0dC5nZXRBdHRyaWJ1dGUoJ3htbDpzcGFjZScpICE9PSAncHJlc2VydmUnO1xuICB2YXIgc3R5bGVFbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdzdHlsaW5nJywgJ3N0eWxlJykpO1xuICB2YXIgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgdmFyIGN1ZUVsZW1lbnRzID0gZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdib2R5JywgJ1tiZWdpbl0nKTtcbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBmdW5jdGlvbiAoY3VlRWxlbWVudCkge1xuICAgIHZhciBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG4gICAgaWYgKCFjdWVUZXh0IHx8ICFjdWVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYmVnaW4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzdGFydFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdiZWdpbicpLCByYXRlSW5mbyk7XG4gICAgdmFyIGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICB2YXIgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZW5kVGltZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG4gICAgdmFyIGN1ZSA9IG5ldyBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHN0YXJ0VGltZSAtIHN5bmNUaW1lLCBlbmRUaW1lIC0gc3luY1RpbWUsIGN1ZVRleHQpO1xuICAgIGN1ZS5pZCA9ICgwLF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uZ2VuZXJhdGVDdWVJZCkoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICB2YXIgcmVnaW9uID0gcmVnaW9uRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZ2lvbicpXTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTtcblxuICAgIC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcbiAgICB2YXIgc3R5bGVzID0gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlLCBzdHlsZUVsZW1lbnRzKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGVzLnRleHRBbGlnbjtcbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAvLyBjdWUucG9zaXRpb25BbGlnbiBub3Qgc2V0dGFibGUgaW4gRkZ+MjAxNlxuICAgICAgdmFyIGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG4gICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBsaW5lQWxpZ247XG4gICAgICB9XG4gICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgfVxuICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcbiAgICByZXR1cm4gY3VlO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGN1ZSkge1xuICAgIHJldHVybiBjdWUgIT09IG51bGw7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudENvbGxlY3Rpb24oZnJvbUVsZW1lbnQsIHBhcmVudE5hbWUsIGNoaWxkTmFtZSkge1xuICB2YXIgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gIHJldHVybiBlbGVtZW50c1dpdGhJZC5yZWR1Y2UoZnVuY3Rpb24gKGRpY3QsIGVsZW1lbnQpIHtcbiAgICB2YXIgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBkaWN0W2lkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcykucmVkdWNlKGZ1bmN0aW9uIChzdHIsIG5vZGUsIGkpIHtcbiAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgJ1xcbic7XG4gICAgfVxuICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT09IG51bGwgJiYgX25vZGUkY2hpbGROb2RlcyAhPT0gdm9pZCAwICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgfSBlbHNlIGlmICh0cmltKSB7XG4gICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlLCBzdHlsZUVsZW1lbnRzKSB7XG4gIHZhciB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICB2YXIgcmVnaW9uU3R5bGUgPSBudWxsO1xuICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydkaXNwbGF5QWxpZ24nLCAndGV4dEFsaWduJywgJ2NvbG9yJywgJ2JhY2tncm91bmRDb2xvcicsICdmb250U2l6ZScsICdmb250RmFtaWx5J1xuICAvLyAnZm9udFdlaWdodCcsXG4gIC8vICdsaW5lSGVpZ2h0JyxcbiAgLy8gJ3dyYXBPcHRpb24nLFxuICAvLyAnZm9udFN0eWxlJyxcbiAgLy8gJ2RpcmVjdGlvbicsXG4gIC8vICd3cml0aW5nTW9kZSdcbiAgXTtcblxuICB2YXIgcmVnaW9uU3R5bGVOYW1lID0gcmVnaW9uICE9PSBudWxsICYmIHJlZ2lvbiAhPT0gdm9pZCAwICYmIHJlZ2lvbi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgPyByZWdpb24uZ2V0QXR0cmlidXRlKCdzdHlsZScpIDogbnVsbDtcbiAgaWYgKHJlZ2lvblN0eWxlTmFtZSAmJiBzdHlsZUVsZW1lbnRzLmhhc093blByb3BlcnR5KHJlZ2lvblN0eWxlTmFtZSkpIHtcbiAgICByZWdpb25TdHlsZSA9IHN0eWxlRWxlbWVudHNbcmVnaW9uU3R5bGVOYW1lXTtcbiAgfVxuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGVzLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb25TdHlsZSwgdHRzTnMsIG5hbWUpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKG5zLCBuYW1lKSA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcFBhcnNpbmdFcnJvcihub2RlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgdHRtbCB0aW1lc3RhbXAgXCIgKyBub2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzZWNvbmRzID0gKDAsX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnBhcnNlVGltZVN0YW1wKSh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBpZiAoc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIGlmIChITVNGX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgc2Vjb25kcyA9IHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9IGVsc2UgaWYgKFRJTUVfVU5JVF9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlY29uZHM7XG59XG5mdW5jdGlvbiBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICB2YXIgbSA9IEhNU0ZfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICB2YXIgZnJhbWVzID0gKG1bNF0gfCAwKSArIChtWzVdIHwgMCkgLyByYXRlSW5mby5zdWJGcmFtZVJhdGU7XG4gIHJldHVybiAobVsxXSB8IDApICogMzYwMCArIChtWzJdIHwgMCkgKiA2MCArIChtWzNdIHwgMCkgKyBmcmFtZXMgLyByYXRlSW5mby5mcmFtZVJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIHZhciBtID0gVElNRV9VTklUX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgdmFyIHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICB2YXIgdW5pdCA9IG1bMl07XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDYwO1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDEwMDA7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby50aWNrUmF0ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2tleXN5c3RlbS11dGlsLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2tleXN5c3RlbS11dGlsLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY2hhbmdlRW5kaWFubmVzc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjaGFuZ2VFbmRpYW5uZXNzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwic3RyVG9VdGY4YXJyYXlcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3RyVG9VdGY4YXJyYXkpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbnVtZXJpY19lbmNvZGluZ191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9udW1lcmljLWVuY29kaW5nLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvbnVtZXJpYy1lbmNvZGluZy11dGlscy50c1wiKTtcblxuZnVuY3Rpb24gZ2V0S2V5SWRCeXRlcyhzdHIpIHtcbiAgdmFyIGtleUlkYnl0ZXMgPSBzdHJUb1V0ZjhhcnJheShzdHIpLnN1YmFycmF5KDAsIDE2KTtcbiAgdmFyIHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gcGFkZGVka2V5SWRieXRlcztcbn1cbmZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgdmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGFycmF5LCBmcm9tLCB0bykge1xuICAgIHZhciBjdXIgPSBhcnJheVtmcm9tXTtcbiAgICBhcnJheVtmcm9tXSA9IGFycmF5W3RvXTtcbiAgICBhcnJheVt0b10gPSBjdXI7XG4gIH07XG4gIHN3YXAoa2V5SWQsIDAsIDMpO1xuICBzd2FwKGtleUlkLCAxLCAyKTtcbiAgc3dhcChrZXlJZCwgNCwgNSk7XG4gIHN3YXAoa2V5SWQsIDYsIDcpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFVcmlUb0FycmF5Qnl0ZXModXJpKSB7XG4gIC8vIGRhdGE6WzxtZWRpYSB0eXBlXVs7YXR0cmlidXRlPXZhbHVlXVs7YmFzZTY0XSw8ZGF0YT5cbiAgdmFyIGNvbG9uc3BsaXQgPSB1cmkuc3BsaXQoJzonKTtcbiAgdmFyIGtleWRhdGEgPSBudWxsO1xuICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNlbWljb2xvbnNwbGl0ID0gY29sb25zcGxpdFsxXS5zcGxpdCgnOycpO1xuICAgIHZhciBjb21tYXNwbGl0ID0gc2VtaWNvbG9uc3BsaXRbc2VtaWNvbG9uc3BsaXQubGVuZ3RoIC0gMV0uc3BsaXQoJywnKTtcbiAgICBpZiAoY29tbWFzcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBpc2Jhc2U2NCA9IGNvbW1hc3BsaXRbMF0gPT09ICdiYXNlNjQnO1xuICAgICAgdmFyIGRhdGEgPSBjb21tYXNwbGl0WzFdO1xuICAgICAgaWYgKGlzYmFzZTY0KSB7XG4gICAgICAgIHNlbWljb2xvbnNwbGl0LnNwbGljZSgtMSwgMSk7IC8vIHJlbW92ZSBmcm9tIHByb2Nlc3NpbmdcbiAgICAgICAga2V5ZGF0YSA9ICgwLF9udW1lcmljX2VuY29kaW5nX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYmFzZTY0RGVjb2RlKShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleWRhdGEgPSBnZXRLZXlJZEJ5dGVzKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5ZGF0YTtcbn1cbmZ1bmN0aW9uIHN0clRvVXRmOGFycmF5KHN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9sb2dnZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZW5hYmxlTG9nc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBlbmFibGVMb2dzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJsb2dnZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbG9nZ2VyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG52YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgdmFyIGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG4gIGlmIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMuYmluZChzZWxmLmNvbnNvbGUsIFwiW1wiICsgdHlwZSArIFwiXSA+XCIpO1xuICB9XG4gIHJldHVybiBub29wO1xufVxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnLCBpZCkge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGlmIChzZWxmLmNvbnNvbGUgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgIC8vICd0cmFjZScsXG4gICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZyhcIkRlYnVnIGxvZ3MgZW5hYmxlZCBmb3IgXFxcIlwiICsgaWQgKyBcIlxcXCJcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cbnZhciBsb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIktleVN5c3RlbUZvcm1hdHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gS2V5U3lzdGVtRm9ybWF0cyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiS2V5U3lzdGVtSWRzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEtleVN5c3RlbUlkcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiS2V5U3lzdGVtc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBLZXlTeXN0ZW1zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldEtleVN5c3RlbXNGb3JDb25maWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwia2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGtleVN5c3RlbUlkVG9LZXlTeXN0ZW1Eb21haW4pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcztcblxuLy8gUGxheWxpc3QgI0VYVC1YLUtFWSBLRVlGT1JNQVQgdmFsdWVzXG4oZnVuY3Rpb24gKEtleVN5c3RlbXMpIHtcbiAgS2V5U3lzdGVtc1tcIkNMRUFSS0VZXCJdID0gXCJvcmcudzMuY2xlYXJrZXlcIjtcbiAgS2V5U3lzdGVtc1tcIkZBSVJQTEFZXCJdID0gXCJjb20uYXBwbGUuZnBzXCI7XG4gIEtleVN5c3RlbXNbXCJQTEFZUkVBRFlcIl0gPSBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCI7XG4gIEtleVN5c3RlbXNbXCJXSURFVklORVwiXSA9IFwiY29tLndpZGV2aW5lLmFscGhhXCI7XG59KShLZXlTeXN0ZW1zIHx8IChLZXlTeXN0ZW1zID0ge30pKTtcbnZhciBLZXlTeXN0ZW1Gb3JtYXRzO1xuKGZ1bmN0aW9uIChLZXlTeXN0ZW1Gb3JtYXRzKSB7XG4gIEtleVN5c3RlbUZvcm1hdHNbXCJDTEVBUktFWVwiXSA9IFwib3JnLnczLmNsZWFya2V5XCI7XG4gIEtleVN5c3RlbUZvcm1hdHNbXCJGQUlSUExBWVwiXSA9IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCI7XG4gIEtleVN5c3RlbUZvcm1hdHNbXCJQTEFZUkVBRFlcIl0gPSBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCI7XG4gIEtleVN5c3RlbUZvcm1hdHNbXCJXSURFVklORVwiXSA9IFwidXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkXCI7XG59KShLZXlTeXN0ZW1Gb3JtYXRzIHx8IChLZXlTeXN0ZW1Gb3JtYXRzID0ge30pKTtcbmZ1bmN0aW9uIGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkZBSVJQTEFZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuQ0xFQVJLRVk7XG4gIH1cbn1cblxuLy8gU3lzdGVtIElEcyBmb3Igd2hpY2ggd2UgY2FuIGV4dHJhY3QgYSBrZXkgSUQgZnJvbSBcImVuY3J5cHRlZFwiIGV2ZW50IFBTU0hcbnZhciBLZXlTeXN0ZW1JZHM7XG4oZnVuY3Rpb24gKEtleVN5c3RlbUlkcykge1xuICBLZXlTeXN0ZW1JZHNbXCJXSURFVklORVwiXSA9IFwiZWRlZjhiYTk3OWQ2NGFjZWEzYzgyN2RjZDUxZDIxZWRcIjtcbn0pKEtleVN5c3RlbUlkcyB8fCAoS2V5U3lzdGVtSWRzID0ge30pKTtcbmZ1bmN0aW9uIGtleVN5c3RlbUlkVG9LZXlTeXN0ZW1Eb21haW4oc3lzdGVtSWQpIHtcbiAgaWYgKHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuV0lERVZJTkUpIHtcbiAgICByZXR1cm4gS2V5U3lzdGVtcy5XSURFVklORTtcbiAgICAvLyB9IGVsc2UgaWYgKHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuUExBWVJFQURZKSB7XG4gICAgLy8gICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgLy8gfSBlbHNlIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLkNFTkMgfHwgc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5DTEVBUktFWSkge1xuICAgIC8vICAgcmV0dXJuIEtleVN5c3RlbXMuQ0xFQVJLRVk7XG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSB7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLlBMQVlSRUFEWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTtcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyhjb25maWcpIHtcbiAgdmFyIGRybVN5c3RlbXMgPSBjb25maWcuZHJtU3lzdGVtcyxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmwgPSBjb25maWcud2lkZXZpbmVMaWNlbnNlVXJsO1xuICB2YXIga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihmdW5jdGlvbiAoa2V5U3lzdGVtKSB7XG4gICAgcmV0dXJuICEhZHJtU3lzdGVtc1trZXlTeXN0ZW1dO1xuICB9KSA6IFtdO1xuICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHRbS2V5U3lzdGVtcy5XSURFVklORV0gJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAga2V5U3lzdGVtc1RvQXR0ZW1wdC5wdXNoKEtleVN5c3RlbXMuV0lERVZJTkUpO1xuICB9XG4gIHJldHVybiBrZXlTeXN0ZW1zVG9BdHRlbXB0O1xufVxudmFyIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLm5hdmlnYXRvciAmJiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLmJpbmQoc2VsZi5uYXZpZ2F0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KCk7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgdmFyIGluaXREYXRhVHlwZXM7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgaW5pdERhdGFUeXBlcyA9IFsnY2VuYycsICdzaW5mJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgY2FzZSBLZXlTeXN0ZW1zLlBMQVlSRUFEWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAna2V5aWRzJ107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBrZXktc3lzdGVtOiBcIiArIGtleVN5c3RlbSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIHZhciBiYXNlQ29uZmlnID0ge1xuICAgIGluaXREYXRhVHlwZXM6IGluaXREYXRhVHlwZXMsXG4gICAgcGVyc2lzdGVudFN0YXRlOiBkcm1TeXN0ZW1PcHRpb25zLnBlcnNpc3RlbnRTdGF0ZSB8fCAnbm90LWFsbG93ZWQnLFxuICAgIGRpc3RpbmN0aXZlSWRlbnRpZmllcjogZHJtU3lzdGVtT3B0aW9ucy5kaXN0aW5jdGl2ZUlkZW50aWZpZXIgfHwgJ25vdC1hbGxvd2VkJyxcbiAgICBzZXNzaW9uVHlwZXM6IGRybVN5c3RlbU9wdGlvbnMuc2Vzc2lvblR5cGVzIHx8IFtkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlIHx8ICd0ZW1wb3JhcnknXSxcbiAgICBhdWRpb0NhcGFiaWxpdGllczogYXVkaW9Db2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXVkaW8vbXA0OyBjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIixcbiAgICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICAgIGVuY3J5cHRpb25TY2hlbWU6IGRybVN5c3RlbU9wdGlvbnMuYXVkaW9FbmNyeXB0aW9uU2NoZW1lIHx8IG51bGxcbiAgICAgIH07XG4gICAgfSksXG4gICAgdmlkZW9DYXBhYmlsaXRpZXM6IHZpZGVvQ29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInZpZGVvL21wNDsgY29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIsXG4gICAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnLFxuICAgICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLnZpZGVvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG4gIHJldHVybiBbYmFzZUNvbmZpZ107XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImdldE1lZGlhU291cmNlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldE1lZGlhU291cmNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqIE1lZGlhU291cmNlIGhlbHBlclxuICovXG5cbmZ1bmN0aW9uIGdldE1lZGlhU291cmNlKCkge1xuICByZXR1cm4gc2VsZi5NZWRpYVNvdXJjZSB8fCBzZWxmLldlYktpdE1lZGlhU291cmNlO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21wNC10b29scy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJSZW11eGVyVHJhY2tJZENvbmZpZ1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBSZW11eGVyVHJhY2tJZENvbmZpZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYXBwZW5kVWludDhBcnJheVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhcHBlbmRVaW50OEFycmF5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJiaW4yc3RyXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGJpbjJzdHIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkaXNjYXJkRVBCXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGRpc2NhcmRFUEIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImZpbmRCb3hcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZmluZEJveCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZ2V0RHVyYXRpb25cIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0RHVyYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImdldFN0YXJ0RFRTXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFN0YXJ0RFRTKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJtcDRCb3hcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbXA0Qm94KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJtcDRwc3NoXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG1wNHBzc2gpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIm9mZnNldFN0YXJ0RFRTXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG9mZnNldFN0YXJ0RFRTKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZUVtc2dcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcGFyc2VFbXNnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZUluaXRTZWdtZW50XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlSW5pdFNlZ21lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInBhcnNlUHNzaFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJzZVBzc2gpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInBhcnNlU0VJTWVzc2FnZUZyb21OQUx1XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZVNhbXBsZXNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcGFyc2VTYW1wbGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwYXJzZVNlZ21lbnRJbmRleFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJzZVNlZ21lbnRJbmRleCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicGFyc2VTaW5mXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlU2luZiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicGF0Y2hFbmN5cHRpb25EYXRhXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhdGNoRW5jeXB0aW9uRGF0YSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicmVhZFNpbnQzMlwiOiAoKSA9PiAoLyogYmluZGluZyAqLyByZWFkU2ludDMyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJyZWFkVWludDE2XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlYWRVaW50MTYpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInJlYWRVaW50MzJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcmVhZFVpbnQzMiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwic2VnbWVudFZhbGlkUmFuZ2VcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2VnbWVudFZhbGlkUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIndyaXRlVWludDMyXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHdyaXRlVWludDMyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZXggKi8gXCIuL3NyYy91dGlscy9oZXgudHNcIik7XG5cblxuXG5cblxudmFyIFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBXZSBhcmUgdXNpbmcgZml4ZWQgdHJhY2sgSURzIGZvciBkcml2aW5nIHRoZSBNUDQgcmVtdXhlclxuLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIFRTIFBJRHMuXG4vLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4vLyBtYXkgbm90IGxpa2UgaWYgdGhlcmUgYXJlIFRyYWNrSUQgXCJzd2l0Y2hlc1wiXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzEzMzFcbi8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbi8vIFdpdGggTVNFIGN1cnJlbnRseSBvbmUgY2FuIG9ubHkgaGF2ZSBvbmUgdHJhY2sgb2YgZWFjaCwgYW5kIHdlIGFyZSBtdXhpbmdcbi8vIHdoYXRldmVyIHZpZGVvL2F1ZGlvIHJlbmRpdGlvbiBpbiB0aGVtLlxudmFyIFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgMV07XG4gIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG59XG5mdW5jdGlvbiByZWFkVWludDMyKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciB2YWwgPSByZWFkU2ludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbn1cbmZ1bmN0aW9uIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDggJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59XG5cbi8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuZnVuY3Rpb24gZmluZEJveChkYXRhLCBwYXRoKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgdmFyIGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgdmFyIHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIHZhciB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIHZhciBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgdmFyIHN1YnJlc3VsdHMgPSBmaW5kQm94KGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCksIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBlbmRib3g7XG4gIH1cblxuICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4KSB7XG4gIHZhciByZWZlcmVuY2VzID0gW107XG4gIHZhciB2ZXJzaW9uID0gc2lkeFswXTtcblxuICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgdmFyIGluZGV4ID0gODtcbiAgdmFyIHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSA0O1xuXG4gIC8vIFRPRE86IHBhcnNlIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSBhbmQgZmlyc3RPZmZzZXRcbiAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG4gIHZhciBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICB2YXIgZmlyc3RPZmZzZXQgPSAwO1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIGluZGV4ICs9IDg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggKz0gMTY7XG4gIH1cblxuICAvLyBza2lwIHJlc2VydmVkXG4gIGluZGV4ICs9IDI7XG4gIHZhciBzdGFydEJ5dGUgPSBzaWR4Lmxlbmd0aCArIGZpcnN0T2Zmc2V0O1xuICB2YXIgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICB2YXIgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcbiAgICB2YXIgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgdmFyIHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3ZmZmZmZmZjtcbiAgICB2YXIgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3Vic2VnbWVudER1cmF0aW9uID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgcmVmZXJlbmNlU2l6ZTogcmVmZXJlbmNlU2l6ZSxcbiAgICAgIHN1YnNlZ21lbnREdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgLy8gdW5zY2FsZWRcbiAgICAgIGluZm86IHtcbiAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHN0YXJ0Qnl0ZSArPSByZWZlcmVuY2VTaXplO1xuXG4gICAgLy8gU2tpcHBpbmcgMSBiaXQgZm9yIHxzdGFydHNXaXRoU2FwfCwgMyBiaXRzIGZvciB8c2FwVHlwZXwsIGFuZCAyOCBiaXRzXG4gICAgLy8gZm9yIHxzYXBEZWx0YXwuXG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICB9XG4gIHJldHVybiB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQ6IHJlZmVyZW5jZXNDb3VudCxcbiAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzXG4gIH07XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXG4gKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAqXG4gKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXG4gKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cbiAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gKiBgYGBcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gKiBgYGBcbiAqIEBwYXJhbSBpbml0U2VnbWVudCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm4ge0luaXREYXRhfSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFrID0gdHJha3NbaV07XG4gICAgdmFyIHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICBpZiAodGtoZCkge1xuICAgICAgdmFyIHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgdmFyIF9pbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgdmFyIHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIF9pbmRleCk7XG4gICAgICB2YXIgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICBpZiAobWRoZCkge1xuICAgICAgICB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgICAgX2luZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIHZhciB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIF9pbmRleCk7XG4gICAgICAgIHZhciBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICB2YXIgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHtcbiAgICAgICAgICAgIHNvdW46IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sXG4gICAgICAgICAgICB2aWRlOiBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgfVtoZGxyVHlwZV07XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvZGVjIGRldGFpbHNcbiAgICAgICAgICAgIHZhciBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICAgICAgICB2YXIgY29kZWMgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc3RzZCkge1xuICAgICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoc3RzZC5zdWJhcnJheSgxMiwgMTYpKTtcbiAgICAgICAgICAgICAgLy8gVE9ETzogUGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZS5cbiAgICAgICAgICAgICAgLy8gc3RzZC5zdGFydCArPSA4O1xuICAgICAgICAgICAgICAvLyBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc3RzZCwgW2NvZGVjXSlbMF07XG4gICAgICAgICAgICAgIC8vIGlmIChjb2RlY0JveCkge1xuICAgICAgICAgICAgICAvLyAgIFRPRE86IENvZGVjIHBhcnNpbmcgc3VwcG9ydCBmb3IgYXZjMSwgbXA0YSwgaGV2YywgYXYwMS4uLlxuICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgICBpZDogdHJhY2tJZCxcbiAgICAgICAgICAgICAgY29kZWM6IGNvZGVjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaChmdW5jdGlvbiAodHJleCkge1xuICAgIHZhciB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICB2YXIgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkge1xuICBpZiAoIWluaXRTZWdtZW50IHx8ICFkZWNyeXB0ZGF0YSkge1xuICAgIHJldHVybiBpbml0U2VnbWVudDtcbiAgfVxuICB2YXIga2V5SWQgPSBkZWNyeXB0ZGF0YS5rZXlJZDtcbiAgaWYgKGtleUlkICYmIGRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgIHZhciB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIHRyYWtzLmZvckVhY2goZnVuY3Rpb24gKHRyYWspIHtcbiAgICAgIHZhciBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG5cbiAgICAgIC8vIHNraXAgdGhlIHNhbXBsZSBlbnRyeSBjb3VudFxuICAgICAgdmFyIHNhbXBsZUVudHJpZXMgPSBzdHNkLnN1YmFycmF5KDgpO1xuICAgICAgdmFyIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY2EnXSk7XG4gICAgICB2YXIgaXNBdWRpbyA9IGVuY0JveGVzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoIWlzQXVkaW8pIHtcbiAgICAgICAgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jdiddKTtcbiAgICAgIH1cbiAgICAgIGVuY0JveGVzLmZvckVhY2goZnVuY3Rpb24gKGVuYykge1xuICAgICAgICB2YXIgZW5jQm94Q2hpbGRyZW4gPSBpc0F1ZGlvID8gZW5jLnN1YmFycmF5KDI4KSA6IGVuYy5zdWJhcnJheSg3OCk7XG4gICAgICAgIHZhciBzaW5mQm94ZXMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgICAgIHNpbmZCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaW5mKSB7XG4gICAgICAgICAgdmFyIHRlbmMgPSBwYXJzZVNpbmYoc2luZik7XG4gICAgICAgICAgaWYgKHRlbmMpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGRlZmF1bHQga2V5IGlkIChrZXlJRCBvZmZzZXQgaXMgYWx3YXlzIDggd2l0aGluIHRoZSB0ZW5jIGJveCk6XG4gICAgICAgICAgICB2YXIgdGVuY0tleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgICAgICBpZiAoIXRlbmNLZXlJZC5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiICE9PSAwO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci5sb2coXCJbZW1lXSBQYXRjaGluZyBrZXlJZCBpbiAnZW5jXCIgKyAoaXNBdWRpbyA/ICdhJyA6ICd2JykgKyBcIj5zaW5mPj50ZW5jJyBib3g6IFwiICsgX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXS5oZXhEdW1wKHRlbmNLZXlJZCkgKyBcIiAtPiBcIiArIF9oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0uaGV4RHVtcChrZXlJZCkpO1xuICAgICAgICAgICAgICB0ZW5jLnNldChrZXlJZCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbml0U2VnbWVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZihzaW5mKSB7XG4gIHZhciBzY2htID0gZmluZEJveChzaW5mLCBbJ3NjaG0nXSlbMF07XG4gIGlmIChzY2htKSB7XG4gICAgdmFyIHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgaWYgKHNjaGVtZSA9PT0gJ2NiY3MnIHx8IHNjaGVtZSA9PT0gJ2NlbmMnKSB7XG4gICAgICByZXR1cm4gZmluZEJveChzaW5mLCBbJ3NjaGknLCAndGVuYyddKVswXTtcbiAgICB9XG4gIH1cbiAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmxvZ2dlci5lcnJvcihcIltlbWVdIG1pc3NpbmcgJ3NjaG0nIGJveFwiKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSBpbml0RGF0YSB7SW5pdERhdGF9IGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXNcbiAqIEBwYXJhbSBmbXA0IHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgdGhlIG1wNCBmcmFnbWVudFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG5mdW5jdGlvbiBnZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCkge1xuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgcmV0dXJuIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHRyYWYpIHtcbiAgICB2YXIgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgIHZhciB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICB2YXIgc3RhcnQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdGZoZCkge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgdmFyIHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHZhciBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgYmFzZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgdmFyIHNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzdGFydFRpbWUpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgbnVsbCk7XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBudWxsKSB8fCAwO1xufVxuXG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrRnJhZ21lbnRIZWFkZXJCb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRmaGTigJksIDAsIHRmX2ZsYWdzKXtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgIC8vIGFsbCB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgdW5zaWduZWQgaW50KDY0KSAgYmFzZV9kYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfc2l6ZTtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgfVxuICovXG5mdW5jdGlvbiBnZXREdXJhdGlvbihkYXRhLCBpbml0RGF0YSkge1xuICB2YXIgcmF3RHVyYXRpb24gPSAwO1xuICB2YXIgdmlkZW9EdXJhdGlvbiA9IDA7XG4gIHZhciBhdWRpb0R1cmF0aW9uID0gMDtcbiAgdmFyIHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFmID0gdHJhZnNbaV07XG4gICAgLy8gVGhlcmUgaXMgb25seSBvbmUgdGZoZCAmIHRydW4gcGVyIHRyYWZcbiAgICAvLyBUaGlzIGlzIHRydWUgZm9yIENNQUYgc3R5bGUgY29udGVudCwgYW5kIHdlIHNob3VsZCBwZXJoYXBzIGNoZWNrIHRoZSBmdHlwXG4gICAgLy8gYW5kIG9ubHkgbG9vayBmb3IgYSBzaW5nbGUgdHJ1biB0aGVuLCBidXQgZm9yIElTT0JNRkYgd2Ugc2hvdWxkIGNoZWNrXG4gICAgLy8gZm9yIG11bHRpcGxlIHRyYWNrIHJ1bnMuXG4gICAgdmFyIHRmaGQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKVswXTtcbiAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIHZhciB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHRyYWNrRGVmYXVsdCA9IHRyYWNrLmRlZmF1bHQ7XG4gICAgdmFyIHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgfCAodHJhY2tEZWZhdWx0ID09PSBudWxsIHx8IHRyYWNrRGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmZsYWdzKTtcbiAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSB0cmFja0RlZmF1bHQgPT09IG51bGwgfHwgdHJhY2tEZWZhdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZHVyYXRpb247XG4gICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDA4KSB7XG4gICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgIC8vIDB4MDAwMDAyIGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCBmaWVsZCwgd2hpY2ggcHJlY2VkZXMgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgIHZhciB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHJ1bnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJhd0R1cmF0aW9uID0gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bnNbal0pO1xuICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBzYW1wbGVEdXJhdGlvbikge1xuICAgICAgICB2YXIgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW5zW2pdLCA0KTtcbiAgICAgICAgcmF3RHVyYXRpb24gPSBzYW1wbGVEdXJhdGlvbiAqIHNhbXBsZUNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgdmlkZW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sudHlwZSA9PT0gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTykge1xuICAgICAgICBhdWRpb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlkZW9EdXJhdGlvbiA9PT0gMCAmJiBhdWRpb0R1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgdmFyIHNpZHhEdXJhdGlvbiA9IDA7XG4gICAgdmFyIHNpZHhzID0gZmluZEJveChkYXRhLCBbJ3NpZHgnXSk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNpZHhzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChzaWR4c1tfaV0pO1xuICAgICAgaWYgKHNpZHggIT09IG51bGwgJiYgc2lkeCAhPT0gdm9pZCAwICYmIHNpZHgucmVmZXJlbmNlcykge1xuICAgICAgICBzaWR4RHVyYXRpb24gKz0gc2lkeC5yZWZlcmVuY2VzLnJlZHVjZShmdW5jdGlvbiAoZHVyLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaWR4RHVyYXRpb247XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24pIHtcbiAgICByZXR1cm4gdmlkZW9EdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gYXVkaW9EdXJhdGlvbjtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja1J1bkJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdHJ1buKAmSwgdmVyc2lvbiwgdHJfZmxhZ3MpIHtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2NvdW50O1xuICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgc2lnbmVkIGludCgzMikgZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGZpcnN0X3NhbXBsZV9mbGFncztcbiAgICAgLy8gYWxsIGZpZWxkcyBpbiB0aGUgZm9sbG93aW5nIGFycmF5IGFyZSBvcHRpb25hbFxuICAgICB7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kdXJhdGlvbjtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX3NpemU7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9mbGFnc1xuICAgICAgICBpZiAodmVyc2lvbiA9PSAwKVxuICAgICAgICAgICB7IHVuc2lnbmVkIGludCgzMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICB7IHNpZ25lZCBpbnQoMzIpXG4gICAgIH1bIHNhbXBsZV9jb3VudCBdXG4gIH1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bikge1xuICB2YXIgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApO1xuICAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG4gIHZhciBvZmZzZXQgPSA4O1xuICAvLyBkYXRhLW9mZnNldC1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuICAvLyBmaXJzdC1zYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDA0KSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgdmFyIGR1cmF0aW9uID0gMDtcbiAgdmFyIHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMTAwKSB7XG4gICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtc2l6ZS1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDIwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDQwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1jb21wb3NpdGlvbi10aW1lLW9mZnNldHMtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59XG5mdW5jdGlvbiBvZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCwgdGltZU9mZnNldCkge1xuICBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLmZvckVhY2goZnVuY3Rpb24gKHRyYWYpIHtcbiAgICBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5mb3JFYWNoKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICB2YXIgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIHZhciBiYXNlTWVkaWFEZWNvZGVUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIGJhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIHZhciB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIHZhciBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcbmZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGEpIHtcbiAgdmFyIHNlZ21lbnRlZFJhbmdlID0ge1xuICAgIHZhbGlkOiBudWxsLFxuICAgIHJlbWFpbmRlcjogbnVsbFxuICB9O1xuICB2YXIgbW9vZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZiddKTtcbiAgaWYgKCFtb29mcykge1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfSBlbHNlIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgdmFyIGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTtcbiAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9ICgwLF90eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnNsaWNlVWludDgpKGRhdGEsIDAsIGxhc3QuYnl0ZU9mZnNldCAtIDgpO1xuICBzZWdtZW50ZWRSYW5nZS5yZW1haW5kZXIgPSAoMCxfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zbGljZVVpbnQ4KShkYXRhLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgdmFyIHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB0cmFjaykge1xuICB2YXIgc2VpU2FtcGxlcyA9IFtdO1xuICB2YXIgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgdmFyIHRyYWNrSWQgPSB0cmFjay5pZDtcbiAgdmFyIGlzSEVWQ0ZsYXZvciA9IGZhbHNlO1xuICB2YXIgbW9vZnMgPSBmaW5kQm94KHZpZGVvRGF0YSwgWydtb29mJ10pO1xuICBtb29mcy5tYXAoZnVuY3Rpb24gKG1vb2YpIHtcbiAgICB2YXIgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgdmFyIHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgdmFyIGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIHZhciB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApICYgMHhmZmZmZmY7XG4gICAgICAgIHZhciBiYXNlRGF0YU9mZnNldFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICB2YXIgc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDIpICE9PSAwO1xuICAgICAgICB2YXIgZGVmYXVsdFNhbXBsZUR1cmF0aW9uUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkgIT09IDA7XG4gICAgICAgIHZhciBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDEwKSAhPT0gMDtcbiAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVTaXplID0gMDtcbiAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICB2YXIgdGZoZE9mZnNldCA9IDg7XG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAoZnVuY3Rpb24gKHRydW4pIHtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDEwMCkgIT09IDA7XG4gICAgICAgICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVNpemVQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAyMDApICE9PSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA4MDApICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICB2YXIgdHJ1bk9mZnNldCA9IDg7IC8vIHBhc3QgdmVyc2lvbiwgZmxhZ3MsIGFuZCBzYW1wbGUgY291bnRcblxuICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgZm9yICh2YXIgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbHVUb3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuYWx1VG90YWxTaXplIDwgc2FtcGxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbHVTaXplID0gcmVhZFVpbnQzMih2aWRlb0RhdGEsIHNhbXBsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1NFSU1lc3NhZ2UoaXNIRVZDRmxhdm9yLCB2aWRlb0RhdGFbc2FtcGxlT2Zmc2V0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoc2FtcGxlT2Zmc2V0LCBzYW1wbGVPZmZzZXQgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KGRhdGEsIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNlaVNhbXBsZXM7XG59XG5mdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZGVsaW1pdCA9IGNvZGVjLmluZGV4T2YoJy4nKTtcbiAgdmFyIGJhc2VDb2RlYyA9IGRlbGltaXQgPCAwID8gY29kZWMgOiBjb2RlYy5zdWJzdHJpbmcoMCwgZGVsaW1pdCk7XG4gIHJldHVybiBiYXNlQ29kZWMgPT09ICdodmMxJyB8fCBiYXNlQ29kZWMgPT09ICdoZXYxJyB8fFxuICAvLyBEb2xieSBWaXNpb25cbiAgYmFzZUNvZGVjID09PSAnZHZoMScgfHwgYmFzZUNvZGVjID09PSAnZHZoZSc7XG59XG5mdW5jdGlvbiBpc1NFSU1lc3NhZ2UoaXNIRVZDRmxhdm9yLCBuYWx1SGVhZGVyKSB7XG4gIGlmIChpc0hFVkNGbGF2b3IpIHtcbiAgICB2YXIgbmFsdVR5cGUgPSBuYWx1SGVhZGVyID4+IDEgJiAweDNmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gMzkgfHwgbmFsdVR5cGUgPT09IDQwO1xuICB9IGVsc2Uge1xuICAgIHZhciBfbmFsdVR5cGUgPSBuYWx1SGVhZGVyICYgMHgxZjtcbiAgICByZXR1cm4gX25hbHVUeXBlID09PSA2O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bmVzY2FwZWREYXRhLCBoZWFkZXJTaXplLCBwdHMsIHNhbXBsZXMpIHtcbiAgdmFyIGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICB2YXIgc2VpUHRyID0gMDtcbiAgLy8gc2tpcCBuYWwgaGVhZGVyXG4gIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICB2YXIgYiA9IDA7XG4gIHdoaWxlIChzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlaVB0ciA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG4gICAgdmFyIGxlZnRPdmVyID0gZGF0YS5sZW5ndGggLSBzZWlQdHI7XG4gICAgaWYgKCFlbmRPZkNhcHRpb25zICYmIHBheWxvYWRUeXBlID09PSA0ICYmIHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcbiAgICAgIHZhciBjb3VudHJ5Q29kZSA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IHJlYWRVaW50MTYoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgc2VpUHRyICs9IDI7XG4gICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgdmFyIHVzZXJTdHJ1Y3R1cmUgPSByZWFkVWludDMyKGRhdGEsIHNlaVB0cik7XG4gICAgICAgICAgc2VpUHRyICs9IDQ7XG4gICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgIHZhciB1c2VyRGF0YVR5cGUgPSBkYXRhW3NlaVB0cisrXTtcblxuICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDB4MWYgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIHZhciBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSBlbmFibGVkID8gMiArIHRvdGFsQ0NzICogMyA6IDA7XG4gICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbMF0gPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0b3RhbEJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHVzZXJEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZTogcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1ICYmIHBheWxvYWRTaXplIDwgbGVmdE92ZXIpIHtcbiAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgdmFyIHV1aWRTdHJBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCAxNjsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX2IgPSBkYXRhW3NlaVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goX2IubGVuZ3RoID09IDEgPyAnMCcgKyBfYiA6IF9iKTtcbiAgICAgICAgICBpZiAoX2kyID09PSAzIHx8IF9pMiA9PT0gNSB8fCBfaTIgPT09IDcgfHwgX2kyID09PSA5KSB7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgdmFyIHVzZXJEYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdXNlckRhdGFCeXRlc1tfaTNdID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwYXlsb2FkVHlwZTogcGF5bG9hZFR5cGUsXG4gICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgIHVzZXJEYXRhOiAoMCxfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18udXRmOEFycmF5VG9TdHIpKHVzZXJEYXRhQnl0ZXMpLFxuICAgICAgICAgIHVzZXJEYXRhQnl0ZXM6IHVzZXJEYXRhQnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBzZWlQdHIgKz0gcGF5bG9hZFNpemU7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA+IGxlZnRPdmVyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAqL1xuZnVuY3Rpb24gZGlzY2FyZEVQQihkYXRhKSB7XG4gIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIHZhciBFUEJQb3NpdGlvbnMgPSBbXTtcbiAgdmFyIGkgPSAxO1xuXG4gIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgaWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gIC8vIGFycmF5XG4gIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICB2YXIgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgfVxuICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgfVxuICByZXR1cm4gbmV3RGF0YTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1zZyhkYXRhKSB7XG4gIHZhciB2ZXJzaW9uID0gZGF0YVswXTtcbiAgdmFyIHNjaGVtZUlkVXJpID0gJyc7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICB2YXIgdGltZVNjYWxlID0gMDtcbiAgdmFyIHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IDA7XG4gIHZhciBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgdmFyIGV2ZW50RHVyYXRpb24gPSAwO1xuICB2YXIgaWQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIDEyKTtcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSByZWFkVWludDMyKGRhdGEsIDE2KTtcbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIDI0KTtcbiAgICBvZmZzZXQgPSAyODtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHZhciBsZWZ0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB2YXIgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHByZXNlbnRhdGlvblRpbWUgPSBNYXRoLnBvdygyLCAzMikgKiBsZWZ0UHJlc2VudGF0aW9uVGltZSArIHJpZ2h0UHJlc2VudGF0aW9uVGltZTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHByZXNlbnRhdGlvblRpbWUpKSB7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdQcmVzZW50YXRpb24gdGltZSBleGNlZWRzIHNhZmUgaW50ZWdlciBsaW1pdCBhbmQgd3JhcHBlZCB0byBtYXggc2FmZSBpbnRlZ2VyIGluIHBhcnNpbmcgZW1zZyBib3gnKTtcbiAgICB9XG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgfVxuICB2YXIgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIHNjaGVtZUlkVXJpOiBzY2hlbWVJZFVyaSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgdGltZVNjYWxlOiB0aW1lU2NhbGUsXG4gICAgcHJlc2VudGF0aW9uVGltZTogcHJlc2VudGF0aW9uVGltZSxcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGE6IHByZXNlbnRhdGlvblRpbWVEZWx0YSxcbiAgICBldmVudER1cmF0aW9uOiBldmVudER1cmF0aW9uLFxuICAgIGlkOiBpZCxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH07XG59XG5mdW5jdGlvbiBtcDRCb3godHlwZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF5bG9hZCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGF5bG9hZFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFyIGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDg7XG4gIHZhciBpID0gbGVuO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXA0cHNzaChzeXN0ZW1JZCwga2V5aWRzLCBkYXRhKSB7XG4gIGlmIChzeXN0ZW1JZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICB9XG4gIHZhciB2ZXJzaW9uO1xuICB2YXIga2lkcztcbiAgaWYgKGtleWlkcykge1xuICAgIHZlcnNpb24gPSAxO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheShrZXlpZHMubGVuZ3RoICogMTYpO1xuICAgIGZvciAodmFyIGl4ID0gMDsgaXggPCBrZXlpZHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICB2YXIgayA9IGtleWlkc1tpeF07IC8vIHVpbnQ4YXJyYXlcbiAgICAgIGlmIChrLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgfVxuICAgICAga2lkcy5zZXQoaywgaXggKiAxNik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZlcnNpb24gPSAwO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIHZhciBraWRDb3VudDtcbiAgaWYgKHZlcnNpb24gPiAwKSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBpZiAoa2V5aWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBEYXRhVmlldyhraWRDb3VudC5idWZmZXIpLnNldFVpbnQzMigwLCBrZXlpZHMubGVuZ3RoLCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICB2YXIgZGF0YVNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgaWYgKGRhdGEgJiYgZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgIG5ldyBEYXRhVmlldyhkYXRhU2l6ZS5idWZmZXIpLnNldFVpbnQzMigwLCBkYXRhLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gbXA0Qm94KFsxMTIsIDExNSwgMTE1LCAxMDRdLCBuZXcgVWludDhBcnJheShbdmVyc2lvbiwgMHgwMCwgMHgwMCwgMHgwMCAvLyBGbGFnc1xuICBdKSwgc3lzdGVtSWQsXG4gIC8vIDE2IGJ5dGVzXG4gIGtpZENvdW50LCBraWRzLCBkYXRhU2l6ZSwgZGF0YSB8fCBuZXcgVWludDhBcnJheSgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHNzaChpbml0RGF0YSkge1xuICBpZiAoIShpbml0RGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCBpbml0RGF0YS5ieXRlTGVuZ3RoIDwgMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge1xuICAgIHZlcnNpb246IDAsXG4gICAgc3lzdGVtSWQ6ICcnLFxuICAgIGtpZHM6IG51bGwsXG4gICAgZGF0YTogbnVsbFxuICB9O1xuICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0RGF0YSk7XG4gIHZhciBib3hTaXplID0gdmlldy5nZXRVaW50MzIoMCk7XG4gIGlmIChpbml0RGF0YS5ieXRlTGVuZ3RoICE9PSBib3hTaXplICYmIGJveFNpemUgPiA0NCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0eXBlID0gdmlldy5nZXRVaW50MzIoNCk7XG4gIGlmICh0eXBlICE9PSAweDcwNzM3MzY4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnZlcnNpb24gPSB2aWV3LmdldFVpbnQzMig4KSA+Pj4gMjQ7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA+IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQuc3lzdGVtSWQgPSBfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLmhleER1bXAobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDEyLCAxNikpO1xuICB2YXIgZGF0YVNpemVPcktpZENvdW50ID0gdmlldy5nZXRVaW50MzIoMjgpO1xuICBpZiAocmVzdWx0LnZlcnNpb24gPT09IDApIHtcbiAgICBpZiAoYm94U2l6ZSAtIDMyIDwgZGF0YVNpemVPcktpZENvdW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmRhdGEgPSBuZXcgVWludDhBcnJheShpbml0RGF0YSwgMzIsIGRhdGFTaXplT3JLaWRDb3VudCk7XG4gIH0gZWxzZSBpZiAocmVzdWx0LnZlcnNpb24gPT09IDEpIHtcbiAgICByZXN1bHQua2lkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVNpemVPcktpZENvdW50OyBpKyspIHtcbiAgICAgIHJlc3VsdC5raWRzLnB1c2gobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyICsgaSAqIDE2LCAxNikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9udW1lcmljLWVuY29kaW5nLXV0aWxzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbnVtZXJpYy1lbmNvZGluZy11dGlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYmFzZTY0RGVjb2RlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGJhc2U2NERlY29kZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYmFzZTY0RGVjb2RlVG9TdHJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYmFzZTY0RGVjb2RlVG9TdHIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImJhc2U2NEVuY29kZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBiYXNlNjRFbmNvZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImJhc2U2NFRvQmFzZTY0VXJsXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGJhc2U2NFRvQmFzZTY0VXJsKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJiYXNlNjRVcmxFbmNvZGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYmFzZTY0VXJsRW5jb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJzdHJUb0Jhc2U2NEVuY29kZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzdHJUb0Jhc2U2NEVuY29kZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuZnVuY3Rpb24gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0ZW5jb2RlZFN0cikge1xuICByZXR1cm4gYmFzZTY0ZW5jb2RlZFN0ci5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5mdW5jdGlvbiBzdHJUb0Jhc2U2NEVuY29kZShzdHIpIHtcbiAgcmV0dXJuIGJ0b2Eoc3RyKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NERlY29kZVRvU3RyKHN0cikge1xuICByZXR1cm4gYXRvYihzdHIpO1xufVxuZnVuY3Rpb24gYmFzZTY0RW5jb2RlKGlucHV0KSB7XG4gIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBpbnB1dCkpO1xufVxuZnVuY3Rpb24gYmFzZTY0VXJsRW5jb2RlKGlucHV0KSB7XG4gIHJldHVybiBiYXNlNjRUb0Jhc2U2NFVybChiYXNlNjRFbmNvZGUoaW5wdXQpKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NERlY29kZShiYXNlNjRlbmNvZGVkU3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRlbmNvZGVkU3RyKSwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gT3V0cHV0RmlsdGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG52YXIgT3V0cHV0RmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3V0cHV0RmlsdGVyKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gIH1cbiAgdmFyIF9wcm90byA9IE91dHB1dEZpbHRlci5wcm90b3R5cGU7XG4gIF9wcm90by5kaXNwYXRjaEN1ZSA9IGZ1bmN0aW9uIGRpc3BhdGNoQ3VlKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbiwgdGhpcy5jdWVSYW5nZXMpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfTtcbiAgX3Byb3RvLm5ld0N1ZSA9IGZ1bmN0aW9uIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuY3JlYXRlQ2FwdGlvbnNUcmFjayh0aGlzLnRyYWNrTmFtZSk7XG4gIH07XG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9O1xuICByZXR1cm4gT3V0cHV0RmlsdGVyO1xufSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImFkZEN1ZVRvVHJhY2tcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRkQ3VlVG9UcmFjayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY2xlYXJDdXJyZW50Q3Vlc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjbGVhckN1cnJlbnRDdWVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZXRDdWVzSW5SYW5nZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRDdWVzSW5SYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwicmVtb3ZlQ3Vlc0luUmFuZ2VcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcmVtb3ZlQ3Vlc0luUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInNlbmRBZGRUcmFja0V2ZW50XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNlbmRBZGRUcmFja0V2ZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cbmZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gIHZhciBldmVudDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gIHZhciBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgaWYgKCF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRDdWUgaXMgZmFpbGVkIGZvcjogXCIgKyBjdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvZ2dlci5kZWJ1ZyhcIlt0ZXh0dHJhY2stdXRpbHNdOiBcIiArIGVycik7XG4gICAgICB2YXIgdGV4dFRyYWNrQ3VlID0gbmV3IHNlbGYuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIHZhciBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gdHJhY2suY3Vlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UodHJhY2ssIHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICB2YXIgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzICYmIHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbi8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCB0aW1lKSB7XG4gIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgaWYgKHRpbWUgPCBjdWVzWzBdLnN0YXJ0VGltZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIElmIHRoZSBsYXN0IGN1ZSBlbmRzIGJlZm9yZSB0aW1lIHRoZXJlIGlzIG5vIG92ZXJsYXBcbiAgdmFyIGxlbiA9IGN1ZXMubGVuZ3RoIC0gMTtcbiAgaWYgKHRpbWUgPiBjdWVzW2xlbl0uZW5kVGltZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IGxlbjtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuICAgIGlmICh0aW1lIDwgY3Vlc1ttaWRdLnN0YXJ0VGltZSkge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cbiAgLy8gTm8gZGlyZWN0IG1hdGNoIHdhcyBmb3VuZCwgbGVmdCBvciByaWdodCBlbGVtZW50IG11c3QgYmUgdGhlIGNsb3Nlc3QuIENoZWNrIHdoaWNoIG9uZSBoYXMgdGhlIHNtYWxsZXN0IGRpZmYuXG4gIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lID8gbGVmdCA6IHJpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0Q3Vlc0luUmFuZ2UoY3Vlcywgc3RhcnQsIGVuZCkge1xuICB2YXIgY3Vlc0ZvdW5kID0gW107XG4gIHZhciBmaXJzdEN1ZUluUmFuZ2UgPSBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKGN1ZXMsIHN0YXJ0KTtcbiAgaWYgKGZpcnN0Q3VlSW5SYW5nZSA+IC0xKSB7XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0Q3VlSW5SYW5nZSwgbGVuID0gY3Vlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9jdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKF9jdWUuc3RhcnRUaW1lID49IHN0YXJ0ICYmIF9jdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgY3Vlc0ZvdW5kLnB1c2goX2N1ZSk7XG4gICAgICB9IGVsc2UgaWYgKF9jdWUuc3RhcnRUaW1lID4gZW5kKSB7XG4gICAgICAgIHJldHVybiBjdWVzRm91bmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjdWVzRm91bmQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbnZhciBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcocikge1xuICAgIHZhciBsb2cgPSAnJztcbiAgICB2YXIgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbG9nICs9IFwiW1wiICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgXCItXCIgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgXCJdXCI7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFRpbWVSYW5nZXMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHRvTXNGcm9tTXBlZ1RzQ2xvY2spLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInRvVGltZXNjYWxlRnJvbUJhc2VcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdG9UaW1lc2NhbGVGcm9tQmFzZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidG9UaW1lc2NhbGVGcm9tU2NhbGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdG9UaW1lc2NhbGVGcm9tU2NhbGUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbnZhciBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIGRlc3RTY2FsZSwgc3JjQmFzZSwgcm91bmQpIHtcbiAgaWYgKHNyY0Jhc2UgPT09IHZvaWQgMCkge1xuICAgIHNyY0Jhc2UgPSAxO1xuICB9XG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBmYWxzZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdmFsdWUgKiBkZXN0U2NhbGUgKiBzcmNCYXNlOyAvLyBlcXVpdmFsZW50IHRvIGAodmFsdWUgKiBzY2FsZSkgLyAoMSAvIGJhc2UpYFxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZSh2YWx1ZSwgZGVzdFNjYWxlLCBzcmNTY2FsZSwgcm91bmQpIHtcbiAgaWYgKHNyY1NjYWxlID09PSB2b2lkIDApIHtcbiAgICBzcmNTY2FsZSA9IDE7XG4gIH1cbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKHZhbHVlLCBkZXN0U2NhbGUsIDEgLyBzcmNTY2FsZSwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9Nc0Zyb21NcGVnVHNDbG9jayh2YWx1ZSwgcm91bmQpIHtcbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKHZhbHVlLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZSh2YWx1ZSwgc3JjU2NhbGUpIHtcbiAgaWYgKHNyY1NjYWxlID09PSB2b2lkIDApIHtcbiAgICBzcmNTY2FsZSA9IDE7XG4gIH1cbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJzbGljZVVpbnQ4XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNsaWNlVWludDgpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmZ1bmN0aW9uIHNsaWNlVWludDgoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIHBvbHlmaWxscyBJRTExIHVzYWdlIG9mIFVpbnQ4QXJyYXkgc2xpY2UuXG4gIC8vIEl0IGFsd2F5cyBleGlzdHMgaW4gdGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBzbyBmYWlscywgYnV0IGl0IGZhaWxzIGF0IHJ1bnRpbWUgb24gSUUxMS5cbiAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlID8gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCkgOiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgc3RhcnQsIGVuZCkpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3Z0dGN1ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLlZUVEN1ZSkge1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgfVxuICB2YXIgQWxsb3dlZERpcmVjdGlvbnMgPSBbJycsICdscicsICdybCddO1xuICB2YXIgQWxsb3dlZEFsaWdubWVudHMgPSBbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnLCAnbGVmdCcsICdyaWdodCddO1xuICBmdW5jdGlvbiBpc0FsbG93ZWRWYWx1ZShhbGxvd2VkLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5lY2Vzc2FyeSBmb3IgYXNzdXJpbmcgdGhlIGdlbmVyaWMgY29uZm9ybXMgdG8gdGhlIEFycmF5IGludGVyZmFjZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyByZXNldCB0aGUgdHlwZSBzbyB0aGF0IHRoZSBuZXh0IG5hcnJvd2luZyB3b3JrcyB3ZWxsXG4gICAgdmFyIGxjVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuICAgIGlmICh+YWxsb3dlZC5pbmRleE9mKGxjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbGNWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkQWxpZ25tZW50cywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICB2YXIgY3VlID0gdGhpcztcbiAgICB2YXIgYmFzZU9iaiA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgdmFyIF9pZCA9ICcnO1xuICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgdmFyIF9yZWdpb24gPSBudWxsO1xuICAgIHZhciBfdmVydGljYWwgPSAnJztcbiAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICB2YXIgX2xpbmUgPSAnYXV0byc7XG4gICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICB2YXIgX3NpemUgPSA1MDtcbiAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvLyB0b2RvOiBpbXBsZW1lbnQgVlRUUmVnaW9uIHBvbHlmaWxsP1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIHZhciBXZWJWVFQgPSBzZWxmLldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHBvbHlmaWxsIGhhY2tcbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy92dHRwYXJzZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3Z0dHBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJWVFRQYXJzZXJcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVlRUUGFyc2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmaXhMaW5lQnJlYWtzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpeExpbmVCcmVha3MpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInBhcnNlVGltZVN0YW1wXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlVGltZVN0YW1wKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRjdWUgKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIik7XG4vKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanNcbiAqL1xuXG5cbnZhciBTdHJpbmdEZWNvZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHt9XG4gIHZhciBfcHJvdG8gPSBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBfcHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gIH07XG4gIHJldHVybiBTdHJpbmdEZWNvZGVyO1xufSgpOyAvLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyBwYXJzZUZsb2F0KGYgfHwgMCk7XG4gIH1cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocGFyc2VGbG9hdChtWzJdKSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzJdLCBtWzNdLCAwLCBtWzRdKTtcbiAgfVxuICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG52YXIgU2V0dGluZ3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIF9wcm90bzIgPSBTZXR0aW5ncy5wcm90b3R5cGU7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9XG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICA7XG4gIF9wcm90bzIuZ2V0ID0gZnVuY3Rpb24gZ2V0KGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH1cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICA7XG4gIF9wcm90bzIuaGFzID0gZnVuY3Rpb24gaGFzKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgO1xuICBfcHJvdG8yLmFsdCA9IGZ1bmN0aW9uIGFsdChrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgO1xuICBfcHJvdG8yLmludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIDtcbiAgX3Byb3RvMi5wZXJjZW50ID0gZnVuY3Rpb24gcGVyY2VudChrLCB2KSB7XG4gICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodikpIHtcbiAgICAgIHZhciBwZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmIChwZXJjZW50ID49IDAgJiYgcGVyY2VudCA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHJldHVybiBTZXR0aW5ncztcbn0oKTsgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0IGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICB2YXIgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBfayA9IGt2WzBdO1xuICAgIHZhciBfdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKF9rLCBfdik7XG4gIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKDAsIDAsICcnKTtcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxuLy8gIFNhZmFyaSBkb2Vzbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgYW5kIENocm9tZSBkby5cbnZhciBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgdmFyIHZhbHM7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgdmFyIHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnNsaWNlKDAsIDMpICE9PSAnLS0+Jykge1xuICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICsgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxudmFyIFZUVFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbiAgICB0aGlzLmN1ZSA9IG51bGw7XG4gICAgdGhpcy5vbmN1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ucGFyc2luZ2Vycm9yID0gdm9pZCAwO1xuICAgIHRoaXMub25mbHVzaCA9IHZvaWQgMDtcbiAgfVxuICB2YXIgX3Byb3RvMyA9IFZUVFBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90bzMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnNsaWNlKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXIuc2xpY2UocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIC8vIHN3aXRjaCAoaykge1xuICAgICAgICAvLyBjYXNlICdyZWdpb24nOlxuICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAvLyB9XG4gICAgICB9LCAvOi8pO1xuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZSA9ICcnO1xuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICB9XG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdIRUFERVInOlxuICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ05PVEUnOlxuICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VlID0gbmV3IF92dHRjdWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oMCwgMCwgJycpO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgX3RoaXMuY3VlLCBfdGhpcy5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmN1ZSAmJiBfdGhpcy5jdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBfdGhpcy5jdWUgJiYgX3RoaXMub25jdWUpIHtcbiAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8zLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICAvLyBfdGhpcy5idWZmZXIgKz0gX3RoaXMuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKF90aGlzLmN1ZSB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgX3RoaXMuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBfdGhpcy5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnIHx8IF90aGlzLnN0YXRlID09PSAnQkFEV0VCVlRUJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChfdGhpcy5vbnBhcnNpbmdlcnJvcikge1xuICAgICAgICBfdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF90aGlzLm9uZmx1c2gpIHtcbiAgICAgIF90aGlzLm9uZmx1c2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJldHVybiBWVFRQYXJzZXI7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJnZW5lcmF0ZUN1ZUlkXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdlbmVyYXRlQ3VlSWQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInBhcnNlV2ViVlRUXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBhcnNlV2ViVlRUKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRwYXJzZXIgKi8gXCIuL3NyYy91dGlscy92dHRwYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aW1lc2NhbGUtY29udmVyc2lvbiAqLyBcIi4vc3JjL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vcmVtdXgvbXA0LXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci50c1wiKTtcblxuXG5cblxuXG5cblxuXG52YXIgTElORUJSRUFLUyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUxMVxudmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcG9zaXRpb24gPSAwO1xuICB9XG4gIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcbnZhciBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gY3VlU3RyaW5nMm1pbGxpcyh0aW1lU3RyaW5nKSB7XG4gIHZhciB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTMpKTtcbiAgdmFyIHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC02LCAtNCkpO1xuICB2YXIgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTksIC03KSk7XG4gIHZhciBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuICBpZiAoISgwLF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Zpbml0ZU51bWJlcikodHMpIHx8ICEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKHNlY3MpIHx8ICEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKG1pbnMpIHx8ICEoMCxfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGaW5pdGVOdW1iZXIpKGhvdXJzKSkge1xuICAgIHRocm93IEVycm9yKFwiTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogTG9jYWw6XCIgKyB0aW1lU3RyaW5nKTtcbiAgfVxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTtcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxudmFyIGhhc2ggPSBmdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgdmFyIGhhc2ggPSA1MzgxO1xuICB2YXIgaSA9IHRleHQubGVuZ3RoO1xuICB3aGlsZSAoaSkge1xuICAgIGhhc2ggPSBoYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG4vLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxudmFyIGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gIHZhciBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICB2YXIgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKChfcHJldkNDID0gcHJldkNDKSAhPT0gbnVsbCAmJiBfcHJldkNDICE9PSB2b2lkIDAgJiYgX3ByZXZDQy5uZXcpIHtcbiAgICB2YXIgX3ByZXZDQztcbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcbmZ1bmN0aW9uIHBhcnNlV2ViVlRUKHZ0dEJ5dGVBcnJheSwgaW5pdFBUUywgdGltZXNjYWxlLCB2dHRDQ3MsIGNjLCB0aW1lT2Zmc2V0LCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICB2YXIgcGFyc2VyID0gbmV3IF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5WVFRQYXJzZXIoKTtcbiAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICB2YXIgdnR0TGluZXMgPSAoMCxfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18udXRmOEFycmF5VG9TdHIpKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBjdWVzID0gW107XG4gIHZhciBpbml0UFRTOTBIeiA9ICgwLF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLnRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKShpbml0UFRTLCB0aW1lc2NhbGUpO1xuICB2YXIgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICB2YXIgdGltZXN0YW1wTWFwTVBFR1RTID0gMDtcbiAgdmFyIHRpbWVzdGFtcE1hcExPQ0FMID0gMDtcbiAgdmFyIHBhcnNpbmdFcnJvcjtcbiAgdmFyIGluSGVhZGVyID0gdHJ1ZTtcbiAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgIC8vIEFkanVzdCBjdWUgdGltaW5nOyBjbGFtcCBjdWVzIHRvIHN0YXJ0IG5vIGVhcmxpZXIgdGhhbiAtIGFuZCBkcm9wIGN1ZXMgdGhhdCBkb24ndCBlbmQgYWZ0ZXIgLSAwIG9uIHRpbWVsaW5lLlxuICAgIHZhciBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIHZhciBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuICAgIHZhciB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgPSAodGltZXN0YW1wTWFwTVBFR1RTIC0gaW5pdFBUUzkwSHopIC8gOTAwMDA7XG5cbiAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgIGlmIChjdXJyQ0MgIT09IG51bGwgJiYgY3VyckNDICE9PSB2b2lkIDAgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2ViVnR0TXBlZ1RzTWFwT2Zmc2V0KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgY3VlT2Zmc2V0ID0gd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gY3VlLmVuZFRpbWUgLSBjdWUuc3RhcnRUaW1lO1xuICAgIHZhciBzdGFydFRpbWUgPSAoMCxfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5ub3JtYWxpemVQdHMpKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICBjdWUuc3RhcnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCAwKTtcbiAgICBjdWUuZW5kVGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIGR1cmF0aW9uLCAwKTtcblxuICAgIC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcbiAgICB2YXIgdGV4dCA9IGN1ZS50ZXh0LnRyaW0oKTtcblxuICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuXG4gICAgLy8gSWYgdGhlIGN1ZSB3YXMgbm90IGFzc2lnbmVkIGFuIGlkIGZyb20gdGhlIFZUVCBmaWxlIChsaW5lIGFib3ZlIHRoZSBjb250ZW50KSwgY3JlYXRlIG9uZS5cbiAgICBpZiAoIWN1ZS5pZCkge1xuICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgdGV4dCk7XG4gICAgfVxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gIH07XG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07XG5cbiAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gIHZ0dExpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICBsaW5lLnNsaWNlKDE2KS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ0xPQ0FMOicpKSB7XG4gICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnNsaWNlKDYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcE1hcE1QRUdUUyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zbGljZSg3KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICB0aW1lc3RhbXBNYXBMT0NBTCA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICB9KTtcbiAgcGFyc2VyLmZsdXNoKCk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3hoci1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy94aHItbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9sb2FkLXN0YXRzICovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIik7XG5cblxudmFyIEFHRV9IRUFERVJfTElORV9SRUdFWCA9IC9eYWdlOlxccypbXFxkLl0rXFxzKiQvbTtcbnZhciBYaHJMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYaHJMb2FkZXIoY29uZmlnIC8qIEhsc0NvbmZpZyAqLykge1xuICAgIHRoaXMueGhyU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCA6IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5Mb2FkU3RhdHMoKTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICB9XG4gIHZhciBfcHJvdG8gPSBYaHJMb2FkZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gIH07XG4gIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgaWYgKGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3MgIT09IHZvaWQgMCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGlmICh0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH07XG4gIF9wcm90by5sb2FkSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2FkSW50ZXJuYWwoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICB2YXIgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuICAgIHRyeSB7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGZpeCB4aHJTZXR1cDogKHhociwgdXJsKSA9PiB7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LUxhbmd1YWdlXCIsIFwidGVzdFwiKTt9XG4gICAgICAgICAgLy8gbm90IHdvcmtpbmcsIGFzIHhoci5zZXRSZXF1ZXN0SGVhZGVyIGV4cGVjdHMgeGhyLnJlYWR5U3RhdGUgPT09IE9QRU5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IHRoaXMuY29udGV4dC5oZWFkZXJzO1xuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgdGV4dDogZS5tZXNzYWdlXG4gICAgICB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9O1xuICBfcHJvdG8ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICB4aHIgPSB0aGlzLmxvYWRlcixcbiAgICAgIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCAmJiAoaXNBcnJheUJ1ZmZlciAmJiB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhLCB4aHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5sb2dnZXIuZXJyb3Ioc3RhdHVzICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvZ2dlci53YXJuKHN0YXR1cyArIFwiIHdoaWxlIGxvYWRpbmcgXCIgKyBjb250ZXh0LnVybCArIFwiLCByZXRyeWluZyBpbiBcIiArIHRoaXMucmV0cnlEZWxheSArIFwiLi4uXCIpO1xuICAgICAgICAgICAgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5sb2dnZXIud2FybihcInRpbWVvdXQgd2hpbGUgbG9hZGluZyBcIiArIHRoaXMuY29udGV4dC51cmwpO1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0Q2FjaGVBZ2UgPSBmdW5jdGlvbiBnZXRDYWNoZUFnZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5sb2FkZXIgJiYgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICB2YXIgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIFhockxvYWRlcjtcbn0oKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoWGhyTG9hZGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgdmFyIFVSTF9SRUdFWCA9XG4gICAgL14oPz0oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKVxcMSg/PSgoPzpcXC9cXC9bXlxcLz8jXSopPykpXFwyKD89KCg/Oig/OltePyNcXC9dKlxcLykqW147PyNcXC9dKik/KSlcXDMoKD86O1tePyNdKik/KShcXD9bXiNdKik/KCNbXl0qKT8kLztcbiAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2c7XG5cbiAgdmFyIFVSTFRvb2xraXQgPSB7XG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cbiAgICAvLyBFLmdcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uIChiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG4gICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcbiAgICAgICAgLy8gZW50aXJlIGJhc2UgVVJMIChpLmUuLCBpcyBzZXQgZXF1YWwgdG8gdGhlIGJhc2UgVVJMKVxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVVSTDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgICAgaWYgKCFiYXNlUGFydHNGb3JOb3JtYWxpc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChcbiAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG4gICAgICB9O1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG4gICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cbiAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID1cbiAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG4gICAgICAgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemVcbiAgICAgICAgICA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpXG4gICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhidWlsdFBhcnRzKTtcbiAgICB9LFxuICAgIHBhcnNlVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcbiAgICAgIH07XG4gICAgfSxcbiAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxuICAgICAgLy8gdGhlbiBhcHBsaWVkLCBpbiBvcmRlciwgdG8gdGhlIG5ldyBwYXRoOlxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyA2YikgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiLlwiIGFzIGEgY29tcGxldGUgcGF0aCBzZWdtZW50LFxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xuICAgICAgLy8gNmMpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIjxzZWdtZW50Pi8uLi9cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXG4gICAgICAvLyByZW1vdmluZyB0aGUgbGVmdG1vc3QgbWF0Y2hpbmcgcGF0dGVybiBvbiBlYWNoIGl0ZXJhdGlvbixcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cbiAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCB0aGF0XG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aFxuICAgICAgKSB7fVxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhcnRzLnNjaGVtZSArXG4gICAgICAgIHBhcnRzLm5ldExvYyArXG4gICAgICAgIHBhcnRzLnBhdGggK1xuICAgICAgICBwYXJ0cy5wYXJhbXMgK1xuICAgICAgICBwYXJ0cy5xdWVyeSArXG4gICAgICAgIHBhcnRzLmZyYWdtZW50XG4gICAgICApO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKHRydWUpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIHt9XG59KSh0aGlzKTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIG1vZHVsZSBmYWN0b3JpZXMgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaGxzLnRzXCIpO1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.js\n"));

/***/ })

}]);